(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
biojsvispsicquic = require('./pGraph.js');
module.exports = biojsvispsicquic;
//Libraries
var psicquic = require('biojs-rest-psicquic');
var cytoscape = require('cytoscape');
var MITab = require('biojs-io-mitab');
var _ = require('underscore');

//Private members
var _selector = 'body', _div = null;

//Cytoscape vars
var _cyopts = {};

// psicquic vars
var _url = '', _proxy = null, _method = 'query', _params = null, _query='';

var _initSelector = function(selector){
    _div = document.querySelector(selector);
    _div.style.left = 0;
    _div.style.top = 0;
    _div.style.width = '100%';
    _div.style.height = '100%';
    _div.style.position = 'absolute';
};

// Public members
var pGraph = function(){};

pGraph.url = function(_){
    if (!arguments.length)
        return _url;
    _url = _;
    return pGraph;
};

pGraph.proxy = function(_){
    if (!arguments.length)
        return _proxy;
    _proxy = _;
    return pGraph;
};

pGraph.method = function(_){
    if (!arguments.length)
        return _method;
    _method = _;
    return pGraph;
};

pGraph.params = function(_){
    if (!arguments.length)
        return _params;
    _params = _;
    return pGraph;
};

pGraph.query = function(_){
    if (!arguments.length)
        return _query;
    _query = _;
    return pGraph;
};

pGraph.selector = function(_){
    if (!arguments.length)
        return _selector;
    
    _selector = _;
    return pGraph;
};

//Cytoscape related options
pGraph.cyopts = function(_){
    if (!arguments.length)
        return _cyopts;
    
    _cyopts = _;
    return pGraph;
};

pGraph.update = function(){
    if(_div === null) _initSelector(_selector);
    
    psicquic.url(_url).params(_params).method(_method).proxy(_proxy).query(_query, function(err, resp, body){
        var parsed = MITab.parse(body);
        
        _cyopts.elements = {
            nodes: _.map(parsed.nodes, function(n){
                return {data:n};
            }),
            edges : _.map(parsed.links, function(n){
                return {data:n};
            })
        };
        
        _cyopts.container = _div;
        var cy = cytoscape(_cyopts);
    });
};

module.exports = pGraph;
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_6ec017d7.js","/")
},{"./pGraph.js":2,"1YiZ5S":18,"biojs-io-mitab":3,"biojs-rest-psicquic":5,"buffer":15,"cytoscape":14,"underscore":19}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//Libraries
var psicquic = require('biojs-rest-psicquic');
var cytoscape = require('cytoscape');
var MITab = require('biojs-io-mitab');
var _ = require('underscore');

//Private members
var _selector = 'body', _div = null;

//Cytoscape vars
var _cyopts = {};

// psicquic vars
var _url = '', _proxy = null, _method = 'query', _params = null, _query='';

var _initSelector = function(selector){
    _div = document.querySelector(selector);
    _div.style.left = 0;
    _div.style.top = 0;
    _div.style.width = '100%';
    _div.style.height = '100%';
    _div.style.position = 'absolute';
};

// Public members
var pGraph = function(){};

pGraph.url = function(_){
    if (!arguments.length)
        return _url;
    _url = _;
    return pGraph;
};

pGraph.proxy = function(_){
    if (!arguments.length)
        return _proxy;
    _proxy = _;
    return pGraph;
};

pGraph.method = function(_){
    if (!arguments.length)
        return _method;
    _method = _;
    return pGraph;
};

pGraph.params = function(_){
    if (!arguments.length)
        return _params;
    _params = _;
    return pGraph;
};

pGraph.query = function(_){
    if (!arguments.length)
        return _query;
    _query = _;
    return pGraph;
};

pGraph.selector = function(_){
    if (!arguments.length)
        return _selector;
    
    _selector = _;
    return pGraph;
};

//Cytoscape related options
pGraph.cyopts = function(_){
    if (!arguments.length)
        return _cyopts;
    
    _cyopts = _;
    return pGraph;
};

pGraph.update = function(){
    if(_div === null) _initSelector(_selector);
    
    psicquic.url(_url).params(_params).method(_method).proxy(_proxy).query(_query, function(err, resp, body){
        var parsed = MITab.parse(body);
        
        _cyopts.elements = {
            nodes: _.map(parsed.nodes, function(n){
                return {data:n};
            }),
            edges : _.map(parsed.links, function(n){
                return {data:n};
            })
        };
        
        _cyopts.container = _div;
        var cy = cytoscape(_cyopts);
    });
};

module.exports = pGraph;
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/pGraph.js","/")
},{"1YiZ5S":18,"biojs-io-mitab":3,"biojs-rest-psicquic":5,"buffer":15,"cytoscape":14,"underscore":19}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var _ = require('underscore');

module.exports = MITab = (function() {
     
    var nodes = {}; 
    var links = [];
    var scores = {};
    var textInParenthesis = /\((.*?)\)/;
    var textInQuotes = /\"(.*?)\"/;
    var textInTax = /\:(.*?)\(/;
    
    // Creates a node from identifiers, alternative idenifiers,
    // and taxonomy values
    var _getNode = function(idStr, altIdsStr, taxStr){
        
        var ids = _.map(idStr.split('|'), _mapPub);
        var node = {
            id: ids[0].value,
            ids: ids,
            altIds: _.map(altIdsStr.split('|'), _mapPub),
            taxonomy: _.uniq(_.map(taxStr.split('|'), _mapTaxonomy))
        }
        return node;
    }
    
    // Parses a string and returns an interaction
    var _parse = function(line, i){
        
        if (! _.isString(line)) {
            console.warn('MITab cannot parse line ' + i);
            return {};
        }
        
        var fields = line.split('\t');
        
        if(fields.length < 15) {
            console.warn('MITab cannot parse line ' + i);
            return {};
        }
        
        var nodeA = _getNode(fields[0], fields[2], fields[9]);
        var nodeB = _getNode(fields[1], fields[3], fields[10]);
        
        
        var interaction = {
            source: nodeA.id,
            target: nodeB.id,
            detMethods: _.map(fields[6].split('|'), _mapField),
            firstAuthor: fields[7].split('|'),
            publications: _.map(fields[8].split('|'), _mapPub),
            intTypes: _.map(fields[11].split('|'), _mapField),
            sourceDbs: _.map(fields[12].split('|'), _mapField),
            intIds : _.map(fields[13].split('|'), _mapPub),
            scores: _.map(fields[14].split('|'), _mapScore)
        };
        
        nodes[nodeA.id] = nodeA;
        nodes[nodeB.id] = nodeB;
        
        return interaction;
    }
    
    var _mapScore = function(scoreStr){
        var arr = scoreStr.split(':'), score = {name:arr[0], score:+arr[1]};
        
        _addScore(score);
        return score;
    };
    
    var _mapField = function(fieldStr){
        if(fieldStr.match(textInQuotes) == null || fieldStr.match(textInParenthesis) == null){
            var arr = fieldStr.split(':');
            return {name:arr[0], score:arr[1]};
        }
        return {name:fieldStr.match(textInQuotes)[1], value:fieldStr.match(textInParenthesis)[1]};
    };
    
    var _mapPub = function(pubStr){
        var arr = pubStr.split(':');
        return {name:arr[0], value:arr[1]};
    };
    
    var _mapTaxonomy = function(taxStr){
        if(taxStr != '-'){
            return (taxStr.match(textInTax) == null) ? taxStr.split(':')[1] : taxStr.match(textInTax)[1];
        }
    };
    
    var _addScore = function(score){
        if( !_.isNaN(score.score) && _.isNumber(score.score)){
            if(_.has(scores, score.name)){
                if(scores[score.name].min > score.score) scores[score.name].min = score.score;
                if(scores[score.name].max < score.score) scores[score.name].max = score.score;
            }else{
                scores[score.name] = {name:score.name, min:score.score, max:score.score};
            }
        }
    };
    
    function MITab() {}
    
    MITab.parse = function(text) {
        
        if (! _.isString(text)) {
            throw 'MITab cannot parse ' + typeof text;
            return;
        }
        
        // Initialize variables
        nodes = {}; 
        links = [];
        scores = {};
        
        var lines = text.split('\n');
        
        var interactions = _.reject(_.map(lines, _parse), _.isEmpty);
        var nodeval = _.values(nodes);
        
        return {
            links: interactions,
            nodes: nodeval,
            ids: _.pluck(nodeval, 'id'),
            taxa: _.compact(_.reduce(nodeval, function(memo,n){ return _.union(memo,n.taxonomy)},[])),
            scores: _.values(scores)
        };
    };
    
    return MITab;
})();
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-io-mitab/index.js","/../node_modules/biojs-io-mitab")
},{"1YiZ5S":18,"buffer":15,"underscore":4}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-io-mitab/node_modules/underscore/underscore.js","/../node_modules/biojs-io-mitab/node_modules/underscore")
},{"1YiZ5S":18,"buffer":15}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var xhr = require('nets')

var _url = '', _proxy = null, _method = 'query', _params = null;

//Private members
var _fetch = function(url, callback){
    xhr({
        url: url,
        method: 'GET'
    }, 
    callback)
}

var _eval_params = function(params){
    var str = '';
    if(typeof params === 'string'){
        return params;
    }else if(typeof params === 'object'){
        for(var key in params){
            if (params.hasOwnProperty(key)) str += key+'='+params[key]+'&';
        }
    }
    return str;
}

var _createUrl = function(method, query, params){
    
    var paramsStr = ''; 
    if(params !== null)
        paramsStr = '?'+_eval_params(params);
    
    var url = _url+'/'+method+'/'+query+paramsStr;
    url = url.replace('//'+method, '/'+method)
    
    if(_proxy === null) return url;
    
    return _processProxy(url);
}

var _processProxy = function(url){
    if (typeof _proxy === 'function') return _proxy(url);
    
    if(typeof _proxy === 'string') return _proxy +'?url='+url;
    
    return url;
}

//Public members
var psicquicServer = function(){}
    
psicquicServer.url = function(_){
    if (!arguments.length)
        return _url;
    _url = _;
    return psicquicServer;
};

psicquicServer.proxy = function(_){
    if (!arguments.length)
        return _proxy;
    _proxy = _;
    return psicquicServer;
};

psicquicServer.method = function(_){
    if (!arguments.length)
        return _method;
    _method = _;
    return psicquicServer;
};

psicquicServer.params = function(_){
    if (!arguments.length)
        return _params;
    _params = _;
    return psicquicServer;
};

psicquicServer.query = function(query, callback){
    var url = _createUrl(_method, query, _params);
    _fetch(url, callback);
};

psicquicServer.count = function(query, callback){
    var url = _createUrl(_method, query, {format:'count'});
    _fetch(url, callback);
}

module.exports = psicquicServer;
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/index.js","/../node_modules/biojs-rest-psicquic")
},{"1YiZ5S":18,"buffer":15,"nets":6}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var req = require('request')

module.exports = Nets

function Nets(uri, opts, cb) {
  req(uri, opts, cb)
}
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets")
},{"1YiZ5S":18,"buffer":15,"request":7}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var window = require("global/window")
var once = require("once")
var parseHeaders = require('parse-headers')

var messages = {
    "0": "Internal XMLHttpRequest Error",
    "4": "4xx Client Error",
    "5": "5xx Server Error"
}

var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var key
    var load = options.response ? loadResponse : loadXhr

    if ("json" in options) {
        isJson = true
        headers["Accept"] = "application/json"
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = load
    xhr.onerror = error
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    // hate IE
    xhr.ontimeout = noop
    xhr.open(method, uri, !sync)
                                    //backward compatibility
    if (options.withCredentials || (options.cors && options.withCredentials !== false)) {
        xhr.withCredentials = true
    }

    // Cannot set timeout with sync request
    if (!sync) {
        xhr.timeout = "timeout" in options ? options.timeout : 5000
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr

    function readystatechange() {
        if (xhr.readyState === 4) {
            load()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = null

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === 'text' || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function getStatusCode() {
        return xhr.status === 1223 ? 204 : xhr.status
    }

    // if we're getting a none-ok statusCode, build & return an error
    function errorFromStatusCode(status, body) {
        var error = null
        if (status === 0 || (status >= 400 && status < 600)) {
            var message = (typeof body === "string" ? body : false) ||
                messages[String(status).charAt(0)]
            error = new Error(message)
            error.statusCode = status
        }

        return error
    }

    // will load the data & process the response in a special response object
    function loadResponse() {
        var status = getStatusCode()
        var body = getBody()
        var error = errorFromStatusCode(status, body)
        var response = {
            body: body,
            statusCode: status,
            statusText: xhr.statusText,
            raw: xhr
        }
        if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
            response.headers = parseHeaders(xhr.getAllResponseHeaders())
        } else {
            response.headers = {}
        }

        callback(error, response, response.body)
    }

    // will load the data and add some response properties to the source xhr
    // and then respond with that
    function loadXhr() {
        var status = getStatusCode()
        var error = errorFromStatusCode(status)

        xhr.status = xhr.statusCode = status
        xhr.body = getBody()
        xhr.headers = parseHeaders(xhr.getAllResponseHeaders())

        callback(error, xhr, xhr.body)
    }

    function error(evt) {
        callback(evt, xhr)
    }
}


function noop() {}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr")
},{"1YiZ5S":18,"buffer":15,"global/window":8,"once":9,"parse-headers":13}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/global/window.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/global")
},{"1YiZ5S":18,"buffer":15}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/once/once.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/once")
},{"1YiZ5S":18,"buffer":15}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/for-each/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/for-each")
},{"1YiZ5S":18,"buffer":15,"is-function":11}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/for-each/node_modules/is-function/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/for-each/node_modules/is-function")
},{"1YiZ5S":18,"buffer":15}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/trim/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/trim")
},{"1YiZ5S":18,"buffer":15}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/parse-headers.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers")
},{"1YiZ5S":18,"buffer":15,"for-each":10,"trim":12}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * This file is part of Cytoscape.js 2.3.9.
 * 
 * Cytoscape.js is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 * 
 * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License along with
 * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.
 */
 

// this is put as a global var in the browser
// or it's just a global to this module if commonjs

var cytoscape;

(function(window){ 'use strict';

  // the object iteself is a function that init's an instance of cytoscape

  var $$ = cytoscape = function(){ // jshint ignore:line
    return cytoscape.init.apply(cytoscape, arguments);
  };

  $$.version = '2.3.9';
  
  // allow functional access to cytoscape.js
  // e.g. var cyto = $.cytoscape({ selector: "#foo", ... });
  //      var nodes = cyto.nodes();
  $$.init = function( options ){
    
    // if no options specified, use default
    if( options === undefined ){
      options = {};
    }

    // create instance
    if( $$.is.plainObject( options ) ){
      return new $$.Core( options );
    } 
    
    // allow for registration of extensions
    // e.g. $.cytoscape('renderer', 'svg', SvgRenderer);
    // e.g. $.cytoscape('renderer', 'svg', 'nodeshape', 'ellipse', SvgEllipseNodeShape);
    // e.g. $.cytoscape('core', 'doSomething', function(){ /* doSomething code */ });
    // e.g. $.cytoscape('collection', 'doSomething', function(){ /* doSomething code */ });
    else if( $$.is.string( options ) ) {
      return $$.extension.apply($$.extension, arguments);
    }
  };

  // define the function namespace here, since it has members in many places
  $$.fn = {};

  if( typeof module !== 'undefined' && module.exports ){ // expose as a commonjs module
    module.exports = cytoscape;
  }

  if( typeof define !== 'undefined' && define.amd ){ // expose as an amd/requirejs module
    define('cytoscape', function(){
      return cytoscape;
    });
  }

  // make sure we always register in the window just in case (e.g. w/ derbyjs)
  if( window ){
    window.cytoscape = cytoscape;
  }
  
})( typeof window === 'undefined' ? null : window );

// type testing utility functions

;(function($$, window){ 'use strict';

  $$.is = {
    defined: function(obj){
      return obj != null; // not undefined or null
    },

    string: function(obj){
      return obj != null && typeof obj == typeof '';
    },
    
    fn: function(obj){
      return obj != null && typeof obj === typeof function(){};
    },
    
    array: function(obj){
      return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
    },
    
    plainObject: function(obj){
      return obj != null && typeof obj === typeof {} && !$$.is.array(obj) && obj.constructor === Object;
    },
    
    number: function(obj){
      return obj != null && typeof obj === typeof 1 && !isNaN(obj);
    },

    integer: function( obj ){
      return $$.is.number(obj) && Math.floor(obj) === obj;
    },
    
    color: function(obj){
      return obj != null && typeof obj === typeof '' && $.Color(obj).toString() !== '';
    },
    
    bool: function(obj){
      return obj != null && typeof obj === typeof true;
    },
    
    elementOrCollection: function(obj){
      return $$.is.element(obj) || $$.is.collection(obj);
    },
    
    element: function(obj){
      return obj instanceof $$.Element && obj._private.single;
    },
    
    collection: function(obj){
      return obj instanceof $$.Collection && !obj._private.single;
    },
    
    core: function(obj){
      return obj instanceof $$.Core;
    },

    style: function(obj){
      return obj instanceof $$.Style;
    },

    stylesheet: function(obj){
      return obj instanceof $$.Stylesheet;
    },

    event: function(obj){
      return obj instanceof $$.Event;
    },

    emptyString: function(obj){
      if( !obj ){ // null is empty
        return true; 
      } else if( $$.is.string(obj) ){
        if( obj === '' || obj.match(/^\s+$/) ){
          return true; // empty string is empty
        }
      }
      
      return false; // otherwise, we don't know what we've got
    },
    
    nonemptyString: function(obj){
      if( obj && $$.is.string(obj) && obj !== '' && !obj.match(/^\s+$/) ){
        return true;
      }

      return false;
    },

    domElement: function(obj){
      if( typeof HTMLElement === 'undefined' ){
        return false; // we're not in a browser so it doesn't matter
      } else {
        return obj instanceof HTMLElement;
      }
    },

    boundingBox: function(obj){
      return $$.is.plainObject(obj) && 
        $$.is.number(obj.x1) && $$.is.number(obj.x2) &&
        $$.is.number(obj.y1) && $$.is.number(obj.y2)
      ;
    },

    touch: function(){
      return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
    },

    gecko: function(){
      return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);
    },

    webkit: function(){
      return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);
    },

    chromium: function(){
      return typeof chrome !== 'undefined';
    },

    khtml: function(){
      return navigator.vendor.match(/kde/i); // TODO probably a better way to detect this...
    },

    khtmlEtc: function(){
      return $$.is.khtml() || $$.is.webkit() || $$.is.blink();
    },

    trident: function(){
       return typeof ActiveXObject !== 'undefined' || /*@cc_on!@*/false;
    },

    windows: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Win/i);
    },

    mac: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Mac/i);
    },

    linux: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Linux/i);
    },

    unix: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/X11/i);
    }
  };  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  // utility functions only for internal use

  $$.util = {

    // the jquery extend() function
    // NB: modified to use $$.is etc since we can't use jquery functions
    extend: function() {
      var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

      // Handle a deep copy situation
      if ( typeof target === 'boolean' ) {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
      }

      // Handle case when target is a string or something (possible in deep copy)
      if ( typeof target !== 'object' && !$$.is.fn(target) ) {
        target = {};
      }

      // extend jQuery itself if only one argument is passed
      if ( length === i ) {
        target = this;
        --i;
      }

      for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
          // Extend the base object
          for ( name in options ) {
            src = target[ name ];
            copy = options[ name ];

            // Prevent never-ending loop
            if ( target === copy ) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            if ( deep && copy && ( $$.is.plainObject(copy) || (copyIsArray = $$.is.array(copy)) ) ) {
              if ( copyIsArray ) {
                copyIsArray = false;
                clone = src && $$.is.array(src) ? src : [];

              } else {
                clone = src && $$.is.plainObject(src) ? src : {};
              }

              // Never move original objects, clone them
              target[ name ] = $$.util.extend( deep, clone, copy );

            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
              target[ name ] = copy;
            }
          }
        }
      }

      // Return the modified object
      return target;
    },

    // require that pulls in module from commonjs, amd, or window (falling back until found)
    require: function( name, callback, options ){
      var ret;
      options = $$.util.extend({
        msgIfNotFound: true
      }, options);

      var done = false;
      var fulfil = function( ret ){
        done = true;
        callback( ret );
      };

      var checkWindow = function( next ){
        if( window ){ // detected browser/window env
          ret = window[ name ];
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckWindowDone = function(){
        if( !done ){
          checkCommonJs( onCheckCommonJsDone );
        }
      };

      var checkCommonJs = function( next ){
        if( typeof module !== 'undefined' && module.exports && require ){ // detected commonjs env
          ret = require( name ); // regular require
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckCommonJsDone = function(){
        if( !done ){
          checkAmd( onCheckAmdDone );
        }
      };

      var checkAmd = function( next ){
        if( typeof define !== 'undefined' && define.amd && require ){ // detected amd env w/ defined module
          require([ name ], function( nameImpl ){
            ret = nameImpl;
            
            if( ret !== undefined ){ fulfil(ret); }
            if( next ){ next(); }
          });
        }
      };
      var onCheckAmdDone = function(){
        if( !done && options.msgIfNotFound ){
          $$.util.error('Cytoscape.js tried to pull in dependency `' + name + '` but no module (i.e. CommonJS, AMD, or window) was found');
        }
      };

      // kick off 1st check: window
      checkWindow( onCheckWindowDone );

    },

    // multiple requires in one callback
    requires: function( names, callback ){
      var impls = [];
      var gotImpl = [];

      var checkDone = function(){
        for( var i = 0; i < names.length; i++ ){ // check have all impls
          if( !gotImpl[i] ){ return; }
        }

        // otherwise, all got all impls => done
        callback.apply( callback, impls ); 
      };

      for( var i = 0; i < names.length; i++ ){ (function(){ // w/scope
        var name = names[i];
        var index = i;

        $$.util.require(name, function(impl){
          impls[index] = impl;
          gotImpl[index] = true;

          checkDone();
        });
      })(); }
    },

    // ported lodash throttle function
    throttle: function(func, wait, options) {
      var leading = true,
          trailing = true;

      if (options === false) {
        leading = false;
      } else if ($$.is.plainObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      options = options || {};
      options.leading = leading;
      options.maxWait = wait;
      options.trailing = trailing;

      return $$.util.debounce(func, wait, options);
    },

    now: function(){
      return +new Date();
    },

    // ported lodash debounce function
    debounce: function(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!$$.is.fn(func)) {
        return;
      }
      wait = Math.max(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if ($$.is.plainObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - ($$.util.now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = $$.util.now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = $$.util.now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = $$.util.now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    },

    error: function( msg ){
      if( console ){
        if( console.error ){
          console.error.apply( console, arguments );
        } else if( console.log ){
          console.log.apply( console, arguments );
        } else {
          throw msg;
        }
      } else {
        throw msg;
      }
    },    

    clone: function( obj ){
      var target = {};
      for (var i in obj) {
        if ( obj.hasOwnProperty(i) ) { // TODO is this hasOwnProperty() call necessary for our use?
          target[i] = obj[i];
        }
      }
      return target;
    },

    // gets a shallow copy of the argument
    copy: function( obj ){
      if( obj == null ){
        return obj;
      } if( $$.is.array(obj) ){
        return obj.slice();
      } else if( $$.is.plainObject(obj) ){
        return $$.util.clone( obj );
      } else {
        return obj;
      }
    },
    
    // makes a full bb (x1, y1, x2, y2, w, h) from implicit params
    makeBoundingBox: function( bb ){
      if( bb.x1 != null && bb.y1 != null ){
        if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x2,
            y2: bb.y2,
            w: bb.x2 - bb.x1,
            h: bb.y2 - bb.y1
          };
        } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x1 + bb.w,
            y2: bb.y1 + bb.h,
            w: bb.w,
            h: bb.h
          };
        }
      } 
    },

    // has anything been set in the map
    mapEmpty: function( map ){
      var empty = true;

      if( map != null ){
        for(var i in map){ // jshint ignore:line
          empty = false;
          break;
        }
      }

      return empty;
    },

    // pushes to the array at the end of a map (map may not be built)
    pushMap: function( options ){
      var array = $$.util.getMap(options);

      if( array == null ){ // if empty, put initial array
        $$.util.setMap( $.extend({}, options, {
          value: [ options.value ]
        }) );
      } else {
        array.push( options.value );
      }
    },

    // sets the value in a map (map may not be built)
    setMap: function( options ){
      var obj = options.map;
      var key;
      var keys = options.keys;
      var l = keys.length;

      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to set map with object key');
        }

        if( i < keys.length - 1 ){
          
          // extend the map if necessary
          if( obj[key] == null ){
            obj[key] = {};
          }
          
          obj = obj[key];
        } else {
          // set the value
          obj[key] = options.value;
        }
      }
    },
    
    // gets the value in a map even if it's not built in places
    getMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to get map with object key');
        }

        obj = obj[key];
        
        if( obj == null ){
          return obj;
        }
      }
      
      return obj;
    },

    // deletes the entry in the map
    deleteMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      var keepChildren = options.keepChildren;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to delete map with object key');
        }

        var lastKey = i === options.keys.length - 1;
        if( lastKey ){
          
          if( keepChildren ){ // then only delete child fields not in keepChildren
            for( var child in obj ){
              if( !keepChildren[child] ){
                obj[child] = undefined;
              }
            }
          } else {
            obj[key] = undefined;
          }

        } else {
          obj = obj[key];
        }
      }
    },
    
    capitalize: function(str){
      if( $$.is.emptyString(str) ){
        return str;
      }
      
      return str.charAt(0).toUpperCase() + str.substring(1);
    },

    camel2dash: function( str ){
      var ret = [];

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var chLowerCase = ch.toLowerCase();
        var isUpperCase = ch !== chLowerCase;

        if( isUpperCase ){
          ret.push( '-' );
          ret.push( chLowerCase );
        } else {
          ret.push( ch );
        }
      }

      var noUpperCases = ret.length === str.length;
      if( noUpperCases ){ return str; } // cheaper than .join()

      return ret.join('');
    },

    dash2camel: function( str ){
      var ret = [];
      var nextIsUpper = false;

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var isDash = ch === '-';

        if( isDash ){
          nextIsUpper = true;
        } else {
          if( nextIsUpper ){
            ret.push( ch.toUpperCase() );
          } else {
            ret.push( ch );
          }

          nextIsUpper = false;
        }
      }

      return ret.join('');
    },

    // strip spaces from beginning of string and end of string
    trim: function( str ){
      var first, last;

      // find first non-space char
      for( first = 0; first < str.length && str[first] === ' '; first++ ){}

      // find last non-space char
      for( last = str.length - 1; last > first && str[last] === ' '; last-- ){}

      return str.substring(first, last + 1);
    },

    // get [r, g, b] from #abc or #aabbcc
    hex2tuple: function( hex ){
      if( !(hex.length === 4 || hex.length === 7) || hex[0] !== "#" ){ return; }

      var shortHex = hex.length === 4;
      var r, g, b;
      var base = 16;

      if( shortHex ){
        r = parseInt( hex[1] + hex[1], base );
        g = parseInt( hex[2] + hex[2], base );
        b = parseInt( hex[3] + hex[3], base );
      } else {
        r = parseInt( hex[1] + hex[2], base );
        g = parseInt( hex[3] + hex[4], base );
        b = parseInt( hex[5] + hex[6], base );
      }

      return [r, g, b];
    },

    // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
    hsl2tuple: function( hsl ){
      var ret;
      var h, s, l, a, r, g, b;
      function hue2rgb(p, q, t){
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      }

      var m = new RegExp("^" + $$.util.regex.hsla + "$").exec(hsl);
      if( m ){

        // get hue
        h = parseInt( m[1] ); 
        if( h < 0 ){
          h = ( 360 - (-1*h % 360) ) % 360;
        } else if( h > 360 ){
          h = h % 360;
        }
        h /= 360; // normalise on [0, 1]

        s = parseFloat( m[2] );
        if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
        s = s/100; // normalise on [0, 1]

        l = parseFloat( m[3] );
        if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
        l = l/100; // normalise on [0, 1]

        a = m[4];
        if( a !== undefined ){
          a = parseFloat( a );

          if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
        }

        // now, convert to rgb
        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
        if( s === 0 ){
          r = g = b = Math.round(l * 255); // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );
          g = Math.round( 255 * hue2rgb(p, q, h) );
          b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );
        }

        ret = [r, g, b, a];
      }

      return ret;
    },

    // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
    rgb2tuple: function( rgb ){
      var ret;

      var m = new RegExp("^" + $$.util.regex.rgba + "$").exec(rgb);
      if( m ){
        ret = [];

        var isPct = [];
        for( var i = 1; i <= 3; i++ ){
          var channel = m[i];

          if( channel[ channel.length - 1 ] === "%" ){
            isPct[i] = true;
          }
          channel = parseFloat( channel );

          if( isPct[i] ){
            channel = channel/100 * 255; // normalise to [0, 255]
          }

          if( channel < 0 || channel > 255 ){ return; } // invalid channel value

          ret.push( Math.floor(channel) );
        }

        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
        var allArePct = isPct[1] && isPct[2] && isPct[3];
        if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

        var alpha = m[4];
        if( alpha !== undefined ){
          alpha = parseFloat( alpha );

          if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

          ret.push( alpha );
        }
      }

      return ret;
    },

    colorname2tuple: function( color ){
      return $$.util.colors[ color.toLowerCase() ];
    },

    color2tuple: function( color ){
      return ( $$.is.array(color) ? color : null ) 
        || $$.util.colorname2tuple(color)
        || $$.util.hex2tuple(color)
        || $$.util.rgb2tuple(color)
        || $$.util.hsl2tuple(color);
    },

    tuple2hex: function( tuple ){
      var r = tuple[0];
      var g = tuple[1];
      var b = tuple[2];

      function ch2hex( ch ){
        var hex = ch.toString(16);

        if( hex.length === 1 ){
          hex = '0' + hex;
        }

        return hex;
      }

      return '#' + ch2hex(r) + ch2hex(g) + ch2hex(b);
    },

    colors: {
      // special colour names
      transparent:      [0,0,0,0], // NB alpha === 0

      // regular colours
      aliceblue:        [240,248,255],
      antiquewhite:      [250,235,215],
      aqua:          [0,255,255],
      aquamarine:        [127,255,212],
      azure:          [240,255,255],
      beige:          [245,245,220],
      bisque:          [255,228,196],
      black:          [0,0,0],
      blanchedalmond:      [255,235,205],
      blue:          [0,0,255],
      blueviolet:        [138,43,226],
      brown:          [165,42,42],
      burlywood:        [222,184,135],
      cadetblue:        [95,158,160],
      chartreuse:        [127,255,0],
      chocolate:        [210,105,30],
      coral:          [255,127,80],
      cornflowerblue:      [100,149,237],
      cornsilk:        [255,248,220],
      crimson:        [220,20,60],
      cyan:          [0,255,255],
      darkblue:        [0,0,139],
      darkcyan:        [0,139,139],
      darkgoldenrod:      [184,134,11],
      darkgray:        [169,169,169],
      darkgreen:        [0,100,0],
      darkgrey:        [169,169,169],
      darkkhaki:        [189,183,107],
      darkmagenta:      [139,0,139],
      darkolivegreen:      [85,107,47],
      darkorange:        [255,140,0],
      darkorchid:        [153,50,204],
      darkred:        [139,0,0],
      darksalmon:        [233,150,122],
      darkseagreen:      [143,188,143],
      darkslateblue:      [72,61,139],
      darkslategray:      [47,79,79],
      darkslategrey:      [47,79,79],
      darkturquoise:      [0,206,209],
      darkviolet:        [148,0,211],
      deeppink:        [255,20,147],
      deepskyblue:      [0,191,255],
      dimgray:        [105,105,105],
      dimgrey:        [105,105,105],
      dodgerblue:        [30,144,255],
      firebrick:        [178,34,34],
      floralwhite:      [255,250,240],
      forestgreen:      [34,139,34],
      fuchsia:        [255,0,255],
      gainsboro:        [220,220,220],
      ghostwhite:        [248,248,255],
      gold:          [255,215,0],
      goldenrod:        [218,165,32],
      gray:          [128,128,128],
      grey:          [128,128,128],
      green:          [0,128,0],
      greenyellow:      [173,255,47],
      honeydew:        [240,255,240],
      hotpink:        [255,105,180],
      indianred:        [205,92,92],
      indigo:          [75,0,130],
      ivory:          [255,255,240],
      khaki:          [240,230,140],
      lavender:        [230,230,250],
      lavenderblush:      [255,240,245],
      lawngreen:        [124,252,0],
      lemonchiffon:      [255,250,205],
      lightblue:        [173,216,230],
      lightcoral:        [240,128,128],
      lightcyan:        [224,255,255],
      lightgoldenrodyellow:  [250,250,210],
      lightgray:        [211,211,211],
      lightgreen:        [144,238,144],
      lightgrey:        [211,211,211],
      lightpink:        [255,182,193],
      lightsalmon:      [255,160,122],
      lightseagreen:      [32,178,170],
      lightskyblue:      [135,206,250],
      lightslategray:      [119,136,153],
      lightslategrey:      [119,136,153],
      lightsteelblue:      [176,196,222],
      lightyellow:      [255,255,224],
      lime:          [0,255,0],
      limegreen:        [50,205,50],
      linen:          [250,240,230],
      magenta:        [255,0,255],
      maroon:          [128,0,0],
      mediumaquamarine:    [102,205,170],
      mediumblue:        [0,0,205],
      mediumorchid:      [186,85,211],
      mediumpurple:      [147,112,219],
      mediumseagreen:      [60,179,113],
      mediumslateblue:    [123,104,238],
      mediumspringgreen:    [0,250,154],
      mediumturquoise:    [72,209,204],
      mediumvioletred:    [199,21,133],
      midnightblue:      [25,25,112],
      mintcream:        [245,255,250],
      mistyrose:        [255,228,225],
      moccasin:        [255,228,181],
      navajowhite:      [255,222,173],
      navy:          [0,0,128],
      oldlace:        [253,245,230],
      olive:          [128,128,0],
      olivedrab:        [107,142,35],
      orange:          [255,165,0],
      orangered:        [255,69,0],
      orchid:          [218,112,214],
      palegoldenrod:      [238,232,170],
      palegreen:        [152,251,152],
      paleturquoise:      [175,238,238],
      palevioletred:      [219,112,147],
      papayawhip:        [255,239,213],
      peachpuff:        [255,218,185],
      peru:          [205,133,63],
      pink:          [255,192,203],
      plum:          [221,160,221],
      powderblue:        [176,224,230],
      purple:          [128,0,128],
      red:          [255,0,0],
      rosybrown:        [188,143,143],
      royalblue:        [65,105,225],
      saddlebrown:      [139,69,19],
      salmon:          [250,128,114],
      sandybrown:        [244,164,96],
      seagreen:        [46,139,87],
      seashell:        [255,245,238],
      sienna:          [160,82,45],
      silver:          [192,192,192],
      skyblue:        [135,206,235],
      slateblue:        [106,90,205],
      slategray:        [112,128,144],
      slategrey:        [112,128,144],
      snow:          [255,250,250],
      springgreen:      [0,255,127],
      steelblue:        [70,130,180],
      tan:          [210,180,140],
      teal:          [0,128,128],
      thistle:        [216,191,216],
      tomato:          [255,99,71],
      turquoise:        [64,224,208],
      violet:          [238,130,238],
      wheat:          [245,222,179],
      white:          [255,255,255],
      whitesmoke:        [245,245,245],
      yellow:          [255,255,0],
      yellowgreen:      [154,205,50]
    }
      
  };

  $$.util.regex = {};
  
  $$.util.regex.number = "(?:[-]?\\d*\\.\\d+|[-]?\\d+|[-]?\\d*\\.\\d+[eE]\\d+)";
  
  $$.util.regex.rgba = "rgb[a]?\\(("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.rgbaNoBackRefs = "rgb[a]?\\((?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hsla = "hsl[a]?\\(("+ $$.util.regex.number +")\\s*,\\s*("+ $$.util.regex.number +"[%])\\s*,\\s*("+ $$.util.regex.number +"[%])(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.hslaNoBackRefs = "hsl[a]?\\((?:"+ $$.util.regex.number +")\\s*,\\s*(?:"+ $$.util.regex.number +"[%])\\s*,\\s*(?:"+ $$.util.regex.number +"[%])(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hex3 = "\\#[0-9a-fA-F]{3}";
  $$.util.regex.hex6 = "\\#[0-9a-fA-F]{6}";

  var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||  
        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );

  raf = raf || function(fn){ if(fn){ setTimeout(fn, 1000/60); } };

  $$.util.requestAnimationFrame = function(fn){
    raf( fn );
  };

})( cytoscape, typeof window === 'undefined' ? null : window  );

;(function($$){ 'use strict';
  
  $$.math = {};
  
  $$.math.signum = function(x){
    if( x > 0 ){
      return 1;
    } else if( x < 0 ){
      return -1;
    } else {
      return 0;
    }
  };

  $$.math.distance = function( p1, p2 ){
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt( dx*dx + dy*dy );
  };

  // from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves
  $$.math.qbezierAt = function(p0, p1, p2, t){
    return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;
  };

  $$.math.qbezierPtAt = function(p0, p1, p2, t){
    return {
      x: $$.math.qbezierAt( p0.x, p1.x, p2.x, t ),
      y: $$.math.qbezierAt( p0.y, p1.y, p2.y, t )
    };
  };

  $$.math.boundingBoxesIntersect = function( bb1, bb2 ){
    // case: one bb to right of other
    if( bb1.x1 > bb2.x2 ){ return false; }
    if( bb2.x1 > bb1.x2 ){ return false; }

    // case: one bb to left of other
    if( bb1.x2 < bb2.x1 ){ return false; }
    if( bb2.x2 < bb1.x1 ){ return false; }

    // case: one bb above other
    if( bb1.y2 < bb2.y1 ){ return false; }
    if( bb2.y2 < bb1.y1 ){ return false; }

    // case: one bb below other
    if( bb1.y1 > bb2.y2 ){ return false; }
    if( bb2.y1 > bb1.y2 ){ return false; }

    // otherwise, must have some overlap
    return true;
  };

  $$.math.inBoundingBox = function( bb, x, y ){
    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
  };

  $$.math.pointInBoundingBox = function( bb, pt ){
    return this.inBoundingBox( bb, pt.x, pt.y );
  };

  $$.math.roundRectangleIntersectLine = function(
    x, y, nodeX, nodeY, width, height, padding) {
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    
    // Check intersections with straight line segments
    var straightLineIntersections;
    
    // Top segment, left to right
    {
      var topStartX = nodeX - halfWidth + cornerRadius - padding;
      var topStartY = nodeY - halfHeight - padding;
      var topEndX = nodeX + halfWidth - cornerRadius + padding;
      var topEndY = topStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Right segment, top to bottom
    {
      var rightStartX = nodeX + halfWidth + padding;
      var rightStartY = nodeY - halfHeight + cornerRadius - padding;
      var rightEndX = rightStartX;
      var rightEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Bottom segment, left to right
    {
      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
      var bottomStartY = nodeY + halfHeight + padding;
      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
      var bottomEndY = bottomStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Left segment, top to bottom
    {
      var leftStartX = nodeX - halfWidth - padding;
      var leftStartY = nodeY - halfHeight + cornerRadius - padding;
      var leftEndX = leftStartX;
      var leftEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Check intersections with arc segments
    var arcIntersections;
    
    // Top Left
    {
      var topLeftCenterX = nodeX - halfWidth + cornerRadius;
      var topLeftCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topLeftCenterX, topLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= topLeftCenterX
        && arcIntersections[1] <= topLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Top Right
    {
      var topRightCenterX = nodeX + halfWidth - cornerRadius;
      var topRightCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topRightCenterX, topRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= topRightCenterX
        && arcIntersections[1] <= topRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Right
    {
      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= bottomRightCenterX
        && arcIntersections[1] >= bottomRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Left
    {
      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= bottomLeftCenterX
        && arcIntersections[1] >= bottomLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }

    return []; // if nothing
  };
  
  $$.math.roundRectangleIntersectBox = function(
    boxX1, boxY1, boxX2, boxY2, width, height, centerX, centerY, padding) {
    
    // We have the following shpae
    
    //    _____
    //  _|     |_
    // |         |
    // |_       _|
    //   |_____|
    //
    // With a quarter circle at each corner.
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var hBoxTopLeftX = centerX - width / 2 - padding;
    var hBoxTopLeftY = centerY - height / 2 + cornerRadius - padding;
    var hBoxBottomRightX = centerX + width / 2 + padding;
    var hBoxBottomRightY = centerY + height / 2 - cornerRadius + padding;
    
    var vBoxTopLeftX = centerX - width / 2 + cornerRadius - padding;
    var vBoxTopLeftY = centerY - height / 2 - padding;
    var vBoxBottomRightX = centerX + width / 2 - cornerRadius + padding;
    var vBoxBottomRightY = centerY + height / 2 + padding;
    
    // Check if the box is out of bounds
    var boxMinX = Math.min(boxX1, boxX2);
    var boxMaxX = Math.max(boxX1, boxX2);
    var boxMinY = Math.min(boxY1, boxY2);
    var boxMaxY = Math.max(boxY1, boxY2);
    
    if (boxMaxX < hBoxTopLeftX) {
      return false;
    } else if (boxMinX > hBoxBottomRightX) {
      return false;
    }
    
    if (boxMaxY < vBoxTopLeftY) {
      return false;
    } else if (boxMinY > vBoxBottomRightY) {
      return false;
    }
    
    // Check if an hBox point is in given box
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the hBox
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    // Check if an vBox point is in given box
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the vBox
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    // Lastly, check if one of the ellipses coincide with the box
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    return false;
  };
  
  // @O Approximate collision functions
  $$.math.checkInBoundingCircle = function(
    x, y, farthestPointSqDistance, padding, width, height, centerX, centerY) {
    
    x = (x - centerX) / (width + padding);
    y = (y - centerY) / (height + padding);
    
    return (x * x + y * y) <= farthestPointSqDistance;
  };
  
  $$.math.boxInBezierVicinity = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    // Return values:
    // 0 - curve is not in box
    // 1 - curve may be in box; needs precise check
    // 2 - curve is in box
    
    // midpoint
    var midX = 0.25 * x1 + 0.5 * x2 + 0.25 * x3;
    var midY = 0.25 * y1 + 0.5 * y2 + 0.25 * y3;

    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) { // (x1, y1) in box
      return 1;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) { // (x3, y3) in box
      return 1;
    } else if (midX >= boxMinX && midX <= boxMaxX && midY >= boxMinY && midY <= boxMaxY) { // (midX, midY) in box
      return 1;
    } else if (x2 >= boxMinX && x2 <= boxMaxX && y2 >= boxMinY && y2 <= boxMaxY) { // ctrl pt in box
      return 1;
    }
    
    var curveMinX = Math.min(x1, midX, x3);
    var curveMinY = Math.min(y1, midY, y3);
    var curveMaxX = Math.max(x1, midX, x3);
    var curveMaxY = Math.max(y1, midY, y3);
    
    /*
    console.log(curveMinX + ", " + curveMinY + ", " + curveMaxX 
      + ", " + curveMaxY);
    if (curveMinX == undefined) {
      console.log("undefined curveMinX: " + x1 + ", " + x2 + ", " + x3);
    }
    */
    
    if (curveMinX > boxMaxX
      || curveMaxX < boxMinX
      || curveMinY > boxMaxY
      || curveMaxY < boxMinY) {
      
      return 0;  
    }
    
    return 1;
  };

  $$.math.checkBezierInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {

    function sampleInBox(t){
      var x = $$.math.qbezierAt(x1, x2, x3, t);
      var y = $$.math.qbezierAt(y1, y2, y3, t);

      return x1box <= x && x <= x2box
        && y1box <= y && y <= y2box
      ;
    }

    for( var t = 0; t <= 1; t += 0.25 ){
      if( !sampleInBox(t) ){
        return false;
      }
    }

    return true;
  };
  
  $$.math.checkStraightEdgeInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {

    return x1box <= x1 && x1 <= x2box
      && x1box <= x2 && x2 <= x2box
      && y1box <= y1 && y1 <= y2box
      && y1box <= y2 && y2 <= y2box
    ;
  };

  $$.math.checkStraightEdgeCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {
    
   //console.log(arguments);
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    // Check left + right bounds
    var aX = x2 - x1;
    var bX = x1;
    var yValue;
    
    // Top and bottom
    var aY = y2 - y1;
    var bY = y1;
    var xValue;
    
    if (Math.abs(aX) < 0.0001) {
      return (x1 >= boxMinX && x1 <= boxMaxX
        && Math.min(y1, y2) <= boxMinY
        && Math.max(y1, y2) >= boxMaxY);  
    }
    
    var tLeft = (boxMinX - bX) / aX;
    if (tLeft > 0 && tLeft <= 1) {
      yValue = aY * tLeft + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tRight = (boxMaxX - bX) / aX;
    if (tRight > 0 && tRight <= 1) {
      yValue = aY * tRight + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tTop = (boxMinY - bY) / aY;
    if (tTop > 0 && tTop <= 1) {
      xValue = aX * tTop + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    var tBottom = (boxMaxY - bY) / aY;
    if (tBottom > 0 && tBottom <= 1) {
      xValue = aX * tBottom + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    return false;
  };
  
  $$.math.checkBezierCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) {
      return true;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) {
      return true;
    }
    
    var aX = x1 - 2 * x2 + x3;
    var bX = -2 * x1 + 2 * x2;
    var cX = x1;

    var xIntervals = [];
    
    if (Math.abs(aX) < 0.0001) {
      var leftParam = (boxMinX - x1) / bX;
      var rightParam = (boxMaxX - x1) / bX;
      
      xIntervals.push(leftParam, rightParam);
    } else {
      // Find when x coordinate of the curve crosses the left side of the box
      var discriminantX1 = bX * bX - 4 * aX * (cX - boxMinX);
      var tX1, tX2;
      if (discriminantX1 > 0) {
        var sqrt = Math.sqrt(discriminantX1);
        tX1 = (-bX + sqrt) / (2 * aX);
        tX2 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX1, tX2);
      }
      
      var discriminantX2 = bX * bX - 4 * aX * (cX - boxMaxX);
      var tX3, tX4;
      if (discriminantX2 > 0) {
        var sqrt = Math.sqrt(discriminantX2);
        tX3 = (-bX + sqrt) / (2 * aX);
        tX4 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX3, tX4);
      }
    }
    
    xIntervals.sort(function(a, b) { return a - b; });
    
    var aY = y1 - 2 * y2 + y3;
    var bY = -2 * y1 + 2 * y2;
    var cY = y1;
    
    var yIntervals = [];
    
    if (Math.abs(aY) < 0.0001) {
      var topParam = (boxMinY - y1) / bY;
      var bottomParam = (boxMaxY - y1) / bY;
      
      yIntervals.push(topParam, bottomParam);
    } else {
      var discriminantY1 = bY * bY - 4 * aY * (cY - boxMinY);
      
      var tY1, tY2;
      if (discriminantY1 > 0) {
        var sqrt = Math.sqrt(discriminantY1);
        tY1 = (-bY + sqrt) / (2 * aY);
        tY2 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY1, tY2);
      }
  
      var discriminantY2 = bY * bY - 4 * aY * (cY - boxMaxY);
      
      var tY3, tY4;
      if (discriminantY2 > 0) {
        var sqrt = Math.sqrt(discriminantY2);
        tY3 = (-bY + sqrt) / (2 * aY);
        tY4 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY3, tY4);
      }
    }
        
    yIntervals.sort(function(a, b) { return a - b; });

    for (var index = 0; index < xIntervals.length; index += 2) {
      for (var yIndex = 1; yIndex < yIntervals.length; yIndex += 2) {
        
        // Check if there exists values for the Bezier curve
        // parameter between 0 and 1 where both the curve's
        // x and y coordinates are within the bounds specified by the box
        if (xIntervals[index] < yIntervals[yIndex]
          && yIntervals[yIndex] >= 0.0
          && xIntervals[index] <= 1.0
          && xIntervals[index + 1] > yIntervals[yIndex - 1]
          && yIntervals[yIndex - 1] <= 1.0
          && xIntervals[index + 1] >= 0.0) {
          
          return true;
        }
      }
    }
    
    return false;
  };
  
  $$.math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){
    var t = tolerance;

    var x1 = Math.min(lx1, lx2);
    var x2 = Math.max(lx1, lx2);
    var y1 = Math.min(ly1, ly2);
    var y2 = Math.max(ly1, ly2);

    return x1 - t <= x && x <= x2 + t
      && y1 - t <= y && y <= y2 + t;
  };

  $$.math.inBezierVicinity = function(
    x, y, x1, y1, x2, y2, x3, y3, toleranceSquared) {

    var bb = {
      x1: Math.min( x1, x3, x2 ),
      x2: Math.max( x1, x3, x2 ),
      y1: Math.min( y1, y3, y2 ),
      y2: Math.max( y1, y3, y2 )
    };

    // if outside the rough bounding box for the bezier, then it can't be a hit
    if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
      // console.log('bezier out of rough bb')
      return false;
    } else {
      // console.log('do more expensive check');
      return true;
    }

  };
  
  $$.math.solveCubic = function(a, b, c, d, result) {
    
    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
    // r is the real component, i is the imaginary component

    // An implementation of the Cardano method from the year 1545
    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

    b /= a;
    c /= a;
    d /= a;
    
    var discriminant, q, r, dum1, s, t, term1, r13;

    q = (3.0 * c - (b * b)) / 9.0;
    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
    r /= 54.0;
    
    discriminant = q * q * q + r * r;
    result[1] = 0;
    term1 = (b / 3.0);
    
    if (discriminant > 0) {
      s = r + Math.sqrt(discriminant);
      s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));
      t = r - Math.sqrt(discriminant);
      t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));
      result[0] = -term1 + s + t;
      term1 += (s + t) / 2.0;
      result[4] = result[2] = -term1;
      term1 = Math.sqrt(3.0) * (-t + s) / 2;
      result[3] = term1;
      result[5] = -term1;
      return;
    }
    
    result[5] = result[3] = 0;
    
    if (discriminant === 0) {
      r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));
      result[0] = -term1 + 2.0 * r13;
      result[4] = result[2] = -(r13 + term1);
      return;
    }
    
    q = -q;
    dum1 = q * q * q;
    dum1 = Math.acos(r / Math.sqrt(dum1));
    r13 = 2.0 * Math.sqrt(q);
    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
    
    return;
  };

  $$.math.sqDistanceToQuadraticBezier = function(
    x, y, x1, y1, x2, y2, x3, y3) {
    
    // Find minimum distance by using the minimum of the distance 
    // function between the given point and the curve
    
    // This gives the coefficients of the resulting cubic equation
    // whose roots tell us where a possible minimum is
    // (Coefficients are divided by 4)
    
    var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3
      + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;
    
    var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3
      + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;
    
    var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x
      + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;
      
    var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x
      + y1*y2 - y1*y1 + y1*y - y2*y;
    
    // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);
    
    var roots = [];
    
    // Use the cubic solving algorithm
    this.solveCubic(a, b, c, d, roots);
    
    var zeroThreshold = 0.0000001;
    
    var params = [];
    
    for (var index = 0; index < 6; index += 2) {
      if (Math.abs(roots[index + 1]) < zeroThreshold
          && roots[index] >= 0
          && roots[index] <= 1.0) {
        params.push(roots[index]);
      }
    }
    
    params.push(1.0);
    params.push(0.0);
    
    var minDistanceSquared = -1;
    var closestParam;
    
    var curX, curY, distSquared;
    for (var i = 0; i < params.length; i++) {
      curX = Math.pow(1.0 - params[i], 2.0) * x1
        + 2.0 * (1 - params[i]) * params[i] * x2
        + params[i] * params[i] * x3;
        
      curY = Math.pow(1 - params[i], 2.0) * y1
        + 2 * (1.0 - params[i]) * params[i] * y2
        + params[i] * params[i] * y3;
        
      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
      // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
      if (minDistanceSquared >= 0) {
        if (distSquared < minDistanceSquared) {
          minDistanceSquared = distSquared;
          closestParam = params[i];
        }
      } else {
        minDistanceSquared = distSquared;
        closestParam = params[i];
      }
    }
    
    /*
    debugStats.clickX = x;
    debugStats.clickY = y;
    
    debugStats.closestX = Math.pow(1.0 - closestParam, 2.0) * x1
        + 2.0 * (1.0 - closestParam) * closestParam * x2
        + closestParam * closestParam * x3;
        
    debugStats.closestY = Math.pow(1.0 - closestParam, 2.0) * y1
        + 2.0 * (1.0 - closestParam) * closestParam * y2
        + closestParam * closestParam * y3;
    */
    
    // debug("given: " 
    //   + "( " + x + ", " + y + "), " 
    //   + "( " + x1 + ", " + y1 + "), " 
    //   + "( " + x2 + ", " + y2 + "), "
    //   + "( " + x3 + ", " + y3 + ")");
    
    
    // debug("roots: " + roots);
    // debug("params: " + params);
    // debug("closest param: " + closestParam);
    return minDistanceSquared;
  };
  
  $$.math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {
    var offset = [x - x1, y - y1];
    var line = [x2 - x1, y2 - y1];
    
    var lineSq = line[0] * line[0] + line[1] * line[1];
    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
    
    var dotProduct = offset[0] * line[0] + offset[1] * line[1];
    var adjSq = dotProduct * dotProduct / lineSq;
    
    if (dotProduct < 0) {
      return hypSq;
    }
    
    if (adjSq > lineSq) {
      return (x - x2) * (x - x2) + (y - y2) * (y - y2);
    }
    
    return hypSq - adjSq;
  };

  $$.math.pointInsidePolygon = function(
    x, y, basePoints, centerX, centerY, width, height, direction, padding) {

    //var direction = arguments[6];
    var transformedPoints = new Array(basePoints.length);

    // Gives negative angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
        
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
//    console.log("base: " + basePoints);
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);

      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = this.expandPolygon(
        transformedPoints,
        -padding);
      
      points = this.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    var x1, y1, x2, y2;
    var y3;
    
    // Intersect with vertical line through (x, y)
    var up = 0;
    var down = 0;
    for (var i = 0; i < points.length / 2; i++) {
      
      x1 = points[i * 2];
      y1 = points[i * 2 + 1];
      
      if (i + 1 < points.length / 2) {
        x2 = points[(i + 1) * 2];
        y2 = points[(i + 1) * 2 + 1];
      } else {
        x2 = points[(i + 1 - points.length / 2) * 2];
        y2 = points[(i + 1 - points.length / 2) * 2 + 1];
      }
      
//*      console.log("line from (" + x1 + ", " + y1 + ") to (" + x2 + ", " + y2 + ")");

//&      console.log(x1, x, x2);

      if (x1 == x && x2 == x) {
        
      } else if ((x1 >= x && x >= x2)
        || (x1 <= x && x <= x2)) {
        
        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;
        
        if (y3 > y) {
          up++;
        }
        
        if (y3 < y) {
          down++;
        }
        
//*        console.log(y3, y);
        
      } else {
//*        console.log('22');
        continue;
      }
      
    }
    
//*    console.log("up: " + up + ", down: " + down);
    
    if (up % 2 === 0) {
      return false;
    } else {
      return true;
    }
  };

  $$.math.joinLines = function(lineSet) {
    
    var vertices = new Array(lineSet.length / 2);
    
    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
    
    for (var i = 0; i < lineSet.length / 4; i++) {
      currentLineStartX = lineSet[i * 4];
      currentLineStartY = lineSet[i * 4 + 1];
      currentLineEndX = lineSet[i * 4 + 2];
      currentLineEndY = lineSet[i * 4 + 3];
      
      if (i < lineSet.length / 4 - 1) {
        nextLineStartX = lineSet[(i + 1) * 4];
        nextLineStartY = lineSet[(i + 1) * 4 + 1];
        nextLineEndX = lineSet[(i + 1) * 4 + 2];
        nextLineEndY = lineSet[(i + 1) * 4 + 3];
      } else {
        nextLineStartX = lineSet[0];
        nextLineStartY = lineSet[1];
        nextLineEndX = lineSet[2];
        nextLineEndY = lineSet[3];
      }
      
      var intersection = this.finiteLinesIntersect(
        currentLineStartX, currentLineStartY,
        currentLineEndX, currentLineEndY,
        nextLineStartX, nextLineStartY,
        nextLineEndX, nextLineEndY,
        true);
      
      vertices[i * 2] = intersection[0];
      vertices[i * 2 + 1] = intersection[1];
    }
    
    return vertices;
  };

  $$.math.expandPolygon = function(points, pad) {
    
    var expandedLineSet = new Array(points.length * 2);
    
    var currentPointX, currentPointY, nextPointX, nextPointY;
    
    for (var i = 0; i < points.length / 2; i++) {
      currentPointX = points[i * 2];
      currentPointY = points[i * 2 + 1];
      
      if (i < points.length / 2 - 1) {
        nextPointX = points[(i + 1) * 2];
        nextPointY = points[(i + 1) * 2 + 1];
      } else {
        nextPointX = points[0];
        nextPointY = points[1];
      }
      
      // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
      
      // Assume CCW polygon winding
      
      var offsetX = (nextPointY - currentPointY);
      var offsetY = -(nextPointX - currentPointX);
      
      // Normalize
      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
      var normalizedOffsetX = offsetX / offsetLength;
      var normalizedOffsetY = offsetY / offsetLength;
      
      expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
      expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
    }
    
    return expandedLineSet;
  };

  $$.math.intersectLineEllipse = function(
    x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
    
    var dispX = centerX - x;
    var dispY = centerY - y;
    
    dispX /= ellipseWradius;
    dispY /= ellipseHradius;
    
    var len = Math.sqrt(dispX * dispX + dispY * dispY);
    
    var newLength = len - 1;
    
    if (newLength < 0) {
      return [];
    }
    
    var lenProportion = newLength / len;
    
    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
  };
  
  $$.math.dotProduct = function(
    vec1, vec2) {
    
    if (vec1.length != 2 || vec2.length != 2) {
      throw 'dot product: arguments are not vectors';
    }
    
    return (vec1[0] * vec2[0] + vec1[1] * vec2[1]);
  };
  
  // Returns intersections of increasing distance from line's start point
  $$.math.intersectLineCircle = function(
    x1, y1, x2, y2, centerX, centerY, radius) {
    
    // Calculate d, direction vector of line
    var d = [x2 - x1, y2 - y1]; // Direction vector of line
    var c = [centerX, centerY]; // Center of circle
    var f = [x1 - centerX, y1 - centerY];
    
    var a = d[0] * d[0] + d[1] * d[1];
    var b = 2 * (f[0] * d[0] + f[1] * d[1]);
    var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;
    
    var discriminant = b*b-4*a*c;
    
    if (discriminant < 0) {
      return [];
    }
    
    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
    
    var tMin = Math.min(t1, t2);
    var tMax = Math.max(t1, t2);
    var inRangeParams = [];
    
    if (tMin >= 0 && tMin <= 1) {
      inRangeParams.push(tMin);
    }
    
    if (tMax >= 0 && tMax <= 1) {
      inRangeParams.push(tMax);
    }
    
    if (inRangeParams.length === 0) {
      return [];
    }
    
    var nearIntersectionX = inRangeParams[0] * d[0] + x1;
    var nearIntersectionY = inRangeParams[0] * d[1] + y1;
    
    if (inRangeParams.length > 1) {
    
      if (inRangeParams[0] == inRangeParams[1]) {
        return [nearIntersectionX, nearIntersectionY];
      } else {
        
        var farIntersectionX = inRangeParams[1] * d[0] + x1;
        var farIntersectionY = inRangeParams[1] * d[1] + y1;
      
        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
      }
      
    } else {
      return [nearIntersectionX, nearIntersectionY];
    }
    
  };
  
  $$.math.findCircleNearPoint = function(centerX, centerY, 
    radius, farX, farY) {
    
    var displacementX = farX - centerX;
    var displacementY = farY - centerY;
    var distance = Math.sqrt(displacementX * displacementX 
      + displacementY * displacementY);
    
    var unitDisplacementX = displacementX / distance;
    var unitDisplacementY = displacementY / distance;
    
    return [centerX + unitDisplacementX * radius, 
      centerY + unitDisplacementY * radius];
  };
  
  $$.math.findMaxSqDistanceToOrigin = function(points) {
    var maxSqDistance = 0.000001;
    var sqDistance;
    
    for (var i = 0; i < points.length / 2; i++) {
      
      sqDistance = points[i * 2] * points[i * 2] 
        + points[i * 2 + 1] * points[i * 2 + 1];
      
      if (sqDistance > maxSqDistance) {
        maxSqDistance = sqDistance;
      }
    }
    
    return maxSqDistance;
  };
  
  $$.math.finiteLinesIntersect = function(
    x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
    
    var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    if (u_b !== 0) {
      var ua = ua_t / u_b;
      var ub = ub_t / u_b;
      
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {  
        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        
      } else {
        if (!infiniteLines) {
          return [];
        } else {
          return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        }
      }
    } else {
      if (ua_t === 0 || ub_t === 0) {

        // Parallel, coincident lines. Check if overlap

        // Check endpoint of second line
        if ([x1, x2, x4].sort()[1] === x4) {
          return [x4, y4];
        }
        
        // Check start point of second line
        if ([x1, x2, x3].sort()[1] === x3) {
          return [x3, y3];
        }
        
        // Endpoint of first line
        if ([x3, x4, x2].sort()[1] === x2) {
          return [x2, y2];
        }
        
        return [];
      } else {
      
        // Parallel, non-coincident
        return [];
      }
    }
  };
  
  // (boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
  //      cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
  
  $$.math.boxIntersectEllipse = function(
    x1, y1, x2, y2, padding, width, height, centerX, centerY) {
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    // 4 ortho extreme points
    var west = [centerX - width / 2 - padding, centerY];
    var east = [centerX + width / 2 + padding, centerY];
    var north = [centerX, centerY - height / 2 - padding];
    var south = [centerX, centerY + height / 2 + padding];
    
    // out of bounds: return false
    if (x2 < west[0]) {
      return false;
    }
    
    if (x1 > east[0]) {
      return false;
    }
    
    if (y1 > south[1]) {
      return false;
    }
    
    if (y2 < north[1]) {
      return false;
    }
    
    // 1 of 4 ortho extreme points in box: return true
    if (x1 <= east[0] && east[0] <= x2
        && y1 <= east[1] && east[1] <= y2) {
      return true;
    }
    
    if (x1 <= west[0] && west[0] <= x2
        && y1 <= west[1] && west[1] <= y2) {
      return true;
    }
    
    if (x1 <= north[0] && north[0] <= x2
        && y1 <= north[1] && north[1] <= y2) {
      return true;
    }
    
    if (x1 <= south[0] && south[0] <= x2
        && y1 <= south[1] && south[1] <= y2) {
      return true;
    }
    
    // box corner in ellipse: return true    
    x1 = (x1 - centerX) / (width / 2 + padding);
    x2 = (x2 - centerX) / (width / 2 + padding);
    
    y1 = (y1 - centerY) / (height / 2 + padding);
    y2 = (y2 - centerY) / (height / 2 + padding);
    
    if (x1 * x1 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y2 * y2 <= 1) {
      return true;
    }
    
    if (x1 * x1 + y2 * y2 <= 1) {
      return true;
    }
    
    return false;
  };
  
  $$.math.boxIntersectPolygon = function(
    x1, y1, x2, y2, basePoints, width, height, centerX, centerY, direction, padding) {
    
//    console.log(arguments);
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    var transformedPoints = new Array(basePoints.length);
    
    // Gives negative of angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
    
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);
      
      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    // Assume transformedPoints.length > 0, and check if intersection is possible
    var minTransformedX = transformedPoints[0];
    var maxTransformedX = transformedPoints[0];
    var minTransformedY = transformedPoints[1];
    var maxTransformedY = transformedPoints[1];
    
    for (var i = 1; i < transformedPoints.length / 2; i++) {
      if (transformedPoints[i * 2] > maxTransformedX) {
        maxTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2] < minTransformedX) {
        minTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2 + 1] > maxTransformedY) {
        maxTransformedY = transformedPoints[i * 2 + 1];
      }
      
      if (transformedPoints[i * 2 + 1] < minTransformedY) {
        minTransformedY = transformedPoints[i * 2 + 1];
      }
    }
    
    if (x2 < minTransformedX - padding) {
      return false;
    }
    
    if (x1 > maxTransformedX + padding) {
      return false;
    }
    
    if (y2 < minTransformedY - padding) {
      return false;
    }
    
    if (y1 > maxTransformedY + padding) {
      return false;
    }
    
    // Continue checking with padding-corrected points
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    // Check if a point is in box
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      if (x1 <= transformedPoints[i * 2]
          && transformedPoints[i * 2] <= x2) {
        
        if (y1 <= transformedPoints[i * 2 + 1]
            && transformedPoints[i * 2 + 1] <= y2) {
          
          return true;
        }
      }
    }
    
    
    // Check for intersections with the selection box
    for (var i = 0; i < points.length / 2; i++) {
      
      var currentX = points[i * 2];
      var currentY = points[i * 2 + 1];
      var nextX;
      var nextY;
      
      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2];
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0];
        nextY = points[1];
      }
      
      // Intersection with top of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x2, y1, false).length > 0) {
        return true;
      }
      
      // Intersection with bottom of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y2, x2, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with left side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x1, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with right side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x2, y1, x2, y2, false).length > 0) {
        return true;
      }
    }

    /*
    // Check if box corner in the polygon
    if ($$.math.pointInsidePolygon(
      x1, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x1, y2, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x2, y2, points, 0, 0, 1, 1, 0, direction)) {
       
      return true; 
    } else if ($$.math.pointInsidePolygon(
      x2, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    }
    */
    return false;
  };
  
  $$.math.polygonIntersectLine = function(
    x, y, basePoints, centerX, centerY, width, height, padding) {
    
    var intersections = [];
    var intersection;
    
    var transformedPoints = new Array(basePoints.length);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    // var points = transformedPoints;
    
    var currentX, currentY, nextX, nextY;
    
    for (var i = 0; i < points.length / 2; i++) {
    
      currentX = points[i * 2];
      currentY = points[i * 2 + 1];

      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2]; 
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0]; 
        nextY = points[1];
      }
      
      intersection = this.finiteLinesIntersect(
        x, y, centerX, centerY,
        currentX, currentY,
        nextX, nextY);
      
      if (intersection.length !== 0) {
        intersections.push(intersection[0], intersection[1]);
      }
    }
    
    return intersections;
  };
  
  $$.math.shortenIntersection = function(
    intersection, offset, amount) {
    
    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
    
    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
    
    var lenRatio = (length - amount) / length;
    
    if (lenRatio < 0) {
      lenRatio = 0.00001;
    }

    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
  };

  $$.math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {
    var points = $$.math.generateUnitNgonPoints(sides, rotationRadians);
    points = $$.math.fitPolygonToSquare(points);

    return points;
  };

  $$.math.fitPolygonToSquare = function(points){
    var x, y;
    var sides = points.length/2;
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    for (var i = 0; i < sides; i++) {
      x = points[2 * i];
      y = points[2 * i + 1];

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }
    
    // stretch factors
    var sx = 2 / (maxX - minX);
    var sy = 2 / (maxY - minY);

    for (var i = 0; i < sides; i++){
      x = points[2 * i] = points[2 * i] * sx;
      y = points[2 * i + 1] = points[2 * i + 1] * sy;

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }

    if( minY < -1 ){
      for (var i = 0; i < sides; i++){
        y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);
      }
    }
    
    return points;
  };

  $$.math.generateUnitNgonPoints = function(sides, rotationRadians) {
    
    var increment = 1.0 / sides * 2 * Math.PI;
    var startAngle = sides % 2 === 0 ? 
      Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
//    console.log(nodeShapes['square']);
    startAngle += rotationRadians;
    
    var points = new Array(sides * 2);

    var currentAngle, x, y;
    for (var i = 0; i < sides; i++) {
      currentAngle = i * increment + startAngle;
      
      x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);
      y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);
    }
    
    return points;
  };

  $$.math.getRoundRectangleRadius = function(width, height) {
    
    // Set the default radius, unless half of width or height is smaller than default
    return Math.min(width / 4, height / 4, 8);
  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // registered extensions to cytoscape, indexed by name
  var extensions = {};
  $$.extensions = extensions;
  
  // registered modules for extensions, indexed by name
  var modules = {};
  $$.modules = modules;
  
  function setExtension(type, name, registrant){
    var impl = {};
    impl[name] = registrant;
    
    switch( type ){
    case 'core':
    case 'collection':
      $$.fn[type]( impl );
    }
    
    // fill in missing layout functions in the prototype
    if( type === 'layout' ){
      var layoutProto = registrant.prototype;
      var optLayoutFns = ['stop'];

      for( var i = 0; i < optLayoutFns.length; i++ ){
        var fnName = optLayoutFns[i];

        layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };
      }

      // either .start() or .run() is defined, so autogen the other
      if( layoutProto.start && !layoutProto.run ){
        layoutProto.run = function(){ this.start(); return this; };
      } else if( !layoutProto.start && layoutProto.run ){
        layoutProto.start = function(){ this.run(); return this; };
      }

      layoutProto.on = $$.define.on({ layout: true });
      layoutProto.one = $$.define.on({ layout: true, unbindSelfOnTrigger: true });
      layoutProto.once = $$.define.on({ layout: true, unbindAllBindersOnTrigger: true });
      layoutProto.off = $$.define.off({ layout: true });
      layoutProto.trigger = $$.define.trigger({ layout: true });

      // aliases for those folks who like old stuff:
      layoutProto.bind = layoutProto.on;
      layoutProto.unbind = layoutProto.off;
    }

    return $$.util.setMap({
      map: extensions,
      keys: [ type, name ],
      value: registrant
    });
  }
  
  function getExtension(type, name){
    return $$.util.getMap({
      map: extensions,
      keys: [ type, name ]
    });
  }
  
  function setModule(type, name, moduleType, moduleName, registrant){
    return $$.util.setMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ],
      value: registrant
    });
  }
  
  function getModule(type, name, moduleType, moduleName){
    return $$.util.getMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ]
    });
  }
  
  $$.extension = function(){
    // e.g. $$.extension('renderer', 'svg')
    if( arguments.length == 2 ){
      return getExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', { ... })
    else if( arguments.length == 3 ){
      return setExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if( arguments.length == 4 ){
      return getModule.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
    else if( arguments.length == 5 ){
      return setModule.apply(this, arguments);
    }
    
    else {
      $$.util.error('Invalid extension access syntax');
    }
  
  };
  
})( cytoscape );

;(function($, $$){ 'use strict';
  
  if( !$ ){ return; } // no jquery => don't need this

  var cyReg = function( $ele ){
    var d = $ele[0]._cyreg = $ele[0]._cyreg || {};

    return d;
  };

  // allow calls on a jQuery selector by proxying calls to $.cytoscape
  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
  $.fn.cytoscape = function(opts){
    var $this = $(this);

    // get object
    if( opts === 'get' ){
      return cyReg( $this ).cy;
    }
    
    // bind to ready
    else if( $$.is.fn(opts) ){

      var ready = opts;
      var cy = cyReg( $this ).cy;
      
      if( cy && cy.isReady() ){ // already ready so just trigger now
        cy.trigger('ready', [], ready);

      } else { // not yet ready, so add to readies list
        var data = cyReg( $this );
        var readies = data.readies = data.readies || [];

        readies.push( ready );
      } 
      
    }
    
    // proxy to create instance
    else if( $$.is.plainObject(opts) ){
      return $this.each(function(){
        var options = $.extend({}, opts, {
          container: $(this)[0]
        });
      
        cytoscape(options);
      });
    }
  };
  
  // allow access to the global cytoscape object under jquery for legacy reasons
  $.cytoscape = cytoscape;
  
  // use short alias (cy) if not already defined
  if( $.fn.cy == null && $.cy == null ){
    $.fn.cy = $.fn.cytoscape;
    $.cy = $.cytoscape;
  }
  
})(typeof jQuery !== 'undefined' ? jQuery : null , cytoscape);

;(function($$){ 'use strict';
  
  // shamelessly taken from jQuery
  // https://github.com/jquery/jquery/blob/master/src/event.js

  $$.Event = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof $$.Event) ) {
      return new $$.Event( src, props );
    }

    // Event object
    if ( src && src.type ) {
      this.originalEvent = src;
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

    // Event type
    } else {
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
      // $$.util.extend( this, props );

      // more efficient to manually copy fields we use
      this.type = props.type !== undefined ? props.type : this.type;
      this.cy = props.cy;
      this.cyTarget = props.cyTarget;
      this.cyPosition = props.cyPosition;
      this.cyRenderedPosition = props.cyRenderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
      this.data = props.data;
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || +new Date();
  };

  function returnFalse() {
    return false;
  }
  function returnTrue() {
    return true;
  }

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  $$.Event.prototype = {
    preventDefault: function() {
      this.isDefaultPrevented = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }

      // if preventDefault exists run it on the original event
      if ( e.preventDefault ) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      this.isPropagationStopped = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }
      // if stopPropagation exists run it on the original event
      if ( e.stopPropagation ) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    },
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse
  };
  
  
})( cytoscape );

;(function($$){ 'use strict';

  // use this module to cherry pick functions into your prototype
  // (useful for functions shared between the core and collections, for example)

  // e.g.
  // $$.fn.collection({
  //   foo: $$.define.foo({ /* params... */ })
  // });

  $$.define = {

    // access data field
    data: function( params ){
      var defaults = { 
        field: 'data',
        bindingEvent: 'data',
        allowBinding: false,
        allowSetting: false,
        allowGetting: false,
        settingEvent: 'data',
        settingTriggersEvent: false,
        triggerFnName: 'trigger',
        immutableKeys: {}, // key => true if immutable
        updateStyle: false,
        onSet: function( self ){},
        canSet: function( self ){ return true; }
      };
      params = $$.util.extend({}, defaults, params);

      return function dataImpl( name, value ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var single = selfIsArrayLike ? self[0] : self;

        // .data('foo', ...)
        if( $$.is.string(name) ){ // set or get property

          // .data('foo')
          if( p.allowGetting && value === undefined ){ // get

            var ret;
            if( single ){
              ret = single._private[ p.field ][ name ];
            }
            return ret;
          
          // .data('foo', 'bar')
          } else if( p.allowSetting && value !== undefined ) { // set
            var valid = !p.immutableKeys[name];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ name ] = value;
                }
              }

              // update mappers if asked
              if( p.updateStyle ){ self.updateStyle(); }

              // call onSet callback
              p.onSet( self );

              if( p.settingTriggersEvent ){
                self[ p.triggerFnName ]( p.settingEvent );
              }
            }
          }

        // .data({ 'foo': 'bar' })
        } else if( p.allowSetting && $$.is.plainObject(name) ){ // extend
          var obj = name;
          var k, v;

          for( k in obj ){
            v = obj[ k ];

            var valid = !p.immutableKeys[k];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ k ] = v;
                }
              }
            }
          }
          
          // update mappers if asked
          if( p.updateStyle ){ self.updateStyle(); }

          // call onSet callback
          p.onSet( self );

          if( p.settingTriggersEvent ){
            self[ p.triggerFnName ]( p.settingEvent );
          }
        
        // .data(function(){ ... })
        } else if( p.allowBinding && $$.is.fn(name) ){ // bind to event
          var fn = name;
          self.bind( p.bindingEvent, fn );
        
        // .data()
        } else if( p.allowGetting && name === undefined ){ // get whole object
          var ret;
          if( single ){
            ret = single._private[ p.field ];
          }
          return ret;
        }

        return self; // maintain chainability
      }; // function
    }, // data

    // remove data field
    removeData: function( params ){
      var defaults = { 
        field: 'data',
        event: 'data',
        triggerFnName: 'trigger',
        triggerEvent: false,
        immutableKeys: {} // key => true if immutable
      };
      params = $$.util.extend({}, defaults, params);

      return function removeDataImpl( names ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        
        // .removeData('foo bar')
        if( $$.is.string(names) ){ // then get the list of keys, and delete them
          var keys = names.split(/\s+/);
          var l = keys.length;

          for( var i = 0; i < l; i++ ){ // delete each non-empty key
            var key = keys[i];
            if( $$.is.emptyString(key) ){ continue; }

            var valid = !p.immutableKeys[ key ]; // not valid if immutable
            if( valid ){
              for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
                all[ i_a ]._private[ p.field ][ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }

        // .removeData()
        } else if( names === undefined ){ // then delete all keys

          for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
            var _privateFields = all[ i_a ]._private[ p.field ];
            
            for( var key in _privateFields ){
              var validKeyToDelete = !p.immutableKeys[ key ];

              if( validKeyToDelete ){
                _privateFields[ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }
        }

        return self; // maintain chaining
      }; // function
    }, // removeData

    // event function reusable stuff
    event: {
      regex: /(\w+)(\.\w+)?/, // regex for matching event strings (e.g. "click.namespace")
      optionalTypeRegex: /(\w+)?(\.\w+)?/,
      falseCallback: function(){ return false; }
    },

    // event binding
    on: function( params ){
      var defaults = {
        unbindSelfOnTrigger: false,
        unbindAllBindersOnTrigger: false
      };
      params = $$.util.extend({}, defaults, params);
      
      return function onImpl(events, selector, data, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var p = params;

        if( $$.is.plainObject(selector) ){ // selector is actually data
          callback = data;
          data = selector;
          selector = undefined;
        } else if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          data = undefined;
          selector = undefined;
        }

        if( $$.is.fn(data) || data === false ){ // data is actually callback
          callback = data;
          data = undefined;
        }

        // if there isn't a callback, we can't really do anything
        // (can't speak for mapped events arg version)
        if( !($$.is.fn(callback) || callback === false) && eventsIsString ){
          return self; // maintain chaining
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];
          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          if( !$$.is.fn(callback) ){ continue; }

          evts = evts.split(/\s+/);
          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]

            if( match ){
              var type = match[1];
              var namespace = match[2] ? match[2] : undefined;

              var listener = {
                callback: callback, // callback to run
                data: data, // extra data in eventObj.data
                delegated: selector ? true : false, // whether the evt is delegated
                selector: selector, // the selector to match for delegated events
                selObj: new $$.Selector(selector), // cached selector object to save rebuilding
                type: type, // the event type (e.g. 'click')
                namespace: namespace, // the event namespace (e.g. ".foo")
                unbindSelfOnTrigger: p.unbindSelfOnTrigger,
                unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
                binders: all // who bound together
              };

              for( var j = 0; j < all.length; j++ ){
                all[j]._private.listeners.push( listener );
              }
            }
          } // for events array
        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // on

    off: function offImpl( params ){
      var defaults = {
      };
      params = $$.util.extend({}, defaults, params);
      
      return function(events, selector, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);

        if( arguments.length === 0 ){ // then unbind all

          for( var i = 0; i < all.length; i++ ){
            all[i]._private.listeners = [];
          }

          return self; // maintain chaining
        }

        if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          selector = undefined;
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];

          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          evts = evts.split(/\s+/);
          for( var h = 0; h < evts.length; h++ ){
            var evt = evts[h];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.optionalTypeRegex ); // [type][.namespace]
            if( match ){
              var type = match[1] ? match[1] : undefined;
              var namespace = match[2] ? match[2] : undefined;

              for( var i = 0; i < all.length; i++ ){ //
                var listeners = all[i]._private.listeners;

                for( var j = 0; j < listeners.length; j++ ){
                  var listener = listeners[j];
                  var nsMatches = !namespace || namespace === listener.namespace;
                  var typeMatches = !type || listener.type === type;
                  var cbMatches = !callback || callback === listener.callback;
                  var listenerMatches = nsMatches && typeMatches && cbMatches;

                  // delete listener if it matches
                  if( listenerMatches ){
                    listeners.splice(j, 1);
                    j--;
                  }
                } // for listeners
              } // for all
            } // if match
          } // for events array

        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // off

    trigger: function( params ){
      var defaults = {};
      params = $$.util.extend({}, defaults, params);
      
      return function triggerImpl(events, extraParams, fnToTrigger){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var eventsIsObject = $$.is.plainObject(events);
        var eventsIsEvent = $$.is.event(events);
        var cy = this._private.cy || this;
        var hasCompounds = cy.hasCompoundNodes();

        if( eventsIsString ){ // then make a plain event object for each event name
          var evts = events.split(/\s+/);
          events = [];

          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            events.push( {
              type: type,
              namespace: namespace
            } );
          }
        } else if( eventsIsObject ){ // put in length 1 array
          var eventArgObj = events;

          events = [ eventArgObj ];
        }

        if( extraParams ){
          if( !$$.is.array(extraParams) ){ // make sure extra params are in an array if specified
            extraParams = [ extraParams ];
          }
        } else { // otherwise, we've got nothing
          extraParams = [];
        }

        for( var i = 0; i < events.length; i++ ){ // trigger each event in order
          var evtObj = events[i];
          
          for( var j = 0; j < all.length; j++ ){ // for each
            var triggerer = all[j];
            var listeners = triggerer._private.listeners;
            var triggererIsElement = $$.is.element(triggerer);
            var bubbleUp = triggererIsElement || params.layout;

            // create the event for this element from the event object
            var evt;

            if( eventsIsEvent ){ // then just get the object
              evt = evtObj;
              
              evt.cyTarget = evt.cyTarget || triggerer;
              evt.cy = evt.cy || cy;

            } else { // then we have to make one
              evt = new $$.Event( evtObj, {
                cyTarget: triggerer,
                cy: cy,
                namespace: evtObj.namespace
              } );
            }

            // if a layout was specified, then put it in the typed event
            if( evtObj.layout ){
              evt.layout = evtObj.layout;
            }

            // if triggered by layout, put in event
            if( params.layout ){
              evt.layout = triggerer;
            }

            // create a rendered position based on the passed position
            if( evt.cyPosition ){
              var pos = evt.cyPosition;
              var zoom = cy.zoom();
              var pan = cy.pan();

              evt.cyRenderedPosition = {
                x: pos.x * zoom + pan.x,
                y: pos.y * zoom + pan.y
              };
            }

            if( fnToTrigger ){ // then override the listeners list with just the one we specified
              listeners = [{
                namespace: evt.namespace,
                type: evt.type,
                callback: fnToTrigger
              }];
            }

            for( var k = 0; k < listeners.length; k++ ){ // check each listener
              var lis = listeners[k];
              var nsMatches = !lis.namespace || lis.namespace === evt.namespace;
              var typeMatches = lis.type === evt.type;
              var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && $$.is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive
              var listenerMatches = nsMatches && typeMatches && targetMatches;

              if( listenerMatches ){ // then trigger it
                var args = [ evt ];
                args = args.concat( extraParams ); // add extra params to args list

                if( lis.data ){ // add on data plugged into binding
                  evt.data = lis.data;
                } else { // or clear it in case the event obj is reused
                  evt.data = undefined;
                }

                if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                  listeners.splice(k, 1);
                  k--;
                }

                if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                  var binders = lis.binders;
                  for( var l = 0; l < binders.length; l++ ){
                    var binder = binders[l];
                    if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                    var binderListeners = binder._private.listeners;
                    for( var m = 0; m < binderListeners.length; m++ ){
                      var binderListener = binderListeners[m];

                      if( binderListener === lis ){ // delete listener from list
                        binderListeners.splice(m, 1);
                        m--;
                      }
                    }
                  }
                }

                // run the callback
                var context = lis.delegated ? evt.cyTarget : triggerer;
                var ret = lis.callback.apply( context, args );

                if( ret === false || evt.isPropagationStopped() ){
                  // then don't bubble
                  bubbleUp = false;

                  if( ret === false ){
                    // returning false is a shorthand for stopping propagation and preventing the def. action
                    evt.stopPropagation();
                    evt.preventDefault();
                  }
                }
              } // if listener matches
            } // for each listener

            // bubble up event for elements
            if( bubbleUp ){
              var parent = hasCompounds ? triggerer._private.parent : null;
              var hasParent = parent != null && parent.length !== 0;

              if( hasParent ){ // then bubble up to parent
                parent = parent[0];
                parent.trigger(evt);
              } else { // otherwise, bubble up to the core
                cy.trigger(evt);
              }
            }

          } // for each of all
        } // for each event
        
        return self; // maintain chaining
      }; // function
    }, // trigger


    animated: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animatedImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return false; }

        var ele = all[0];

        if( ele ){
          return ele._private.animation.current.length > 0;
        }
      };
    }, // animated

    clearQueue: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function clearQueueImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          ele._private.animation.queue = [];
        }

        return this;
      };
    }, // clearQueue

    delay: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function delayImpl( time, complete ){
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        this.animate({
          delay: time
        }, {
          duration: time,
          complete: complete
        });

        return this;
      };
    }, // delay

    animate: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animateImpl( properties, params ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;
        var isCore = !selfIsArrayLike;
        var isEles = !isCore;

        if( !cy.styleEnabled() ){ return this; }

        var callTime = +new Date();
        var style = cy.style();
        var q;
        
        if( params === undefined ){
          params = {};
        }

        if( params.duration === undefined ){
          params.duration = 400;
        }
        
        switch( params.duration ){
        case 'slow':
          params.duration = 600;
          break;
        case 'fast':
          params.duration = 200;
          break;
        }
        
        var propertiesEmpty = true;
        if( properties ){ for( var i in properties ){
          propertiesEmpty = false;
          break;
        } }

        if( propertiesEmpty ){
          return this; // nothing to animate
        }

        if( properties.css && isEles ){
          properties.css = style.getValueStyle( properties.css, { array: true } );
        }

        if( properties.renderedPosition && isEles ){
          var rpos = properties.renderedPosition;
          var pan = cy.pan();
          var zoom = cy.zoom();

          properties.position = {
            x: ( rpos.x - pan.x ) /zoom,
            y: ( rpos.y - pan.y ) /zoom
          };
        }

        // override pan w/ panBy if set
        if( properties.panBy && isCore ){
          var panBy = properties.panBy;
          var cyPan = cy.pan();

          properties.pan = {
            x: cyPan.x + panBy.x,
            y: cyPan.y + panBy.y
          };
        }

        // override pan w/ center if set
        var center = properties.center || properties.centre;
        if( center && isCore ){
          var centerPan = cy.getCenterPan( center.eles, properties.zoom );

          if( centerPan ){
            properties.pan = centerPan;
          }
        }

        // override pan & zoom w/ fit if set
        if( properties.fit && isCore ){
          var fit = properties.fit;
          var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

          if( fitVp ){
            properties.pan = fitVp.pan; //{ x: fitVp.pan.x, y: fitVp.pan.y };
            properties.zoom = fitVp.zoom;
          }
        }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
         
          if( ele.animated() && (params.queue === undefined || params.queue) ){
            q = ele._private.animation.queue;
          } else {
            q = ele._private.animation.current;
          }

          q.push({
            properties: properties,
            duration: params.duration,
            params: params,
            callTime: callTime
          });
        }

        if( isEles ){
          cy.addToAnimationPool( this );
        }

        return this; // chaining
      };
    }, // animate

    stop: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function stopImpl( clearQueue, jumpToEnd ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          var anis = ele._private.animation.current;

          for( var j = 0; j < anis.length; j++ ){
            var animation = anis[j];    
            if( jumpToEnd ){
              // next iteration of the animation loop, the animation
              // will go straight to the end and be removed
              animation.duration = 0; 
            }
          }
          
          // clear the queue of future animations
          if( clearQueue ){
            ele._private.animation.queue = [];
          }

          if( !jumpToEnd ){
            ele._private.animation.current = [];
          }
        }
        
        // we have to notify (the animation loop doesn't do it for us on `stop`)
        cy.notify({
          collection: this,
          type: 'draw'
        });
        
        return this;
      };
    } // stop

  }; // define

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.selector = function(map, options){
    for( var name in map ){
      var fn = map[name];
      $$.Selector.prototype[ name ] = fn;
    }
  };

  $$.Selector = function(onlyThisGroup, selector){
    
    if( !(this instanceof $$.Selector) ){
      return new $$.Selector(onlyThisGroup, selector);
    }
  
    if( selector === undefined && onlyThisGroup !== undefined ){
      selector = onlyThisGroup;
      onlyThisGroup = undefined;
    }
    
    var self = this;
    
    self._private = {
      selectorText: null,
      invalid: true
    };
    
    if( !selector || ( $$.is.string(selector) && selector.match(/^\s*$/) ) ){
      
      if( onlyThisGroup == null ){
        // ignore
        self.length = 0;
      } else {
        self[0] = newQuery();
        self[0].group = onlyThisGroup;
        self.length = 1;
      }
              
    } else if( $$.is.element( selector ) ){
      var collection = new $$.Collection(self.cy(), [ selector ]);
      
      self[0] = newQuery();
      self[0].collection = collection;
      self.length = 1;
      
    } else if( $$.is.collection( selector ) ){
      self[0] = newQuery();
      self[0].collection = selector;
      self.length = 1;
      
    } else if( $$.is.fn( selector ) ) {
      self[0] = newQuery();
      self[0].filter = selector;
      self.length = 1;
      
    } else if( $$.is.string( selector ) ){

      // the current subject in the query
      var currentSubject = null;
      
      // storage for parsed queries
      var newQuery = function(){
        return {
          classes: [], 
          colonSelectors: [],
          data: [],
          group: null,
          ids: [],
          meta: [],

          // fake selectors
          collection: null, // a collection to match against
          filter: null, // filter function

          // these are defined in the upward direction rather than down (e.g. child)
          // because we need to go up in Selector.filter()
          parent: null, // parent query obj
          ancestor: null, // ancestor query obj
          subject: null, // defines subject in compound query (subject query obj; points to self if subject)

          // use these only when subject has been defined
          child: null,
          descendant: null
        };
      };

      // tokens in the query language
      var tokens = {
        metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
        comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
        boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
        string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
        number: $$.util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
        meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from $$.Collection)
        separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
        descendant: '\\s+',
        child: '\\s+>\\s+',
        subject: '\\$'
      };
      tokens.variable = '(?:[\\w-]|(?:\\\\'+ tokens.metaChar +'))+'; // a variable name
      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
      tokens.className = tokens.variable; // a class name (follows variable conventions)
      tokens.id = tokens.variable; // an element id (follows variable conventions)

      // when a token like a variable has escaped meta characters, we need to clean the backslashes out
      // so that values get compared properly in Selector.filter()
      var cleanMetaChars = function(str){
        return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){
          return $1;
        });
      };
      
      // add @ variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];
        tokens.comparatorOp += '|@' + op;
      }

      // add ! variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];

        if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !
        if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

        tokens.comparatorOp += '|\\!' + op;
      }

      // NOTE: add new expression syntax here to have it recognised by the parser;
      // - a query contains all adjacent (i.e. no separator in between) expressions;
      // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
      // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
      // - when you add something here, also add to Selector.toString()
      var exprs = {
        group: {
          query: true,
          regex: '(node|edge|\\*)',
          populate: function( group ){
            this.group = group == "*" ? group : group + 's';
          }
        },
        
        state: {
          query: true,
          // NB: if one colon selector is a substring of another from its start, place the longer one first
          // e.g. :foobar|:foo
          regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch)',
          populate: function( state ){
            this.colonSelectors.push( state );
          }
        },
        
        id: {
          query: true,
          regex: '\\#('+ tokens.id +')',
          populate: function( id ){
            this.ids.push( cleanMetaChars(id) );
          }
        },
        
        className: {
          query: true,
          regex: '\\.('+ tokens.className +')',
          populate: function( className ){
            this.classes.push( cleanMetaChars(className) );
          }
        },
        
        dataExists: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( variable ){
            this.data.push({
              field: cleanMetaChars(variable)
            });
          }
        },
        
        dataCompare: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.value +')\\s*\\]',
          populate: function( variable, comparatorOp, value ){ 
            var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

            if( valueIsString ){
              value = value.substring(1, value.length - 1);
            } else {
              value = parseFloat(value);
            }

            this.data.push({
              field: cleanMetaChars(variable),
              operator: comparatorOp,
              value: value
            });
          }
        },
        
        dataBool: {
          query: true,
          regex: '\\[\\s*('+ tokens.boolOp +')\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( boolOp, variable ){
            this.data.push({
              field: cleanMetaChars(variable),
              operator: boolOp
            });
          }
        },
        
        metaCompare: {
          query: true,
          regex: '\\[\\[\\s*('+ tokens.meta +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.number +')\\s*\\]\\]',
          populate: function( meta, comparatorOp, number ){
            this.meta.push({
              field: cleanMetaChars(meta),
              operator: comparatorOp,
              value: parseFloat(number)
            });
          }
        },

        nextQuery: {
          separator: true,
          regex: tokens.separator,
          populate: function(){
            // go on to next query
            self[++i] = newQuery();
            currentSubject = null;
          }
        },

        child: {
          separator: true,
          regex: tokens.child,
          populate: function(){
            // this query is the parent of the following query
            var childQuery = newQuery();
            childQuery.parent = this;
            childQuery.subject = currentSubject;

            // we're now populating the child query with expressions that follow
            self[i] = childQuery;
          }
        },

        descendant: {
          separator: true,
          regex: tokens.descendant,
          populate: function(){
            // this query is the ancestor of the following query
            var descendantQuery = newQuery();
            descendantQuery.ancestor = this;
            descendantQuery.subject = currentSubject;

            // we're now populating the descendant query with expressions that follow
            self[i] = descendantQuery;
          }
        },

        subject: {
          modifier: true,
          regex: tokens.subject,
          populate: function(){
            if( currentSubject != null && this.subject != this ){
              $$.util.error('Redefinition of subject in selector `' + selector + '`');
              return false;
            }

            currentSubject = this;
            this.subject = this;
          }

        }
      };

      var j = 0;
      for( var name in exprs ){
        exprs[j] = exprs[name];
        exprs[j].name = name;

        j++;
      }
      exprs.length = j;

      self._private.selectorText = selector;
      var remaining = selector;
      var i = 0;
      
      // of all the expressions, find the first match in the remaining text
      var consumeExpr = function( expectation ){
        var expr;
        var match;
        var name;
        
        for( var j = 0; j < exprs.length; j++ ){
          var e = exprs[j];
          var n = e.name;

          // ignore this expression if it doesn't meet the expectation function
          if( $$.is.fn( expectation ) && !expectation(n, e) ){ continue; }

          var m = remaining.match(new RegExp( '^' + e.regex ));
          
          if( m != null ){
            match = m;
            expr = e;
            name = n;
            
            var consumed = m[0];
            remaining = remaining.substring( consumed.length );                
            
            break; // we've consumed one expr, so we can return now
          }
        }
        
        return {
          expr: expr,
          match: match,
          name: name
        };
      };
      
      // consume all leading whitespace
      var consumeWhitespace = function(){
        var match = remaining.match(/^\s+/);
        
        if( match ){
          var consumed = match[0];
          remaining = remaining.substring( consumed.length );
        }
      };
      
      self[0] = newQuery(); // get started

      consumeWhitespace(); // get rid of leading whitespace
      for(;;){        
        var check = consumeExpr();
        
        if( check.expr == null ){
          $$.util.error('The selector `'+ selector +'`is invalid');
          return;
        } else {
          var args = [];
          for(var j = 1; j < check.match.length; j++){
            args.push( check.match[j] );
          }
          
          // let the token populate the selector object (i.e. in self[i])
          var ret = check.expr.populate.apply( self[i], args );

          if( ret === false ){ return; } // exit if population failed
        }
        
        // we're done when there's nothing left to parse
        if( remaining.match(/^\s*$/) ){
          break;
        }
      }
      
      self.length = i + 1;

      // adjust references for subject
      for(j = 0; j < self.length; j++){
        var query = self[j];

        if( query.subject != null ){
          // go up the tree until we reach the subject
          for(;;){
            if( query.subject == query ){ break; } // done if subject is self

            if( query.parent != null ){ // swap parent/child reference
              var parent = query.parent;
              var child = query;

              child.parent = null;
              parent.child = child;

              query = parent; // go up the tree
            } else if( query.ancestor != null ){ // swap ancestor/descendant
              var ancestor = query.ancestor;
              var descendant = query;

              descendant.ancestor = null;
              ancestor.descendant = descendant;

              query = ancestor; // go up the tree
            } else {
              $$.util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');
              break;
            }
          } // for

          self[j] = query.subject; // subject should be the root query
        } // if
      } // for

      // make sure for each query that the subject group matches the implicit group if any
      if( onlyThisGroup != null ){
        for(var j = 0; j < self.length; j++){
          if( self[j].group != null && self[j].group != onlyThisGroup ){
            $$.util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');
            return;
          }

          self[j].group = onlyThisGroup; // set to implicit group
        }
      }
      
    } else {
      $$.util.error('A selector must be created from a string; found ' + selector);
      return;
    }

    self._private.invalid = false;
    
  };

  $$.selfn = $$.Selector.prototype;
  
  $$.selfn.size = function(){
    return this.length;
  };
  
  $$.selfn.eq = function(i){
    return this[i];
  };
  
  // get elements from the core and then filter them
  $$.selfn.find = function(){
    // TODO impl if we decide to use a DB for storing elements
  };
  
  var queryMatches = function(query, element){
    // check group
    if( query.group != null && query.group != '*' && query.group != element._private.group ){
      return false;
    }

    var cy = element.cy();
    
    // check colon selectors
    var allColonSelectorsMatch = true;
    for(var k = 0; k < query.colonSelectors.length; k++){
      var sel = query.colonSelectors[k];
      
      switch(sel){
      case ':selected':
        allColonSelectorsMatch = element.selected();
        break;
      case ':unselected':
        allColonSelectorsMatch = !element.selected();
        break;
      case ':selectable':
        allColonSelectorsMatch = element.selectable();
        break;
      case ':unselectable':
        allColonSelectorsMatch = !element.selectable();
        break;
      case ':locked':
        allColonSelectorsMatch = element.locked();
        break;
      case ':unlocked':
        allColonSelectorsMatch = !element.locked();
        break;
      case ':visible':
        allColonSelectorsMatch = element.visible();
        break;
      case ':hidden':
        allColonSelectorsMatch = !element.visible();
        break;
      case ':transparent':
        allColonSelectorsMatch = element.transparent();
        break;
      case ':grabbed':
        allColonSelectorsMatch = element.grabbed();
        break;
      case ':free':
        allColonSelectorsMatch = !element.grabbed();
        break;
      case ':removed':
        allColonSelectorsMatch = element.removed();
        break;
      case ':inside':
        allColonSelectorsMatch = !element.removed();
        break;
      case ':grabbable':
        allColonSelectorsMatch = element.grabbable();
        break;
      case ':ungrabbable':
        allColonSelectorsMatch = !element.grabbable();
        break;
      case ':animated':
        allColonSelectorsMatch = element.animated();
        break;
      case ':unanimated':
        allColonSelectorsMatch = !element.animated();
        break;
      case ':parent':
        allColonSelectorsMatch = element.isNode() && element.children().nonempty();
        break;
      case ':child':
      case ':nonorphan':
        allColonSelectorsMatch = element.isNode() && element.parent().nonempty();
        break;
      case ':orphan':
        allColonSelectorsMatch = element.isNode() && element.parent().empty();
        break;
      case ':loop':
        allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');
        break;
      case ':simple':
        allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');
        break;
      case ':active':
        allColonSelectorsMatch = element.active();
        break;
      case ':inactive':
        allColonSelectorsMatch = !element.active();
        break;
      case ':touch':
        allColonSelectorsMatch = $$.is.touch();
        break;
      }
      
      if( !allColonSelectorsMatch ) break;
    }
    if( !allColonSelectorsMatch ) return false;
    
    // check id
    var allIdsMatch = true;
    for(var k = 0; k < query.ids.length; k++){
      var id = query.ids[k];
      var actualId = element._private.data.id;
      
      allIdsMatch = allIdsMatch && (id == actualId);
      
      if( !allIdsMatch ) break;
    }
    if( !allIdsMatch ) return false;
    
    // check classes
    var allClassesMatch = true;
    for(var k = 0; k < query.classes.length; k++){
      var cls = query.classes[k];
      
      allClassesMatch = allClassesMatch && element.hasClass(cls);
      
      if( !allClassesMatch ) break;
    }
    if( !allClassesMatch ) return false;
    
    // generic checking for data/metadata
    var operandsMatch = function(params){
      var allDataMatches = true;
      for(var k = 0; k < query[params.name].length; k++){
        var data = query[params.name][k];
        var operator = data.operator;
        var value = data.value;
        var field = data.field;
        var matches;
        
        if( operator != null && value != null ){
          
          var fieldVal = params.fieldValue(field);
          var fieldStr = !$$.is.string(fieldVal) && !$$.is.number(fieldVal) ? '' : '' + fieldVal;
          var valStr = '' + value;
          
          var caseInsensitive = false;
          if( operator.indexOf('@') >= 0 ){
            fieldStr = fieldStr.toLowerCase();
            valStr = valStr.toLowerCase();
            
            operator = operator.replace('@', '');
            caseInsensitive = true;
          }

          var notExpr = false;
          var handledNotExpr = false;
          if( operator.indexOf('!') >= 0 ){
            operator = operator.replace('!', '');
            notExpr = true;
          }
          
          // if we're doing a case insensitive comparison, then we're using a STRING comparison
          // even if we're comparing numbers
          if( caseInsensitive ){
            value = valStr.toLowerCase();
            fieldVal = fieldStr.toLowerCase();
          }

          switch(operator){
          case '*=':
            matches = fieldStr.search(valStr) >= 0;
            break;
          case '$=':
            matches = new RegExp(valStr + '$').exec(fieldStr) != null;
            break;
          case '^=':
            matches = new RegExp('^' + valStr).exec(fieldStr) != null;
            break;
          case '=':
            matches = fieldVal === value;
            break;
          case '!=':
            matches = fieldVal !== value;
            break;
          case '>':
            matches = !notExpr ? fieldVal > value : fieldVal <= value;
            handledNotExpr = true;
            break;
          case '>=':
            matches = !notExpr ? fieldVal >= value : fieldVal < value;
            handledNotExpr = true;
            break;
          case '<':
            matches = !notExpr ? fieldVal < value : fieldVal >= value;
            handledNotExpr = true;
            break;
          case '<=':
            matches = !notExpr ? fieldVal <= value : fieldVal > value;
            handledNotExpr = true;
            break;
          default:
            matches = false;
            break;
            
          }
        } else if( operator != null ){
          switch(operator){
          case '?':
            matches = params.fieldTruthy(field);
            break;
          case '!':
            matches = !params.fieldTruthy(field);
            break;
          case '^':
            matches = params.fieldUndefined(field);
            break;
          }
        } else {   
          matches = !params.fieldUndefined(field);
        }

        if( notExpr && !handledNotExpr ){
          matches = !matches;
          handledNotExpr = true;
        }
        
        if( !matches ){
          allDataMatches = false;
          break;
        }
      } // for
      
      return allDataMatches;
    }; // operandsMatch
    
    // check data matches
    var allDataMatches = operandsMatch({
      name: 'data',
      fieldValue: function(field){
        return element._private.data[field];
      },
      fieldRef: function(field){
        return 'element._private.data.' + field;
      },
      fieldUndefined: function(field){
        return element._private.data[field] === undefined;
      },
      fieldTruthy: function(field){
        if( element._private.data[field] ){
          return true;
        }
        return false;
      }
    });
    
    if( !allDataMatches ){
      return false;
    }
    
    // check metadata matches
    var allMetaMatches = operandsMatch({
      name: 'meta',
      fieldValue: function(field){
        return element[field]();
      },
      fieldRef: function(field){
        return 'element.' + field + '()';
      },
      fieldUndefined: function(field){
        return element[field]() == null;
      },
      fieldTruthy: function(field){
        if( element[field]() ){
          return true;
        }
        return false;
      }
    });
    
    if( !allMetaMatches ){
      return false;
    }
    
    // check collection
    if( query.collection != null ){
      var matchesAny = query.collection._private.ids[ element.id() ] != null;
      
      if( !matchesAny ){
        return false;
      }
    }
    
    // check filter function
    if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){
      return false;
    }
    

    // check parent/child relations
    var confirmRelations = function( query, elements ){
      if( query != null ){
        var matches = false;

        if( !cy.hasCompoundNodes() ){
          return false;
        }

        elements = elements(); // make elements functional so we save cycles if query == null

        // query must match for at least one element (may be recursive)
        for(var i = 0; i < elements.length; i++){
          if( queryMatches( query, elements[i] ) ){
            matches = true;
            break;
          }
        }

        return matches;
      } else {
        return true;
      }
    };

    if (! confirmRelations(query.parent, function(){
      return element.parent();
    }) ){ return false; }

    if (! confirmRelations(query.ancestor, function(){
      return element.parents();
    }) ){ return false; }

    if (! confirmRelations(query.child, function(){
      return element.children();
    }) ){ return false; }

    if (! confirmRelations(query.descendant, function(){
      return element.descendants();
    }) ){ return false; }

    // we've reached the end, so we've matched everything for this query
    return true;
  }; // queryMatches

  // filter an existing collection
  $$.selfn.filter = function(collection){
    var self = this;
    var cy = collection.cy();
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return new $$.Collection( cy );
    }
  
    var selectorFunction = function(i, element){
      for(var j = 0; j < self.length; j++){
        var query = self[j];
        
        if( queryMatches(query, element) ){
          return true;
        }
      }
      
      return false;
    };
    
    if( self._private.selectorText == null ){
      selectorFunction = function(){ return true; };
    }
    
    var filteredCollection = collection.filter( selectorFunction );
    
    return filteredCollection;
  }; // filter

  // does selector match a single element?
  $$.selfn.matches = function(ele){
    var self = this;
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return false;
    }
  
    for(var j = 0; j < self.length; j++){
      var query = self[j];
      
      if( queryMatches(query, ele) ){
        return true;
      }
    }
    
    return false;
  }; // filter
  
  // ith query to string
  $$.selfn.toString = $$.selfn.selector = function(){
    
    var str = '';
    
    var clean = function(obj, isValue){
      if( $$.is.string(obj) ){
        return isValue ? '"' + obj + '"' : obj;
      } 
      return '';
    };
    
    var queryToString = function(query){
      var str = '';

      if( query.subject === query ){
        str += '$';
      }

      var group = clean(query.group);
      str += group.substring(0, group.length - 1);
      
      for(var j = 0; j < query.data.length; j++){
        var data = query.data[j];
        
        if( data.value ){
          str += '[' + data.field + clean(data.operator) + clean(data.value, true) + ']';
        } else {
          str += '[' + clean(data.operator) + data.field + ']';
        }
      }

      for(var j = 0; j < query.meta.length; j++){
        var meta = query.meta[j];
        str += '[[' + meta.field + clean(meta.operator) + clean(meta.value, true) + ']]';
      }
      
      for(var j = 0; j < query.colonSelectors.length; j++){
        var sel = query.colonSelectors[i];
        str += sel;
      }
      
      for(var j = 0; j < query.ids.length; j++){
        var sel = '#' + query.ids[i];
        str += sel;
      }
      
      for(var j = 0; j < query.classes.length; j++){
        var sel = '.' + query.classes[i];
        str += sel;
      }

      if( query.parent != null ){
        str = queryToString( query.parent ) + ' > ' + str; 
      }

      if( query.ancestor != null ){
        str = queryToString( query.ancestor ) + ' ' + str; 
      }

      if( query.child != null ){
        str += ' > ' + queryToString( query.child ); 
      }

      if( query.descendant != null ){
        str += ' ' + queryToString( query.descendant ); 
      }

      return str;
    };

    for(var i = 0; i < this.length; i++){
      var query = this[i];
      
      str += queryToString( query );
      
      if( this.length > 1 && i < this.length - 1 ){
        str += ', ';
      }
    }
    
    return str;
  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.Style = function( cy ){

    if( !(this instanceof $$.Style) ){
      return new $$.Style(cy);
    }

    if( !$$.is.core(cy) ){
      $$.util.error('A style must have a core reference');
      return;
    }

    this._private = {
      cy: cy,
      coreStyle: {},
      newStyle: true
    };
    
    this.length = 0;

    this.addDefaultStylesheet();
  };

  // nice-to-have aliases
  $$.style = $$.Style;
  $$.styfn = $$.Style.prototype;

  // define functions in the Style prototype
  $$.fn.style = function( fnMap, options ){
    for( var fnName in fnMap ){
      var fn = fnMap[ fnName ];
      $$.Style.prototype = fn;
    }
  };

  (function(){
    var number = $$.util.regex.number;
    var rgba = $$.util.regex.rgbaNoBackRefs;
    var hsla = $$.util.regex.hslaNoBackRefs;
    var hex3 = $$.util.regex.hex3;
    var hex6 = $$.util.regex.hex6;
    var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
    var mapData = function( prefix ){ return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\s*\\,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\)$'; };

    // each visual style property has a type and needs to be validated according to it
    $$.style.types = {
      time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
      percent: { number: true, min: 0, max: 100, units: '%' },
      zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
      nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
      nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
      position: { enums: ['parent', 'origin'] },
      autoSize: { number: true, min: 0, enums: ['auto'] },
      number: { number: true },
      size: { number: true, min: 0 },
      bgSize: { number: true, min: 0, allowPercent: true },
      bgPos: { number: true, allowPercent: true },
      bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },
      bgFit: { enums: ['none', 'contain', 'cover'] },
      bgClip: { enums: ['none', 'node'] },
      color: { color: true },
      lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
      borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
      curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack'] },
      fontFamily: { regex: '^([\\w- ]+(?:\\s*,\\s*[\\w- ]+)*)$' },
      fontVariant: { enums: ['small-caps', 'normal'] },
      fontStyle: { enums: ['italic', 'normal', 'oblique'] },
      fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
      textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
      textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
      nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star'] },
      arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'square', 'circle', 'diamond', 'none'] },
      arrowFill: { enums: ['filled', 'hollow'] },
      display: { enums: ['element', 'none'] },
      visibility: { enums: ['hidden', 'visible'] },
      valign: { enums: ['top', 'center', 'bottom'] },
      halign: { enums: ['left', 'center', 'right'] },
      text: { string: true },
      data: { mapping: true, regex: data('data') },
      layoutData: { mapping: true, regex: data('layoutData') },
      mapData: { mapping: true, regex: mapData('mapData') },
      mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
      url: { regex: '^url\\s*\\(\\s*([^\\s]+)\\s*\\s*\\)|none|(.+)$' },
      propList: { propList: true },
      angle: { number: true, units: 'deg|rad' }
    };

    // define visual style properties
    var t = $$.style.types;
    var props = $$.style.properties = [
      // labels
      { name: 'text-valign', type: t.valign },
      { name: 'text-halign', type: t.halign },
      { name: 'color', type: t.color },
      { name: 'content', type: t.text },
      { name: 'text-outline-color', type: t.color },
      { name: 'text-outline-width', type: t.size },
      { name: 'text-outline-opacity', type: t.zeroOneNumber },
      { name: 'text-opacity', type: t.zeroOneNumber },
      // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
      { name: 'text-transform', type: t.textTransform },
      // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes
      { name: 'font-family', type: t.fontFamily },
      { name: 'font-style', type: t.fontStyle },
      // { name: 'font-variant', type: t.fontVariant }, // not useful
      { name: 'font-weight', type: t.fontWeight },
      { name: 'font-size', type: t.size },
      { name: 'min-zoomed-font-size', type: t.size },

      // visibility
      { name: 'display', type: t.display },
      { name: 'visibility', type: t.visibility },
      { name: 'opacity', type: t.zeroOneNumber },
      { name: 'z-index', type: t.nonNegativeInt },

      // overlays
      { name: 'overlay-padding', type: t.size },
      { name: 'overlay-color', type: t.color },
      { name: 'overlay-opacity', type: t.zeroOneNumber },

      // transition anis
      { name: 'transition-property', type: t.propList },
      { name: 'transition-duration', type: t.time },
      { name: 'transition-delay', type: t.time },

      // node body
      { name: 'height', type: t.autoSize },
      { name: 'width', type: t.autoSize },
      { name: 'shape', type: t.nodeShape },
      { name: 'background-color', type: t.color },
      { name: 'background-opacity', type: t.zeroOneNumber },
      { name: 'background-blacken', type: t.nOneOneNumber },

      // node border
      { name: 'border-color', type: t.color },
      { name: 'border-opacity', type: t.zeroOneNumber },
      { name: 'border-width', type: t.size },
      { name: 'border-style', type: t.borderStyle },
      
      // node background images
      { name: 'background-image', type: t.url },
      { name: 'background-image-opacity', type: t.zeroOneNumber },
      { name: 'background-position-x', type: t.bgPos },
      { name: 'background-position-y', type: t.bgPos },
      { name: 'background-repeat', type: t.bgRepeat },
      { name: 'background-fit', type: t.bgFit },
      { name: 'background-clip', type: t.bgClip },

      // compound props
      { name: 'padding-left', type: t.size },
      { name: 'padding-right', type: t.size },
      { name: 'padding-top', type: t.size },
      { name: 'padding-bottom', type: t.size },
      { name: 'position', type: t.position },

      // edge line
      { name: 'line-style', type: t.lineStyle },
      { name: 'line-color', type: t.color },
      { name: 'control-point-step-size', type: t.size },
      { name: 'control-point-distance', type: t.number },
      { name: 'control-point-weight', type: t.zeroOneNumber },
      { name: 'curve-style', type: t.curveStyle },
      { name: 'haystack-radius', type: t.zeroOneNumber },

      // edge arrows
      { name: 'source-arrow-shape', type: t.arrowShape },
      { name: 'target-arrow-shape', type: t.arrowShape },
      { name: 'mid-source-arrow-shape', type: t.arrowShape },
      { name: 'mid-target-arrow-shape', type: t.arrowShape },
      { name: 'source-arrow-color', type: t.color },
      { name: 'target-arrow-color', type: t.color },
      { name: 'mid-source-arrow-color', type: t.color },
      { name: 'mid-target-arrow-color', type: t.color },
      { name: 'source-arrow-fill', type: t.arrowFill },
      { name: 'target-arrow-fill', type: t.arrowFill },
      { name: 'mid-source-arrow-fill', type: t.arrowFill },
      { name: 'mid-target-arrow-fill', type: t.arrowFill },

      // these are just for the core
      { name: 'selection-box-color', type: t.color },
      { name: 'selection-box-opacity', type: t.zeroOneNumber },
      { name: 'selection-box-border-color', type: t.color },
      { name: 'selection-box-border-width', type: t.size },
      { name: 'active-bg-color', type: t.color },
      { name: 'active-bg-opacity', type: t.zeroOneNumber },
      { name: 'active-bg-size', type: t.size },
      { name: 'outside-texture-bg-color', type: t.color },
      { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
    ];

    // pie backgrounds for nodes
    $$.style.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
    props.push({ name: 'pie-size', type: t.bgSize });
    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){
      props.push({ name: 'pie-'+i+'-background-color', type: t.color });
      props.push({ name: 'pie-'+i+'-background-size', type: t.percent });
      props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });
    }

    // allow access of properties by name ( e.g. $$.style.properties.height )
    for( var i = 0; i < props.length; i++ ){
      var prop = props[i];
      
      props[ prop.name ] = prop; // allow lookup by name
    }
  })();

  // adds the default stylesheet to the current style
  $$.styfn.addDefaultStylesheet = function(){
    // to be nice, we build font related style properties from the core container
    // so that cytoscape matches the style of its container by default
    // 
    // unfortunately, this doesn't seem work consistently and can grab the default stylesheet values
    // instead of the developer's values so let's just make it explicit for the dev for now
    //
    // delaying the read of these val's is not an opt'n: that would delay init'l load time
    var fontFamily = 'Helvetica' || this.containerPropertyAsString('font-family') || 'sans-serif';
    var fontStyle = 'normal' || this.containerPropertyAsString('font-style') || 'normal';
    // var fontVariant = 'normal' || this.containerPropertyAsString('font-variant') || 'normal';
    var fontWeight = 'normal' || this.containerPropertyAsString('font-weight') || 'normal';
    var color = '#000' || this.containerPropertyAsString('color') || '#000';
    var textTransform = 'none' || this.containerPropertyAsString('text-transform') || 'none';
    var fontSize = 16 || this.containerPropertyAsString('font-size') || 16;

    // fill the style with the default stylesheet
    this
      .selector('node, edge') // common properties
        .css({
          'text-valign': 'top',
          'text-halign': 'center',
          'color': color,
          'text-outline-color': '#000',
          'text-outline-width': 0,
          'text-outline-opacity': 1,
          'text-opacity': 1,
          'text-decoration': 'none',
          'text-transform': textTransform,
          'font-family': fontFamily,
          'font-style': fontStyle,
          // 'font-variant': fontVariant,
          'font-weight': fontWeight,
          'font-size': fontSize,
          'min-zoomed-font-size': 0,
          'visibility': 'visible',
          'display': 'element',
          'opacity': 1,
          'z-index': 0,
          'content': '',
          'overlay-opacity': 0,
          'overlay-color': '#000',
          'overlay-padding': 10,
          'transition-property': 'none',
          'transition-duration': 0,
          'transition-delay': 0,

          // node props
          'background-blacken': 0,
          'background-color': '#888',
          'background-opacity': 1,
          'background-image': 'none',
          'background-image-opacity': 1,
          'background-position-x': '50%',
          'background-position-y': '50%',
          'background-repeat': 'no-repeat',
          'background-fit': 'none',
          'background-clip': 'node',
          'border-color': '#000',
          'border-opacity': 1,
          'border-width': 0,
          'border-style': 'solid',
          'height': 30,
          'width': 30,
          'shape': 'ellipse',

          // compound props
          'padding-top': 0,
          'padding-bottom': 0,
          'padding-left': 0,
          'padding-right': 0,
          'position': 'origin',
          

          // node pie bg
          'pie-size': '100%',
          'pie-1-background-color': 'black',
          'pie-2-background-color': 'black',
          'pie-3-background-color': 'black',
          'pie-4-background-color': 'black',
          'pie-5-background-color': 'black',
          'pie-6-background-color': 'black',
          'pie-7-background-color': 'black',
          'pie-8-background-color': 'black',
          'pie-9-background-color': 'black',
          'pie-10-background-color': 'black',
          'pie-11-background-color': 'black',
          'pie-12-background-color': 'black',
          'pie-13-background-color': 'black',
          'pie-14-background-color': 'black',
          'pie-15-background-color': 'black',
          'pie-16-background-color': 'black',
          'pie-1-background-size': '0%',
          'pie-2-background-size': '0%',
          'pie-3-background-size': '0%',
          'pie-4-background-size': '0%',
          'pie-5-background-size': '0%',
          'pie-6-background-size': '0%',
          'pie-7-background-size': '0%',
          'pie-8-background-size': '0%',
          'pie-9-background-size': '0%',
          'pie-10-background-size': '0%',
          'pie-11-background-size': '0%',
          'pie-12-background-size': '0%',
          'pie-13-background-size': '0%',
          'pie-14-background-size': '0%',
          'pie-15-background-size': '0%',
          'pie-16-background-size': '0%',
          'pie-1-background-opacity': 1,
          'pie-2-background-opacity': 1,
          'pie-3-background-opacity': 1,
          'pie-4-background-opacity': 1,
          'pie-5-background-opacity': 1,
          'pie-6-background-opacity': 1,
          'pie-7-background-opacity': 1,
          'pie-8-background-opacity': 1,
          'pie-9-background-opacity': 1,
          'pie-10-background-opacity': 1,
          'pie-11-background-opacity': 1,
          'pie-12-background-opacity': 1,
          'pie-13-background-opacity': 1,
          'pie-14-background-opacity': 1,
          'pie-15-background-opacity': 1,
          'pie-16-background-opacity': 1,

          // edge props
          'source-arrow-shape': 'none',
          'mid-source-arrow-shape': 'none',
          'target-arrow-shape': 'none',
          'mid-target-arrow-shape': 'none',
          'source-arrow-color': '#ddd',
          'mid-source-arrow-color': '#ddd',
          'target-arrow-color': '#ddd',
          'mid-target-arrow-color': '#ddd',
          'source-arrow-fill': 'filled',
          'mid-source-arrow-fill': 'filled',
          'target-arrow-fill': 'filled',
          'mid-target-arrow-fill': 'filled',
          'line-style': 'solid',
          'line-color': '#ddd',
          'control-point-step-size': 40,
          'control-point-weight': 0.5,
          'curve-style': 'bezier',
          'haystack-radius': 0.8
        })
      .selector('$node > node') // compound (parent) node properties
        .css({
          'width': 'auto',
          'height': 'auto',
          'shape': 'rectangle',
          'background-opacity': 0.5,
          'padding-top': 10,
          'padding-right': 10,
          'padding-left': 10,
          'padding-bottom': 10
        })
      .selector('edge') // just edge properties
        .css({
          'width': 1
        })
      .selector(':active')
        .css({
          'overlay-color': 'black',
          'overlay-padding': 10,
          'overlay-opacity': 0.25
        })
      .selector('core') // just core properties
        .css({
          'selection-box-color': '#ddd',
          'selection-box-opacity': 0.65,
          'selection-box-border-color': '#aaa',
          'selection-box-border-width': 1,
          'active-bg-color': 'black',
          'active-bg-opacity': 0.15,
          'active-bg-size': $$.is.touch() ? 40 : 15,
          'outside-texture-bg-color': '#000',
          'outside-texture-bg-opacity': 0.125
        })
    ;

    this.defaultLength = this.length;
  };

  // remove all contexts
  $$.styfn.clear = function(){
    for( var i = 0; i < this.length; i++ ){
      this[i] = undefined;
    }
    this.length = 0;
    this._private.newStyle = true;

    return this; // chaining
  };

  $$.styfn.resetToDefault = function(){
    this.clear();
    this.addDefaultStylesheet();

    return this;
  };

  // builds a style object for the 'core' selector
  $$.styfn.core = function(){
    return this._private.coreStyle;
  };

  // parse a property; return null on invalid; return parsed property otherwise
  // fields :
  // - name : the name of the property
  // - value : the parsed, native-typed value of the property
  // - strValue : a string value that represents the property value in valid css
  // - bypass : true iff the property is a bypass property
  $$.styfn.parse = function( name, value, propIsBypass, propIsFlat ){
    
    name = $$.util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')
    var property = $$.style.properties[ name ];
    var passedValue = value;
    
    if( !property ){ return null; } // return null on property of unknown name
    if( value === undefined || value === null ){ return null; } // can't assign null

    var valueIsString = $$.is.string(value);
    if( valueIsString ){ // trim the value to make parsing easier
      value = $$.util.trim( value );
    }

    var type = property.type;
    if( !type ){ return null; } // no type, no luck

    // check if bypass is null or empty string (i.e. indication to delete bypass property)
    if( propIsBypass && (value === '' || value === null) ){
      return {
        name: name,
        value: value,
        bypass: true,
        deleteBypass: true
      };
    }

    // check if value is mapped
    var data, mapData, layoutData, mapLayoutData;
    if( !valueIsString || propIsFlat ){
      // then don't bother to do the expensive regex checks

    } else if(
      ( data = new RegExp( $$.style.types.data.regex ).exec( value ) ) ||
      ( layoutData = new RegExp( $$.style.types.layoutData.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass
      
      var isLayout = layoutData !== undefined;
      data = data || layoutData;

      return {
        name: name,
        value: data,
        strValue: '' + value,
        mapped: isLayout ? $$.style.types.layoutData : $$.style.types.data,
        field: data[1],
        bypass: propIsBypass,
        hasPie: name.match(/pie-(\d+)-background-size/)
      };

    } else if(
      ( mapData = new RegExp( $$.style.types.mapData.regex ).exec( value ) ) ||
      ( mapLayoutData = new RegExp( $$.style.types.mapLayoutData.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass

      var isLayout = mapLayoutData !== undefined;
      mapData = mapData || mapLayoutData;

      // we can map only if the type is a colour or a number
      if( !(type.color || type.number) ){ return false; }

      var valueMin = this.parse( name, mapData[4]); // parse to validate
      if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

      var valueMax = this.parse( name, mapData[5]); // parse to validate
      if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

      // check if valueMin and valueMax are the same
      if( valueMin.value === valueMax.value ){
        return false; // can't make much of a mapper without a range
      
      } else if( type.color ){
        var c1 = valueMin.value;
        var c2 = valueMax.value;
        
        var same = c1[0] === c2[0] // red
          && c1[1] === c2[1] // green
          && c1[2] === c2[2] // blue
          && ( // optional alpha
            c1[3] === c2[3] // same alpha outright
            || (
              (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
              &&
              (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
            )
          )
        ;

        if( same ){ return false; } // can't make a mapper without a range
      }

      return {
        name: name,
        value: mapData,
        strValue: '' + value,
        mapped: isLayout ? $$.style.types.mapLayoutData : $$.style.types.mapData,
        field: mapData[1],
        fieldMin: parseFloat( mapData[2] ), // min & max are numeric
        fieldMax: parseFloat( mapData[3] ),
        valueMin: valueMin.value,
        valueMax: valueMax.value,
        bypass: propIsBypass,
        hasPie: name.match(/pie-(\d+)-background-size/)
      };
    }

    // check the type and return the appropriate object
    if( type.number ){ 
      var units;
      var implicitUnits = 'px'; // not set => px

      if( type.units ){ // use specified units if set
        units = type.units;
      }

      if( type.implicitUnits ){
        implicitUnits = type.implicitUnits;
      }

      if( !type.unitless ){
        if( valueIsString ){
          var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
          if( units ){ unitsRegex = units; } // only allow explicit units if so set 
          var match = value.match( '^(' + $$.util.regex.number + ')(' + unitsRegex + ')?' + '$' );
          
          if( match ){
            value = match[1];
            units = match[2] || implicitUnits;
          }
          
        } else if( !units || type.implicitUnits ) {
          units = implicitUnits; // implicitly px if unspecified
        }
      }

      value = parseFloat( value );

      // if not a number and enums not allowed, then the value is invalid
      if( isNaN(value) && type.enums === undefined ){
        return null;
      }

      // check if this number type also accepts special keywords in place of numbers
      // (i.e. `left`, `auto`, etc)
      if( isNaN(value) && type.enums !== undefined ){
        value = passedValue;

        for( var i = 0; i < type.enums.length; i++ ){
          var en = type.enums[i];

          if( en === value ){
            return {
              name: name,
              value: value,
              strValue: '' + value,
              bypass: propIsBypass
            };
          }
        }

        return null; // failed on enum after failing on number
      }

      // check if value must be an integer
      if( type.integer && !$$.is.integer(value) ){
        return null;
      }

      // check value is within range
      if( (type.min !== undefined && value < type.min) 
      || (type.max !== undefined && value > type.max)
      ){
        return null;
      }

      var ret = {
        name: name,
        value: value,
        strValue: '' + value + (units ? units : ''),
        units: units,
        bypass: propIsBypass,
        hasPie: name.match(/pie-(\d+)-background-size/) && value != null && value !== 0 && value !== ''
      };

      // normalise value in pixels
      if( type.unitless || (units !== 'px' && units !== 'em') ){
        // then pxValue does not apply
      } else {
        ret.pxValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
      }

      // normalise value in ms
      if( units === 'ms' || units === 's' ){
        ret.msValue = units === 'ms' ? value : 1000 * value;
      }

      return ret;

    } else if( type.propList ) {

      var props = [];
      var propsStr = '' + value;      
 
      if( propsStr === 'none' ){
        // leave empty

      } else { // go over each prop

        var propsSplit = propsStr.split(',');
        for( var i = 0; i < propsSplit.length; i++ ){
          var propName = $$.util.trim( propsSplit[i] );

          if( $$.style.properties[propName] ){
            props.push( propName );
          }
        }

        if( props.length === 0 ){ return null; }

      }

      return {
        name: name,
        value: props,
        strValue: props.length === 0 ? 'none' : props.join(', '),
        bypass: propIsBypass
      };

    } else if( type.color ){
      var tuple = $$.util.color2tuple( value );

      if( !tuple ){ return null; }

      return {
        name: name,
        value: tuple,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else if( type.enums ){
      for( var i = 0; i < type.enums.length; i++ ){
        var en = type.enums[i];

        if( en === value ){
          return {
            name: name,
            value: value,
            strValue: '' + value,
            bypass: propIsBypass
          };
        }
      }

      return null;

    } else if( type.regex ){
      var regex = new RegExp( type.regex ); // make a regex from the type
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      } else { // regex doesn't match
        return null; // didn't match the regex so the value is bogus
      }

    } else if( type.string ){
      // just return
      return {
        name: name,
        value: value,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else {
      return null; // not a type we can handle
    }

  };

  // create a new context from the specified selector string and switch to that context
  $$.styfn.selector = function( selectorStr ){
    // 'core' is a special case and does not need a selector
    var selector = selectorStr === 'core' ? null : new $$.Selector( selectorStr );

    var i = this.length++; // new context means new index
    this[i] = {
      selector: selector,
      properties: [],
      mappedProperties: [],
      index: i
    };

    return this; // chaining
  };

  // add one or many css rules to the current context
  $$.styfn.css = function(){
    var args = arguments;

    switch( args.length ){
    case 1:
      var map = args[0];

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          this.cssRule( prop.name, mapVal );
        }
      }

      break;

    case 2:
      this.cssRule( args[0], args[1] );
      break;

    default:
      break; // do nothing if args are invalid
    }

    return this; // chaining
  };

  // add a single css rule to the current context
  $$.styfn.cssRule = function( name, value ){ 
    // name-value pair
    var property = this.parse( name, value );

    // add property to current context if valid
    if( property ){
      var i = this.length - 1;
      this[i].properties.push( property );
      this[i].properties[ property.name ] = property; // allow access by name as well

      if( property.hasPie ){
        this._private.hasPie = true;
      }

      if( property.mapped ){
        this[i].mappedProperties.push( property );
      }

      // add to core style if necessary
      var currentSelectorIsCore = !this[i].selector;
      if( currentSelectorIsCore ){
        this._private.coreStyle[ property.name ] = property;
      }
    }

    return this; // chaining
  };

})( cytoscape );
;(function($$){ 'use strict';

  // (potentially expensive calculation)
  // apply the style to the element based on
  // - its bypass
  // - what selectors match it
  $$.styfn.apply = function( eles ){
    var self = this;

    if( self._private.newStyle ){ // clear style caches
      this._private.contextStyles = {};
      this._private.propDiffs = {};
    }

    for( var ie = 0; ie < eles.length; ie++ ){
      var ele = eles[ie];
      var cxtMeta = self.getContextMeta( ele );
      var cxtStyle = self.getContextStyle( cxtMeta );
      var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

      self.updateTransitions( ele, app.diffProps );
      self.updateStyleHints( ele );

    } // for elements

    self._private.newStyle = false;
  };

  $$.styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
    var self = this;
    var cache = self._private.propDiffs = self._private.propDiffs || {};
    var dualCxtKey = oldCxtKey + '-' + newCxtKey;
    var cachedVal = cache[dualCxtKey];

    if( cachedVal ){
      return cachedVal;
    }

    var diffProps = [];
    var addedProp = {};

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var oldHasCxt = oldCxtKey[i] === 't';
      var newHasCxt = newCxtKey[i] === 't';
      var cxtHasDiffed = oldHasCxt !== newHasCxt;
      var cxtHasMappedProps = cxt.mappedProperties.length > 0;

      if( cxtHasDiffed || cxtHasMappedProps ){
        var props;

        if( cxtHasDiffed && cxtHasMappedProps ){
          props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
        } else if( cxtHasDiffed ){
          props = cxt.properties; // need to check them all
        } else if( cxtHasMappedProps ){
          props = cxt.mappedProperties; // only need to check mapped
        }

        for( var j = 0; j < props.length; j++ ){
          var prop = props[j];
          var name = prop.name;

          // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
          // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
          // is cached)
          var laterCxtOverrides = false; 
          for( var k = i + 1; k < self.length; k++ ){
            var laterCxt = self[k];
            var hasLaterCxt = newCxtKey[k] === 't';

            if( !hasLaterCxt ){ continue; } // can't override unless the context is active

            laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

            if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
          }

          if( !addedProp[name] && !laterCxtOverrides ){
            addedProp[name] = true;
            diffProps.push( name );
          }
        } // for props
      } // if

    } // for contexts

    cache[ dualCxtKey ] = diffProps;
    return diffProps;
  };

  $$.styfn.getContextMeta = function( ele ){
    var self = this;
    var cxtKey = '';
    var diffProps;
    var prevKey = ele._private.styleCxtKey || '';

    if( self._private.newStyle ){
      prevKey = ''; // since we need to apply all style if a fresh stylesheet
    }

    // get the cxt key
    for( var i = 0; i < self.length; i++ ){
      var context = self[i];
      var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

      if( contextSelectorMatches ){
        cxtKey += 't';
      } else {
        cxtKey += 'f';
      }
    } // for context

    diffProps = self.getPropertiesDiff( prevKey, cxtKey );

    ele._private.styleCxtKey = cxtKey;

    return {
      key: cxtKey,
      diffPropNames: diffProps
    };
  };

  // gets a computed ele style object based on matched contexts
  $$.styfn.getContextStyle = function( cxtMeta ){
    var cxtKey = cxtMeta.key;
    var self = this;
    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

    // if already computed style, returned cached copy
    if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }

    var style = {
      _private: {
        key: cxtKey
      }
    };

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var hasCxt = cxtKey[i] === 't';

      if( !hasCxt ){ continue; }

      for( var j = 0; j < cxt.properties.length; j++ ){
        var prop = cxt.properties[j];
        var styProp = style[ prop.name ] = prop;

        styProp.context = cxt;
      }
    }

    cxtStyles[cxtKey] = style;
    return style;
  };

  $$.styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
    var self = this;
    var diffProps = cxtMeta.diffPropNames;
    var retDiffProps = {};

    for( var i = 0; i < diffProps.length; i++ ){
      var diffPropName = diffProps[i];
      var cxtProp = cxtStyle[ diffPropName ];
      var eleProp = ele._private.style[ diffPropName ];

      // save cycles when the context prop doesn't need to be applied
      if( !cxtProp || eleProp === cxtProp ){ continue; }

      var retDiffProp = retDiffProps[ diffPropName ] = {
        prev: eleProp
      };

      self.applyParsedProperty( ele, cxtProp );

      retDiffProp.next = ele._private.style[ diffPropName ];

      if( retDiffProp.next && retDiffProp.next.bypass ){
        retDiffProp.next = retDiffProp.next.bypassed;
      }
    }

    return {
      diffProps: retDiffProps
    };
  };

  $$.styfn.updateStyleHints = function(ele){
    var _p = ele._private;
    var self = this;
    var style = _p.style;

    // set whether has pie or not; for greater efficiency
    var hasPie = false;
    if( _p.group === 'nodes' && self._private.hasPie ){
      for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
        var size = _p.style['pie-' + i + '-background-size'].value;

        if( size > 0 ){
          hasPie = true;
          break;
        }
      }
    }

    _p.hasPie = hasPie;

    var transform = style['text-transform'].strValue;
    var content = style['content'].strValue;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;
    var valign = style['text-valign'].strValue;
    var halign = style['text-valign'].strValue;
    var oWidth = style['text-outline-width'].pxValue;
    _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth;
    _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;

    var width = style['width'].pxValue;
    var height = style['height'].pxValue;
    var borderW = style['border-width'].pxValue;
    _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;

    if( ele._private.group === 'edges' ){
      var cpss = style['control-point-step-size'].pxValue;
      var cpd = style['control-point-distance'] ? style['control-point-distance'].pxValue : undefined;
      var cpw = style['control-point-weight'].value;
      var curve = style['curve-style'].strValue;
      
      _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ curve;
    }

    _p.styleKey = Date.now(); // probably safe to use applied time and much faster
    // for( var i = 0; i < $$.style.properties.length; i++ ){
    //   var prop = $$.style.properties[i];
    //   var eleProp = _p.style[ prop.name ];
    //   var val = eleProp && eleProp.strValue ? eleProp.strValue : 'undefined';

    //   _p.styleKey += '$' + val;
    // }
  };

  // apply a property to the style (for internal use)
  // returns whether application was successful
  //
  // now, this function flattens the property, and here's how:
  //
  // for parsedProp:{ bypass: true, deleteBypass: true }
  // no property is generated, instead the bypass property in the
  // element's style is replaced by what's pointed to by the `bypassed`
  // field in the bypass property (i.e. restoring the property the
  // bypass was overriding)
  //
  // for parsedProp:{ mapped: truthy }
  // the generated flattenedProp:{ mapping: prop }
  // 
  // for parsedProp:{ bypass: true }
  // the generated flattenedProp:{ bypassed: parsedProp } 
  $$.styfn.applyParsedProperty = function( ele, parsedProp ){
    var prop = parsedProp;
    var style = ele._private.style;
    var fieldVal, flatProp;
    var type = $$.style.properties[ prop.name ].type;
    var propIsBypass = prop.bypass;
    var origProp = style[ prop.name ];
    var origPropIsBypass = origProp && origProp.bypass;

    // can't apply auto to width or height unless it's a parent node
    if( (parsedProp.name === 'height' || parsedProp.name === 'width') && parsedProp.value === 'auto' && ele.isNode() && !ele.isParent() ){
      return false;
    }

    // check if we need to delete the current bypass
    if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete
      var currentProp = style[ prop.name ];

      // can only delete if the current prop is a bypass and it points to the property it was overriding
      if( !currentProp ){
        return true; // property is already not defined
      } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original
        
        // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
        style[ prop.name ] = currentProp.bypassed;
        return true;
      
      } else {
        return false; // we're unsuccessful deleting the bypass
      }
    }

    var printMappingErr = function(){
      $$.util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');
    };

    // put the property in the style objects
    switch( prop.mapped ){ // flatten the property if mapped
    case $$.style.types.mapData:
    case $$.style.types.mapLayoutData:
      
      var isLayout = prop.mapped === $$.style.types.mapLayoutData;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal = isLayout ? ele._private.layoutData : ele._private.data;
      for( var i = 0; i < fields.length && fieldVal; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      }

      var percent;
      if( !$$.is.number(fieldVal) ){ // then keep the mapping but assume 0% for now
        percent = 0;
      } else {
        percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
      }

      // make sure to bound percent value
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( type.color ){
        var r1 = prop.valueMin[0];
        var r2 = prop.valueMax[0];
        var g1 = prop.valueMin[1];
        var g2 = prop.valueMax[1];
        var b1 = prop.valueMin[2];
        var b2 = prop.valueMax[2];
        var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
        var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

        var clr = [
          Math.round( r1 + (r2 - r1)*percent ),
          Math.round( g1 + (g2 - g1)*percent ),
          Math.round( b1 + (b2 - b1)*percent ),
          Math.round( a1 + (a2 - a1)*percent )
        ];

        flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
          bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
          name: prop.name,
          value: clr,
          strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
        };
      
      } else if( type.number ){
        var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
        flatProp = this.parse( prop.name, calcValue, prop.bypass, true );
      
      } else {
        return false; // can only map to colours and numbers
      }

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );
      } 

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    // direct mapping  
    case $$.style.types.data: 
    case $$.style.types.layoutData: 

      var isLayout = prop.mapped === $$.style.types.layoutData;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal = isLayout ? ele._private.layoutData : ele._private.data;
      for( var i = 0; i < fields.length && fieldVal; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      }

      flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        var flatPropVal = origProp ? origProp.strValue : '';

        flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );
      }

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want
      break;

    case undefined:
      break; // just set the property

    default: 
      return false; // not a valid mapping
    }

    // if the property is a bypass property, then link the resultant property to the original one
    if( propIsBypass ){
      if( origPropIsBypass ){ // then this bypass overrides the existing one
        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
      } else { // then link the orig prop to the new bypass
        prop.bypassed = origProp;
      }

      style[ prop.name ] = prop; // and set
    
    } else { // prop is not bypass
      if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
        origProp.bypassed = prop;
      } else { // then just replace the old prop with the new one
        style[ prop.name ] = prop; 
      }
    }

    return true;
  };

  // updates the visual style for all elements (useful for manual style modification after init)
  $$.styfn.update = function(){
    var cy = this._private.cy;
    var eles = cy.elements();

    eles.updateStyle();
  };

  // just update the functional properties (i.e. mappings) in the elements'
  // styles (less expensive than recalculation)
  $$.styfn.updateMappers = function( eles ){
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;

      for( var j = 0; j < $$.style.properties.length; j++ ){ // for each prop
        var prop = $$.style.properties[j];
        var propInStyle = style[ prop.name ];

        if( propInStyle && propInStyle.mapping ){
          var mapping = propInStyle.mapping;
          this.applyParsedProperty( ele, mapping ); // reapply the mapping property
        }
      }

      this.updateStyleHints( ele );
    }
  };

  // diffProps : { name => { prev, next } }
  $$.styfn.updateTransitions = function( ele, diffProps, isBypass ){
    var self = this;
    var style = ele._private.style;

    var props = style['transition-property'].value;
    var duration = style['transition-duration'].msValue;
    var delay = style['transition-delay'].msValue;
    var css = {};

    if( props.length > 0 && duration > 0 ){

      // build up the style to animate towards
      var anyPrev = false;
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        var styProp = style[ prop ];
        var diffProp = diffProps[ prop ];

        if( !diffProp ){ continue; }

        var prevProp = diffProp.prev;
        var fromProp = prevProp;
        var toProp = diffProp.next != null ? diffProp.next : styProp;
        var diff = false;

        if( !fromProp ){ continue; } 

        // consider px values
        if( $$.is.number( fromProp.pxValue ) && $$.is.number( toProp.pxValue ) ){
          diff = fromProp.pxValue !== toProp.pxValue;

        // consider numerical values
        } else if( $$.is.number( fromProp.value ) && $$.is.number( toProp.value ) ){
          diff = fromProp.value !== toProp.value;

        // consider colour values
        } else if( $$.is.array( fromProp.value ) && $$.is.array( toProp.value ) ){
          diff = fromProp.value[0] !== toProp.value[0]
            || fromProp.value[1] !== toProp.value[1]
            || fromProp.value[2] !== toProp.value[2]
          ;
        }

        // the previous value is good for an animation only if it's different
        if( diff ){
          css[ prop ] = toProp.strValue; // to val
          this.applyBypass(ele, prop, fromProp.strValue); // from val
          anyPrev = true;
        }
        
      } // end if props allow ani

      // can't transition if there's nothing previous to transition from
      if( !anyPrev ){ return; }
      
      ele._private.transitioning = true;

      ele.stop();

      if( delay > 0 ){
        ele.delay( delay );
      }

      ele.animate({
        css: css
      }, {
        duration: duration,
        queue: false,
        complete: function(){ 
          if( !isBypass ){
            self.removeBypasses( ele, props );
          }

          ele._private.transitioning = false;
        }
      });

    } else if( ele._private.transitioning ){
      ele.stop();

      this.removeBypasses( ele, props );

      ele._private.transitioning = false;
    }
  }; 

})( cytoscape );
;(function($$){ 'use strict';

  // bypasses are applied to an existing style on an element, and just tacked on temporarily
  // returns true iff application was successful for at least 1 specified property
  $$.styfn.applyBypass = function( eles, name, value, updateTransitions ){
    var props = [];
    var isBypass = true;
    
    // put all the properties (can specify one or many) in an array after parsing them
    if( name === "*" || name === "**" ){ // apply to all property names

      if( value !== undefined ){
        for( var i = 0; i < $$.style.properties.length; i++ ){
          var prop = $$.style.properties[i];
          var name = prop.name;

          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }

    } else if( $$.is.string(name) ){ // then parse the single property
      var parsedProp = this.parse(name, value, true);

      if( parsedProp ){
        props.push( parsedProp );
      }
    } else if( $$.is.plainObject(name) ){ // then parse each property
      var specifiedProps = name;
      updateTransitions = value;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = specifiedProps[ name ];

        if( value === undefined ){ // try camel case name too
          value = specifiedProps[ $$.util.dash2camel(name) ];
        }

        if( value !== undefined ){
          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }
    } else { // can't do anything without well defined properties
      return false;
    }

    // we've failed if there are no valid properties
    if( props.length === 0 ){ return false; }

    // now, apply the bypass properties on the elements
    var ret = false; // return true if at least one succesful bypass applied
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;
      var diffProps = {};
      var diffProp;

      for( var j = 0; j < props.length; j++ ){ // for each prop
        var prop = props[j];

        if( updateTransitions ){
          var prevProp = style[ prop.name ];
          diffProp = diffProps[ prop.name ] = { prev: prevProp };
        }

        ret = this.applyParsedProperty( ele, prop ) || ret;

        if( updateTransitions ){
          diffProp.next = style[ prop.name ];
        }

      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles

    return ret;
  };

  // only useful in specific cases like animation
  $$.styfn.overrideBypass = function( eles, name, value ){
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var prop = ele._private.style[ $$.util.camel2dash(name) ];

      if( !prop.bypass ){ // need a bypass if one doesn't exist
        this.applyBypass( ele, name, value );
        continue;
      }

      prop.value = value;
      prop.pxValue = value;
    }
  };

  $$.styfn.removeAllBypasses = function( eles, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

  $$.styfn.removeBypasses = function( eles, props, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < props.length; i++ ){
        var name = props[i];
        var prop = $$.style.properties[ name ];
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

})( cytoscape );
;(function($$, window){ 'use strict';

  // gets what an em size corresponds to in pixels relative to a dom element
  $$.styfn.getEmSizeInPixels = function(){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      var pxAsStr = window.getComputedStyle(domElement).getPropertyValue('font-size');
      var px = parseFloat( pxAsStr );
      return px;
    } else {
      return 1; // in case we're running outside of the browser
    }
  };

  // gets css property from the core container
  $$.styfn.containerCss = function( propName ){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      return window.getComputedStyle(domElement).getPropertyValue( propName );
    }
  };

  $$.styfn.containerProperty = function( propName ){
    var propStr = this.containerCss( propName );
    var prop = this.parse( propName, propStr );
    return prop;
  };

  $$.styfn.containerPropertyAsString = function( propName ){
    var prop = this.containerProperty( propName );

    if( prop ){
      return prop.strValue;
    }
  };

})( cytoscape, typeof window === 'undefined' ? null : window );
;(function($$){ 'use strict';

  // gets the rendered style for an element
  $$.styfn.getRenderedStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;
      var cy = this._private.cy;
      var zoom = cy.zoom();

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          var val = styleProp.unitless ? styleProp.strValue : (styleProp.pxValue * zoom) + 'px';
          rstyle[ prop.name ] = val;
          rstyle[ $$.util.dash2camel(prop.name) ] = val;
        }
      }

      return rstyle;
    }
  };

  // gets the raw style for an element
  $$.styfn.getRawStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          rstyle[ prop.name ] = styleProp.strValue;
          rstyle[ $$.util.dash2camel(prop.name) ] = styleProp.strValue;
        }
      }

      return rstyle;
    }
  };

  // gets the value style for an element (useful for things like animations)
  $$.styfn.getValueStyle = function( ele, opts ){
    opts = opts || {};

    var rstyle = opts.array ? [] : {}; 
    var style;

    if( $$.is.element(ele) ){
      style = ele._private.style;    
    } else {
      style = ele; // just passed the style itself
    }

    if( style ){
      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ] || style[ $$.util.dash2camel(prop.name) ];

        if( styleProp !== undefined && !$$.is.plainObject( styleProp ) ){ // then make a prop of it
          styleProp = this.parse(prop.name, styleProp);
        }

        if( styleProp ){
          if( opts.array ){
            rstyle.push( styleProp );
          } else {
            rstyle[ prop.name ] = styleProp;
            rstyle[ $$.util.dash2camel(prop.name) ] = styleProp;
          }
        }
      }
    }

    return rstyle;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromJson = function( style, json ){
    for( var i = 0; i < json.length; i++ ){
      var context = json[i];
      var selector = context.selector;
      var props = context.css;

      style.selector(selector); // apply selector

      for( var name in props ){
        var value = props[name];

        style.css( name, value ); // apply property
      }
    }

    return style;
  };

  // static function
  $$.style.fromJson = function( cy, json ){
    var style = new $$.Style(cy);

    $$.style.applyFromJson( style, json );

    return style;
  };

  // accessible cy.style() function
  $$.styfn.fromJson = function( json ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromJson( style, json );

    return style;
  };

  // get json from cy.style() api
  $$.styfn.json = function(){
    var json = [];

    for( var i = this.defaultLength; i < this.length; i++ ){
      var cxt = this[i];
      var selector = cxt.selector;
      var props = cxt.properties;
      var css = {};

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        css[ prop.name ] = prop.strValue;
      }

      json.push({
        selector: !selector ? 'core' : selector.toString(),
        css: css
      });
    }

    return json;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromString = function( style, string ){
    var remaining = '' + string;
    var selAndBlockStr;
    var blockRem;
    var propAndValStr;

    // remove comments from the style string
    remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

    function removeSelAndBlockFromRemaining(){
      // remove the parsed selector and block from the remaining text to parse
      if( remaining.length > selAndBlockStr.length ){
        remaining = remaining.substr( selAndBlockStr.length );
      } else {
        remaining = '';
      }
    }

    function removePropAndValFromRem(){
      // remove the parsed property and value from the remaining block text to parse
      if( blockRem.length > propAndValStr.length ){
        blockRem = blockRem.substr( propAndValStr.length );
      } else {
        blockRem = '';
      }
    }

    while(true){
      var nothingLeftToParse = remaining.match(/^\s*$/);
      if( nothingLeftToParse ){ break; }

      var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

      if( !selAndBlock ){
        $$.util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
        break;
      }

      selAndBlockStr = selAndBlock[0];

      // parse the selector
      var selectorStr = selAndBlock[1];
      var selector = new $$.Selector( selectorStr );
      if( selector._private.invalid && selectorStr !== 'core' ){
        $$.util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

        // skip this selector and block
        removeSelAndBlockFromRemaining();
        continue; 
      }

      // parse the block of properties and values
      var blockStr = selAndBlock[2];
      var invalidBlock = false;
      blockRem = blockStr;
      var props = [];

      while(true){
        var nothingLeftToParse = blockRem.match(/^\s*$/);
        if( nothingLeftToParse ){ break; }

        var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

        if( !propAndVal ){
          $$.util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
          invalidBlock = true;
          break;
        }

        propAndValStr = propAndVal[0];
        var propStr = propAndVal[1];
        var valStr = propAndVal[2];

        var prop = $$.style.properties[ propStr ];
        if( !prop ){
          $$.util.error('Skipping property: Invalid property name in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        var parsedProp = style.parse( propStr, valStr );

        if( !parsedProp ){
          $$.util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        props.push({
          name: propStr,
          val: valStr
        });
        removePropAndValFromRem();
      }

      if( invalidBlock ){
        removeSelAndBlockFromRemaining();
        break;
      }

      // put the parsed block in the style
      style.selector( selectorStr );
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        style.css( prop.name, prop.val );
      }

      removeSelAndBlockFromRemaining();
    }

    return style;
  };

  $$.style.fromString = function( cy, string ){
    var style = new $$.Style(cy);
    
    $$.style.applyFromString( style, string );

    return style;
  };

  $$.styfn.fromString = function( string ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromString( style, string );

    return style;
  };

})( cytoscape );

;(function($$){ 'use strict';

  // a dummy stylesheet object that doesn't need a reference to the core
  // (useful for init)
  $$.stylesheet = $$.Stylesheet = function(){
    if( !(this instanceof $$.Stylesheet) ){
      return new $$.Stylesheet();
    }

    this.length = 0;
  };

  // just store the selector to be parsed later
  $$.Stylesheet.prototype.selector = function( selector ){
    var i = this.length++;

    this[i] = {
      selector: selector,
      properties: []
    };

    return this; // chaining
  };

  // just store the property to be parsed later
  $$.Stylesheet.prototype.css = function( name, value ){
    var i = this.length - 1;

    if( $$.is.string(name) ){
      this[i].properties.push({
        name: name,
        value: value
      });
    } else if( $$.is.plainObject(name) ){
      var map = name;

      for( var j = 0; j < $$.style.properties.length; j++ ){
        var prop = $$.style.properties[j];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){ // also try camel case name
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          var name = prop.name;
          var value = mapVal;

          this[i].properties.push({
            name: name,
            value: value
          });
        }
      }
    }

    return this; // chaining
  };

  // generate a real style object from the dummy stylesheet
  $$.Stylesheet.prototype.generateStyle = function( cy ){
    var style = new $$.Style(cy);

    for( var i = 0; i < this.length; i++ ){
      var context = this[i];
      var selector = context.selector;
      var props = context.properties;

      style.selector(selector); // apply selector

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];

        style.css( prop.name, prop.value ); // apply property
      }
    }

    return style;
  };

})( cytoscape );
;(function($$, window){ 'use strict';

  var isTouch = $$.is.touch();

  var defaults = {
  };
  
  var origDefaults = $$.util.copy( defaults );

  $$.defaults = function( opts ){
    defaults = $$.util.extend({}, origDefaults, opts);
  };

  $$.fn.core = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Core.prototype[ name ] = fn;
    }
  };
  
  $$.Core = function( opts ){
    if( !(this instanceof $$.Core) ){
      return new $$.Core(opts);
    }
    var cy = this;

    opts = $$.util.extend({}, defaults, opts);

    var container = opts.container;
    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
    reg = reg || {};

    if( reg && reg.cy ){ 
      if( container ){
        while( container.firstChild ){ // clean the container
          container.removeChild( container.firstChild );
        }
      }
      
      reg.cy.notify({ type: 'destroy' }); // destroy the renderer

      reg = {}; // old instance => replace reg completely
    }

    var readies = reg.readies = reg.readies || [];
    
    if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
    reg.cy = cy;

    var head = window !== undefined && container !== undefined && !opts.headless;
    var options = opts;
    options.layout = $$.util.extend( { name: head ? 'grid' : 'null' }, options.layout );
    options.renderer = $$.util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );
    
    var defVal = function( def, val, altVal ){
      if( val !== undefined ){
        return val;
      } else if( altVal !== undefined ){
        return altVal;
      } else {
        return def;
      }
    };

    var _p = this._private = {
      container: options.container, // html dom ele container
      ready: false, // whether ready has been triggered
      initrender: false, // has initrender has been triggered
      options: options, // cached options
      elements: [], // array of elements
      id2index: {}, // element id => index in elements array
      listeners: [], // list of listeners
      aniEles: $$.Collection(this), // elements being animated
      scratch: {}, // scratch object for core
      layout: null,
      renderer: null,
      notificationsEnabled: true, // whether notifications are sent to the renderer
      minZoom: 1e-50,
      maxZoom: 1e50,
      zoomingEnabled: defVal(true, options.zoomingEnabled),
      userZoomingEnabled: defVal(true, options.userZoomingEnabled),
      panningEnabled: defVal(true, options.panningEnabled),
      userPanningEnabled: defVal(true, options.userPanningEnabled),
      boxSelectionEnabled: defVal(false, options.boxSelectionEnabled),
      autolock: defVal(false, options.autolock, options.autolockNodes),
      autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
      autounselectify: defVal(false, options.autounselectify),
      styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
      zoom: $$.is.number(options.zoom) ? options.zoom : 1,
      pan: {
        x: $$.is.plainObject(options.pan) && $$.is.number(options.pan.x) ? options.pan.x : 0,
        y: $$.is.plainObject(options.pan) && $$.is.number(options.pan.y) ? options.pan.y : 0
      },
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      hasCompoundNodes: false,
      deferredExecQueue: []
    };

    // set selection type
    var selType = options.selectionType;
    if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
      // then set default

      if( isTouch ){
        _p.selectionType = 'additive';
      } else {
        _p.selectionType = 'single';
      }
    } else {
      _p.selectionType = selType;
    }

    // init zoom bounds
    if( $$.is.number(options.minZoom) && $$.is.number(options.maxZoom) && options.minZoom < options.maxZoom ){
      _p.minZoom = options.minZoom;
      _p.maxZoom = options.maxZoom;
    } else if( $$.is.number(options.minZoom) && options.maxZoom === undefined ){
      _p.minZoom = options.minZoom;
    } else if( $$.is.number(options.maxZoom) && options.minZoom === undefined ){
      _p.maxZoom = options.maxZoom;
    }

    // init style
    if( _p.styleEnabled ){
      this.setStyle( options.style );
    }

    // create the renderer
    cy.initRenderer( $$.util.extend({
      hideEdgesOnViewport: options.hideEdgesOnViewport,
      hideLabelsOnViewport: options.hideLabelsOnViewport,
      textureOnViewport: options.textureOnViewport,
      wheelSensitivity: $$.is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
      motionBlur: options.motionBlur,
      pixelRatio: $$.is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : (options.pixelRatio === 'auto' ? undefined : 1),
      tapThreshold: defVal( $$.is.touch() ? 8 : 4, $$.is.touch() ? options.touchTapThreshold : options.desktopTapThreshold )
    }, options.renderer) );

    // trigger the passed function for the `initrender` event
    if( options.initrender ){
      cy.on('initrender', options.initrender);
      cy.on('initrender', function(){
        cy._private.initrender = true;
      });
    }

    // initial load
    cy.load(options.elements, function(){ // onready
      cy.startAnimationLoop();
      cy._private.ready = true;

      // if a ready callback is specified as an option, the bind it
      if( $$.is.fn( options.ready ) ){
        cy.on('ready', options.ready);
      }

      // bind all the ready handlers registered before creating this instance
      for( var i = 0; i < readies.length; i++ ){
        var fn = readies[i];
        cy.on('ready', fn);
      }
      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc
      
      cy.trigger('ready');
    }, options.done);
  };

  $$.corefn = $$.Core.prototype; // short alias
  

  $$.fn.core({
    isReady: function(){
      return this._private.ready;
    },

    ready: function( fn ){
      if( this.isReady() ){
        this.trigger('ready', [], fn); // just calls fn as though triggered via ready event
      } else {
        this.on('ready', fn);
      }
    },

    initrender: function(){
      return this._private.initrender;
    },

    destroy: function(){
      this.notify({ type: 'destroy' }); // destroy the renderer

      var domEle = this.container();
      var parEle = domEle.parentNode;
      if( parEle ){
        parEle.removeChild( domEle );
      }

      return this;
    },

    getElementById: function( id ){
      var index = this._private.id2index[ id ];
      if( index !== undefined ){
        return this._private.elements[ index ];
      }

      // worst case, return an empty collection
      return new $$.Collection( this );
    },

    selectionType: function(){
      return this._private.selectionType;
    },

    hasCompoundNodes: function(){
      return this._private.hasCompoundNodes;
    },

    styleEnabled: function(){
      return this._private.styleEnabled;
    },

    addToPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var alreadyInPool = index !== undefined;

        if( !alreadyInPool ){
          index = elements.length;
          elements.push( ele );
          id2index[ id ] = index;
          ele._private.index = index;
        }
      }

      return this; // chaining
    },

    removeFromPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var inPool = index !== undefined;

        if( inPool ){
          this._private.id2index[ id ] = undefined;
          elements.splice(index, 1);

          // adjust the index of all elements past this index
          for( var j = index; j < elements.length; j++ ){
            var jid = elements[j]._private.data.id;
            id2index[ jid ]--;
          }
        }
      }
    },

    container: function(){
      return this._private.container;
    },

    options: function(){
      return $$.util.copy( this._private.options );
    },
    
    json: function(params){
      var json = {};
      var cy = this;
      
      json.elements = {};
      cy.elements().each(function(i, ele){
        var group = ele.group();
        
        if( !json.elements[group] ){
          json.elements[group] = [];
        }
        
        json.elements[group].push( ele.json() );
      });

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = cy._private.pan;
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.layout = cy._private.options.layout;
      json.renderer = cy._private.options.renderer;
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;
      
      return json;
    },

    // defer execution until not busy and guarantee relative execution order of deferred functions
    defer: function( fn ){
      var cy = this;
      var _p = cy._private;
      var q = _p.deferredExecQueue;

      q.push( fn );

      if( !_p.deferredTimeout ){
        _p.deferredTimeout = setTimeout(function(){
          while( q.length > 0 ){
            ( q.shift() )();
          }

          _p.deferredTimeout = null;
        }, 0);
      }
    }
    
  });  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

(function($$, window){ 'use strict';

  function ready(f) {
    var fn = ( document && (document.readyState === 'interactive' || document.readyState === 'complete') )  ? f : ready;

    setTimeout(fn, 9, f);
  }

  $$.fn.core({
    add: function(opts){
      
      var elements;
      var cy = this;
      
      // add the elements
      if( $$.is.elementOrCollection(opts) ){
        var eles = opts;

        if( eles._private.cy === cy ){ // same instance => just restore
          elements = eles.restore();

        } else { // otherwise, copy from json
          var jsons = [];

          for( var i = 0; i < eles.length; i++ ){
            var ele = eles[i];
            jsons.push( ele.json() );
          }

          elements = new $$.Collection( cy, jsons );
        }
      }
      
      // specify an array of options
      else if( $$.is.array(opts) ){
        var jsons = opts;

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify via opts.nodes and opts.edges
      else if( $$.is.plainObject(opts) && ($$.is.array(opts.nodes) || $$.is.array(opts.edges)) ){
        var elesByGroup = opts;
        var jsons = [];

        var grs = ['nodes', 'edges'];
        for( var i = 0, il = grs.length; i < il; i++ ){
          var group = grs[i];
          var elesArray = elesByGroup[group];

          if( $$.is.array(elesArray) ){

            for( var j = 0, jl = elesArray.length; j < jl; j++ ){
              var json = elesArray[j];
              json.group = group;

              jsons.push( json );
            }
          } 
        }

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify options for one element
      else {
        var json = opts;
        elements = (new $$.Element( cy, json )).collection();
      }
      
      return elements;
    },
    
    remove: function(collection){
      if( $$.is.elementOrCollection(collection) ){
        collection = collection;
      } else if( $$.is.string(collection) ){
        var selector = collection;
        collection = this.$( selector );
      }
      
      return collection.remove();
    },
    
    load: function(elements, onload, ondone){
      var cy = this;
      
      // remove old elements
      var oldEles = cy.elements();
      if( oldEles.length > 0 ){
        oldEles.remove();
      }

      cy.notifications(false);
      
      if( elements != null ){
        if( $$.is.plainObject(elements) || $$.is.array(elements) ){
          cy.add( elements );
        } 
      }
      
      function callback(){        
        cy.one('layoutready', function(e){
          cy.notifications(true);
          cy.trigger(e); // we missed this event by turning notifications off, so pass it on

          cy.notify({
            type: 'load',
            collection: cy.elements()
          });

          cy.one('load', onload);
          cy.trigger('load');
        }).one('layoutstop', function(){
          cy.one('done', ondone);
          cy.trigger('done');
        });
        
        var layoutOpts = $$.util.extend({}, cy._private.options.layout);
        layoutOpts.eles = cy.$();

        cy.layout( layoutOpts );

      }

      if( window ){
        ready( callback );
      } else {
        callback();
      }

      return this;
    }
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  $$.fn.core({
    
    // pull in animation functions
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop(),

    addToAnimationPool: function( eles ){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used
      
      cy._private.aniEles.merge( eles );
    },

    startAnimationLoop: function(){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used

      // don't execute the animation loop in headless environments
      if( !window ){
        return;
      }
      
      function globalAnimationStep(){
        $$.util.requestAnimationFrame(function(now){
          handleElements(now);
          globalAnimationStep();
        });
      }
      
      globalAnimationStep(); // first call
      
      function handleElements(now){
        now = +new Date();

        var eles = cy._private.aniEles;
        var doneEles = [];

        function handleElement( ele, isCore ){
          var current = ele._private.animation.current;
          var queue = ele._private.animation.queue;
          var ranAnis = false;
          
          // if nothing currently animating, get something from the queue
          if( current.length === 0 ){
            var next = queue.length > 0 ? queue.shift() : null;
            
            if( next ){
              next.callTime = now; // was queued, so update call time
              current.push( next );
            }
          }
          
          // step and remove if done
          var completes = [];
          for(var i = current.length - 1; i >= 0; i--){
            var ani = current[i];

            // start if need be
            if( !ani.started ){ startAnimation( ele, ani ); }
            
            step( ele, ani, now, isCore );

            if( ani.done ){
              completes.push( ani );
              
              // remove current[i]
              current.splice(i, 1);
            }

            ranAnis = true;
          }
          
          // call complete callbacks
          for( var i = 0; i < completes.length; i++ ){
            var ani = completes[i];
            var complete = ani.params.complete;

            if( $$.is.fn(complete) ){
              complete.apply( ele, [ now ] );
            }
          }

          if( !isCore && current.length === 0 && queue.length === 0 ){
            doneEles.push( ele );
          }

          return ranAnis;
        } // handleElements

        // handle all eles
        for( var e = 0; e < eles.length; e++ ){
          var ele = eles[e];
          
          handleElement( ele );
        } // each element

        var ranCoreAni = handleElement( cy, true );
        
        // notify renderer
        if( eles.length > 0 || ranCoreAni ){
          var toNotify;

          if( eles.length > 0 ){
            var updatedEles = eles.updateCompoundBounds();
            toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;
          }

          cy.notify({
            type: 'draw',
            collection: toNotify
          });
        }

        // remove elements from list of currently animating if its queues are empty
        eles.unmerge( doneEles );

      } // handleElements
      
      function startAnimation( self, ani ){
        var isCore = $$.is.core( self );
        var isEles = !isCore;
        var ele = self;
        var style = cy._private.style;

        if( isEles ){
          var pos = ele._private.position;
          var startPosition = {
            x: pos.x,
            y: pos.y
          };
          var startStyle = style.getValueStyle( ele );
        }

        if( isCore ){
          var pan = cy._private.pan;
          var startPan = {
            x: pan.x,
            y: pan.y
          };

          var startZoom = cy._private.zoom;
        }

        ani.started = true;
        ani.startTime = Date.now();
        ani.startPosition = startPosition;
        ani.startStyle = startStyle;
        ani.startPan = startPan;
        ani.startZoom = startZoom;
      }

      function step( self, animation, now, isCore ){
        var style = cy._private.style;
        var properties = animation.properties;
        var params = animation.params;
        var startTime = animation.startTime;
        var percent;
        var isEles = !isCore;
        
        if( animation.duration === 0 ){
          percent = 1;
        } else {
          percent = Math.min(1, (now - startTime)/animation.duration);
        }

        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }
        
        if( properties.delay == null ){ // then update

          var startPos = animation.startPosition;
          var endPos = properties.position;
          var pos = self._private.position;
          if( endPos && isEles ){
            if( valid( startPos.x, endPos.x ) ){
              pos.x = ease( startPos.x, endPos.x, percent );
            }

            if( valid( startPos.y, endPos.y ) ){
              pos.y = ease( startPos.y, endPos.y, percent );
            }
          }

          var startPan = animation.startPan;
          var endPan = properties.pan;
          var pan = self._private.pan;
          var animatingPan = endPan != null && isCore;
          if( animatingPan ){
            if( valid( startPan.x, endPan.x ) ){
              pan.x = ease( startPan.x, endPan.x, percent );
            }

            if( valid( startPan.y, endPan.y ) ){
              pan.y = ease( startPan.y, endPan.y, percent );
            }

            self.trigger('pan');
          }

          var startZoom = animation.startZoom;
          var endZoom = properties.zoom;
          var animatingZoom = endZoom != null && isCore;
          if( animatingZoom ){
            if( valid( startZoom, endZoom ) ){
              self._private.zoom = ease( startZoom, endZoom, percent );
            }

            self.trigger('zoom');
          }

          if( animatingPan || animatingZoom ){
            self.trigger('viewport');
          }

          if( properties.css && isEles ){
            var props = properties.css;

            for( var i = 0; i < props.length; i++ ){
              var name = props[i].name;
              var prop = props[i];
              var end = prop;

              var start = animation.startStyle[ name ];
              var easedVal = ease( start, end, percent );
              
              style.overrideBypass( self, name, easedVal );
            } // for props
          } // if 

        }
        
        if( $$.is.fn(params.step) ){
          params.step.apply( self, [ now ] );
        }
        
        if( percent >= 1 ){
          animation.done = true;
        }
        
        return percent;
      }
      
      function valid(start, end){
        if( start == null || end == null ){
          return false;
        }
        
        if( $$.is.number(start) && $$.is.number(end) ){
          return true;
        } else if( (start) && (end) ){
          return true;
        }
        
        return false;
      }
      
      function ease(startProp, endProp, percent){
        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }

        var start, end;

        if( startProp.pxValue != null || startProp.value != null ){
          start = startProp.pxValue != null ? startProp.pxValue : startProp.value;
        } else {
          start = startProp;
        }

        if( endProp.pxValue != null || endProp.value != null ){
          end = endProp.pxValue != null ? endProp.pxValue : endProp.value;
        } else {
          end = endProp;
        }

        if( $$.is.number(start) && $$.is.number(end) ){
          return start + (end - start) * percent;

        } else if( $$.is.number(start[0]) && $$.is.number(end[0]) ){ // then assume a colour
          var c1 = start;
          var c2 = end;

          var ch = function(ch1, ch2){
            var diff = ch2 - ch1;
            var min = ch1;
            return Math.round( percent * diff + min );
          };
          
          var r = ch( c1[0], c2[0] );
          var g = ch( c1[1], c2[1] );
          var b = ch( c1[2], c2[2] );
          
          return [r, g, b];
        }
        
        return undefined;
      }
      
    }
    
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );


  
    
;(function($$){ 'use strict';
  
  $$.fn.core({
    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      triggerEvent: false
    })
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.core({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger() // .trigger( events [, extraParams] )
  });

  // aliases for those folks who like old stuff:
  $$.corefn.bind = $$.corefn.on;
  $$.corefn.unbind = $$.corefn.off;

})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    png: function( options ){
      var renderer = this._private.renderer;
      options = options || {};

      return renderer.png( options );      
    }
    
  });
  
})( cytoscape );
;(function($$){ 'use strict';
  
  $$.fn.core({
    
    layout: function( params ){
      var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.initLayout( params ) );

      layout.run();

      return this; // chaining
    },

    makeLayout: function( params ){
      return this.initLayout( params );
    },
    
    initLayout: function( options ){
      if( options == null ){
        $$.util.error('Layout options must be specified to make a layout');
        return;
      }
      
      if( options.name == null ){
        $$.util.error('A `name` must be specified to make a layout');
        return;
      }
      
      var name = options.name;
      var LayoutProto = $$.extension('layout', name);
      
      if( LayoutProto == null ){
        $$.util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
        return;
      }

      options.eles = options.eles != null ? options.eles : this.$();

      if( $$.is.string( options.eles ) ){
        options.eles = this.$( options.eles );
      }
      
      var layout = new LayoutProto( $$.util.extend({}, options, {
        cy: this
      }) );

      // make sure layout has _private for use w/ std apis like .on()
      if( !$$.is.plainObject(layout._private) ){
        layout._private = {};
      }

      layout._private.cy = this;
      layout._private.listeners = [];
      
      return layout;
    }
    
  });
  
})( cytoscape );
(function($$){ 'use strict';
  
  $$.fn.core({
    notify: function( params ){
      if( this._private.batchingNotify ){
        var bEles = this._private.batchNotifyEles;
        var bTypes = this._private.batchNotifyTypes;

        if( params.collection ){ for( var i = 0; i < params.collection.length; i++ ){
          var ele = params.collection[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        } }

        if( !bTypes.ids[ params.type ] ){
          bTypes.push( params.type );
        }

        return; // notifications are disabled during batching
      }

      if( !this._private.notificationsEnabled ){ return; } // exit on disabled

      var renderer = this.renderer();
      
      renderer.notify(params);
    },
    
    notifications: function( bool ){
      var p = this._private;
      
      if( bool === undefined ){
        return p.notificationsEnabled;
      } else {
        p.notificationsEnabled = bool ? true : false;
      }
    },
    
    noNotifications: function( callback ){
      this.notifications(false);
      callback();
      this.notifications(true);
    },

    startBatch: function(){
      var _p = this._private;

      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = [];
      _p.batchNotifyEles = [];
      _p.batchNotifyTypes = [];

      _p.batchStyleEles.ids = {};
      _p.batchNotifyEles.ids = {};
      _p.batchNotifyTypes.ids = {};

      return this;
    },

    endBatch: function(){
      var _p = this._private;

      // update style for dirty eles
      _p.batchingStyle = false;
      new $$.Collection(this, _p.batchStyleEles).updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify({
        type: _p.batchNotifyTypes,
        collection: _p.batchNotifyEles
      });

      return this;
    },

    batch: function( callback ){
      this.startBatch();
      callback();
      this.endBatch();

      return this;
    },

    // for backwards compatibility
    batchData: function( map ){
      var cy = this;

      return this.batch(function(){
        for( var id in map ){
          var data = map[id];
          var ele = cy.getElementById( id );
          
          ele.data( data );
        }
      });
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    renderTo: function( context, zoom, pan, pxRatio ){
      var r = this._private.renderer;

      r.renderTo( context, zoom, pan, pxRatio );
      return this;
    },

    renderer: function(){
      return this._private.renderer;
    },

    forceRender: function(){
      this.notify({
        type: 'draw'
      });

      return this;
    },

    resize: function(){
      this.notify({
        type: 'resize'
      });

      this.trigger('resize');

      return this;
    },
    
    initRenderer: function( options ){
      var cy = this;

      var RendererProto = $$.extension('renderer', options.name);
      if( RendererProto == null ){
        $$.util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
        return;
      }
      
      this._private.renderer = new RendererProto(
        $$.util.extend({}, options, {
          cy: cy,
          style: cy._private.style
        })
      );
       
    }
    
  });  
  
})( cytoscape );
;(function($$){ 'use strict';
  
  $$.fn.core({

    // get a collection
    // - empty collection on no args
    // - collection of elements in the graph on selector arg
    // - guarantee a returned collection when elements or collection specified
    collection: function( eles ){

      if( $$.is.string( eles ) ){
        return this.$( eles );

      } else if( $$.is.elementOrCollection( eles ) ){
        return eles.collection();

      } else if( $$.is.array( eles ) ){
        return new $$.Collection( this, eles );
      }

      return new $$.Collection( this );
    },
    
    nodes: function( selector ){
      var nodes = this.$(function(){
        return this.isNode();
      });

      if( selector ){
        return nodes.filter( selector );
      } 

      return nodes;
    },
    
    edges: function( selector ){
      var edges = this.$(function(){
        return this.isEdge();
      });

      if( selector ){
        return edges.filter( selector );
      }

      return edges;
    },
      
    // search the graph like jQuery
    $: function( selector ){
      var eles = new $$.Collection( this, this._private.elements );

      if( selector ){
        return eles.filter( selector );
      }

      return eles;
    }
    
  });  

  // aliases
  $$.corefn.elements = $$.corefn.filter = $$.corefn.$;  
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    style: function( newStyle ){
      if( newStyle ){
        var s = this.setStyle( newStyle );

        s.update();
      }

      return this._private.style;
    },

    setStyle: function( style ){
      var _p = this._private;

      if( $$.is.stylesheet(style) ){
        _p.style = style.generateStyle(this);
      
      } else if( $$.is.array(style) ) {
        _p.style = $$.style.fromJson(this, style);
      
      } else if( $$.is.string(style) ){
        _p.style = $$.style.fromString(this, style);
      
      } else {
        _p.style = new $$.Style( this );
      }

      return _p.style;
    }
  });
  
})( cytoscape );


;(function($$){ 'use strict';
  
  $$.fn.core({

    autolock: function(bool){
      if( bool !== undefined ){
        this._private.autolock = bool ? true : false;
      } else {
        return this._private.autolock;
      }
      
      return this; // chaining
    },

    autoungrabify: function(bool){
      if( bool !== undefined ){
        this._private.autoungrabify = bool ? true : false;
      } else {
        return this._private.autoungrabify;
      }
      
      return this; // chaining
    },

    autounselectify: function(bool){
      if( bool !== undefined ){
        this._private.autounselectify = bool ? true : false;
      } else {
        return this._private.autounselectify;
      }
      
      return this; // chaining
    },

    panningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.panningEnabled = bool ? true : false;
      } else {
        return this._private.panningEnabled;
      }
      
      return this; // chaining
    },

    userPanningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userPanningEnabled = bool ? true : false;
      } else {
        return this._private.userPanningEnabled;
      }
      
      return this; // chaining
    },
    
    zoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.zoomingEnabled = bool ? true : false;
      } else {
        return this._private.zoomingEnabled;
      }
      
      return this; // chaining
    },

    userZoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userZoomingEnabled = bool ? true : false;
      } else {
        return this._private.userZoomingEnabled;
      }
      
      return this; // chaining
    },

    boxSelectionEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.boxSelectionEnabled = bool ? true : false;
      } else {
        return this._private.boxSelectionEnabled;
      }
      
      return this; // chaining
    },
    
    pan: function(){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      switch( args.length ){
      case 0: // .pan()
        return pan;

      case 1: 

        if( $$.is.string( args[0] ) ){ // .pan('x')
          dim = args[0];
          return pan[ dim ];

        } else if( $$.is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })
          if( !this._private.panningEnabled ){
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x = x;
          }

          if( $$.is.number(y) ){
            pan.y = y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .pan('x', 100)
        if( !this._private.panningEnabled ){
          return this;
        }

        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] = val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    panBy: function(params){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      if( !this._private.panningEnabled ){
        return this;
      }

      switch( args.length ){
      case 1: 

        if( $$.is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x += x;
          }

          if( $$.is.number(y) ){
            pan.y += y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .panBy('x', 100)
        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] += val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    fit: function( elements, padding ){
      var viewportState = this.getFitViewport( elements, padding );

      if( viewportState ){
        var _p = this._private;
        _p.zoom = viewportState.zoom;
        _p.pan = viewportState.pan;

        this.trigger('pan zoom viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getFitViewport: function( elements, padding ){
      if( $$.is.number(elements) && padding === undefined ){ // elements is optional
        padding = elements;
        elements = undefined;
      }

      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return;
      }

      var bb;

      if( $$.is.string(elements) ){
        var sel = elements;
        elements = this.$( sel );

      } else if( $$.is.boundingBox(elements) ){ // assume bb
        var bbe = elements;
        bb = {
          x1: bbe.x1,
          y1: bbe.y1,
          x2: bbe.x2,
          y2: bbe.y2
        };

        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;

      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      bb = bb || elements.boundingBox();

      var w = this.width();
      var h = this.height();
      var zoom;
      padding = $$.is.number(padding) ? padding : 0;

      if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){
        zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );

        // crop zoom
        zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
        zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

        var pan = { // now pan to middle
          x: (w - zoom*( bb.x1 + bb.x2 ))/2,
          y: (h - zoom*( bb.y1 + bb.y2 ))/2
        };

        return {
          zoom: zoom, 
          pan: pan
        };
      }

      return;
    },
    
    minZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.minZoom;
      } else if( $$.is.number(zoom) ){
        this._private.minZoom = zoom;
      }

      return this;
    },

    maxZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.maxZoom;
      } else if( $$.is.number(zoom) ){
        this._private.maxZoom = zoom;
      }

      return this;
    },

    zoom: function( params ){
      var pos; // in rendered px
      var zoom;

      if( params === undefined ){ // then get the zoom
        return this._private.zoom;

      } else if( $$.is.number(params) ){ // then set the zoom
        zoom = params;

      } else if( $$.is.plainObject(params) ){ // then zoom about a point
        zoom = params.level;

        if( params.position ){
          var p = params.position;
          var pan = this._private.pan;
          var z = this._private.zoom;

          pos = { // convert to rendered px
            x: p.x * z + pan.x,
            y: p.y * z + pan.y
          };
        } else if( params.renderedPosition ){
          pos = params.renderedPosition;
        }

        if( pos && !this._private.panningEnabled ){
          return this; // panning disabled
        }
      }

      if( !this._private.zoomingEnabled ){
        return this; // zooming disabled
      }

      if( !$$.is.number(zoom) || ( pos && (!$$.is.number(pos.x) || !$$.is.number(pos.y)) ) ){
        return this; // can't zoom with invalid params
      }

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      if( pos ){ // set zoom about position
        var pan1 = this._private.pan;
        var zoom1 = this._private.zoom;
        var zoom2 = zoom;
        
        var pan2 = {
          x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,
          y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y
        };

        this._private.zoom = zoom;
        this._private.pan = pan2;

        var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
        this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );
      
      } else { // just set the zoom
        this._private.zoom = zoom;
        this.trigger('zoom viewport');
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },

    viewport: function( opts ){ 
      var _p = this._private;
      var zoomDefd = true;
      var panDefd = true;
      var events = []; // to trigger
      var zoomFailed = false;
      var panFailed = false;

      if( !opts ){ return this; }
      if( !$$.is.number(opts.zoom) ){ zoomDefd = false; }
      if( !$$.is.plainObject(opts.pan) ){ panDefd = false; }
      if( !zoomDefd && !panDefd ){ return this; }

      if( zoomDefd ){
        var z = opts.zoom;

        if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
          zoomFailed = true;

        } else {
          _p.zoom = z;

          events.push('zoom');
        }
      }

      if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
        var p = opts.pan;

        if( $$.is.number(p.x) ){
          _p.pan.x = p.x;
          panFailed = false;
        }

        if( $$.is.number(p.y) ){
          _p.pan.y = p.y;
          panFailed = false;
        }

        if( !panFailed ){
          events.push('pan');
        }
      }

      if( events.length > 0 ){
        events.push('viewport');
        this.trigger( events.join(' ') );

        this.notify({
          type: 'viewport'
        });
      }

      return this; // chaining
    },
    
    center: function( elements ){
      var pan = this.getCenterPan( elements );

      if( pan ){
        this._private.pan = pan;

        this.trigger('pan viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getCenterPan: function( elements, zoom ){
      if( !this._private.panningEnabled ){
        return;
      }

      if( $$.is.string(elements) ){
        var selector = elements;
        elements = this.elements( selector );
      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      var bb = elements.boundingBox();
      var w = this.width();
      var h = this.height();
      zoom = zoom === undefined ? this._private.zoom : zoom;

      var pan = { // middle
        x: (w - zoom*( bb.x1 + bb.x2 ))/2,
        y: (h - zoom*( bb.y1 + bb.y2 ))/2
      };
      
      return pan;
    },
    
    reset: function(){
      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return this;
      }

      this.viewport({
        pan: { x: 0, y: 0 },
        zoom: 1
      });
      
      return this; // chaining
    },

    width: function(){
      var container = this._private.container;

      if( container ){
        return container.clientWidth;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    height: function(){
      var container = this._private.container;

      if( container ){
        return container.clientHeight;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    extent: function(){
      var pan = this._private.pan;
      var zoom = this._private.zoom;
      var rb = this.renderedExtent();

      var b = {
        x1: ( rb.x1 - pan.x )/zoom,
        x2: ( rb.x2 - pan.x )/zoom,
        y1: ( rb.y1 - pan.y )/zoom,
        y2: ( rb.y2 - pan.y )/zoom,
      };

      b.w = b.x2 - b.x1;
      b.h = b.y2 - b.y1;

      return b;
    },

    renderedExtent: function(){
      var width = this.width();
      var height = this.height();

      return {
        x1: 0,
        y1: 0,
        x2: width,
        y2: height,
        w: width,
        h: height
      };
    }
  });

  // aliases
  $$.corefn.centre = $$.corefn.center;

  // backwards compatibility
  $$.corefn.autolockNodes = $$.corefn.autolock;
  $$.corefn.autoungrabifyNodes = $$.corefn.autoungrabify;

})( cytoscape );

;(function($$){ 'use strict';
  
  // Use this interface to define functions for collections/elements.
  // This interface is good, because it forces you to think in terms
  // of the collections case (more than 1 element), so we don't need
  // notification blocking nonsense everywhere.
  //
  // Other collection-*.js files depend on this being defined first.
  // It's a trade off: It simplifies the code for Collection and 
  // Element integration so much that it's worth it to create the
  // JS dependency.
  //
  // Having this integration guarantees that we can call any
  // collection function on an element and vice versa.

  // e.g. $$.fn.collection({ someFunc: function(){ /* ... */ } })
  $$.fn.collection = $$.fn.eles = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];

      $$.Collection.prototype[ name ] = fn;
    }
  };
  
  // factory for generating edge ids when no id is specified for a new element
  var idFactory = {
    prefix: {
      nodes: 'n',
      edges: 'e'
    },
    id: {
      nodes: 0,
      edges: 0
    },
    generate: function(cy, element, tryThisId){
      var json = $$.is.element( element ) ? element._private : element;
      var group = json.group;
      var id = tryThisId != null ? tryThisId : this.prefix[group] + this.id[group];
      
      if( cy.getElementById(id).empty() ){
        this.id[group]++; // we've used the current id, so move it up
      } else { // otherwise keep trying successive unused ids
        while( !cy.getElementById(id).empty() ){
          id = this.prefix[group] + ( ++this.id[group] );
        }
      }
      
      return id;
    }
  };
  
  // Element
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a node or an edge
  $$.Element = function(cy, params, restore){
    if( !(this instanceof $$.Element) ){
      return new $$.Element(cy, params, restore);
    }

    var self = this;
    restore = (restore === undefined || restore ? true : false);
    
    if( cy === undefined || params === undefined || !$$.is.core(cy) ){
      $$.util.error('An element must have a core reference and parameters set');
      return;
    }
    
    // validate group
    if( params.group !== 'nodes' && params.group !== 'edges' ){
      $$.util.error('An element must be of type `nodes` or `edges`; you specified `' + params.group + '`');
      return;
    }
    
    // make the element array-like, just like a collection
    this.length = 1;
    this[0] = this;
    
    // NOTE: when something is added here, add also to ele.json()
    this._private = {
      cy: cy,
      single: true, // indicates this is an element
      data: params.data || {}, // data object
      layoutData: {}, // place for layouts to put calculated stats etc for mappers
      position: params.position || {}, // (x, y) position pair
      autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
      autoHeight: undefined, 
      listeners: [], // array of bound listeners
      group: params.group, // string; 'nodes' or 'edges'
      style: {}, // properties as set by the style
      rstyle: {}, // properties for style sent from the renderer to the core
      styleCxts: [], // applied style contexts from the styler
      removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
      selected: params.selected ? true : false, // whether it's selected
      selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
      locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
      grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
      grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
      active: false, // whether the element is active from user interaction
      classes: {}, // map ( className => true )
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      rscratch: {}, // object in which the renderer can store information
      scratch: {}, // scratch objects
      edges: [], // array of connected edges
      children: [] // array of children
    };
    
    // renderedPosition overrides if specified
    if( params.renderedPosition ){
      var rpos = params.renderedPosition;
      var pan = cy.pan();
      var zoom = cy.zoom();

      this._private.position = {
        x: (rpos.x - pan.x)/zoom,
        y: (rpos.y - pan.y)/zoom
      };
    }
    
    if( $$.is.string(params.classes) ){
      var classes = params.classes.split(/\s+/);
      for( var i = 0, l = classes.length; i < l; i++ ){
        var cls = classes[i];
        if( !cls || cls === '' ){ continue; }

        self._private.classes[cls] = true;
      }
    }

    if( params.css ){
      cy.style().applyBypass( this, params.css );
    }
    
    if( restore === undefined || restore ){
      this.restore();
    }
    
  };

  
  // Collection
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a set of nodes, edges, or both together
  $$.Collection = function(cy, elements, options){
    if( !(this instanceof $$.Collection) ){
      return new $$.Collection(cy, elements);
    }

    if( cy === undefined || !$$.is.core(cy) ){
      $$.util.error('A collection must have a reference to the core');
      return;
    }
    
    var ids = {};
    var indexes = {};
    var createdElements = false;
    
    if( !elements ){
      elements = [];
    } else if( elements.length > 0 && $$.is.plainObject( elements[0] ) && !$$.is.element( elements[0] ) ){
      createdElements = true;

      // make elements from json and restore all at once later
      var eles = [];
      var elesIds = {};

      for( var i = 0, l = elements.length; i < l; i++ ){
        var json = elements[i];

        if( json.data == null ){
          json.data = {};
        }
        
        var data = json.data;

        // make sure newly created elements have valid ids
        if( data.id == null ){
          data.id = idFactory.generate( cy, json );
        } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){
          continue; // can't create element if prior id already exists
        }

        var ele = new $$.Element( cy, json, false );
        eles.push( ele );
        elesIds[ data.id ] = true;
      }

      elements = eles;
    }
    
    this.length = 0;

    for( var i = 0, l = elements.length; i < l; i++ ){
      var element = elements[i];
      if( !element ){  continue; }
      
      var id = element._private.data.id;
      
      if( !options || (options.unique && !ids[ id ] ) ){
        ids[ id ] = element;
        indexes[ id ] = this.length;

        this[ this.length ] = element;
        this.length++;
      }
    }
    
    this._private = {
      cy: cy,
      ids: ids,
      indexes: indexes
    };

    // restore the elements if we created them from json
    if( createdElements ){
      this.restore();
    }
  };
  
  
  // Functions
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // keep the prototypes in sync (an element has the same functions as a collection)
  // and use $$.elefn and $$.elesfn as shorthands to the prototypes
  $$.elefn = $$.elesfn = $$.Element.prototype = $$.Collection.prototype;

  $$.elesfn.cy = function(){
    return this._private.cy;
  };
  
  $$.elesfn.element = function(){
    return this[0];
  };
  
  $$.elesfn.collection = function(){
    if( $$.is.collection(this) ){
      return this;
    } else { // an element
      return new $$.Collection( this._private.cy, [this] );
    }
  };

  $$.elesfn.unique = function(){
    return new $$.Collection( this._private.cy, this, { unique: true } );
  };

  $$.elesfn.getElementById = function( id ){
    var cy = this._private.cy;
    var ele = this._private.ids[ id ];

    return ele ? ele : $$.Collection(cy); // get ele or empty collection
  };

  $$.elesfn.json = function(){
    var ele = this.element();
    if( ele == null ){ return undefined; }

    var p = ele._private;
    
    var json = $$.util.copy({
      data: p.data,
      position: p.position,
      group: p.group,
      bypass: p.bypass,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbed: p.grabbed,
      grabbable: p.grabbable,
      classes: ''
    });
    
    var classes = [];
    for( var cls in p.classes ){
      if( p.classes[cls] ){
        classes.push(cls);
      }
    }
    
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[i];
      json.classes += cls + ( i < classes.length - 1 ? ' ' : '' );
    }
    
    return json;
  };

  $$.elesfn.jsons = function(){
    var jsons = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();

      jsons.push( json );
    }

    return jsons;
  };

  $$.elesfn.clone = function(){
    var cy = this.cy();
    var elesArr = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();
      var clone = new $$.Element(cy, json, false); // NB no restore

      elesArr.push( clone );
    }

    return new $$.Collection( cy, elesArr );
  };

  $$.elesfn.restore = function( notifyRenderer ){
    var self = this;
    var restored = [];
    var cy = self.cy();
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }

    // create arrays of nodes and edges, since we need to
    // restore the nodes first
    var elements = [];
    var nodes = [], edges = [];
    var numNodes = 0;
    var numEdges = 0;
    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];
      
      // keep nodes first in the array and edges after
      if( ele.isNode() ){ // put to front of array if node
        nodes.push( ele );
        numNodes++;
      } else { // put to end of array if edge
        edges.push( ele );
        numEdges++;
      }
    }

    elements = nodes.concat( edges );

    // now, restore each element
    for( var i = 0, l = elements.length; i < l; i++ ){
      var ele = elements[i];

      if( !ele.removed() ){
        // don't need to do anything
        continue;
      }
      
      var _private = ele._private;
      var data = _private.data;
      
      // set id and validate
      if( data.id === undefined ){
        data.id = idFactory.generate( cy, ele );
      } else if( $$.is.emptyString(data.id) || !$$.is.string(data.id) ){
        $$.util.error('Can not create element with invalid string ID `' + data.id + '`');
        
        // can't create element if it has empty string as id or non-string id
        continue;
      } else if( cy.getElementById( data.id ).length !== 0 ){
        $$.util.error('Can not create second element with ID `' + data.id + '`');
        
        // can't create element if one already has that id
        continue;
      }

      var id = data.id; // id is finalised, now let's keep a ref
      
      if( ele.isEdge() ){ // extra checks for edges
        
        var edge = ele;
        var fields = ['source', 'target'];
        var fieldsLength = fields.length;
        var badSourceOrTarget = false;
        for(var j = 0; j < fieldsLength; j++){
          
          var field = fields[j];
          var val = data[field];
          
          if( val == null || val === '' ){
            // can't create if source or target is not defined properly
            $$.util.error('Can not create edge `' + id + '` with unspecified ' + field);
            badSourceOrTarget = true;
          } else if( cy.getElementById(val).empty() ){ 
            // can't create edge if one of its nodes doesn't exist
            $$.util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
            badSourceOrTarget = true;
          }
        }

        if( badSourceOrTarget ){ continue; } // can't create this
        
        var src = cy.getElementById( data.source );
        var tgt = cy.getElementById( data.target );

        src._private.edges.push( edge );
        tgt._private.edges.push( edge );

        edge._private.source = src;
        edge._private.target = tgt;

      } // if is edge
       
      // create mock ids map for element so it can be used like collections
      _private.ids = {};
      _private.ids[ id ] = ele;

      _private.removed = false;
      cy.addToPool( ele );
      
      restored.push( ele );
    } // for each element

    // do compound node sanity checks
    for( var i = 0; i < numNodes; i++ ){ // each node 
      var node = elements[i];
      var data = node._private.data;

      var parentId = node._private.data.parent;
      var specifiedParent = parentId != null;

      if( specifiedParent ){
        var parent = cy.getElementById( parentId );

        if( parent.empty() ){
          // non-existant parent; just remove it
          data.parent = undefined;
        } else {
          var selfAsParent = false;
          var ancestor = parent;
          while( !ancestor.empty() ){
            if( node.same(ancestor) ){
              // mark self as parent and remove from data
              selfAsParent = true;
              data.parent = undefined; // remove parent reference

              // exit or we loop forever
              break;
            }

            ancestor = ancestor.parent();
          }

          if( !selfAsParent ){
            // connect with children
            parent[0]._private.children.push( node );
            node._private.parent = parent[0];

            // let the core know we have a compound graph
            cy._private.hasCompoundNodes = true;
          }
        } // else
      } // if specified parent
    } // for each node
    
    restored = new $$.Collection( cy, restored );
    if( restored.length > 0 ){

      var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
      toUpdateStyle.updateStyle( notifyRenderer );

      if( notifyRenderer ){
        restored.rtrigger('add');
      } else {
        restored.trigger('add');
      }
    }
    
    return self; // chainability
  };
  
  $$.elesfn.removed = function(){
    var ele = this[0];
    return ele && ele._private.removed;
  };

  $$.elesfn.inside = function(){
    var ele = this[0];
    return ele && !ele._private.removed;
  };

  $$.elesfn.remove = function( notifyRenderer ){
    var self = this;
    var removed = [];
    var elesToRemove = [];
    var elesToRemoveIds = {};
    var cy = self._private.cy;
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }
    
    // add connected edges
    function addConnectedEdges(node){
      var edges = node._private.edges; 
      for( var i = 0; i < edges.length; i++ ){
        add( edges[i] );
      }
    }
    

    // add descendant nodes
    function addChildren(node){
      var children = node._private.children;
      
      for( var i = 0; i < children.length; i++ ){
        add( children[i] );
      }
    }

    function add( ele ){
      var alreadyAdded =  elesToRemoveIds[ ele.id() ];
      if( alreadyAdded ){
        return;
      } else {
        elesToRemoveIds[ ele.id() ] = true;
      }

      if( ele.isNode() ){
        elesToRemove.push( ele ); // nodes are removed last

        addConnectedEdges( ele );
        addChildren( ele );
      } else {
        elesToRemove.unshift( ele ); // edges are removed first
      }
    }

    // make the list of elements to remove
    // (may be removing more than specified due to connected edges etc)

    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];

      add( ele );
    }
    
    function removeEdgeRef(node, edge){
      var connectedEdges = node._private.edges;
      for( var j = 0; j < connectedEdges.length; j++ ){
        var connectedEdge = connectedEdges[j];
        
        if( edge === connectedEdge ){
          connectedEdges.splice( j, 1 );
          break;
        }
      }
    }

    function removeChildRef(parent, ele){
      ele = ele[0];
      parent = parent[0];
      var children = parent._private.children;

      for( var j = 0; j < children.length; j++ ){
        if( children[j][0] === ele[0] ){
          children.splice(j, 1);
          break;
        }
      }
    }

    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];

      // mark as removed
      ele._private.removed = true;

      // remove from core pool
      cy.removeFromPool( ele );

      // add to list of removed elements
      removed.push( ele );

      if( ele.isEdge() ){ // remove references to this edge in its connected nodes
        var src = ele.source()[0];
        var tgt = ele.target()[0];

        removeEdgeRef( src, ele );
        removeEdgeRef( tgt, ele );

      } else { // remove reference to parent 
        var parent = ele.parent();

        if( parent.length !== 0 ){
          removeChildRef(parent, ele);
        }
      }
    }

    // check to see if we have a compound graph or not
    var elesStillInside = cy._private.elements;
    cy._private.hasCompoundNodes = false;
    for( var i = 0; i < elesStillInside.length; i++ ){
      var ele = elesStillInside[i];

      if( ele.isParent() ){
        cy._private.hasCompoundNodes = true;
        break;
      }
    }

    var removedElements = new $$.Collection( this.cy(), removed );
    if( removedElements.size() > 0 ){
      // must manually notify since trigger won't do this automatically once removed
      
      if( notifyRenderer ){
        this.cy().notify({
          type: 'remove',
          collection: removedElements
        });
      }
      
      removedElements.trigger('remove');
    }

    // check for empty remaining parent nodes
    var checkedParentId = {};
    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];
      var isNode = ele._private.group === 'nodes';
      var parentId = ele._private.data.parent;

      if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){
        checkedParentId[ parentId ] = true;
        var parent = cy.getElementById( parentId );

        if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){
          parent.updateStyle();
        }
      }
    }

    return this;
  };

  $$.elesfn.move = function( struct ){
    var cy = this._private.cy;

    if( struct.source !== undefined || struct.target !== undefined ){
      var srcId = struct.source;
      var tgtId = struct.target;
      var srcExists = cy.getElementById( srcId ).length > 0;
      var tgtExists = cy.getElementById( tgtId ).length > 0;

      if( srcExists || tgtExists ){
        var jsons = this.jsons();

        this.remove();

        for( var i = 0; i < jsons.length; i++ ){
          var json = jsons[i];

          if( json.group === 'edges' ){
            if( srcExists ){ json.data.source = srcId; }
            if( tgtExists ){ json.data.target = tgtId; }
          }
        }

        return cy.add( jsons );
      }
 
    } else if( struct.parent !== undefined ){ // move node to new parent
      var parentId = struct.parent;
      var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;
    
      if( parentExists ){
        var jsons = this.jsons();
        var descs = this.descendants();
        var descsEtc = descs.merge( descs.add(this).connectedEdges() );

        this.remove(); // NB: also removes descendants and their connected edges

        for( var i = 0; i < this.length; i++ ){
          var json = jsons[i];

          if( json.group === 'nodes' ){
            json.data.parent = parentId === null ? undefined : parentId;
          }
        }
      }

      return cy.add( jsons ).merge( descsEtc.restore() );
    }

    return this; // if nothing done
  };
  
})( cytoscape );


;(function($$){ 'use strict';

  // search, spanning trees, etc
  $$.fn.eles({

    // std functional ele first callback style
    stdBreadthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.breadthFirstSearch( options );
    },

    // do a breadth first search from the nodes in the collection
    // from pseudocode on wikipedia
    breadthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }

      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var Q = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var V = {};
      var j = 0;
      var found;
      var nodes = this.nodes();
      var edges = this.edges();

      // enqueue v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          Q.unshift( v[i] );
          V[ v[i].id() ] = true; 

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( Q.length !== 0 ){
        var v = Q.shift();
        var depth = id2depth[ v.id() ];
        var prevEdge = connectedBy[ v.id() ];
        var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
        var ret;

        if( std ){
          ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
        } else {
          ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
        }

        if( ret === true ){
          found = v;
          break;
        }

        if( ret === false ){
          break;
        }

        var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
        for( var i = 0; i < vwEdges.length; i++ ){
          var e = vwEdges[i];
          var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

          if( w.length !== 0 && !V[ w.id() ] ){
            w = w[0];

            Q.push( w );
            V[ w.id() ] = true;

            id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

            connectedNodes.push( w );
            connectedBy[ w.id() ] = e;
          }
        }
        
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // std functional ele first callback style
    stdDepthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.depthFirstSearch( options );
    },

    // do a depth first search on the nodes in the collection
    // from pseudocode on wikipedia (iterative impl)
    depthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }
      
      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var S = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var discovered = {};
      var j = 0;
      var found;
      var edges = this.edges();
      var nodes = this.nodes();

      // push v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          S.push( v[i] );

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( S.length !== 0 ){
        var v = S.pop();

        if( !discovered[ v.id() ] ){
          discovered[ v.id() ] = true;

          var depth = id2depth[ v.id() ];
          var prevEdge = connectedBy[ v.id() ];
          var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
          var ret;

          if( std ){
            ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
          } else {
            ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
          }

          if( ret === true ){
            found = v;
            break;
          }

          if( ret === false ){
            break;
          }

          var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
          
          for( var i = 0; i < vwEdges.length; i++ ){
            var e = vwEdges[i];
            var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

            if( w.length !== 0 && !discovered[ w.id() ] ){
              w = w[0];

              S.push( w );

              id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

              connectedNodes.push( w );
              connectedBy[ w.id() ] = e;
            }
          }
        }
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
    // implemented from pseudocode from wikipedia
    kruskal: function( weightFn ){
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      function findSet(ele){
        for( var i = 0; i < forest.length; i++ ){
          var eles = forest[i];

          if( eles.anySame(ele) ){
            return {
              eles: eles,
              index: i
            };
          }
        }
      }

      var A = new $$.Collection(this._private.cy, []);
      var forest = [];
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        forest.push( nodes[i].collection() );
      }

      var edges = this.edges();
      var S = edges.toArray().sort(function(a, b){
        var weightA = weightFn.call(a, a);
        var weightB = weightFn.call(b, b);

        return weightA - weightB;
      });

      for(var i = 0; i < S.length; i++){
        var edge = S[i];
        var u = edge.source()[0];
        var v = edge.target()[0];
        var setU = findSet(u);
        var setV = findSet(v);

        if( setU.index !== setV.index ){
          A = A.add( edge );

          // combine forests for u and v
          forest[ setU.index ] = setU.eles.add( setV.eles );
          forest.splice( setV.index, 1 );
        }
      }

      return nodes.add( A );

    },

    dijkstra: function( root, weightFn, directed ){
      var options;
      if( $$.is.plainObject(root) && !$$.is.elementOrCollection(root) ){
        options = root;
        root = options.root;
        weightFn = options.weight;
        directed = options.directed;
      }

      var cy = this._private.cy;
      directed = !$$.is.fn(weightFn) ? weightFn : directed;
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      var source = $$.is.string(root) ? this.filter(root).eq(0) : root.eq(0);
      var dist = {};
      var prev = {};
      var knownDist = {};

      var edges = this.edges().filter(function(){ return !this.isLoop(); });
      var nodes = this.nodes();
      var Q = [];

      for( var i = 0; i < nodes.length; i++ ){
        dist[ nodes[i].id() ] = nodes[i].same( source ) ? 0 : Infinity;
        Q.push( nodes[i] );
      }

      var valueFn = function(node) {
        return dist[ node.id() ];
      };
      
      Q = new $$.Collection(cy, Q);
    
      var heap = $$.Minheap(cy, Q, valueFn);
    
      var distBetween = function(u, v){
        var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);
        var smallestDistance = Infinity;
        var smallestEdge;

        for( var i = 0; i < uvs.length; i++ ){
          var edge = uvs[i];
          var weight = weightFn.apply( edge, [edge] );

          if( weight < smallestDistance || !smallestEdge ){
            smallestDistance = weight;
            smallestEdge = edge;
          }
        }

        return {
          edge: smallestEdge,
          dist: smallestDistance
        };
      };

      while(heap.size() > 0){
        var smallestEl = heap.pop(),
        smalletsDist = smallestEl.value,
        uid = smallestEl.id,
        u = cy.getElementById(uid);
    
        knownDist[uid] = smalletsDist;
      
        if( smalletsDist === Math.Infinite ){
          break;
        }

        var neighbors = u.neighborhood().intersect(nodes);
        for( var i = 0; i < neighbors.length; i++ ){
          var v = neighbors[i];
          var vid = v.id();
          var vDist = distBetween(u, v);

          var alt = smalletsDist + vDist.dist;

          if( alt < heap.getValueById(vid) ){
            heap.edit(vid, alt);
            prev[ vid ] = {
              node: u,
              edge: vDist.edge
            };
          }
        } // for 
      } // while

      return {
        distanceTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node).eq(0) : node.eq(0);

          return knownDist[ target.id() ];
        },

        pathTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node).eq(0) : node.eq(0);
          var S = [];
          var u = target;

          if( target.length > 0 ){
            S.unshift( target );

            while( prev[ u.id() ] ){
              var p = prev[ u.id() ];

              S.unshift( p.edge );
              S.unshift( p.node );

              u = p.node;
            }
          }

          return new $$.Collection( cy, S );
        }
      };
    }  
  });

  // nice, short mathemathical alias
  $$.elesfn.bfs = $$.elesfn.breadthFirstSearch;
  $$.elesfn.dfs = $$.elesfn.depthFirstSearch;
  $$.elesfn.stdBfs = $$.elesfn.stdBreadthFirstSearch;
  $$.elesfn.stdDfs = $$.elesfn.stdDepthFirstSearch;
  
})( cytoscape );
;(function($$) { 
  'use strict';

  // Additional graph analysis algorithms
  $$.fn.eles({

    // Implemented from pseudocode from wikipedia

    // options => options object
    //   root // starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   heuristic: function( node ){} // specifies heuristic value for `node`/`this`
    //   directed // default false
    //   goal // target node (either element or selector string). Mandatory.

    // retObj => returned object by function
    //   found : true/false // whether a path from root to goal has been found
    //   distance // Distance for the shortest path from root to goal
    //   path // Array of ids of nodes in shortest path
    aStar: function(options) {
      options = options || {};

      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };

      // Reconstructs the path from Start to End, acumulating the result in pathAcum
      var reconstructPath = function(start, end, cameFromMap, pathAcum) {
        // Base case
        if (start == end) {
          pathAcum.push( cy.getElementById(end) );
          return pathAcum;
        }
        
        if (end in cameFromMap) {
          // We know which node is before the last one
          var previous = cameFromMap[end];
          var previousEdge = cameFromEdge[end];

          pathAcum.push( cy.getElementById(end) );
          pathAcum.push( cy.getElementById(previousEdge) );


          return reconstructPath(start, 
                       previous, 
                       cameFromMap, 
                       pathAcum);
        }

        // We should not reach here!
        return undefined;       
      };

      // Returns the index of the element in openSet which has minimum fScore
      var findMin = function(openSet, fScore) {
        if (openSet.length === 0) {
          // Should never be the case
          return undefined;
        }
        var minPos = 0;
        var tempScore = fScore[openSet[0]];
        for (var i = 1; i < openSet.length; i++) {
          var s = fScore[openSet[i]];
          if (s < tempScore) {
            tempScore = s;
            minPos = i;
          }
        }
        return minPos;
      };

      // Parse options
      // debug - optional
      if (options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }

      logDebug("Starting aStar..."); 
      var cy = this._private.cy;

      // root - mandatory!
      if (options != null && options.root != null) {        
        var source = $$.is.string(options.root) ? 
          // use it as a selector, e.g. "#rootID
          this.filter(options.root)[0] : 
          options.root[0];
        logDebug("Source node: %s", source.id()); 
      } else {
        return undefined;
      }
      
      // goal - mandatory!
      if (options.goal != null) {       
        var target = $$.is.string(options.goal) ? 
          // use it as a selector, e.g. "#goalID
          this.filter(options.goal)[0] : 
          options.goal[0];
        logDebug("Target node: %s", target.id()); 
      } else {
        return undefined;
      }

      // Heuristic function - optional
      if (options.heuristic != null && $$.is.fn(options.heuristic)) {       
        var heuristic = options.heuristic;
      } else {
        var heuristic = function(){ return 0; }; // use constant if unspecified
        // $$.util.error("Missing required parameter (heuristic)! Aborting.");
        // return;
      }

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var closedSet = [];
      var openSet = [source.id()];
      var cameFrom = {};
      var cameFromEdge = {};
      var gScore = {};
      var fScore = {};

      gScore[source.id()] = 0;
      fScore[source.id()] = heuristic(source);
      
      var edges = this.edges().not(':loop');
      var nodes = this.nodes();

      // Counter
      var steps = 0;

      // Main loop 
      while (openSet.length > 0) {
        var minPos = findMin(openSet, fScore);
        var cMin = this.filter("#" + openSet[minPos])[0];
        steps++;

        logDebug("\nStep: %s", steps);
        logDebug("Processing node: %s, fScore = %s", cMin.id(), fScore[cMin.id()]);
        
        // If we've found our goal, then we are done
        if (cMin.id() == target.id()) {
          logDebug("Found goal node!");
          var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);
          rPath.reverse();
          logDebug("Path: %s", rPath);
          return {
            found : true,
            distance : gScore[cMin.id()],
            path : new $$.Collection(cy, rPath),
            steps : steps
          };          
        }
        
        // Add cMin to processed nodes
        closedSet.push(cMin.id());
        // Remove cMin from boundary nodes
        openSet.splice(minPos, 1);
        logDebug("Added node to closedSet, removed from openSet.");
        logDebug("Processing neighbors...");

        // Update scores for neighbors of cMin
        // Take into account if graph is directed or not
        var vwEdges = cMin.connectedEdges(directed ? '[source = "' + cMin.id() + '"]' 
                         : undefined).intersect(edges);         
        for (var i = 0; i < vwEdges.length; i++) {
          var e = vwEdges[i];
          var w = e.connectedNodes('[id != "' + cMin.id() + '"]').intersect(nodes);

          logDebug("   processing neighbor: %s", w.id());
          // if node is in closedSet, ignore it
          if (closedSet.indexOf(w.id()) != -1) {
            logDebug("   already in closedSet, ignoring it.");
            continue;
          }
          
          // New tentative score for node w
          var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);
          logDebug("   tentative gScore: %d", tempScore);

          // Update gScore for node w if:
          //   w not present in openSet
          // OR
          //   tentative gScore is less than previous value

          // w not in openSet
          if (openSet.indexOf(w.id()) == -1) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            openSet.push(w.id()); // Add node to openSet
            cameFrom[w.id()] = cMin.id();
            cameFromEdge[w.id()] = e.id();
            logDebug("   not in openSet, adding it. ");
            logDebug("   fScore(%s) = %s", w.id(), tempScore);
            continue;
          }
          // w already in openSet, but with greater gScore
          if (tempScore < gScore[w.id()]) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            cameFrom[w.id()] = cMin.id();
            logDebug("   better score, replacing gScore. ");
            logDebug("   fScore(%s) = %s", w.id(), tempScore);
          }

        } // End of neighbors update

      } // End of main loop

      // If we've reached here, then we've not reached our goal
      logDebug("Reached end of computation without finding our goal");
      return {
        found : false,
        distance : undefined,
        path : undefined,
        steps : steps
      };
    }, // aStar()


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(fromId, toId) // Returns the shortest path from node with ID "fromID" to node with ID "toId", as an array of node IDs
    //   distanceTo: function(fromId, toId) // Returns the distance of the shortest path from node with ID "fromID" to node with ID "toId"
    floydWarshall: function(options) {
      options = options || {};

      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };

      // Parse options
      // debug - optional
      if (options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }
      logDebug("Starting floydWarshall..."); 

      var cy = this._private.cy;

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var edges = this.edges().not(':loop');
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initialize distance matrix
      var dist = [];
      for (var i = 0; i < numNodes; i++) {
        var newRow = new Array(numNodes);
        for (var j = 0; j < numNodes; j++) {
          if (i == j) {
            newRow[j] = 0;
          } else {
            newRow[j] = Infinity;
          }
        }
        dist.push(newRow);
      }           

      // Initialize matrix used for path reconstruction
      // Initialize distance matrix
      var next = [];
      var edgeNext = [];

      var initMatrix = function(next){
        for (var i = 0; i < numNodes; i++) {
          var newRow = new Array(numNodes);
          for (var j = 0; j < numNodes; j++) {
            newRow[j] = undefined;
          }
          next.push(newRow);
        }
      };

      initMatrix(next);
      initMatrix(edgeNext);
      
      // Process edges
      for (var i = 0; i < edges.length ; i++) {     
        var sourceIndex = id2position[edges[i].source().id()];
        var targetIndex = id2position[edges[i].target().id()];    
        var weight = weightFn.apply(edges[i], [edges[i]]);
        
        // Check if already process another edge between same 2 nodes
        if (dist[sourceIndex][targetIndex] > weight) {
          dist[sourceIndex][targetIndex] = weight;
          next[sourceIndex][targetIndex] = targetIndex;
          edgeNext[sourceIndex][targetIndex] = edges[i];
        }
      }

      // If undirected graph, process 'reversed' edges
      if (!directed) {
        for (var i = 0; i < edges.length ; i++) {     
          var sourceIndex = id2position[edges[i].target().id()];    
          var targetIndex = id2position[edges[i].source().id()];
          var weight = weightFn.apply(edges[i], [edges[i]]);
          
          // Check if already process another edge between same 2 nodes
          if (dist[sourceIndex][targetIndex] > weight) {
            dist[sourceIndex][targetIndex] = weight;
            next[sourceIndex][targetIndex] = targetIndex;
            edgeNext[sourceIndex][targetIndex] = edges[i];
          }
        }
      }

      // Main loop
      for (var k = 0; k < numNodes; k++) {
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {            
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
              dist[i][j] = dist[i][k] + dist[k][j];
              next[i][j] = next[i][k];
            }
          }
        }
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }

      var res = {
        distance: function(from, to) {
          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return dist[id2position[fromId]][id2position[toId]];
        },

        path: function(from, to) {
          var reconstructPathAux = function(from, to, next, position2id, edgeNext) {
            if (from === to) {
              return cy.getElementById( position2id[from] );
            }
            if (next[from][to] === undefined) {
              return undefined;
            }

            var path = [ cy.getElementById(position2id[from]) ];
            var prev = from;
            while (from !== to) {
              prev = from;
              from = next[from][to];

              var edge = edgeNext[prev][from];
              path.push( edge );

              path.push( cy.getElementById(position2id[from]) );
            }
            return path;
          };

          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          
          var pathArr = reconstructPathAux(id2position[fromId], 
                        id2position[toId], 
                        next,
                        position2id,
                        edgeNext);

          return new $$.Collection( cy, pathArr );
        },
      };

      return res;

    }, // floydWarshall


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   root: starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(toId) // Returns the shortest path from root node to node with ID "toId", as an array of node IDs
    //   distanceTo: function(toId) // Returns the distance of the shortest path from root node to node with ID "toId"
    //   hasNegativeWeightCycle: true/false (if true, pathTo and distanceTo will be undefined)
    bellmanFord: function(options) {
      options = options || {};

      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };

      // Parse options
      // debug - optional
      if (options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }
      logDebug("Starting bellmanFord..."); 

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // root - mandatory!
      if (options.root != null) {       
        if ($$.is.string(options.root)) {
          // use it as a selector, e.g. "#rootID
          var source = this.filter(options.root)[0];
        } else {
          var source = options.root[0];
        }
        logDebug("Source node: %s", source.id()); 
      } else {
        $$.util.error("options.root required");
        return undefined;
      }

      var cy = this._private.cy;
      var edges = this.edges().not(':loop');
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initializations
      var cost = [];
      var predecessor = [];
      var predEdge = [];
      
      for (var i = 0; i < numNodes; i++) {
        if (nodes[i].id() === source.id()) {
          cost[i] = 0;
        } else {
          cost[i] = Infinity;
        } 
        predecessor[i] = undefined;
      }
      
      // Edges relaxation      
      var flag = false;
      for (var i = 1; i < numNodes; i++) {
        flag = false;
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          var temp = cost[sourceIndex] + weight;
          if (temp < cost[targetIndex]) {
            cost[targetIndex] = temp;
            predecessor[targetIndex] = sourceIndex;
            predEdge[targetIndex] = edges[e];
            flag = true;
          }

          // If undirected graph, we need to take into account the 'reverse' edge
          if (!directed) {
            var temp = cost[targetIndex] + weight;
            if (temp < cost[sourceIndex]) {
              cost[sourceIndex] = temp;
              predecessor[sourceIndex] = targetIndex;
              predEdge[sourceIndex] = edges[e];
              flag = true;
            }
          }
        }

        if (!flag) {
          break;
        }
      }      
            
      if (flag) {
        // Check for negative weight cycles
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          if (cost[sourceIndex] + weight < cost[targetIndex]) {
            $$.util.error("Error: graph contains a negative weigth cycle!"); 
            return { pathTo: undefined,
                 distanceTo: undefined,
                 hasNegativeWeightCycle: true};
          }
        }     
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }
      
      
      var res = {       
        distanceTo : function(to) {
          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return cost[id2position[toId]];
        }, 

        pathTo : function(to) {

          var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
            for(;;){
              // Add toId to path
              acumPath.push( cy.getElementById(position2id[toPos]) );
              acumPath.push( predEdge[toPos] );

              if (fromPos === toPos) {
                // reached starting node
                return acumPath;
              }

              // If no path exists, discart acumulated path and return undefined
              var predPos = predecessor[toPos];
              if (typeof predPos === "undefined") {
                return undefined;
              }

              toPos = predPos;
            }

          };

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          var path = [];

          // This returns a reversed path 
          var res =  reconstructPathAux(predecessor, 
                        id2position[source.id()],
                        id2position[toId], 
                        position2id, 
                        path,
                        predEdge);

          // Get it in the correct order and return it
          if (res != null) {
            res.reverse();
          }

          return new $$.Collection(cy, res);                       
        }, 

        hasNegativeWeightCycle: false
      };

      return res;

    }, // bellmanFord


    // Computes the minimum cut of an undirected graph
    // Returns the correct answer with high probability
    // options => options object
    // 
    // retObj => returned object by function
    //   cut : list of IDs of edges in the cut,
    //   partition1: list of IDs of nodes in one partition
    //   partition2: list of IDs of nodes in the other partition
    kargerStein: function(options) {
      options = options || {};
      
      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };

      // Function which colapses 2 (meta) nodes into one
      // Updates the remaining edge lists
      // Receives as a paramater the edge which causes the collapse
      var colapse = function(edgeIndex, nodeMap, remainingEdges) {
        var edgeInfo = remainingEdges[edgeIndex];
        var sourceIn = edgeInfo[1];
        var targetIn = edgeInfo[2];
        var partition1 = nodeMap[sourceIn];
        var partition2 = nodeMap[targetIn];

        // Delete all edges between partition1 and partition2
        var newEdges = remainingEdges.filter(function(edge) {
          if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
            return false;
          }
          if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
            return false;
          }
          return true;
        });
        
        // All edges pointing to partition2 should now point to partition1
        for (var i = 0; i < newEdges.length; i++) {
          var edge = newEdges[i];
          if (edge[1] === partition2) { // Check source
            newEdges[i] = edge.slice(0);
            newEdges[i][1] = partition1;
          } else if (edge[2] === partition2) { // Check target
            newEdges[i] = edge.slice(0);
            newEdges[i][2] = partition1;
          }
        } 
        
        // Move all nodes from partition2 to partition1
        for (var i = 0; i < nodeMap.length; i++) {
          if (nodeMap[i] === partition2) {
            nodeMap[i] = partition1;
          }
        }
        
        return newEdges;
      };


      // Contracts a graph until we reach a certain number of meta nodes
      var contractUntil = function(metaNodeMap, 
                     remainingEdges,
                     size, 
                     sizeLimit) {
        // Stop condition
        if (size <= sizeLimit) {
          return remainingEdges;
        }
        
        // Choose an edge randomly
        var edgeIndex = Math.floor((Math.random() * remainingEdges.length));

        // Colapse graph based on edge
        var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);
        
        return contractUntil(metaNodeMap, 
                   newEdges, 
                   size - 1, 
                   sizeLimit);        
      };


      // Parse options
      // debug - optional
      if (options != null && options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }
      logDebug("Starting kargerStein..."); 

      var cy = this._private.cy;
      var edges = this.edges().not(':loop');
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;
      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
      var stopSize = Math.floor(numNodes / Math.sqrt(2));

      if (numNodes < 2) {
        $$.util.error("At least 2 nodes are required for KargerSteing algorithm!"); 
        return undefined;
      }

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Now store edge destination as indexes
      // Format for each edge (edge index, source node index, target node index)
      var edgeIndexes = [];
      for (var i = 0; i < numEdges; i++) {
        var e = edges[i];
        edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
      }

      // We will store the best cut found here
      var minCutSize = Infinity;
      var minCut;     

      // Initial meta node partition
      var originalMetaNode = [];
      for (var i = 0; i < numNodes; i++) {
        originalMetaNode.push(i);
      }

      // Main loop
      for (var iter = 0; iter <= numIter; iter++) {
        // Create new meta node partition
        var metaNodeMap = originalMetaNode.slice(0);

        // Contract until stop point (stopSize nodes)
        var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);
        
        // Create a copy of the colapsed nodes state
        var metaNodeMap2 = metaNodeMap.slice(0);

        // Run 2 iterations starting in the stop state
        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
        var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

        // Is any of the 2 results the best cut so far?
        if (res1.length <= res2.length && res1.length < minCutSize) {
          minCutSize = res1.length;
          minCut = [res1, metaNodeMap];
        } else if (res2.length <= res1.length && res2.length < minCutSize) {
          minCutSize = res2.length;
          minCut = [res2, metaNodeMap2];
        }
      } // end of main loop

      
      // Construct result
      var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });
      var partition1 = [];
      var partition2 = [];

      // traverse metaNodeMap for best cut
      var witnessNodePartition = minCut[1][0];
      for (var i = 0; i < minCut[1].length; i++) { 
        var partitionId = minCut[1][i]; 
        if (partitionId === witnessNodePartition) {
          partition1.push(nodes[i]);
        } else {
          partition2.push(nodes[i]);
        }       
      }
      
      var ret = {
        cut: new $$.Collection(cy, resEdges),
        partition1: new $$.Collection(cy, partition1),
        partition2: new $$.Collection(cy, partition2)
      };
      
      return ret;
    },


    // 
    // options => options object
    //   dampingFactor: optional
    //   precision: optional
    //   iterations : optional
    // retObj => returned object by function
    //  rank : function that returns the pageRank of a given node (object or selector string)
    pageRank: function(options) {
      options = options || {};
      
      var normalizeVector = function(vector) {
        var length = vector.length;

        // First, get sum of all elements
        var total = 0; 
        for (var i = 0; i < length; i++) {
          total += vector[i];
        }

        // Now, divide each by the sum of all elements
        for (var i = 0; i < length; i++) {
          vector[i] = vector[i] / total;
        }
      };
      
      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };
      
      // Parse options
      // debug - optional
      if (options != null && 
        options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }
      logDebug("Starting pageRank..."); 

      // dampingFactor - optional
      if (options != null && 
        options.dampingfactor != null) {
        var dampingFactor = options.dampingFactor;
      } else {
        var dampingFactor = 0.8; // Default damping factor
      }

      // desired precision - optional
      if (options != null && 
        options.precision != null) {
        var epsilon = options.precision;
      } else {
        var epsilon = 0.000001; // Default precision
      }

      // Max number of iterations - optional
      if (options != null && 
        options.iterations != null) {
        var numIter = options.iterations;
      } else {
        var numIter = 200; // Default number of iterations
      }

      // Weight function - optional
      if (options != null && 
        options.weight != null && 
        $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;}; 
      }

      var cy = this._private.cy;
      var edges = this.edges().not(':loop');
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Construct transposed adjacency matrix
      // First lets have a zeroed matrix of the right size
      // We'll also keep track of the sum of each column
      var matrix = [];
      var columnSum = [];
      var additionalProb = (1 - dampingFactor) / numNodes;

      // Create null matric
      for (var i = 0; i < numNodes; i++) { 
        var newRow = [];
        for (var j = 0; j < numNodes; j++) {
          newRow.push(0.0);
        }
        matrix.push(newRow);
        columnSum.push(0.0);
      }

      // Now, process edges
      for (var i = 0; i < numEdges; i++) {
        var edge = edges[i];
        var s = id2position[edge.source().id()];
        var t = id2position[edge.target().id()];
        var w = weightFn.apply(edge, [edge]);
        
        // Update matrix
        matrix[t][s] += w;

        // Update column sum
        columnSum[s] += w; 
      }

      // Add additional probability based on damping factor
      // Also, take into account columns that have sum = 0
      var p = 1.0 / numNodes + additionalProb; // Shorthand
      // Traverse matrix, column by column
      for (var j = 0; j < numNodes; j++) { 
        if (columnSum[j] === 0) {
          // No 'links' out from node jth, assume equal probability for each possible node
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = p;
          }
        } else {
          // Node jth has outgoing link, compute normalized probabilities
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
          }         
        }
      }

      // Compute dominant eigenvector using power method
      var eigenvector = [];
      var nullVector = [];
      var previous;

      // Start with a vector of all 1's
      // Also, initialize a null vector which will be used as shorthand
      for (var i = 0; i < numNodes; i++) {
        eigenvector.push(1.0);
        nullVector.push(0.0);
      }
            
      for (var iter = 0; iter < numIter; iter++) {
        // New array with all 0's
        var temp = nullVector.slice(0);
        
        // Multiply matrix with previous result
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {        
            temp[i] += matrix[i][j] * eigenvector[j];
          }
        }

        normalizeVector(temp);
        previous = eigenvector;
        eigenvector = temp;

        var diff = 0;
        // Compute difference (squared module) of both vectors
        for (var i = 0; i < numNodes; i++) {
          diff += Math.pow(previous[i] - eigenvector[i], 2);
        }
        
        // If difference is less than the desired threshold, stop iterating
        if (diff < epsilon) {
          logDebug("Stoped at iteration %s", iter);
          break;
        }
      }
            
      logDebug("Result:\n" + eigenvector);

      // Construct result
      var res = {
        rank : function(node) {
          if ($$.is.string(node)) {
            // is a selector string
            var nodeId = (cy.filter(node)[0]).id();
          } else {
            // is a node object
            var nodeId = node.id();
          }
          return eigenvector[id2position[nodeId]];
        }
      };


      return res;
    } // pageRank

  }); // $$.fn.eles


}) (cytoscape);
;(function( $$ ){ 'use strict';

  $$.fn.eles({
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop()
  });
  
})( cytoscape );  

;(function( $$ ){ 'use strict';
  
  $$.fn.eles({
    classes: function(opts){
      var eles = this;
      var changed = [];
      var fn;

      if( $$.is.fn(opts) ){
        fn = opts;

      } else if( !$$.is.plainObject(opts) ){
        return this; // needs opts or fn
      } 

      for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        var eleChanged = false;

        opts = fn ? fn.apply(ele, [i, ele]) : opts;

        // add classes
        if( opts.add ){ for( var j = 0; j < opts.add.length; j++ ){
          var cls = opts.add[j];
          var hasClass = ele._private.classes[cls];

          ele._private.classes[cls] = true;

          if( !hasClass && !eleChanged ){
            changed.push( ele );
            eleChanged = true;
          }
        } }

        // remove classes
        if( opts.remove ){ for( var j = 0; j < opts.remove.length; j++ ){
          var cls = opts.remove[j];
          var hasClass = ele._private.classes[cls];

          ele._private.classes[cls] = false;

          if( hasClass && !eleChanged ){
            changed.push( ele );
            eleChanged = true;
          }
        } }

        // toggle classes
        if( opts.toggle ){ for( var j = 0; j < opts.toggle.length; j++ ){
          var cls = opts.toggle[j];
          var hasClass = ele._private.classes[cls];

          ele._private.classes[cls] = !hasClass;

          if( !eleChanged ){
            changed.push( ele );
            eleChanged = true;
          }
        } }
      }

      if( changed.length > 0 ){
        new $$.Collection( this.cy(), changed )
          .updateStyle()
          .trigger('class')
        ;
      }

      return this;
    },

    addClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];
      
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[i];
        if( $$.is.emptyString(cls) ){ continue; }
        
        for( var j = 0; j < self.length; j++ ){
          var ele = self[j];
          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = true;

          if( !hasClass ){ // if didn't already have, add to list of changed
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    hasClass: function(className){
      var ele = this[0];
      return ( ele != null && ele._private.classes[className] ) ? true : false;
    },

    toggleClass: function(classesStr, toggle){
      var classes = classesStr.split(/\s+/);
      var self = this;
      var changed = []; // eles who had classes changed
      
      for( var i = 0, il = self.length; i < il; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];

          if( $$.is.emptyString(cls) ){ continue; }
          
          var hasClass = ele._private.classes[cls];
          var shouldAdd = toggle || (toggle === undefined && !hasClass);

          if( shouldAdd ){
            ele._private.classes[cls] = true;

            if( !hasClass ){ changed.push(ele); }
          } else { // then remove
            ele._private.classes[cls] = false;

            if( hasClass ){ changed.push(ele); }
          }

        } // for j classes
      } // for i eles
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    removeClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];

      for( var i = 0; i < self.length; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];
          if( !cls || cls === '' ){ continue; }

          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = undefined;

          if( hasClass ){ // then we changed its set of classes
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(self._private.cy, changed).updateStyle();
      }

      self.trigger('class');
      return self;
    },

    flashClass: function(classes, duration){
      var self = this;

      if( duration == null ){
        duration = 250;
      } else if( duration === 0 ){
        return self; // nothing to do really
      }

      self.addClass( classes );
      setTimeout(function(){
        self.removeClass( classes );
      }, duration);

      return self;
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    allAre: function( selector ){
      return this.filter(selector).length === this.length;
    },

    is: function( selector ){
      return this.filter(selector).length > 0;
    },

    some: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = fn.apply( thisArg, [ this[i], i, this ] );

        if( ret ){
          return true;
        }
      }

      return false;
    },

    every: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = fn.apply( thisArg, [ this[i], i, this ] );

        if( !ret ){
          return false;
        }
      }

      return true;
    },

    same: function( collection ){
      collection = this.cy().collection( collection );

      // cheap extra check
      if( this.length !== collection.length ){
        return false;
      }

      return this.intersect( collection ).length === this.length;
    },

    anySame: function( collection ){
      collection = this.cy().collection( collection );

      return this.intersect( collection ).length > 0;
    },

    allAreNeighbors: function( collection ){
      collection = this.cy().collection( collection );

      return this.neighborhood().intersect( collection ).length === collection.length;
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  // Compound functions
  /////////////////////

  $$.fn.eles({
    parent: function( selector ){
      var parents = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parent = cy.getElementById( ele._private.data.parent );

        if( parent.size() > 0 ){
          parents.push( parent );
        }
      }
      
      return new $$.Collection( cy, parents, { unique: true } ).filter( selector );
    },

    parents: function( selector ){
      var parents = [];

      var eles = this.parent();
      while( eles.nonempty() ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];
          parents.push( ele );
        }

        eles = eles.parent();
      }

      return new $$.Collection( this.cy(), parents, { unique: true } ).filter( selector );
    },

    commonAncestors: function( selector ){
      var ancestors;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parents = ele.parents();
        
        ancestors = ancestors || parents;

        ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
      }

      return ancestors.filter( selector );
    },

    orphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().empty();
      }).filter( selector );
    },

    nonorphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().nonempty();
      }).filter( selector );
    },

    children: function( selector ){
      var children = [];

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        children = children.concat( ele._private.children );
      }

      return new $$.Collection( this.cy(), children, { unique: true } ).filter( selector );
    },

    siblings: function( selector ){
      return this.parent().children().not( this ).filter( selector );
    },

    isParent: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.children.length !== 0;
      }
    },

    isChild: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.parent !== undefined && ele.parent().length !== 0;
      }
    },

    descendants: function( selector ){
      var elements = [];

      function add( eles ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          elements.push( ele );

          if( ele.children().nonempty() ){
            add( ele.children() );
          }
        }
      }

      add( this.children() );

      return new $$.Collection( this.cy(), elements, { unique: true } ).filter( selector );
    }
  });

  // aliases
  $$.elesfn.ancestors = $$.elesfn.parents;
  
})( cytoscape );
;(function($$){ 'use strict';
  
  var borderWidthMultiplier = 2 * 0.5;
  var borderWidthAdjustment = 0;

  $$.fn.eles({

    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      triggerEvent: false
    }),

    rscratch: $$.define.data({
      field: 'rscratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeRscratch: $$.define.removeData({
      field: 'rscratch',
      triggerEvent: false
    }),

    id: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.id;
      }
    },

    position: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: true,
      triggerFnName: 'rtrigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        var updatedEles = eles.updateCompoundBounds();
        updatedEles.rtrigger('position');
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    // position but no notification to renderer
    silentPosition: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: false,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        eles.updateCompoundBounds();
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    positions: function( pos, silent ){
      if( $$.is.plainObject(pos) ){
        this.position(pos);
        
      } else if( $$.is.fn(pos) ){
        var fn = pos;
        
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          var pos = fn.apply(ele, [i, ele]);

          if( pos && !ele.locked() ){
            var elePos = ele._private.position;
            elePos.x = pos.x;
            elePos.y = pos.y;
          }
        }

        var updatedEles = this.updateCompoundBounds();
        var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;

        if( silent ){
          toTrigger.trigger('position');
        } else {
          toTrigger.rtrigger('position');
        }
      }

      return this; // chaining
    },

    silentPositions: function( pos ){
      return this.positions( pos, true );
    },

    updateCompoundBounds: function(){
      var cy = this.cy();

      if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled

      var updated = [];

      function update( parent ){
        var children = parent.children();
        var style = parent._private.style;
        var bb = children.boundingBox({ includeLabels: false, includeEdges: false });
        var padding = {
          top: style['padding-top'].pxValue,
          bottom: style['padding-bottom'].pxValue,
          left: style['padding-left'].pxValue,
          right: style['padding-right'].pxValue
        };
        var pos = parent._private.position;
        var didUpdate = false;

        if( style['width'].value === 'auto' ){
          parent._private.autoWidth = bb.w + padding.left + padding.right;
          pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;
          didUpdate = true;
        }

        if( style['height'].value === 'auto' ){
          parent._private.autoHeight = bb.h + padding.top + padding.bottom;
          pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;
          didUpdate = true;
        }

        if( didUpdate ){
          updated.push( parent );
        }
      }

      // go up, level by level
      var eles = this.parent();
      while( eles.nonempty() ){

        // update each parent node in this level
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          update( ele );
        }

        // next level
        eles = eles.parent();
      }

      // return changed
      return new $$.Collection( cy, updated );
    },

    // get/set the rendered (i.e. on screen) positon of the element
    renderedPosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();
      var rpos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = rpos !== undefined || ( val !== undefined && $$.is.string(dim) );

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = ( val - pan[dim] )/zoom;
            } else if( rpos !== undefined ){ // set whole position
              ele._private.position = {
                x: ( rpos.x - pan.x ) /zoom,
                y: ( rpos.y - pan.y ) /zoom
              };
            }
          }

          this.rtrigger('position');
        } else { // getting
          var pos = ele._private.position;
          rpos = {
            x: pos.x * zoom + pan.x,
            y: pos.y * zoom + pan.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return rpos;
          } else { // then return the specified dimension
            return rpos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // get/set the position relative to the parent
    parentPosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var ppos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = ppos !== undefined || ( val !== undefined && $$.is.string(dim) );
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];
            var parent = hasCompoundNodes ? ele.parent() : null;
            var hasParent = parent && parent.length > 0;
            var relativeToParent = hasParent;

            if( hasParent ){
              parent = parent[0];
            }

            var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = val + origin[dim];
            } else if( ppos !== undefined ){ // set whole position
              ele._private.position = {
                x: ppos.x + origin.x,
                y: ppos.y + origin.y,
              };
            }
          }

          this.rtrigger('position');

        } else { // getting
          var pos = ele._private.position;
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          ppos = {
            x: pos.x - origin.x,
            y: pos.y - origin.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return ppos;
          } else { // then return the specified dimension
            return ppos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // convenience function to get a numerical value for the width of the node/edge
    width: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var w = ele._private.style.width;
          return w.strValue === 'auto' ? ele._private.autoWidth : w.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerWidth: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var style = ele._private.style;
          var width = style.width.strValue === 'auto' ? ele._private.autoWidth : style.width.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;

          return width + border;
        } else {
          return 1;
        }
      }
    },

    renderedWidth: function(){
      var ele = this[0];

      if( ele ){
        var width = ele.width();
        return width * this.cy().zoom();
      }
    },

    renderedOuterWidth: function(){
      var ele = this[0];

      if( ele ){
        var owidth = ele.outerWidth();
        return owidth * this.cy().zoom();
      }
    },

    // convenience function to get a numerical value for the height of the node
    height: function(){ 
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var h = ele._private.style.height;
          return h.strValue === 'auto' ? ele._private.autoHeight : h.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerHeight: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var style = ele._private.style;
          var height = style.height.strValue === 'auto' ? ele._private.autoHeight : style.height.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;
        } else {
          return 1;
        }

        return height + border;
      }
    },

    renderedHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var height = ele.height();
        return height * this.cy().zoom();
      }
    },

    renderedOuterHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var oheight = ele.outerHeight();
        return oheight * this.cy().zoom();
      }
    },

    renderedBoundingBox: function( options ){
      var bb = this.boundingBox( options );
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();

      var x1 = bb.x1 * zoom + pan.x;
      var x2 = bb.x2 * zoom + pan.x;
      var y1 = bb.y1 * zoom + pan.y;
      var y2 = bb.y2 * zoom + pan.y;

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    },

    // get the bounding box of the elements (in raw model position)
    boundingBox: function( options ){
      var eles = this;
      var cy = eles._private.cy;
      var cy_p = cy._private;
      var styleEnabled = cy_p.styleEnabled;

      options = options || {};

      var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;
      var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;
      var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;

      // recalculate projections etc
      if( styleEnabled ){
        cy_p.renderer.recalculateRenderedStyle( this );
      }

      var x1 = Infinity;
      var x2 = -Infinity;
      var y1 = Infinity;
      var y2 = -Infinity;

      // find bounds of elements
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var _p = ele._private;
        var display = styleEnabled ? _p.style['display'].value : 'element';
        var isNode = _p.group === 'nodes';
        var ex1, ex2, ey1, ey2, x, y;
        var includedEle = false;

        if( display === 'none' ){ continue; } // then ele doesn't take up space      

        if( isNode && includeNodes ){
          includedEle = true;

          var pos = _p.position;
          x = pos.x;
          y = pos.y;
          var w = ele.outerWidth();
          var halfW = w/2;
          var h = ele.outerHeight();
          var halfH = h/2;

          // handle node dimensions
          /////////////////////////

          ex1 = x - halfW;
          ex2 = x + halfW;
          ey1 = y - halfH;
          ey2 = y + halfH;

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

        } else if( ele.isEdge() && includeEdges ){ 
          includedEle = true;

          var n1pos = ele._private.source._private.position;
          var n2pos = ele._private.target._private.position;

          // handle edge dimensions (rough box estimate)
          //////////////////////////////////////////////

          var rstyle = ele._private.rstyle || {};

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;

          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

          // handle points along edge (sanity check)
          //////////////////////////////////////////

          if( styleEnabled ){
            var bpts = rstyle.bezierPts || [];

            var w = ele._private.style['width'].pxValue;
            var wHalf = w/2;

            for( var j = 0; j < bpts.length; j++ ){
              var bpt = bpts[j];

              ex1 = bpt.x - wHalf;
              ex2 = bpt.x + wHalf;
              ey1 = bpt.y - wHalf;
              ey2 = bpt.y + wHalf;

              x1 = ex1 < x1 ? ex1 : x1;
              x2 = ex2 > x2 ? ex2 : x2;
              y1 = ey1 < y1 ? ey1 : y1;
              y2 = ey2 > y2 ? ey2 : y2;
            }
          }

        } // edges

        // handle label dimensions
        //////////////////////////

        if( styleEnabled ){

          var style = ele._private.style;
          var rstyle = ele._private.rstyle;
          var label = style['content'].strValue;
          var fontSize = style['font-size'];
          var halign = style['text-halign'];
          var valign = style['text-valign'];
          var labelWidth = rstyle.labelWidth;
          var labelHeight = rstyle.labelHeight;
          var labelX = rstyle.labelX;
          var labelY = rstyle.labelY;

          if( includedEle && includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){
            var lh = labelHeight;
            var lw = labelWidth;
            var lx1, lx2, ly1, ly2;

            if( ele.isEdge() ){
              lx1 = labelX - lw/2;
              lx2 = labelX + lw/2;
              ly1 = labelY - lh/2;
              ly2 = labelY + lh/2;
            } else {
              switch( halign.value ){
                case 'left':
                  lx1 = labelX - lw;
                  lx2 = labelX;
                  break;

                case 'center':
                  lx1 = labelX - lw/2;
                  lx2 = labelX + lw/2;
                  break;

                case 'right':
                  lx1 = labelX;
                  lx2 = labelX + lw;
                  break;
              }

              switch( valign.value ){
                case 'top':
                  ly1 = labelY - lh;
                  ly2 = labelY;
                  break;

                case 'center':
                  ly1 = labelY - lh/2;
                  ly2 = labelY + lh/2;
                  break;

                case 'bottom':
                  ly1 = labelY;
                  ly2 = labelY + lh;
                  break;
              }
            }

            x1 = lx1 < x1 ? lx1 : x1;
            x2 = lx2 > x2 ? lx2 : x2;
            y1 = ly1 < y1 ? ly1 : y1;
            y2 = ly2 > y2 ? ly2 : y2;
          }
        } // style enabled
      } // for

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    }
  }); 

  // in case some users want to be explicit
  $$.elesfn.modelPosition = $$.elesfn.position;
  $$.elesfn.modelPositions = $$.elesfn.positions;
  
})( cytoscape );

;(function( $$ ){ 'use strict';
  
  // Regular degree functions (works on single element)
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeFunction(callback){
    return function( includeLoops ){
      var self = this;

      if( includeLoops === undefined ){
        includeLoops = true;
      }
      
      if( self.length === 0 ){ return; }

      if( self.isNode() && !self.removed() ){
        var degree = 0;
        var node = self[0];
        var connectedEdges = node._private.edges;

        for( var i = 0; i < connectedEdges.length; i++ ){
          var edge = connectedEdges[i];

          if( !includeLoops && edge.isLoop() ){
            continue;
          }

          degree += callback( node, edge );
        }
        
        return degree;
      } else {
        return;
      }
    };
  }
  
  $$.fn.eles({
    degree: defineDegreeFunction(function(node, edge){
      if( edge.source().same( edge.target() ) ){
        return 2;
      } else {
        return 1;
      }
    }),

    indegree: defineDegreeFunction(function(node, edge){
      if( edge.target().same(node) ){
        return 1;
      } else {
        return 0;
      }
    }),

    outdegree: defineDegreeFunction(function(node, edge){
      if( edge.source().same(node) ){
        return 1;
      } else {
        return 0;
      }
    })
  });
  
  
  // Collection degree stats
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeBoundsFunction(degreeFn, callback){
    return function( includeLoops ){
      var ret;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        var ele = nodes[i];
        var degree = ele[degreeFn]( includeLoops );
        if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){
          ret = degree;
        }
      }
      
      return ret;
    };
  }
  
  $$.fn.eles({
    minDegree: defineDegreeBoundsFunction('degree', function(degree, min){
      return degree < min;
    }),

    maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){
      return degree > max;
    }),

    minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){
      return degree < min;
    }),

    maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){
      return degree > max;
    }),

    minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){
      return degree < min;
    }),

    maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){
      return degree > max;
    })
  });
  
  $$.fn.eles({
    totalDegree: function( includeLoops ){
      var total = 0;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        total += nodes[i].degree( includeLoops );
      }

      return total;
    }
  });
  
})( cytoscape );

  
;(function($$){ 'use strict';
  
  // Functions for binding & triggering events
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger(), // .trigger( events [, extraParams] )

    rtrigger: function(event, extraParams){ // for internal use only
      if( this.length === 0 ){ return; } // empty collections don't need to notify anything

      // notify renderer
      this.cy().notify({
        type: event,
        collection: this
      });
      
      this.trigger(event, extraParams);
      return this;
    }
  });

  // aliases for those folks who like old stuff:
  $$.elesfn.bind = $$.elesfn.on;
  $$.elesfn.unbind = $$.elesfn.off;
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    nodes: function( selector ){
      return this.filter(function(i, element){
        return element.isNode();
      }).filter(selector);
    },

    edges: function( selector ){
      return this.filter(function(i, element){
        return element.isEdge();
      }).filter(selector);
    },

    filter: function( filter ){
      var cy = this._private.cy;
      
      if( $$.is.fn(filter) ){
        var elements = [];

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( filter.apply(ele, [i, ele]) ){
            elements.push(ele);
          }
        }
        
        return new $$.Collection(cy, elements);
      
      } else if( $$.is.string(filter) || $$.is.elementOrCollection(filter) ){
        return new $$.Selector(filter).filter(this);
      
      } else if( filter === undefined ){
        return this;
      }

      return new $$.Collection( cy ); // if not handled by above, give 'em an empty collection
    },

    not: function( toRemove ){
      var cy = this._private.cy;

      if( !toRemove ){
        return this;
      } else {
      
        if( $$.is.string( toRemove ) ){
          toRemove = this.filter( toRemove );
        }
        
        var elements = [];
        
        for( var i = 0; i < this.length; i++ ){
          var element = this[i];

          var remove = toRemove._private.ids[ element.id() ];
          if( !remove ){
            elements.push( element );
          }
        }
        
        return new $$.Collection( cy, elements );
      }
      
    },

    intersect: function( other ){
      var cy = this._private.cy;
      
      // if a selector is specified, then filter by it instead
      if( $$.is.string(other) ){
        var selector = other;
        return this.filter( selector );
      }
      
      var elements = [];
      var col1 = this;
      var col2 = other;
      var col1Smaller = this.length < other.length;
      // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
      var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
      var col = col1Smaller ? col1 : col2;
      
      for( var i = 0; i < col.length; i++ ){
        var id = col[i]._private.data.id;
        var ele = ids2[ id ];

        if( ele ){
          elements.push( ele );
        }
      }
      
      return new $$.Collection( cy, elements );
    },

    add: function( toAdd ){
      var cy = this._private.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }
      
      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        elements.push( this[i] );
      }

      for( var i = 0; i < toAdd.length; i++ ){

        var add = !this._private.ids[ toAdd[i].id() ];
        if( add ){
          elements.push( toAdd[i] );
        }
      }
      
      return new $$.Collection(cy, elements);
    },

    // in place merge on calling collection
    merge: function( toAdd ){
      var _p = this._private;
      var cy = _p.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }

      for( var i = 0; i < toAdd.length; i++ ){
        var toAddEle = toAdd[i];
        var id = toAddEle.id();
        var add = !_p.ids[ id ];

        if( add ){
          var index = this.length++;

          this[ index ] = toAddEle;
          _p.ids[ id ] = toAddEle;
          _p.indexes[ id ] = index;
        }
      }
      
      return this; // chaining
    },

    // remove single ele in place in calling collection
    unmergeOne: function( ele ){
      ele = ele[0];

      var _p = this._private;
      var id = ele.id();
      var i = _p.indexes[ id ];

      if( i == null ){
        return this; // no need to remove
      }

      // remove ele
      this[i] = undefined;
      _p.ids[ id ] = undefined;
      _p.indexes[ id ] = undefined;

      var unmergedLastEle = i === this.length - 1;

      // replace empty spot with last ele in collection
      if( this.length > 1 && !unmergedLastEle ){
        var lastEleI = this.length - 1;
        var lastEle = this[ lastEleI ];

        this[ lastEleI ] = undefined;
        this[i] = lastEle;
        _p.indexes[ lastEle.id() ] = i;
      }

      // the collection is now 1 ele smaller
      this.length--;

      return this;
    },

    // remove eles in place on calling collection
    unmerge: function( toRemove ){
      var cy = this._private.cy;    
      
      if( !toRemove ){
        return this;
      }

      if( $$.is.string(toRemove) ){
        var selector = toRemove;
        toRemove = cy.elements(selector);
      }

      for( var i = 0; i < toRemove.length; i++ ){
        this.unmergeOne( toRemove[i] );
      }
      
      return this; // chaining
    },

    map: function( mapFn, thisArg ){
      var arr = [];
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var ret = mapFn.apply( thisArg, [ele, i, eles] );

        arr.push( ret );
      }

      return arr;
    },

    stdFilter: function( fn, thisArg ){
      var filterEles = [];
      var eles = this;
      var cy = this._private.cy;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var include = fn.apply( thisArg, [ele, i, eles] );

        if( include ){
          filterEles.push( ele );
        }
      }

      return new $$.Collection( cy, filterEles );
    },

    max: function( valFn, thisArg ){
      var max = -Infinity;
      var maxEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = valFn.apply( thisArg, [ ele, i, eles ] );

        if( val > max ){
          max = val;
          maxEle = ele;
        }
      }

      return {
        value: max,
        ele: maxEle
      };
    },

    min: function( valFn, thisArg ){
      var min = Infinity;
      var minEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = valFn.apply( thisArg, [ ele, i, eles ] );

        if( val < min ){
          min = val;
          minEle = ele;
        }
      }

      return {
        value: min,
        ele: minEle
      };
    }
  });
  
})( cytoscape );
;(function($$){ 'use strict';

  $$.fn.eles({
    isNode: function(){
      return this.group() === 'nodes';
    },

    isEdge: function(){
      return this.group() === 'edges';
    },

    isLoop: function(){
      return this.isEdge() && this.source().id() === this.target().id();
    },

    isSimple: function(){
      return this.isEdge() && this.source().id() !== this.target().id();
    },

    group: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.group;
      }
    }
  });

  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for iterating over collections
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    each: function(fn){
      if( $$.is.fn(fn) ){
        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = fn.apply( ele, [ i, ele ] );

          if( ret === false ){ break; } // exit each early on return false
        }
      }
      return this;
    },

    forEach: function(fn, thisArg){
      if( $$.is.fn(fn) ){

        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = fn.apply( thisArg, [ ele, i, this ] );

          if( ret === false ){ break; } // exit each early on return false
        }
      }

      return this;
    },

    toArray: function(){
      var array = [];
      
      for(var i = 0; i < this.length; i++){
        array.push( this[i] );
      }
      
      return array;
    },

    slice: function(start, end){
      var array = [];
      var thisSize = this.length;
      
      if( end == null ){
        end = thisSize;
      }

      if( start == null ){
        start = 0;
      }
      
      if( start < 0 ){
        start = thisSize + start;
      }

      if( end < 0 ){
        end = thisSize + end;
      }
      
      for(var i = start; i >= 0 && i < end && i < thisSize; i++){
        array.push( this[i] );
      }
      
      return new $$.Collection(this.cy(), array);
    },

    size: function(){
      return this.length;
    },

    eq: function(i){
      return this[i] || new $$.Collection( this.cy() );
    },

    first: function(){
      return this[0] || new $$.Collection( this.cy() );
    },

    last: function(){
      return this[ this.length - 1 ] || new $$.Collection( this.cy() );
    },

    empty: function(){
      return this.length === 0;
    },

    nonempty: function(){
      return !this.empty();
    },

    sort: function( sortFn ){
      if( !$$.is.fn( sortFn ) ){
        return this;
      }

      var cy = this.cy();      
      var sorted = this.toArray().sort( sortFn );

      return new $$.Collection(cy, sorted);
    },

    sortByZIndex: function(){
      return this.sort( $$.Collection.zIndexSort );
    },

    zDepth: function(){
      var ele = this[0];
      if( !ele ){ return undefined; }

      var _p = ele._private;
      var group = _p.group;

      if( group === 'nodes' ){
        return _p.data.parent ? ele.parents().size() : 0;
      } else {
        var src = _p.source;
        var tgt = _p.target;
        var srcDepth = src._private.data.parent ? src.parents().size() : 0;
        var tgtDepth = tgt._private.data.parent ? tgt.parents().size() : 0;

        return Math.max( srcDepth - 1, tgtDepth - 1, 0 ) + 0.5; // depth of deepest parent and just a bit above
      }
    }
  });

  $$.Collection.zIndexSort = function(a, b){
    var cy = a.cy();
    var a_p = a._private;
    var b_p = b._private;
    var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;
    var depthA = 0;
    var depthB = 0;
    var hasCompoundNodes = cy.hasCompoundNodes();
    var aIsNode = a_p.group === 'nodes';
    var aIsEdge = a_p.group === 'edges';
    var bIsNode = b_p.group === 'nodes';
    var bIsEdge = b_p.group === 'edges';

    // no need to calculate element depth if there is no compound node
    if( hasCompoundNodes ){
      depthA = a.zDepth();
      depthB = b.zDepth();
    }

    var depthDiff = depthA - depthB;
    var sameDepth = depthDiff === 0;

    if( sameDepth ){
      
      if( aIsNode && bIsEdge ){
        return 1; // 'a' is a node, it should be drawn later       
      
      } else if( aIsEdge && bIsNode ){
        return -1; // 'a' is an edge, it should be drawn first

      } else { // both nodes or both edges
        if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)
          return a_p.index - b_p.index;
        } else {
          return zDiff;
        }
      }
    
    // elements on different level
    } else {
      return depthDiff; // deeper element should be drawn later
    }

  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for layouts on nodes
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({

    // using standard layout options, apply position function (w/ or w/o animation)
    layoutPositions: function( layout, options, fn ){
      var nodes = this.nodes();
      var cy = this.cy();

      layout.trigger({ type: 'layoutstart', layout: layout });

      if( options.animate ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var lastNode = i === nodes.length - 1;

          var newPos = fn.call( node, i, node );
          var pos = node.position();

          if( !$$.is.number(pos.x) || !$$.is.number(pos.y) ){
            node.silentPosition({ x: 0, y: 0 });
          }

          node.animate({
            position: newPos
          }, {
            duration: options.animationDuration,
            step: !lastNode ? undefined : function(){
              if( options.fit ){
                cy.fit( options.padding );
              } 
            },
            complete: !lastNode ? undefined : function(){
              if( options.zoom != null ){
                cy.zoom( options.zoom );
              }

              if( options.pan ){
                cy.pan( options.pan );
              } 

              if( options.fit ){
                cy.fit( options.padding );
              } 
              
              layout.one('layoutstop', options.stop);
              layout.trigger({ type: 'layoutstop', layout: layout });
            }
          });
        }

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      } else {
        nodes.positions( fn );

        if( options.fit ){
          cy.fit( options.padding );
        }

        if( options.zoom != null ){
          cy.zoom( options.zoom );
        }

        if( options.pan ){
          cy.pan( options.pan );
        } 

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
        
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }

      return this; // chaining
    },

    layout: function( options ){
      var cy = this.cy();

      cy.layout( $$.util.extend({}, options, {
        eles: this
      }) );

      return this;
    },

    makeLayout: function( options ){
      var cy = this.cy();

      return cy.makeLayout( $$.util.extend({}, options, {
        eles: this
      }) );
    }

  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    // fully updates (recalculates) the style for the elements
    updateStyle: function( notifyRenderer ){
      var cy = this._private.cy;

      if( !cy.styleEnabled() ){ return this; }

      if( cy._private.batchingStyle ){
        var bEles = cy._private.batchStyleEles;

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        }

        return this; // chaining and exit early when batching
      }

      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      style.apply( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
    updateMappers: function( notifyRenderer ){
      var cy = this._private.cy;
      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      if( !cy.styleEnabled() ){ return this; }

      style.updateMappers( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // get the specified css property as a rendered value (i.e. on-screen value)
    // or get the whole rendered style if no property specified (NB doesn't allow setting)
    renderedCss: function( property ){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return this; }

      var ele = this[0];

      if( ele ){
        var renstyle = ele.cy().style().getRenderedStyle( ele );

        if( property === undefined ){
          return renstyle;
        } else {
          return renstyle[ property ];
        }
      }
    },

    // read the calculated css style of the element or override the style (via a bypass)
    css: function( name, value ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();

      if( $$.is.plainObject(name) ){ // then extend the bypass
        var props = name;
        style.applyBypass( this, props, updateTransitions );

        var updatedCompounds = this.updateCompoundBounds();
        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
        toNotify.rtrigger('style'); // let the renderer know we've updated style

      } else if( $$.is.string(name) ){
  
        if( value === undefined ){ // then get the property from the style
          var ele = this[0];

          if( ele ){
            return ele._private.style[ name ].strValue;
          } else { // empty collection => can't get any value
            return;
          }

        } else { // then set the bypass with the property value
          style.applyBypass( this, name, value, updateTransitions );

          var updatedCompounds = this.updateCompoundBounds();
          var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
          toNotify.rtrigger('style'); // let the renderer know we've updated style
        }

      } else if( name === undefined ){
        var ele = this[0];

        if( ele ){
          return style.getRawStyle( ele );
        } else { // empty collection => can't get any value
          return;
        }
      }

      return this; // chaining
    },

    removeCss: function( names ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();
      var eles = this;

      if( names === undefined ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeAllBypasses( ele, updateTransitions );
        }
      } else {
        names = names.split(/\s+/);

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeBypasses( ele, names, updateTransitions );
        }
      }

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
      toNotify.rtrigger('style'); // let the renderer know we've updated style

      return this; // chaining
    },

    show: function(){
      this.css('display', 'element');
      return this; // chaining
    },

    hide: function(){
      this.css('display', 'none');
      return this; // chaining
    },

    visible: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return true; }

      var ele = this[0];
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele ){
        var style = ele._private.style;

        if(
          style['visibility'].value !== 'visible'
          || style['display'].value !== 'element'
        ){
          return false;
        }
        
        if( ele._private.group === 'nodes' ){
          if( !hasCompoundNodes ){ return true; }

          var parents = ele._private.data.parent ? ele.parents() : null;

          if( parents ){
            for( var i = 0; i < parents.length; i++ ){
              var parent = parents[i];
              var pStyle = parent._private.style;
              var pVis = pStyle['visibility'].value;
              var pDis = pStyle['display'].value;

              if( pVis !== 'visible' || pDis !== 'element' ){
                return false;
              }
            }
          }

          return true;
        } else {
          var src = ele._private.source;
          var tgt = ele._private.target;

          return src.visible() && tgt.visible();
        }

      }
    },

    hidden: function(){
      var ele = this[0];

      if( ele ){
        return !ele.visible();
      }
    },

    effectiveOpacity: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return 1; }

      var hasCompoundNodes = cy.hasCompoundNodes();
      var ele = this[0];

      if( ele ){
        var _p = ele._private;
        var parentOpacity = _p.style.opacity.value;

        if( !hasCompoundNodes ){ return parentOpacity; }

        var parents = !_p.data.parent ? null : ele.parents();
        
        if( parents ){
          for( var i = 0; i < parents.length; i++ ){
            var parent = parents[i];
            var opacity = parent._private.style.opacity.value;

            parentOpacity = opacity * parentOpacity;
          }
        }

        return parentOpacity;
      }
    },

    transparent: function(){
      var ele = this[0];
      var hasCompoundNodes = ele.cy().hasCompoundNodes();

      if( ele ){
        if( !hasCompoundNodes ){
          return ele._private.style.opacity.value === 0;
        } else {
          return ele.effectiveOpacity() === 0;
        }
      }
    },

    isFullAutoParent: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];

      if( ele ){
        var autoW = ele._private.style['width'].value === 'auto';
        var autoH = ele._private.style['height'].value === 'auto';

        return ele.isParent() && autoW && autoH;
      }
    }

  });


  $$.elesfn.style = $$.elesfn.css;
  $$.elesfn.renderedStyle = $$.elesfn.renderedCss;
  $$.elesfn.removeStyle = $$.elesfn.removeCss;
  
})( cytoscape );
;(function($$){ 'use strict';
  
  // Collection functions that toggle a boolean value
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  
  function defineSwitchFunction(params){
    return function(){
      var args = arguments;
      
      // e.g. cy.nodes().select( data, handler )
      if( args.length === 2 ){
        var data = args[0];
        var handler = args[1];
        this.bind( params.event, data, handler );
      } 
      
      // e.g. cy.nodes().select( handler )
      else if( args.length === 1 ){
        var handler = args[0];
        this.bind( params.event, handler );
      }
      
      // e.g. cy.nodes().select()
      else if( args.length === 0 ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];
          var able = !params.ableField || ele._private[params.ableField];

          if( params.overrideAble ){
            var overrideAble = params.overrideAble(ele);

            if( overrideAble !== undefined ){
              able = overrideAble;

              if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
            }
          }

          if( able ){
            ele._private[params.field] = params.value;
          }
        }
        this.updateStyle(); // change of state => possible change of style
        this.trigger( params.event );
      }

      return this;
    };
  }
  
  function defineSwitchSet( params ){
    $$.elesfn[ params.field ] = function(){
      var ele = this[0];

      if( ele ){
        if( params.overrideField ){
          var val = params.overrideField(ele);

          if( val !== undefined ){
            return val;
          }
        }

        return ele._private[ params.field ];
      }
    };
    
    $$.elesfn[ params.on ] = defineSwitchFunction({
      event: params.on,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: true
    });

    $$.elesfn[ params.off ] = defineSwitchFunction({
      event: params.off,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: false
    });
  }
  
  defineSwitchSet({
    field: 'locked',
    overrideField: function(ele){
      return ele.cy().autolock() ? true : undefined;
    },
    on: 'lock',
    off: 'unlock'
  });
  
  defineSwitchSet({
    field: 'grabbable',
    overrideField: function(ele){
      return ele.cy().autoungrabify() ? false : undefined;
    },
    on: 'grabify',
    off: 'ungrabify'
  });
  
  defineSwitchSet({
    field: 'selected',
    ableField: 'selectable',
    overrideAble: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'select',
    off: 'unselect'
  });
  
  defineSwitchSet({
    field: 'selectable',
    overrideField: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'selectify',
    off: 'unselectify'
  });
  
  $$.elesfn.grabbed = function(){
    var ele = this[0];
    if( ele ){
      return ele._private.grabbed;
    }
  };

  defineSwitchSet({
    field: 'active',
    on: 'activate',
    off: 'unactivate'
  });

  $$.elesfn.inactive = function(){
    var ele = this[0];
    if( ele ){
      return !ele._private.active;
    }
  };
  
})( cytoscape );

;(function($$){ 'use strict';

  // DAG functions
  //////////////////////////

  $$.fn.eles({
    // get the root nodes in the DAG
    roots: function( selector ){
      var eles = this;
      var roots = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingIn = ele.connectedEdges(function(){
          return this.data('target') === ele.id() && this.data('source') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingIn ){
          roots.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, roots, { unique: true } ).filter( selector );
    },

    // get the leaf nodes in the DAG
    leaves: function( selector ){
      var eles = this;
      var leaves = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingOut = ele.connectedEdges(function(){
          return this.data('source') === ele.id() && this.data('target') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingOut ){
          leaves.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, leaves, { unique: true } ).filter( selector );
    },

    // normally called children in graph theory
    // these nodes =edges=> outgoing nodes
    outgoers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( srcId === eleId && tgtId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.target()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG descendants
    successors: function( selector ){
      var eles = this;
      var sEles = [];
      var sElesIds = {};

      for(;;){
        var outgoers = eles.outgoers();

        if( outgoers.length === 0 ){ break; } // done if no outgoers left

        var newOutgoers = false;
        for( var i = 0; i < outgoers.length; i++ ){
          var outgoer = outgoers[i];
          var outgoerId = outgoer.id();

          if( !sElesIds[ outgoerId ] ){
            sElesIds[ outgoerId ] = true;
            sEles.push( outgoer );
            newOutgoers = true;
          }
        }

        if( !newOutgoers ){ break; } // done if touched all outgoers already

        eles = outgoers;
      }

      return new $$.Collection( this._private.cy, sEles, { unique: true } ).filter( selector );
    },

    // normally called parents in graph theory
    // these nodes <=edges= incoming nodes
    incomers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( tgtId === eleId && srcId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.source()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG ancestors
    predecessors: function( selector ){
      var eles = this;
      var pEles = [];
      var pElesIds = {};

      for(;;){
        var incomers = eles.incomers();

        if( incomers.length === 0 ){ break; } // done if no incomers left

        var newIncomers = false;
        for( var i = 0; i < incomers.length; i++ ){
          var incomer = incomers[i];
          var incomerId = incomer.id();

          if( !pElesIds[ incomerId ] ){
            pElesIds[ incomerId ] = true;
            pEles.push( incomer );
            newIncomers = true;
          }
        }

        if( !newIncomers ){ break; } // done if touched all incomers already

        eles = incomers;
      }

      return new $$.Collection( this._private.cy, pEles, { unique: true } ).filter( selector );
    }
  });


  // Neighbourhood functions
  //////////////////////////

  $$.fn.eles({
    neighborhood: function(selector){
      var elements = [];
      var cy = this._private.cy;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){ // for all nodes
        var node = nodes[i];
        var connectedEdges = node.connectedEdges();

        // for each connected edge, add the edge and the other node
        for( var j = 0; j < connectedEdges.length; j++ ){
          var edge = connectedEdges[j];
          var otherNode = edge.connectedNodes().not(node);

          // need check in case of loop
          if( otherNode.length > 0 ){
            elements.push( otherNode[0] ); // add node 1 hop away
          }
          
          // add connected edge
          elements.push( edge[0] );
        }

      }
      
      return ( new $$.Collection( cy, elements, { unique: true } ) ).filter( selector );
    },

    closedNeighborhood: function(selector){
      return this.neighborhood().add( this ).filter( selector );
    },

    openNeighborhood: function(selector){
      return this.neighborhood( selector );
    }
  });  


  // Edge functions
  /////////////////

  $$.fn.eles({
    source: function( selector ){
      var ele = this[0];
      var src;

      if( ele ){
        src = ele._private.source;
      }

      return src && selector ? src.filter( selector ) : src;
    },

    target: function( selector ){
      var ele = this[0];
      var tgt;

      if( ele ){
        tgt = ele._private.target;
      }

      return tgt && selector ? tgt.filter( selector ) : tgt;
    },

    sources: defineSourceFunction({
      attr: 'source'
    }),

    targets: defineSourceFunction({
      attr: 'target'
    })
  });
  
  function defineSourceFunction( params ){
    return function( selector ){
      var sources = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var src = ele._private[ params.attr ];

        if( src ){
          sources.push( src );
        }
      }
      
      return new $$.Collection( cy, sources, { unique: true } ).filter( selector );
    };
  }

  $$.fn.eles({
    edgesWith: defineEdgesWithFunction(),

    edgesTo: defineEdgesWithFunction({
      thisIs: 'source'
    })
  });
  
  function defineEdgesWithFunction( params ){
    
    return function(otherNodes){
      var elements = [];
      var cy = this._private.cy;
      var p = params || {};

      // get elements if a selector is specified
      if( $$.is.string(otherNodes) ){
        otherNodes = cy.$( otherNodes );
      }
      
      var edges = otherNodes.connectedEdges();
      var thisIds = this._private.ids;
      
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];
        var foundId;
        var edgeData = edge._private.data;

        if( p.thisIs ){
          var idToFind = edgeData[ p.thisIs ];
          foundId = thisIds[ idToFind ];
        } else {
          foundId = thisIds[ edgeData.source ] || thisIds[ edgeData.target ];
        }
        
        if( foundId ){
          elements.push( edge );
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } );
    };
  }
  
  $$.fn.eles({
    connectedEdges: function( selector ){
      var retEles = [];
      var cy = this._private.cy;
      
      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var node = eles[i];
        if( !node.isNode() ){ continue; }

        var edges = node._private.edges;

        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];          
          retEles.push( edge );
        }
      }
      
      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    connectedNodes: function( selector ){
      var retEles = [];
      var cy = this._private.cy;

      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var edge = eles[i];
        if( !edge.isEdge() ){ continue; }

        retEles.push( edge.source()[0] );
        retEles.push( edge.target()[0] );
      }

      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    parallelEdges: defineParallelEdgesFunction(),

    codirectedEdges: defineParallelEdgesFunction({
      codirected: true
    })
  });
  
  function defineParallelEdgesFunction(params){
    var defaults = {
      codirected: false
    };
    params = $$.util.extend({}, defaults, params);
    
    return function( selector ){
      var cy = this._private.cy;
      var elements = [];
      var edges = this.edges();
      var p = params;

      // look at all the edges in the collection
      for( var i = 0; i < edges.length; i++ ){
        var edge1 = edges[i];
        var src1 = edge1.source()[0];
        var srcid1 = src1.id();
        var tgt1 = edge1.target()[0];
        var tgtid1 = tgt1.id();
        var srcEdges1 = src1._private.edges;

        // look at edges connected to the src node of this edge
        for( var j = 0; j < srcEdges1.length; j++ ){
          var edge2 = srcEdges1[j];
          var edge2data = edge2._private.data;
          var tgtid2 = edge2data.target;
          var srcid2 = edge2data.source;

          var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
          var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;
          
          if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
            elements.push( edge2 );
          }
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } ).filter( selector );
    };
  
  }

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    fit: function(){},
    center: function(){}

  });
  
})( cytoscape );
;(function ($$) {
  "use strict";

  /*  Min and Max heap predefaults */
  
  $$.Minheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.minHeapComparator, valueFn);
  };

  $$.Maxheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.maxHeapComparator, valueFn);
  };
  
  $$.Heap = function (cy, eles, comparator, valueFn) {
    if (typeof comparator === "undefined" || typeof eles === "undefined") {
      return;
    }
    
    if (typeof valueFn === "undefined") {
      valueFn = $$.Heap.idFn;
    }

    var sourceHeap = [],
      pointers = {},
      elements = [],
      i = 0,
      id,
      heap,
      elesLen;

    eles = this.getArgumentAsCollection(eles, cy);
    elesLen = eles.length;

    for (i = 0; i < elesLen; i += 1) {
      sourceHeap.push(valueFn.call(cy, eles[i], i, eles));

      id = eles[i].id();
      
      if (pointers.hasOwnProperty(id)) {
        throw "ERROR: Multiple items with the same id found: " + id;
      }
      
      pointers[id] = i;
      elements.push(id);
    }

    this._private = {
      cy: cy,
      heap: sourceHeap,
      pointers: pointers,
      elements: elements,
      comparator: comparator,
      extractor: valueFn,
      length: elesLen
    };

    for (i = Math.floor(elesLen / 2); i >= 0; i -= 1) {
      heap = this.heapify(i);
    }

    return heap;
  };

  /* static methods */
  $$.Heap.idFn = function (node) {
    return node.id();
  };

  $$.Heap.minHeapComparator = function (a, b) {
    return a >= b;
  };

  $$.Heap.maxHeapComparator = function (a, b) {
    return a <= b;
  };

  $$.fn.heap = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Heap.prototype[ name ] = fn;
    }
  };

  $$.heapfn = $$.Heap.prototype; // short alias

  /* object methods */
  $$.heapfn.size = function () {
    return this._private.length;
  };

  $$.heapfn.getArgumentAsCollection = function (eles, cy) {
    var result;
    if(typeof cy === "undefined") {
      cy = this._private.cy;
    }

    if ($$.is.elementOrCollection(eles)) {
      result = eles;

    } else {
      var resultArray = [],
        sourceEles = [].concat.apply([], [eles]);

      for (var i = 0; i < sourceEles.length; i++) {
        var id = sourceEles[i],
          ele = cy.getElementById(id);

        if(ele.length > 0) {
          resultArray.push(ele);
        }
      }

      result = new $$.Collection(cy, resultArray);
    }

    return result;
  };

  $$.heapfn.isHeap = function () {
    var array = this._private.heap,
      arrlen = array.length,
      i,
      left,
      right,
      lCheck,
      rCheck,
      comparator = this._private.comparator;

    for (i = 0; i < arrlen; i += 1) {
      left = 2 * i + 1;
      right = left + 1;
      lCheck = left < arrlen ? comparator(array[left], array[i]) : true;
      rCheck = right < arrlen ? comparator(array[right], array[i]) : true;

      if (!lCheck || !rCheck) {
        return false;
      }
    }

    return true;
  };

  $$.heapfn.heapSwap = function (i, j) {
    var heap = this._private.heap,
      pointers = this._private.pointers,
      elements = this._private.elements,
      swapValue = heap[i],
      swapElems = elements[i],
      idI = elements[i],
      idJ = elements[j];

    heap[i] = heap[j];
    elements[i] = elements[j];

    pointers[idI] = j;
    pointers[idJ] = i;

    heap[j] = swapValue;
    elements[j] = swapElems;
  };

  $$.heapfn.heapify = function (i, rootToLeaf) {
    var treeLen = 0,
      condHeap = false,
      array,
      current,
      left,
      right,
      best,
      comparator,
      parent;
    
    if (typeof rootToLeaf === "undefined") {
      rootToLeaf = true;
    }

    array = this._private.heap;
    treeLen = array.length;
    comparator = this._private.comparator;
    current = i;

    while (!condHeap) {

      if (rootToLeaf) {
        left = 2 * current + 1;
        right = left + 1;
        best = current;
        
        if (left < treeLen && !comparator(array[left], array[best])) {
          best = left;
        }
        
        if (right < treeLen && !comparator(array[right], array[best])) {
          best = right;
        }
        
        condHeap = best === current;
        
        if (!condHeap) {
          this.heapSwap(best, current);
          current = best;
        }

      } else {
        parent = Math.floor((current - 1) / 2);
        best = current;
        condHeap = parent < 0 || comparator(array[best], array[parent]);

        if (!condHeap) {
          this.heapSwap(best, parent);
          current = parent;
        }
      }

    } // while
  };

  /* collectionOrElement */
  $$.heapfn.insert = function (eles) {
    var elements = this.getArgumentAsCollection(eles),
      elsize = elements.length,
      element,
      elindex,
      elvalue,
      elid,
      i;

    for (i = 0; i < elsize; i += 1) {
      element = elements[i];
      elindex = this._private.heap.length;
      elvalue = this._private.extractor(element);
      elid = element.id();

      if (this._private.pointers.hasOwnProperty(elid)) {
        throw "ERROR: Multiple items with the same id found: " + elid;
      }

      this._private.heap.push(elvalue);
      this._private.elements.push(elid);
      this._private.pointers[elid] = elindex;
      this.heapify(elindex, false);
    }

    this._private.length = this._private.heap.length;
  };

  $$.heapfn.getValueById = function (elementId) {
    if (this._private.pointers.hasOwnProperty(elementId)) {
      var elementIndex = this._private.pointers[elementId];

      return this._private.heap[elementIndex];
    }
  };
  
  $$.heapfn.contains = function (eles) {
    var elements = this.getArgumentAsCollection(eles);

    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id();

      if(!this._private.pointers.hasOwnProperty(elementId)) {
        return false;
      }
    }

    return true;
  };
  
  $$.heapfn.top = function () {
    if (this._private.length > 0) {

      return {
        value: this._private.heap[0],
        id: this._private.elements[0]
      };

    }
  };

  $$.heapfn.pop = function () {
    if (this._private.length > 0) {
      var top = this.top(),
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      this.heapSwap(0, lastIndex);

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.heapify(0);
      return top;
    }
  };

  $$.heapfn.findDirectionHeapify = function (index) {
    var parent = Math.floor((index - 1) / 2),
      array = this._private.heap,
      condHeap = parent < 0 || this._private.comparator(array[index], array[parent]);

    this.heapify(index, condHeap);
  };

  /* edit is a new value or function */
  // only values in heap are updated. elements themselves are not!
  $$.heapfn.edit = function (eles, edit) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        elementValue = this._private.heap[elementIndex];
      
      if ($$.is.number(edit)) {
        this._private.heap[elementIndex] = edit;
        
      } else if ($$.is.fn(edit)) {
        this._private.heap[elementIndex] = edit.call(this._private.cy, elementValue, elementIndex);
      }

      this.findDirectionHeapify(elementIndex);
    }
  };

  $$.heapfn.delete = function (eles) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      if (elementIndex !== lastIndex) {
        this.heapSwap(elementIndex, lastIndex);
      }

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.findDirectionHeapify(elementIndex);
    }

    return removeValue;
  };

})(cytoscape);
/*
  The canvas renderer was written by Yue Dong.

  Modifications tracked on Github.
*/

(function($$) { 'use strict';

  function CanvasRenderer(options) {
    
    CanvasRenderer.CANVAS_LAYERS = 5;
    CanvasRenderer.SELECT_BOX = 0;
    CanvasRenderer.DRAG = 2;
    CanvasRenderer.NODE = 4;
    CanvasRenderer.TEXTURE_BUFFER = 0;
    CanvasRenderer.BUFFER_COUNT = 2;

    this.options = options;

    this.data = {
        
      select: [undefined, undefined, undefined, undefined, 0], // Coordinates for selection box, plus enabled flag 
      renderer: this, cy: options.cy, container: options.cy.container(),
      
      canvases: new Array(CanvasRenderer.CANVAS_LAYERS),
      contexts: new Array(CanvasRenderer.CANVAS_LAYERS),
      canvasNeedsRedraw: new Array(CanvasRenderer.CANVAS_LAYERS),
      
      bufferCanvases: new Array(CanvasRenderer.BUFFER_COUNT),
      bufferContexts: new Array(CanvasRenderer.CANVAS_LAYERS)

    };
    
    //--Pointer-related data
    this.hoverData = {down: null, last: null, 
        downTime: null, triggerMode: null, 
        dragging: false, 
        initialPan: [null, null], capture: false};
    
    this.timeoutData = {panTimeout: null};
    
    this.dragData = {possibleDragElements: []};
    
    this.touchData = {start: null, capture: false,
        // These 3 fields related to tap, taphold events
        startPosition: [null, null, null, null, null, null],
        singleTouchStartTime: null,
        singleTouchMoved: true,
        
        
        now: [null, null, null, null, null, null], 
        earlier: [null, null, null, null, null, null] };
    //--
    
    //--Wheel-related data 
    this.zoomData = {freeToZoom: false, lastPointerX: null};
    //--
    
    this.redraws = 0;
    this.showFps = options.showFps;

    this.bindings = [];
    
    this.data.canvasContainer = document.createElement('div');
    var containerStyle = this.data.canvasContainer.style;
    containerStyle.position = 'absolute';
    containerStyle.zIndex = '0';
    containerStyle.overflow = 'hidden';

    this.data.container.appendChild( this.data.canvasContainer );

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {
      this.data.canvases[i] = document.createElement('canvas');
      this.data.contexts[i] = this.data.canvases[i].getContext('2d');
      this.data.canvases[i].style.position = 'absolute';
      this.data.canvases[i].setAttribute('data-id', 'layer' + i);
      this.data.canvases[i].style.zIndex = String(CanvasRenderer.CANVAS_LAYERS - i);
      this.data.canvasContainer.appendChild(this.data.canvases[i]);
      
      this.data.canvasNeedsRedraw[i] = false;
    }
    this.data.topCanvas = this.data.canvases[0];

    this.data.canvases[CanvasRenderer.NODE].setAttribute('data-id', 'layer' + CanvasRenderer.NODE + '-node');
    this.data.canvases[CanvasRenderer.SELECT_BOX].setAttribute('data-id', 'layer' + CanvasRenderer.SELECT_BOX + '-selectbox');
    this.data.canvases[CanvasRenderer.DRAG].setAttribute('data-id', 'layer' + CanvasRenderer.DRAG + '-drag');
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      this.data.bufferCanvases[i] = document.createElement('canvas');
      this.data.bufferContexts[i] = this.data.bufferCanvases[i].getContext('2d');
      this.data.bufferCanvases[i].style.position = 'absolute';
      this.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
      this.data.bufferCanvases[i].style.zIndex = String(-i - 1);
      this.data.bufferCanvases[i].style.visibility = 'hidden';
      //this.data.canvasContainer.appendChild(this.data.bufferCanvases[i]);
    }

    this.hideEdgesOnViewport = options.hideEdgesOnViewport;
    this.hideLabelsOnViewport = options.hideLabelsOnViewport;
    this.textureOnViewport = options.textureOnViewport;
    this.wheelSensitivity = options.wheelSensitivity;
    this.motionBlurEnabled = options.motionBlur === undefined ? true : options.motionBlur; // on by default
    this.forcedPixelRatio = options.pixelRatio;
    this.motionBlur = true; // for initial kick off
    this.tapThreshold = options.tapThreshold;
    this.tapThreshold2 = options.tapThreshold * options.tapThreshold;
    this.tapholdDuration = 500;

    this.load();
  }

  CanvasRenderer.panOrBoxSelectDelay = 400;
  CanvasRenderer.isTouch = $$.is.touch();

  // whether to use Path2D caching for drawing
  var pathsImpld = typeof Path2D !== 'undefined';
  CanvasRenderer.usePaths = function(){
    return pathsImpld;
  };

  CanvasRenderer.prototype.notify = function(params) {
    var types;

    if( $$.is.array( params.type ) ){
      types = params.type;

    } else {
      types = [ params.type ];
    }

    for( var i = 0; i < types.length; i++ ){
      var type = types[i];

      switch( type ){
        case 'destroy':
          this.destroy();
          return;

        case 'add':
        case 'remove':
        case 'load':
          this.updateNodesCache();
          this.updateEdgesCache();
          break;

        case 'viewport':
          this.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          break;

        case 'style':
          this.updateCachedZSortedEles();
          break;
      }

      if( type === 'load' || type === 'resize' ){
        this.invalidateContainerClientCoordsCache();
        this.matchCanvasSize(this.data.container);
      }
    } // for
    
    this.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
    this.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

    this.redraw();
  };

  CanvasRenderer.prototype.destroy = function(){
    this.destroyed = true;

    for( var i = 0; i < this.bindings.length; i++ ){
      var binding = this.bindings[i];
      var b = binding;

      b.target.removeEventListener(b.event, b.handler, b.useCapture);
    }

    if( this.removeObserver ){
      this.removeObserver.disconnect();
    }

    if( this.labelCalcDiv ){
      document.body.removeChild(this.labelCalcDiv);
    }
  };

  

  // copy the math functions into the renderer prototype
  // unfortunately these functions are used interspersed t/o the code
  // and this makes sure things work just in case a ref was missed in refactoring
  // TODO remove this eventually
  for( var fnName in $$.math ){
    CanvasRenderer.prototype[ fnName ] = $$.math[ fnName ];
  }
  
  
  $$('renderer', 'canvas', CanvasRenderer);
  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var rendFunc = CanvasRenderer.prototype;
  var arrowShapes = CanvasRenderer.arrowShapes = {};

  CanvasRenderer.arrowShapeHeight = 0.3;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function(x, y, centerX, centerY, width, height, direction, padding){
    var x1 = centerX - width/2;
    var x2 = centerX + width/2;
    var y1 = centerY - height/2;
    var y2 = centerY + height/2;

    return (x1 <= x && x <= x2) && (y1 <= y && y <= y2);
  };

  var transform = function(x, y, size, angle, translation){
    angle = -angle; // b/c of notation used in arrow draw fn

    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
    
    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;
    
    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  arrowShapes['arrow'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['arrow']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['arrow']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }

    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['triangle'] = arrowShapes['arrow'];
  
  arrowShapes['triangle-backcurve'] = {
    _ctrlPt: [ 0, -0.15 ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['triangle']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['triangle']._points;
      var firstPt;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo(pt.x, pt.y);
      }

      var ctrlPt = this._ctrlPt;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      context.quadraticCurveTo( ctrlPtTrans.x, ctrlPtTrans.y, firstPt.x, firstPt.y );
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  

  arrowShapes['triangle-tee'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    _pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var triPts = arrowShapes['triangle-tee']._points;
      var teePts = arrowShapes['triangle-tee']._pointsTee;
      
      var inside = $$.math.pointInsidePolygon(x, y, teePts, centerX, centerY, width, height, direction, padding) 
        || $$.math.pointInsidePolygon(x, y, triPts, centerX, centerY, width, height, direction, padding);

      return inside;
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var triPts = arrowShapes['triangle-tee']._points;
      for (var i = 0; i < triPts.length / 2; i++){
        var pt = transform( triPts[ i * 2 ],  triPts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }

      var teePts = arrowShapes['triangle-tee']._pointsTee;
      var firstTeePt = transform( teePts[0], teePts[1], size, angle, translation );
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for (var i = 0; i < teePts.length / 2; i++){
        var pt = transform( teePts[ i * 2 ],  teePts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['half-triangle-overshot'] = {
    _points: [
      0, -0.25,
      -0.5, -0.25,
      0.5, 0.25
    ],
    
    leavePathOpen: true,
    matchEdgeWidth: true,

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = this._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = this._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['none'] = {
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    roughCollide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    draw: function(context) {
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return 0;
    }
  };
  
  arrowShapes['circle'] = {
    _baseRadius: 0.15,
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      // Transform x, y to get non-rotated ellipse
      
      if (width != height) {                  
        var aspectRatio = (height + padding) / (width + padding);
        y /= aspectRatio;
        centerY /= aspectRatio;
        
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      } else {
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      }
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      context.arc(translation.x, translation.y, arrowShapes['circle']._baseRadius * size, 0, Math.PI * 2, false);
    },
    
    spacing: function(edge) {
      return rendFunc.getArrowWidth(edge._private.style['width'].pxValue)
        * arrowShapes['circle']._baseRadius;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  
  arrowShapes['inhibitor'] = {
    _points: [
      -0.25, 0,
      -0.25, -0.1,
      0.25, -0.1,
      0.25, 0
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['inhibitor']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['inhibitor']._points;
      
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 1;
    },
    
    gap: function(edge) {
      return 1;
    }
  };

  arrowShapes['tee'] = arrowShapes['inhibitor'];

  arrowShapes['square'] = {
    _points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['square']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['square']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },

    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['diamond'] = {
    _points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['diamond']._points;
          
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },

    roughCollide: bbCollide,

    draw: function(context, size, angle, translation) {
      var points = arrowShapes['diamond']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue;
    }
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  CanvasRenderer.prototype.getCachedNodes = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedNodes == null) {
      data.cache.cachedNodes = cy.nodes();
    }
    
    return data.cache.cachedNodes;
  };
  
  CanvasRenderer.prototype.updateNodesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedNodes = cy.nodes();
  };
  
  CanvasRenderer.prototype.getCachedEdges = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedEdges == null) {
      data.cache.cachedEdges = cy.edges();
    }
    
    return data.cache.cachedEdges;
  };
  
  CanvasRenderer.prototype.updateEdgesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedEdges = cy.edges();
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // Project mouse
  CanvasRenderer.prototype.projectIntoViewport = function(clientX, clientY) {
    var offsets = this.findContainerClientCoords();
    var offsetLeft = offsets[0];
    var offsetTop = offsets[1];
    
    var x = clientX - offsetLeft; 
    var y = clientY - offsetTop;
    
    x -= this.data.cy.pan().x; y -= this.data.cy.pan().y; x /= this.data.cy.zoom(); y /= this.data.cy.zoom();
    return [x, y];
  };

  CanvasRenderer.prototype.findContainerClientCoords = function() {
    var container = this.data.container;

    var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();

    return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];
  };

  CanvasRenderer.prototype.invalidateContainerClientCoordsCache = function(){
    this.containerBB = null;
  };

  // Find nearest element
  CanvasRenderer.prototype.findNearestElement = function(x, y, visibleElementsOnly){
    var self = this;
    var eles = this.getCachedZSortedEles();
    var near = [];
    var isTouch = CanvasRenderer.isTouch;
    var zoom = this.data.cy.zoom();
    var hasCompounds = this.data.cy.hasCompoundNodes();
    var edgeThreshold = (isTouch ? 256 : 32) / zoom;
    var nodeThreshold = (isTouch ? 16 : 0) /  zoom;

    function checkNode(node){
      var width = node.outerWidth();
      var height = node.outerHeight();
      var hw = width/2;
      var hh = height/2;
      var pos = node._private.position;

      if(
        pos.x - hw <= x && x <= pos.x + hw // bb check x
          &&
        pos.y - hh <= y && y <= pos.y + hh // bb check y
      ){
        var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );

        // exit early if invisible edge and must be visible
        if( visibleElementsOnly && !visible ){
          return;
        }

        var shape = CanvasRenderer.nodeShapes[ self.getNodeShape(node) ];
        var borderWO = node._private.style['border-width'].pxValue / 2;

        if(
          shape.checkPoint(x, y, borderWO, width + nodeThreshold, height + nodeThreshold, pos.x, pos.y)
        ){
            near.push( node );
        }

      }
    }

    function checkEdge(edge){
      var rs = edge._private.rscratch;
      var style = edge._private.style;
      var width = style['width'].pxValue;
      var widthSq = width * width;
      var width2 = width * 2;
      var src = edge._private.source;
      var tgt = edge._private.target;
      var inEdgeBB = false;

      // exit early if invisible edge and must be visible
      var passedVisibilityCheck;
      var passesVisibilityCheck = function(){
        if( passedVisibilityCheck !== undefined ){
          return passedVisibilityCheck;
        }

        if( !visibleElementsOnly ){
          passedVisibilityCheck = true;
          return true;
        }

        var visible = edge.visible() && !edge.transparent();
        if( visible ){
          passedVisibilityCheck = true;
          return true;
        }

        passedVisibilityCheck = false;
        return false;
      };

      if (rs.edgeType === 'self') {
        if(
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY) )
            )
              ||
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY) )
            )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'haystack') {
        var radius = style['haystack-radius'].value;
        var halfRadius = radius/2; // b/c have to half width/height

        var tgtPos = tgt._private.position;
        var tgtW = tgt.width();
        var tgtH = tgt.height();
        var srcPos = src._private.position;
        var srcW = src.width();
        var srcH = src.height();

        var startX = srcPos.x + rs.source.x * srcW * halfRadius;
        var startY = srcPos.y + rs.source.y * srcH * halfRadius;
        var endX = tgtPos.x + rs.target.x * tgtW * halfRadius;
        var endY = tgtPos.y + rs.target.y * tgtH * halfRadius;

        if( 
          (inEdgeBB = $$.math.inLineVicinity(x, y, startX, startY, endX, endY, width2))
            && passesVisibilityCheck() &&
          widthSq + edgeThreshold > $$.math.sqDistanceToFiniteLine( x, y, startX, startY, endX, endY )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'straight') {
        if(
          (inEdgeBB = $$.math.inLineVicinity(x, y, rs.startX, rs.startY, rs.endX, rs.endY, width2))
            && passesVisibilityCheck() &&
          widthSq + edgeThreshold > $$.math.sqDistanceToFiniteLine(x, y, rs.startX, rs.startY, rs.endX, rs.endY)
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'bezier') {
        if(
          (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY, widthSq))
            && passesVisibilityCheck() &&
          (widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY))
        ){
          near.push( edge );
        }
      }
      
      if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){
        var srcShape = CanvasRenderer.arrowShapes[ style['source-arrow-shape'].value ];
        var tgtShape = CanvasRenderer.arrowShapes[ style['target-arrow-shape'].value ];

        var src = src || edge._private.source;
        var tgt = tgt || edge._private.target;

        var tgtPos = tgt._private.position;
        var srcPos = src._private.position;

        var srcArW = self.getArrowWidth( style['width'].pxValue );
        var srcArH = self.getArrowHeight( style['width'].pxValue );

        var tgtArW = srcArW;
        var tgtArH = srcArH;

        if(
          (
            srcShape.roughCollide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], 0)
              && 
            srcShape.collide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], 0)
          )
            ||
          (
            tgtShape.roughCollide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], 0)
              &&
            tgtShape.collide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], 0)
          )
        ){
          near.push( edge );
        }
      }

      // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
      if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){
        checkNode( src );
        checkNode( tgt );
      }
    }

    for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
      var ele = eles[i];

      if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early

      if( ele._private.group === 'nodes' ){ 
        checkNode( eles[i] );

      } else  { // then edge
        checkEdge( eles[i] );
      }

    }
  
    
    if( near.length > 0 ){
      return near[ near.length - 1 ];
    } else {
      return null;
    }
  }; 

  // 'Give me everything from this box'
  CanvasRenderer.prototype.getAllInBox = function(x1, y1, x2, y2) {
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var box = [];
    
    var x1c = Math.min(x1, x2);
    var x2c = Math.max(x1, x2);
    var y1c = Math.min(y1, y2);
    var y2c = Math.max(y1, y2); 

    x1 = x1c; 
    x2 = x2c; 
    y1 = y1c; 
    y2 = y2c; 

    var heur;
    
    for ( var i = 0; i < nodes.length; i++ ){
      var pos = nodes[i]._private.position;
      var nShape = this.getNodeShape(nodes[i]);
      var w = this.getNodeWidth(nodes[i]);
      var h = this.getNodeHeight(nodes[i]);
      var border = nodes[i]._private.style['border-width'].pxValue / 2;
      var shapeObj = CanvasRenderer.nodeShapes[ nShape ];

      if ( shapeObj.intersectBox(x1, y1, x2, y2, w, h, pos.x, pos.y, border) ){
        box.push(nodes[i]);
      }
    }
    
    for ( var i = 0; i < edges.length; i++ ){
      var rs = edges[i]._private.rscratch;

      if (edges[i]._private.rscratch.edgeType == 'self') {
        if ((heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2ax, rs.cp2ay,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2ax, rs.cp2ay,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
                ||
          (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2cx, rs.cp2cy,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2cx, rs.cp2cy,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
          )
        { box.push(edges[i]); }
      }
      
      if (rs.edgeType == 'bezier' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2x, rs.cp2y,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2x, rs.cp2y,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }
    
      if (rs.edgeType == 'straight' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.startX * 0.5 + rs.endX * 0.5, 
            rs.startY * 0.5 + rs.endY * 0.5, 
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              && /* console.log('test', heur) == undefined && */
            (heur == 2 || (heur == 1 && $$.math.checkStraightEdgeInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }


      if (rs.edgeType == 'haystack'){
        var tgt = edges[i].target()[0];
        var tgtPos = tgt.position();
        var src = edges[i].source()[0];
        var srcPos = src.position();

        var startX = srcPos.x + rs.source.x;
        var startY = srcPos.y + rs.source.y;
        var endX = tgtPos.x + rs.target.x;
        var endY = tgtPos.y + rs.target.y;

        var startInBox = (x1 <= startX && startX <= x2) && (y1 <= startY && startY <= y2);
        var endInBox = (x1 <= endX && endX <= x2) && (y1 <= endY && endY <= y2);

        if( startInBox && endInBox ){
          box.push( edges[i] );
        }
      }
      
    }
    
    return box;
  };


  /**
   * Returns the width of the given node. If the width is set to auto,
   * returns the value of the autoWidth field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CanvasRenderer.prototype.getNodeWidth = function(node)
  {
    return node.width();
  };

  /**
   * Returns the height of the given node. If the height is set to auto,
   * returns the value of the autoHeight field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CanvasRenderer.prototype.getNodeHeight = function(node)
  {
    return node.height();
  };

  /**
   * Returns the shape of the given node. If the height or width of the given node
   * is set to auto, the node is considered to be a compound.
   *
   * @param node          a node
   * @return {String}     shape of the node
   */
  CanvasRenderer.prototype.getNodeShape = function(node)
  {
    // TODO only allow rectangle for a compound node?
//    if (node._private.style['width'].value == 'auto' ||
//        node._private.style['height'].value == 'auto')
//    {
//      return 'rectangle';
//    }

    var shape = node._private.style['shape'].value;

    if( node.isParent() ){
      if( shape === 'rectangle' || shape === 'roundrectangle' ){
        return shape;
      } else {
        return 'rectangle';
      }
    }

    return shape;
  };


  CanvasRenderer.prototype.getNodePadding = function(node)
  {
    var left = node._private.style['padding-left'].pxValue;
    var right = node._private.style['padding-right'].pxValue;
    var top = node._private.style['padding-top'].pxValue;
    var bottom = node._private.style['padding-bottom'].pxValue;

    if (isNaN(left))
    {
      left = 0;
    }

    if (isNaN(right))
    {
      right = 0;
    }

    if (isNaN(top))
    {
      top = 0;
    }

    if (isNaN(bottom))
    {
      bottom = 0;
    }

    return {left : left,
      right : right,
      top : top,
      bottom : bottom};
  };

  CanvasRenderer.prototype.zOrderSort = $$.Collection.zIndexSort;

  CanvasRenderer.prototype.updateCachedZSortedEles = function(){
    this.getCachedZSortedEles( true );
  };

  CanvasRenderer.prototype.getCachedZSortedEles = function( forceRecalc ){
    var lastNodes = this.lastZOrderCachedNodes;
    var lastEdges = this.lastZOrderCachedEdges;
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var eles = [];

    if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){ 
      //console.time('cachezorder')
      
      for( var i = 0; i < nodes.length; i++ ){
        if( nodes[i].visible() && !nodes[i].transparent() ){
          eles.push( nodes[i] );
        }
      }

      for( var i = 0; i < edges.length; i++ ){
        if( edges[i].visible() && !edges[i].transparent() ){
          eles.push( edges[i] );
        }
      }

      eles.sort( this.zOrderSort );
      this.cachedZSortedEles = eles;
      //console.log('make cache')

      //console.timeEnd('cachezorder')
    } else {
      eles = this.cachedZSortedEles;
      //console.log('read cache')
    }

    this.lastZOrderCachedNodes = nodes;
    this.lastZOrderCachedEdges = edges;

    return eles;
  };

  CanvasRenderer.prototype.projectBezier = function(edge){
    var qbezierAt = $$.math.qbezierAt;
    var rs = edge._private.rscratch;
    var bpts = edge._private.rstyle.bezierPts = [];

    function pushBezierPts(pts){
      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )
      });

      var mid = {
        x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )
      };

      bpts.push( mid );

      if( rs.edgeType === 'self' ){
        rs.midX = rs.selfEdgeMidX;
        rs.midY = rs.selfEdgeMidY;
      } else {
        rs.midX = mid.x;
        rs.midY = mid.y;
      }

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )
      });
    }

    if( rs.edgeType === 'self' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY] );
      pushBezierPts( [rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY] );
    } else if( rs.edgeType === 'bezier' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY] );
    }
  };

  CanvasRenderer.prototype.recalculateNodeLabelProjection = function( node ){
    var content = node._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;
    var nodeWidth = node.outerWidth();
    var nodeHeight = node.outerHeight();
    var nodePos = node._private.position;
    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;
    var rstyle = node._private.rstyle;

    switch( textHalign ){
      case 'left':
        textX = nodePos.x - nodeWidth / 2;
        break;

      case 'right':
        textX = nodePos.x + nodeWidth / 2;
        break;

      default: // e.g. center
        textX = nodePos.x;
    }

    switch( textValign ){
      case 'top':
        textY = nodePos.y - nodeHeight / 2;
        break;

      case 'bottom':
        textY = nodePos.y + nodeHeight / 2;
        break;

      default: // e.g. middle
        textY = nodePos.y;
    }
  
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( node );
  };

  CanvasRenderer.prototype.recalculateEdgeLabelProjection = function( edge ){
    var content = edge._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;  
    var edgeCenterX, edgeCenterY;
    var rs = edge._private.rscratch;
    var rstyle = edge._private.rstyle;
    
    if (rs.edgeType == 'self') {
      edgeCenterX = rs.selfEdgeMidX;
      edgeCenterY = rs.selfEdgeMidY;
    } else if (rs.edgeType == 'straight') {
      edgeCenterX = (rs.startX + rs.endX) / 2;
      edgeCenterY = (rs.startY + rs.endY) / 2;
    } else if (rs.edgeType == 'bezier') {
      edgeCenterX = $$.math.qbezierAt( rs.startX, rs.cp2x, rs.endX, 0.5 );
      edgeCenterY = $$.math.qbezierAt( rs.startY, rs.cp2y, rs.endY, 0.5 );
    } else if (rs.edgeType == 'haystack') {
      var srcPos = edge._private.source._private.position;
      var tgtPos = edge._private.target._private.position;

      edgeCenterX = (srcPos.x + rs.source.x + tgtPos.x + rs.target.x)/2;
      edgeCenterY = (srcPos.y + rs.source.y + tgtPos.y + rs.target.y)/2;
    }
    
    textX = edgeCenterX;
    textY = edgeCenterY;

    // add center point to style so bounding box calculations can use it
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( edge );
  };

  CanvasRenderer.prototype.applyLabelDimensions = function( ele ){
    var rs = ele._private.rscratch;
    var rstyle = ele._private.rstyle;

    var text = this.getLabelText( ele );
    var labelDims = this.calculateLabelDimensions( ele, text );
 
    rstyle.labelWidth = labelDims.width;
    rs.labelWidth = labelDims.width;
 
    rstyle.labelHeight = labelDims.height;
    rs.labelHeight = labelDims.height;
  };

  CanvasRenderer.prototype.getLabelText = function( ele ){
    var style = ele._private.style;
    var text = ele._private.style['content'].strValue;
    var textTransform = style['text-transform'].value;
    
    if (textTransform == 'none') {
    } else if (textTransform == 'uppercase') {
      text = text.toUpperCase();
    } else if (textTransform == 'lowercase') {
      text = text.toLowerCase();
    }

    return text;
  };

  CanvasRenderer.prototype.calculateLabelDimensions = function( ele, text ){
    var r = this;
    var style = ele._private.style;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;

    var cacheKey = ele._private.labelKey;
    var cache = r.labelDimCache || (r.labelDimCache = {});

    if( cache[cacheKey] ){
      return cache[cacheKey];
    }

    var div = this.labelCalcDiv;

    if( !div ){
      div = this.labelCalcDiv = document.createElement('div');
      document.body.appendChild( div );
    }

    var ds = div.style;

    // from ele style
    ds.fontFamily = family;
    ds.fontStyle = fStyle;
    ds.fontSize = size;
    // ds.fontVariant = variant;
    ds.fontWeight = weight;

    // forced style
    ds.position = 'absolute';
    ds.left = '-9999px';
    ds.top = '-9999px';
    ds.zIndex = '-1';
    ds.visibility = 'hidden';
    ds.pointerEvents = 'none';
    ds.padding = '0';
    ds.lineHeight = '1';

    // put label content in div
    div.textContent = text;

    cache[cacheKey] = {
      width: div.clientWidth,
      height: div.clientHeight
    };

    return cache[cacheKey];
  };  

  CanvasRenderer.prototype.recalculateRenderedStyle = function( eles ){
    var edges = [];
    var nodes = [];
    var handledEdge = {};

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var _p = ele._private;
      var rs = _p.rscratch;
      var rstyle = _p.rstyle;
      var id = _p.data.id;
      var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;
      var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;
      var styleSame = bbStyleSame && labelStyleSame;

      if( ele._private.group === 'nodes' ){
        var pos = _p.position;
        var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;

        if( !posSame || !styleSame ){
          nodes.push( ele );
        }

        rstyle.nodeX = pos.x;
        rstyle.nodeY = pos.y;
      } else { // edges

        var srcPos = ele._private.source._private.position;
        var tgtPos = ele._private.target._private.position;
        var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;
        var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;
        var positionsSame = srcSame && tgtSame;

        if( !positionsSame || !styleSame ){
          var curveType = _p.style['curve-style'].value;

          if( curveType === 'bezier' ){
            if( !handledEdge[ id ] ){
              edges.push( ele );
              handledEdge[ id ] = true;

              var parallelEdges = ele.parallelEdges();
              for( var i = 0; i < parallelEdges.length; i++ ){
                var pEdge = parallelEdges[i];
                var pId = pEdge._private.data.id;

                if( !handledEdge[ pId ] ){
                  edges.push( pEdge );
                  handledEdge[ pId ] = true;
                }
                
              }
            }
          } else {
            edges.push( ele );
          }
        } // if positions diff

        // update rstyle positions
        rstyle.srcX = srcPos.x;
        rstyle.srcY = srcPos.y;
        rstyle.tgtX = tgtPos.x;
        rstyle.tgtY = tgtPos.y;

      } // if edges

      rs.boundingBoxKey = _p.boundingBoxKey;
      rs.labelKey = _p.labelKey;
    }

    this.recalculateEdgeProjections( edges );
    this.recalculateLabelProjections( nodes, edges );
  };

  CanvasRenderer.prototype.recalculateLabelProjections = function( nodes, edges ){
    for( var i = 0; i < nodes.length; i++ ){
      this.recalculateNodeLabelProjection( nodes[i] );
    }

    for( var i = 0; i < edges.length; i++ ){
      this.recalculateEdgeLabelProjection( edges[i] );
    }
  };

  CanvasRenderer.prototype.recalculateEdgeProjections = function( edges ){
    this.findEdgeControlPoints( edges );
  };


  // Find edge control points
  CanvasRenderer.prototype.findEdgeControlPoints = function(edges) {
    if( !edges || edges.length === 0 ){ return; }

    var hashTable = {};
    var pairIds = [];
    var haystackEdges = [];

    // create a table of edge (src, tgt) => list of edges between them
    var pairId;
    for (var i = 0; i < edges.length; i++){
      var edge = edges[i];
      var style = edge._private.style;
      var edgeIsUnbundled = style['curve-style'].value === 'unbundled-bezier';

      // ignore edges who are not to be displayed
      // they shouldn't take up space
      if( style.display.value === 'none' ){
        continue;
      }

      if( style['curve-style'].value === 'haystack' ){
        haystackEdges.push( edge );
        continue;
      }

      var srcId = edge._private.data.source;
      var tgtId = edge._private.data.target;

      pairId = srcId > tgtId ?
        tgtId + '-' + srcId :
        srcId + '-' + tgtId ;

      if( edgeIsUnbundled ){
        pairId = 'unbundled' + edge._private.data.id;
      }

      if (hashTable[pairId] == null) {
        hashTable[pairId] = [];
        pairIds.push( pairId );
      }
      
      hashTable[pairId].push( edge );

      if( edgeIsUnbundled ){
        hashTable[pairId].hasUnbundled = true;
      }
    }

    var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape, srcBorder, tgtBorder;
    var vectorNormInverse;
    var badBezier;
    
    // for each pair (src, tgt), create the ctrl pts
    // Nested for loop is OK; total number of iterations for both loops = edgeCount  
    for (var p = 0; p < pairIds.length; p++) {
      pairId = pairIds[p];
      var pairEdges = hashTable[pairId];
    
      // for each pair id, the edges should be sorted by index
      pairEdges.sort(function(edge1, edge2){
        return edge1._private.index - edge2._private.index;
      });

      src = pairEdges[0]._private.source;
      tgt = pairEdges[0]._private.target;

      // make sure src/tgt distinction is consistent
      // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)
      if( src._private.data.id > tgt._private.data.id ){
        var temp = src;
        src = tgt;
        tgt = temp;
      }

      srcPos = src._private.position;
      tgtPos = tgt._private.position;

      srcW = this.getNodeWidth(src);
      srcH = this.getNodeHeight(src);

      tgtW = this.getNodeWidth(tgt);
      tgtH = this.getNodeHeight(tgt);

      srcShape = CanvasRenderer.nodeShapes[ this.getNodeShape(src) ];
      tgtShape = CanvasRenderer.nodeShapes[ this.getNodeShape(tgt) ];

      srcBorder = src._private.style['border-width'].pxValue;
      tgtBorder = tgt._private.style['border-width'].pxValue;

      badBezier = false;
      

      if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){

        // pt outside src shape to calc distance/displacement from src to tgt
        var srcOutside = srcShape.intersectLine(
          srcPos.x,
          srcPos.y,
          srcW,
          srcH,
          tgtPos.x,
          tgtPos.y,
          srcBorder / 2
        );

        // pt outside tgt shape to calc distance/displacement from src to tgt
        var tgtOutside = tgtShape.intersectLine(
          tgtPos.x,
          tgtPos.y,
          tgtW,
          tgtH,
          srcPos.x,
          srcPos.y,
          tgtBorder / 2
        );

        var midptSrcPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };

        var dy = ( tgtOutside[1] - srcOutside[1] );
        var dx = ( tgtOutside[0] - srcOutside[0] );
        var l = Math.sqrt( dx*dx + dy*dy );

        var vector = {
          x: dx,
          y: dy
        };
        
        var vectorNorm = {
          x: vector.x/l,
          y: vector.y/l
        };
        vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        };

        // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw
        if( 
          tgtShape.checkPoint( srcOutside[0], srcOutside[1], tgtBorder/2, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||
          srcShape.checkPoint( tgtOutside[0], tgtOutside[1], srcBorder/2, srcW, srcH, srcPos.x, srcPos.y ) 
        ){
          vectorNormInverse = {};
          badBezier = true;
        }
        
      }
      
      var edge;
      var rs;
      
      for (var i = 0; i < pairEdges.length; i++) {
        edge = pairEdges[i];
        rs = edge._private.rscratch;
        
        var edgeIndex1 = rs.lastEdgeIndex;
        var edgeIndex2 = i;

        var numEdges1 = rs.lastNumEdges;
        var numEdges2 = pairEdges.length;

        var eStyle = edge._private.style;
        var stepSize = eStyle['control-point-step-size'].pxValue;
        var stepDist = eStyle['control-point-distance'] !== undefined ? eStyle['control-point-distance'].pxValue : undefined;
        var stepWeight = eStyle['control-point-weight'].value;
        var edgeIsUnbundled = eStyle['curve-style'].value === 'unbundled-bezier';

        var srcX1 = rs.lastSrcCtlPtX;
        var srcX2 = srcPos.x;
        var srcY1 = rs.lastSrcCtlPtY;
        var srcY2 = srcPos.y;
        var srcW1 = rs.lastSrcCtlPtW;
        var srcW2 = src.outerWidth();
        var srcH1 = rs.lastSrcCtlPtH;
        var srcH2 = src.outerHeight();

        var tgtX1 = rs.lastTgtCtlPtX;
        var tgtX2 = tgtPos.x;
        var tgtY1 = rs.lastTgtCtlPtY;
        var tgtY2 = tgtPos.y;
        var tgtW1 = rs.lastTgtCtlPtW;
        var tgtW2 = tgt.outerWidth();
        var tgtH1 = rs.lastTgtCtlPtH;
        var tgtH2 = tgt.outerHeight();

        var width1 = rs.lastW;
        var width2 = eStyle['control-point-step-size'].pxValue;

        if( badBezier ){
          rs.badBezier = true;
        } else {
          rs.badBezier = false;
        }

        if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
        &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
        &&  width1 === width2
        &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
          // console.log('edge ctrl pt cache HIT')
          continue; // then the control points haven't changed and we can skip calculating them
        } else {
          rs.lastSrcCtlPtX = srcX2;
          rs.lastSrcCtlPtY = srcY2;
          rs.lastSrcCtlPtW = srcW2;
          rs.lastSrcCtlPtH = srcH2;
          rs.lastTgtCtlPtX = tgtX2;
          rs.lastTgtCtlPtY = tgtY2;
          rs.lastTgtCtlPtW = tgtW2;
          rs.lastTgtCtlPtH = tgtH2;
          rs.lastEdgeIndex = edgeIndex2;
          rs.lastNumEdges = numEdges2;
          rs.lastWidth = width2;
          // console.log('edge ctrl pt cache MISS')
        }

        // Self-edge
        if ( src === tgt ) {
            
          rs.edgeType = 'self';
          
          var j = i;
          var loopDist = stepSize;

          if( edgeIsUnbundled ){
            j = 0;
            loopDist = stepDist;
          }

          // New -- fix for large nodes
          rs.cp2ax = srcPos.x;
          rs.cp2ay = srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1);
          
          rs.cp2cx = src._private.position.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1);
          rs.cp2cy = srcPos.y;
          
          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;
          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;
          
        // Straight edge
        } else if (pairEdges.length % 2 === 1
          && i === Math.floor(pairEdges.length / 2)
          && !edgeIsUnbundled ) {
          
          rs.edgeType = 'straight';
          
        // Bezier edge
        } else {
          var normStepDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manStepDist;
          var sign = $$.math.signum( normStepDist );

          if( edgeIsUnbundled ){
            manStepDist = stepDist;
          } else {
            manStepDist = stepDist !== undefined ? sign * stepDist : undefined; 
          }

          var distanceFromMidpoint = manStepDist !== undefined ? manStepDist : normStepDist;
          
          var w1 = (1 - stepWeight);
          var w2 = stepWeight;

          var swappedDirection = edge._private.source !== src;
          if( swappedDirection ){
            w1 = stepWeight;
            w2 = (1 - stepWeight);
          }

          var adjustedMidpt = {
            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
          };

          rs.edgeType = 'bezier';
          
          rs.cp2x = adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint;
          rs.cp2y = adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint;
          
          // console.log(edge, midPointX, displacementX, distanceFromMidpoint);
        }

        // find endpts for edge
        this.findEndpoints( edge );

        var badStart = !$$.is.number( rs.startX ) || !$$.is.number( rs.startY );
        var badAStart = !$$.is.number( rs.arrowStartX ) || !$$.is.number( rs.arrowStartY );
        var badEnd = !$$.is.number( rs.endX ) || !$$.is.number( rs.endY );
        var badAEnd = !$$.is.number( rs.arrowEndX ) || !$$.is.number( rs.arrowEndY );

        var minCpADistFactor = 3;
        var arrowW = this.getArrowWidth( edge._private.style['width'].pxValue ) * CanvasRenderer.arrowShapeHeight;
        var minCpADist = minCpADistFactor * arrowW;
        var startACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        if( rs.edgeType === 'bezier' ){
          var overlapping = false;

          if( badStart || badAStart || closeStartACp ){
            overlapping = true;

            // project control point along line from src centre to outside the src shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - srcPos.x,
              y: rs.cp2y - srcPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var srcCtrlPtIntn = srcShape.intersectLine(
              srcPos.x,
              srcPos.y,
              srcW,
              srcH,
              cpProj.x,
              cpProj.y,
              srcBorder / 2
            );

            if( closeStartACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - startACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - startACpDist);
            } else {
              rs.cp2x = srcCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = srcCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if( badEnd || badAEnd || closeEndACp ){
            overlapping = true;

            // project control point along line from tgt centre to outside the tgt shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - tgtPos.x,
              y: rs.cp2y - tgtPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var tgtCtrlPtIntn = tgtShape.intersectLine(
              tgtPos.x,
              tgtPos.y,
              tgtW,
              tgtH,
              cpProj.x,
              cpProj.y,
              tgtBorder / 2
            );

            if( closeEndACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - endACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - endACpDist);
            } else {
              rs.cp2x = tgtCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
            }
            
          }

          if( overlapping ){
            // recalc endpts
            this.findEndpoints( edge );
          }
        } else if( rs.edgeType === 'straight' ){
          rs.midX = ( srcX2 + tgtX2 )/2;
          rs.midY = ( srcY2 + tgtY2 )/2;
        }

        // project the edge into rstyle
        this.projectBezier( edge );

      }
    }
      
    for( var i = 0; i < haystackEdges.length; i++ ){
      var edge = haystackEdges[i];
      var rscratch = edge._private.rscratch;

      if( !rscratch.haystack ){
        var angle = Math.random() * 2 * Math.PI;

        rscratch.source = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };

        var angle = Math.random() * 2 * Math.PI;

        rscratch.target = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };
      }  

      // always override as haystack in case set to different type previously
      rscratch.edgeType = 'haystack';
      rscratch.haystack = true;
    }

    return hashTable;
  };

  CanvasRenderer.prototype.findEndpoints = function(edge) {
    var intersect;

    var source = edge.source()[0];
    var target = edge.target()[0];
    
    var tgtArShape = edge._private.style['target-arrow-shape'].value;
    var srcArShape = edge._private.style['source-arrow-shape'].value;

    var tgtBorderW = target._private.style['border-width'].pxValue;
    var srcBorderW = source._private.style['border-width'].pxValue;

    var rs = edge._private.rscratch;
    
    if (edge._private.rscratch.edgeType == 'self') {
      
      var cp = [rs.cp2cx, rs.cp2cy];
      
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0],
        cp[1], 
        tgtBorderW / 2
      );
      
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      var cp = [rs.cp2ax, rs.cp2ay];

      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));
      
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];


      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
    } else if (rs.edgeType == 'straight') {
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        source.position().x,
        source.position().y,
        tgtBorderW / 2);
        
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
  //      return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      var arrowEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));

      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        target.position().x,
        target.position().y,
        srcBorderW / 2);
      
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
  //      return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      /*
      console.log("1: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));

      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
            
    } else if (rs.edgeType == 'bezier') {
      // if( window.badArrow) debugger;
      var cp = [rs.cp2x, rs.cp2y];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        tgtBorderW / 2
      );
      
      /*
      console.log("2: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge)
      );
      var edgeStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge)
      );
    
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
      // if( isNaN(rs.startX) || isNaN(rs.startY) ){
      //   debugger;
      // }

    } else if (rs.isArcEdge) {
      return;
    }
  };

  // Find adjacent edges
  CanvasRenderer.prototype.findEdges = function(nodeSet) {
    
    var edges = this.getCachedEdges();
    
    var hashTable = {};
    var adjacentEdges = [];
    
    for (var i = 0; i < nodeSet.length; i++) {
      hashTable[nodeSet[i]._private.data.id] = nodeSet[i];
    }
    
    for (var i = 0; i < edges.length; i++) {
      if (hashTable[edges[i]._private.data.source]
        || hashTable[edges[i]._private.data.target]) {
        
        adjacentEdges.push(edges[i]);
      }
    }
    
    return adjacentEdges;
  };

  CanvasRenderer.prototype.getArrowWidth = CanvasRenderer.prototype.getArrowHeight = function(edgeWidth) {
    var cache = this.arrowWidthCache = this.arrowWidthCache || {};

    var cachedVal = cache[edgeWidth];
    if( cachedVal ){
      return cachedVal;
    }

    cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);
    cache[edgeWidth] = cachedVal;

    return cachedVal;
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

// Draw edge
  CanvasRenderer.prototype.drawEdge = function(context, edge, drawOverlayInstead) {
    var rs = edge._private.rscratch;
    var usePaths = CanvasRenderer.usePaths();

    // if bezier ctrl pts can not be calculated, then die
    if( rs.badBezier || ( (rs.edgeType === 'bezier' || rs.edgeType === 'straight') && isNaN(rs.startX)) ){ // extra isNaN() for safari 7.1 b/c it mangles ctrlpt calcs
      return;
    }

    var style = edge._private.style;
    
    // Edge line width
    if (style['width'].pxValue <= 0) {
      return;
    }

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    // Edge color & opacity
    if( drawOverlayInstead ){

      if( overlayOpacity === 0 ){ // exit early if no overlay
        return;
      }

      this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
      context.lineCap = 'round';

      if( edge._private.rscratch.edgeType == 'self' && !usePaths ){
        context.lineCap = 'butt';
      }

    } else {
      var lineColor = style['line-color'].value;

      this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);
      
      context.lineCap = 'butt'; 
    }
    
    var startNode, endNode, source, target;
    source = startNode = edge._private.source;
    target = endNode = edge._private.target;

    var targetPos = target._private.position;
    var targetW = target.width();
    var targetH = target.height();
    var sourcePos = source._private.position;
    var sourceW = source.width();
    var sourceH = source.height();


    var edgeWidth = style['width'].pxValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
    var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;
    context.lineWidth = edgeWidth;
    
    if( rs.edgeType !== 'haystack' ){
      //this.findEndpoints(edge);
    }
    
    if( rs.edgeType === 'haystack' ){
      var radius = style['haystack-radius'].value;
      var halfRadius = radius/2; // b/c have to half width/height

      this.drawStyledEdge(
        edge, 
        context, 
        rs.haystackPts = [
          rs.source.x * sourceW * halfRadius + sourcePos.x,
          rs.source.y * sourceH * halfRadius + sourcePos.y,
          rs.target.x * targetW * halfRadius + targetPos.x,
          rs.target.y * targetH * halfRadius + targetPos.y
        ],
        lineStyle,
        edgeWidth
      );
    } else if (rs.edgeType === 'self') {
      
      var details = edge._private.rscratch;
      var points = [details.startX, details.startY, details.cp2ax,
        details.cp2ay, details.selfEdgeMidX, details.selfEdgeMidY,
        details.selfEdgeMidX, details.selfEdgeMidY,
        details.cp2cx, details.cp2cy, details.endX, details.endY];

      var details = edge._private.rscratch;
      this.drawStyledEdge(edge, context, points, lineStyle, edgeWidth);
      
    } else if (rs.edgeType === 'straight') {
      
      var nodeDirectionX = endNode._private.position.x - startNode._private.position.x;
      var nodeDirectionY = endNode._private.position.y - startNode._private.position.y;
      
      var edgeDirectionX = rs.endX - rs.startX;
      var edgeDirectionY = rs.endY - rs.startY;
      
      if (nodeDirectionX * edgeDirectionX
        + nodeDirectionY * edgeDirectionY < 0) {
        
        rs.straightEdgeTooShort = true;  
      } else {
        
        var details = rs;
        this.drawStyledEdge(edge, context, [details.startX, details.startY,
                                      details.endX, details.endY],
                                      lineStyle,
                                      edgeWidth);
        
        rs.straightEdgeTooShort = false;  
      }  
    } else {
      
      var details = rs;
      
      this.drawStyledEdge(edge, context, [details.startX, details.startY,
        details.cp2x, details.cp2y, details.endX, details.endY],
        lineStyle,
        edgeWidth);
      
    }
    
    if( rs.edgeType === 'haystack' ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    } else if ( rs.noArrowPlacement !== true && rs.startX !== undefined ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    }

  };
  
  
  CanvasRenderer.prototype.drawStyledEdge = function(
      edge, context, pts, type, width) {

    // 3 points given -> assume Bezier
    // 2 -> assume straight
    
    var rs = edge._private.rscratch;
    var canvasCxt = context;
    var path;
    var pathCacheHit = false;
    var usePaths = CanvasRenderer.usePaths();


    if( usePaths ){

      var pathCacheKey = pts;
      var keyLengthMatches = rs.pathCacheKey && pathCacheKey.length === rs.pathCacheKey.length;
      var keyMatches = keyLengthMatches;

      for( var i = 0; keyMatches && i < pathCacheKey.length; i++ ){
        if( rs.pathCacheKey[i] !== pathCacheKey[i] ){
          keyMatches = false;
        }
      }

      if( keyMatches ){
        path = context = rs.pathCache;
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.pathCacheKey = pathCacheKey;
        rs.pathCache = path;
      }

    }

    if( canvasCxt.setLineDash ){ // for very outofdate browsers
      switch( type ){
        case 'dotted':
          canvasCxt.setLineDash([ 1, 1 ]);
          break;

        case 'dashed':
          canvasCxt.setLineDash([ 6, 3 ]);
          break;

        case 'solid':
          canvasCxt.setLineDash([ ]);
          break;
      }
    }

    if( !pathCacheHit ){
      if( context.beginPath ){ context.beginPath(); }
      context.moveTo(pts[0], pts[1]);
      
      if (pts.length === 3 * 2) { // bezier
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
      } else if( pts.length === 3 * 2 * 2 ){ // double bezier loop
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
        context.quadraticCurveTo(pts[8], pts[9], pts[10], pts[11]);
      } else { // line
        context.lineTo(pts[2], pts[3]);
      }
    }

    context = canvasCxt;
    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }
  
    // reset any line dashes
    if( context.setLineDash ){ // for very outofdate browsers
      context.setLineDash([ ]);
    }

  };

  CanvasRenderer.prototype.drawArrowheads = function(context, edge, drawOverlayInstead) {
    if( drawOverlayInstead ){ return; } // don't do anything for overlays 

    var rs = edge._private.rscratch;
    var self = this;
    var isHaystack = rs.edgeType === 'haystack';

    // Displacement gives direction for arrowhead orientation
    var dispX, dispY;
    var startX, startY, endX, endY;

    var srcPos = edge.source().position();
    var tgtPos = edge.target().position();

    if( isHaystack ){
      startX = rs.haystackPts[0];
      startY = rs.haystackPts[1];
      endX = rs.haystackPts[2];
      endY = rs.haystackPts[3];
    } else {
      startX = rs.arrowStartX;
      startY = rs.arrowStartY;
      endX = rs.arrowEndX;
      endY = rs.arrowEndY;
    }

    var style = edge._private.style;
    
    function drawArrowhead( prefix, x, y, dispX, dispY ){
      var arrowShape = style[prefix + '-arrow-shape'].value;

      if( arrowShape === 'none' ){
        return;
      }

      var gco = context.globalCompositeOperation;

      context.globalCompositeOperation = 'destination-out';
      
      self.fillStyle(context, 255, 255, 255, 1);


      var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';
      var arrowFill = style[prefix + '-arrow-fill'].value;

      if( arrowShape === 'half-triangle-overshot' ){
        arrowFill = 'hollow';
        arrowClearFill = 'hollow';
      }

      self.drawArrowShape( edge, prefix, context, 
        arrowClearFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
        x, y, dispX, dispY
      );

      context.globalCompositeOperation = gco;

      var color = style[prefix + '-arrow-color'].value;
      self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);

      self.drawArrowShape( edge, prefix, context, 
        arrowFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
        x, y, dispX, dispY
      );
    }

    dispX = startX - srcPos.x;
    dispY = startY - srcPos.y;

    if( !isHaystack && !isNaN(startX) && !isNaN(startY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'source', startX, startY, dispX, dispY );

    } else {
      // window.badArrow = true;
      // debugger;
    }
    
    var midX = rs.midX;
    var midY = rs.midY;

    if( isHaystack ){
      midX = ( startX + endX )/2;
      midY = ( startY + endY )/2;
    }

    dispX = startX - endX;
    dispY = startY - endY;

    if( rs.edgeType === 'self' ){
      dispX = 1;
      dispY = -1;
    }

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-target', midX, midY, dispX, dispY );
    }

    dispX *= -1;
    dispY *= -1;

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-source', midX, midY, dispX, dispY );
    }
    
    dispX = endX - tgtPos.x;
    dispY = endY - tgtPos.y;
    
    if( !isHaystack && !isNaN(endX) && !isNaN(endY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'target', endX, endY, dispX, dispY );
    }
  };
  
  // Draw arrowshape
  CanvasRenderer.prototype.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, dispX, dispY) {
    var usePaths = CanvasRenderer.usePaths();
    var rs = edge._private.rscratch;
    var pathCacheHit = false;
    var path;
    var canvasContext = context;
    var translation = { x: x, y: y };

    // Negative of the angle
    var angle = Math.asin(dispY / (Math.sqrt(dispX * dispX + dispY * dispY)));
  
    if (dispX < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = - (Math.PI / 2 + angle);
    }
    
    var size = this.getArrowWidth( edgeWidth );
    var shapeImpl = CanvasRenderer.arrowShapes[shape];

    // context.translate(x, y);

    if( usePaths ){
      var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
      rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
      rs.arrowPathCache = rs.arrowPathCache || {};

      var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
      if( alreadyCached ){
        path = context = rs.arrowPathCache[arrowType];
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.arrowPathCacheKey[arrowType] = pathCacheKey;
        rs.arrowPathCache[arrowType] = path;
      }
    }

    if( context.beginPath ){ context.beginPath(); }

    if( !pathCacheHit ){
      shapeImpl.draw(context, size, angle, translation);
    }
    
    if( !shapeImpl.leavePathOpen && context.closePath ){
      context.closePath();
    }

    context = canvasContext;

    if( fill === 'filled' || fill === 'both' ){
      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }
    }

    if( fill === 'hollow' || fill === 'both' ){
      context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
      context.lineJoin = 'miter';

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }
      
    }

    // context.translate(-x, -y);
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  CanvasRenderer.prototype.getCachedImage = function(url, onLoad) {
    var r = this;
    var imageCache = r.imageCache = r.imageCache || {};

    if( imageCache[url] && imageCache[url].image ){
      return imageCache[url].image;
    }
    
    var cache = imageCache[url] = imageCache[url] || {};

    var image = cache.image = new Image();
    image.addEventListener('load', onLoad);
    image.src = url;
    
    return image;
  };
    
  CanvasRenderer.prototype.drawInscribedImage = function(context, img, node) {
    var r = this;
    var nodeX = node._private.position.x;
    var nodeY = node._private.position.y;
    var style = node._private.style;
    var fit = style['background-fit'].value;
    var xPos = style['background-position-x'];
    var yPos = style['background-position-y'];
    var repeat = style['background-repeat'].value;
    var nodeW = node.width();
    var nodeH = node.height();
    var rs = node._private.rscratch;
    var clip = style['background-clip'].value;
    var shouldClip = clip === 'node';
    var imgOpacity = style['background-image-opacity'].value;
    
    var w = img.width;
    var h = img.height;

    if( w === 0 || h === 0 ){
      return; // no point in drawing empty image (and chrome is broken in this case)
    }

    if( fit === 'contain' ){
      var scale = Math.min( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;

    } else if( fit === 'cover' ){
      var scale = Math.max( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;
    }

    var x = (nodeX - nodeW/2); // left
    if( xPos.units === '%' ){
      x += (nodeW - w) * xPos.value/100;
    } else {
      x += xPos.pxValue;
    }

    var y = (nodeY - nodeH/2); // top
    if( yPos.units === '%' ){
      y += (nodeH - h) * yPos.value/100;
    } else {
      y += yPos.pxValue;
    }

    if( rs.pathCache ){
      x -= nodeX;
      y -= nodeY;

      nodeX = 0;
      nodeY = 0;
    }

    var gAlpha = context.globalAlpha;

    context.globalAlpha = imgOpacity;

    if( repeat === 'no-repeat' ){

      if( shouldClip ){
        context.save();

        if( rs.pathCache ){
          context.clip( rs.pathCache );
        } else {
          CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
            context,
            nodeX, nodeY, 
            nodeW, nodeH);

          context.clip();
        }
      }

      context.drawImage( img, 0, 0, img.width, img.height, x, y, w, h );

      if( shouldClip ){
        context.restore();
      }
    } else {
      var pattern = context.createPattern( img, repeat );
      context.fillStyle = pattern;

      CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
          context,
          nodeX, nodeY, 
          nodeW, nodeH);

        context.translate(x, y);
        context.fill();
        context.translate(-x, -y);
    }

    context.globalAlpha = gAlpha;
    
  };

  
})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // Draw edge text
  CanvasRenderer.prototype.drawEdgeText = function(context, edge) {
    var text = edge._private.style['content'].strValue;

    if( !text || text.match(/^\s+$/) ){
      return;
    }

    if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching

    var computedSize = edge._private.style['font-size'].pxValue * edge.cy().zoom();
    var minSize = edge._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }
  
    // Calculate text draw position
    
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    // this.recalculateEdgeLabelProjection( edge );
    
    var rs = edge._private.rscratch;
    this.drawText(context, edge, rs.labelX, rs.labelY);
  };

  // Draw node text
  CanvasRenderer.prototype.drawNodeText = function(context, node) {
    var text = node._private.style['content'].strValue;

    if ( !text || text.match(/^\s+$/) ) {
      return;
    }

    var computedSize = node._private.style['font-size'].pxValue * node.cy().zoom();
    var minSize = node._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }
      
    // this.recalculateNodeLabelProjection( node );

    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;

    switch( textHalign ){
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default: // e.g. center
        context.textAlign = 'center';
    }

    switch( textValign ){
      case 'top':
        context.textBaseline = 'bottom';
        break;

      case 'bottom':
        context.textBaseline = 'top';
        break;

      default: // e.g. center
        context.textBaseline = 'middle';
    }

    this.drawText(context, node, rs.labelX, rs.labelY);
  };
  
  CanvasRenderer.prototype.getFontCache = function(context){
    var cache;

    this.fontCaches = this.fontCaches || [];

    for( var i = 0; i < this.fontCaches.length; i++ ){
      cache = this.fontCaches[i];

      if( cache.context === context ){
        return cache;
      }
    }

    cache = {
      context: context
    };
    this.fontCaches.push(cache);

    return cache;
  };

  // set up canvas context with font
  // returns transformed text string
  CanvasRenderer.prototype.setupTextStyle = function( context, element ){
    // Font style
    var parentOpacity = element.effectiveOpacity();
    var style = element._private.style;
    var labelStyle = style['font-style'].strValue;
    var labelSize = style['font-size'].pxValue + 'px';
    var labelFamily = style['font-family'].strValue;
    var labelWeight = style['font-weight'].strValue;
    var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;
    var outlineOpacity = style['text-outline-opacity'].value * opacity;
    var color = style['color'].value;
    var outlineColor = style['text-outline-color'].value;

    var fontCacheKey = element._private.fontKey;
    var cache = this.getFontCache(context);

    if( cache.key !== fontCacheKey ){
      context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

      cache.key = fontCacheKey;
    }

    var text = String(style['content'].value);
    var textTransform = style['text-transform'].value;
    
    if (textTransform == 'none') {
    } else if (textTransform == 'uppercase') {
      text = text.toUpperCase();
    } else if (textTransform == 'lowercase') {
      text = text.toLowerCase();
    }
    
    // Calculate text draw position based on text alignment
    
    // so text outlines aren't jagged
    context.lineJoin = 'round';

    this.fillStyle(context, color[0], color[1], color[2], opacity);
    
    this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);

    return text;
  };

  // Draw text
  CanvasRenderer.prototype.drawText = function(context, element, textX, textY) {
    var style = element._private.style;
    var parentOpacity = element.effectiveOpacity();
    if( parentOpacity === 0 ){ return; }

    var text = this.setupTextStyle( context, element );
    
    if ( text != null && !isNaN(textX) && !isNaN(textY) ) {
     
      var lineWidth = 2  * style['text-outline-width'].value; // *2 b/c the stroke is drawn centred on the middle
      if (lineWidth > 0) {
        context.lineWidth = lineWidth;
        context.strokeText(text, textX, textY);
      }

      context.fillText(text, textX, textY);
    }
  };

  
})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // Draw node
  CanvasRenderer.prototype.drawNode = function(context, node, drawOverlayInstead) {

    var r = this;
    var nodeWidth, nodeHeight;
    var style = node._private.style;
    var rs = node._private.rscratch;
    
    var usePaths = CanvasRenderer.usePaths();
    var canvasContext = context;
    var path;
    var pathCacheHit = false;

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw
      return;
    }

    var parentOpacity = node.effectiveOpacity();
    if( parentOpacity === 0 ){ return; }

    nodeWidth = this.getNodeWidth(node);
    nodeHeight = this.getNodeHeight(node);
    
    context.lineWidth = style['border-width'].pxValue;

    if( drawOverlayInstead === undefined || !drawOverlayInstead ){

      // Node color & opacity

      var bgColor = style['background-color'].value;
      var borderColor = style['border-color'].value;
      var borderStyle = style['border-style'].value;

      this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * style['opacity'].value * parentOpacity);
      
      this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * style['opacity'].value * parentOpacity);

      context.lineJoin = 'miter'; // so borders are square with the node shape

      if( context.setLineDash ){ // for very outofdate browsers
        switch( borderStyle ){
          case 'dotted':
            context.setLineDash([ 1, 1 ]);
            break;

          case 'dashed':
            context.setLineDash([ 4, 2 ]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([ ]);
            break;
        }
      }

      //var image = this.getCachedImage('url');
      
      var url = style['background-image'].value[2] ||
        style['background-image'].value[1];
      
      var styleShape = style['shape'].strValue;

      var pos = node._private.position;

      if( usePaths ){
        var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;

        context.translate( pos.x, pos.y );

        if( rs.pathCacheKey === pathCacheKey ){
          path = context = rs.pathCache;
          pathCacheHit = true;
        } else {
          path = context = new Path2D();
          rs.pathCacheKey = pathCacheKey;
          rs.pathCache = path;
        }
      }

      if( !pathCacheHit ){

        var npos = pos;

        if( usePaths ){
          npos = {
            x: 0,
            y: 0
          };
        }

        CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
              context,
              npos.x,
              npos.y,
              nodeWidth,
              nodeHeight);
      }

      context = canvasContext;

      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }

      if (url !== undefined) {
        
        // get image, and if not loaded then ask to redraw when later loaded
        var image = this.getCachedImage(url, function(){
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
          
          r.redraw();
        });
        
        if( image.complete ){
          this.drawInscribedImage(context, image, node);
        }
        
      } 
      
      var darkness = style['background-blacken'].value;
      var borderWidth = style['border-width'].pxValue;

      if( this.hasPie(node) ){
        this.drawPie(context, node);

        // redraw path for blacken and border
        if( darkness !== 0 || borderWidth !== 0 ){

          if( !usePaths ){
            CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
                context,
                pos.x,
                pos.y,
                nodeWidth,
                nodeHeight);
          }
        }
      }

      if( darkness > 0 ){
        this.fillStyle(context, 0, 0, 0, darkness);

        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
        
      } else if( darkness < 0 ){
        this.fillStyle(context, 255, 255, 255, -darkness);
        
        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
      }

      // Border width, draw border
      if (borderWidth > 0) {

        if( usePaths ){
          context.stroke( path );
        } else {
          context.stroke();
        }

        if( borderStyle === 'double' ){
          context.lineWidth = style['border-width'].pxValue/3;

          var gco = context.globalCompositeOperation;
          context.globalCompositeOperation = 'destination-out';

          if( usePaths ){
            context.stroke( path );
          } else {
            context.stroke();
          }

          context.globalCompositeOperation = gco;
        }

      }

      if( usePaths ){
        context.translate( -pos.x, -pos.y );
      }

      // reset in case we changed the border style
      if( context.setLineDash ){ // for very outofdate browsers
        context.setLineDash([ ]);
      }

    // draw the overlay
    } else {

      if( overlayOpacity > 0 ){
        this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

        CanvasRenderer.nodeShapes['roundrectangle'].drawPath(
          context,
          node._private.position.x,
          node._private.position.y,
          nodeWidth + overlayPadding * 2,
          nodeHeight + overlayPadding * 2
        );

        context.fill();
      }
    }

  };

  // does the node have at least one pie piece?
  CanvasRenderer.prototype.hasPie = function(node){
    node = node[0]; // ensure ele ref
    
    return node._private.hasPie;
  };

  CanvasRenderer.prototype.drawPie = function(context, node){
    node = node[0]; // ensure ele ref

    var pieSize = node._private.style['pie-size'];
    var nodeW = this.getNodeWidth( node );
    var nodeH = this.getNodeHeight( node );
    var x = node._private.position.x;
    var y = node._private.position.y;
    var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
    var usePaths = CanvasRenderer.usePaths();

    if( usePaths ){
      x = 0;
      y = 0;
    }

    if( pieSize.units === '%' ){
      radius = radius * pieSize.value / 100;
    } else if( pieSize.pxValue !== undefined ){
      radius = pieSize.pxValue / 2;
    }

    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
      var size = node._private.style['pie-' + i + '-background-size'].value;
      var color = node._private.style['pie-' + i + '-background-color'].value;
      var opacity = node._private.style['pie-' + i + '-background-opacity'].value;
      var percent = size / 100; // map integer range [0, 100] to [0, 1]
      var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
      var angleDelta = 2 * Math.PI * percent;
      var angleEnd = angleStart + angleDelta;

      // ignore if
      // - zero size
      // - we're already beyond the full circle
      // - adding the current slice would go beyond the full circle
      if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
        continue;
      }

      context.beginPath();
      context.moveTo(x, y);
      context.arc( x, y, radius, angleStart, angleEnd );
      context.closePath();

      this.fillStyle(context, color[0], color[1], color[2], opacity);

      context.fill();

      lastPercent += percent;
    }

  };

  
})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // var isFirefox = typeof InstallTrigger !== 'undefined';

  CanvasRenderer.prototype.getPixelRatio = function(){ 
    var context = this.data.contexts[0];

    if( this.forcedPixelRatio != null ){
      return this.forcedPixelRatio;
    }

    var backingStore = context.backingStorePixelRatio ||
      context.webkitBackingStorePixelRatio ||
      context.mozBackingStorePixelRatio ||
      context.msBackingStorePixelRatio ||
      context.oBackingStorePixelRatio ||
      context.backingStorePixelRatio || 1;

    //console.log(window.devicePixelRatio, backingStore);

    // if( isFirefox ){ // because ff can't scale canvas properly
    //   return 1;
    // }

    return (window.devicePixelRatio || 1) / backingStore;
  };

  CanvasRenderer.prototype.paintCache = function(context){
    var caches = this.paintCaches = this.paintCaches || [];
    var needToCreateCache = true;
    var cache;

    for(var i = 0; i < caches.length; i++ ){
      cache = caches[i];

      if( cache.context === context ){
        needToCreateCache = false;
        break;
      }
    }

    if( needToCreateCache ){
      cache = {
        context: context
      };
      caches.push( cache );
    }

    return cache;
  };

  CanvasRenderer.prototype.fillStyle = function(context, r, g, b, a){
    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.fillStyle !== fillStyle ){
    //   context.fillStyle = cache.fillStyle = fillStyle;
    // }
  };

  CanvasRenderer.prototype.strokeStyle = function(context, r, g, b, a){
    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.strokeStyle !== strokeStyle ){
    //   context.strokeStyle = cache.strokeStyle = strokeStyle;
    // }
  };

  // Resize canvas
  CanvasRenderer.prototype.matchCanvasSize = function(container) {
    var data = this.data;
    var width = container.clientWidth;
    var height = container.clientHeight;
    var pixelRatio = this.getPixelRatio();
    var canvasWidth = width * pixelRatio;
    var canvasHeight = height * pixelRatio;
    var canvas;

    if( canvasWidth === this.canvasWidth && canvasHeight === this.canvasHeight ){
      return; // save cycles if same
    }

    this.fontCaches = null; // resizing resets the style

    var canvasContainer = data.canvasContainer;
    canvasContainer.style.width = width + 'px';
    canvasContainer.style.height = height + 'px';

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {

      canvas = data.canvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      
      canvas = data.bufferCanvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }

    this.textureMult = 1;
    if( pixelRatio <= 1 ){
      canvas = data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

      this.textureMult = 2;
      canvas.width = canvasWidth * this.textureMult;
      canvas.height = canvasHeight * this.textureMult;
    }

    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;

  };

  CanvasRenderer.prototype.renderTo = function( cxt, zoom, pan, pxRatio ){
    this.redraw({
      forcedContext: cxt,
      forcedZoom: zoom,
      forcedPan: pan,
      drawAllLayers: true,
      forcedPxRatio: pxRatio
    });
  };

  CanvasRenderer.prototype.timeToRender = function(){
    return this.redrawTotalTime / this.redrawCount;
  };

  CanvasRenderer.minRedrawLimit = 1000/60; // people can't see much better than 60fps
  CanvasRenderer.maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth
  CanvasRenderer.motionBlurDelay = 100;

  // Redraw frame
  CanvasRenderer.prototype.redraw = function( options ) {
    options = options || {};

    // console.log('redraw');

    var forcedContext = options.forcedContext;
    var drawAllLayers = options.drawAllLayers;
    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
    var forcedZoom = options.forcedZoom;
    var forcedPan = options.forcedPan;
    var r = this;
    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
    var cy = r.data.cy; var data = r.data; 
    var needDraw = data.canvasNeedsRedraw;
    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled;

    if( motionBlur && r.motionBlurTimeout ){
      clearTimeout( r.motionBlurTimeout );
    }

    if( !forcedContext && this.redrawTimeout ){
      clearTimeout( this.redrawTimeout );
    }
    this.redrawTimeout = null;

    if( this.averageRedrawTime === undefined ){ this.averageRedrawTime = 0; }

    var minRedrawLimit = CanvasRenderer.minRedrawLimit; 
    var maxRedrawLimit = CanvasRenderer.maxRedrawLimit;

    var redrawLimit = this.averageRedrawTime; // estimate the ideal redraw limit based on how fast we can draw
    redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;
    redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;

    //console.log('--\nideal: %i; effective: %i', this.averageRedrawTime, redrawLimit);

    if( this.lastDrawTime === undefined ){ this.lastDrawTime = 0; }

    var nowTime = +new Date();
    var timeElapsed = nowTime - this.lastDrawTime;
    var callAfterLimit = timeElapsed >= redrawLimit;

    if( !forcedContext ){
      if( !callAfterLimit || this.currentlyDrawing ){
        // console.log('-- skip');

        // we have new things to draw but we're busy, so try again when possibly free
        this.redrawTimeout = setTimeout(function(){
          r.redraw();
        }, redrawLimit);
        return;
      }

      this.lastDrawTime = nowTime;
      this.currentlyDrawing = true;
    }


    var startTime = +new Date();

    //console.log('-- redraw --')


    function drawToContext(){ 
      // startTime = +new Date();
      // console.profile('draw' + startTime)
      var edges = r.getCachedEdges();
      var coreStyle = cy.style()._private.coreStyle;
      
      var zoom = cy.zoom();
      var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
      var pan = cy.pan();
      var effectivePan = {
        x: pan.x,
        y: pan.y
      };

      if( forcedPan ){
        effectivePan = forcedPan;
      }

      // apply pixel ratio

      effectiveZoom *= pixelRatio;
      effectivePan.x *= pixelRatio;
      effectivePan.y *= pixelRatio;
      
      var eles = {
        drag: {
          nodes: [],
          edges: [],
          eles: []
        },
        nondrag: {
          nodes: [],
          edges: [],
          eles: []
        }
      };

      function setContextTransform(context, clear){
        context.setTransform(1, 0, 0, 1, 0, 0);

        if( clear === 'motionBlur' ){
          var gco = context.globalCompositeOperation;

          context.globalCompositeOperation = 'destination-out';
          r.fillStyle( context, 255, 255, 255, 0.666 );
          context.fillRect(0, 0, r.canvasWidth, r.canvasHeight);

          context.globalCompositeOperation = gco;
        } else if( !forcedContext && (clear === undefined || clear) ){
          context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
        }
        
        if( !drawAllLayers ){
          context.translate(effectivePan.x, effectivePan.y);
          context.scale(effectiveZoom, effectiveZoom);
        }
        if( forcedPan ){
          context.translate(forcedPan.x, forcedPan.y);
        } 
        if( forcedZoom ){
          context.scale(forcedZoom, forcedZoom);
        }
      }

      var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);

      if( textureDraw ){

        var bb;

        if( !r.textureCache ){
          r.textureCache = {};

          bb = r.textureCache.bb = cy.elements().boundingBox();

          r.textureCache.texture = r.data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

          var cxt = r.data.bufferContexts[ CanvasRenderer.TEXTURE_BUFFER ];

          cxt.setTransform(1, 0, 0, 1, 0, 0);
          cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
          
          r.redraw({
            forcedContext: cxt,
            drawOnlyNodeLayer: true,
            forcedPxRatio: pixelRatio * r.textureMult
          });

          var vp = r.textureCache.viewport = {
            zoom: cy.zoom(),
            pan: cy.pan(),
            width: r.canvasWidth,
            height: r.canvasHeight
          };

          vp.mpan = {
            x: (0 - vp.pan.x)/vp.zoom,
            y: (0 - vp.pan.y)/vp.zoom
          };
        }

        needDraw[CanvasRenderer.DRAG] = false;
        needDraw[CanvasRenderer.NODE] = false;

        var context = data.contexts[CanvasRenderer.NODE];

        var texture = r.textureCache.texture;
        var vp = r.textureCache.viewport;
        bb = r.textureCache.bb;

        context.setTransform(1, 0, 0, 1, 0, 0);
        context.clearRect(0, 0, vp.width, vp.height);

        var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
        var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
        r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
        context.fillRect( 0, 0, vp.width, vp.height );

        var zoom = cy.zoom();
        
        setContextTransform( context, false );

        context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );
        context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );

      } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
        r.textureCache = null;
      }

      var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
      var hideEdges = r.hideEdgesOnViewport && vpManip;
      var hideLabels = r.hideLabelsOnViewport && vpManip;

      if (needDraw[CanvasRenderer.DRAG] || needDraw[CanvasRenderer.NODE] || drawAllLayers || drawOnlyNodeLayer) {
        //NB : VERY EXPENSIVE

        if( hideEdges ){ 
        } else {
          r.findEdgeControlPoints(edges);
        }

        var zEles = r.getCachedZSortedEles();
        var extent = cy.extent();

        for (var i = 0; i < zEles.length; i++) {
          var ele = zEles[i];
          var list;
          var bb = forcedContext ? null : ele.boundingBox();
          var insideExtent = forcedContext ? true : $$.math.boundingBoxesIntersect( extent, bb );

          if( !insideExtent ){ continue; } // no need to render

          if ( ele._private.rscratch.inDragLayer ) {
            list = eles.drag;
          } else {
            list = eles.nondrag;
          }

          list.eles.push( ele );
        }

      }
      
      
      function drawElements( list, context ){
        var eles = list.eles;

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          if( ele.isNode() ){
            r.drawNode(context, ele);

            if( !hideLabels ){
              r.drawNodeText(context, ele);
            }

            r.drawNode(context, ele, true);
          } else if( !hideEdges ) {
            r.drawEdge(context, ele);

            if( !hideLabels ){
              r.drawEdgeText(context, ele);
            }

            r.drawEdge(context, ele, true);
          }
          
          
        }

      }

      var nodeLayerNeedsMotionClear = needDraw[CanvasRenderer.DRAG] && !needDraw[CanvasRenderer.NODE] && motionBlur && !r.clearedNodeLayerForMotionBlur;
      if( nodeLayerNeedsMotionClear ){ r.clearedNodeLayerForMotionBlur = true; }

      if( needDraw[CanvasRenderer.NODE] || drawAllLayers || drawOnlyNodeLayer || nodeLayerNeedsMotionClear ){
        // console.log('redrawing node layer');
        
        var context = forcedContext || data.contexts[CanvasRenderer.NODE];

        setContextTransform( context, motionBlur && !nodeLayerNeedsMotionClear ? 'motionBlur' : undefined );
        drawElements(eles.nondrag, context);
        
        if( !drawAllLayers ){
          needDraw[CanvasRenderer.NODE] = false; 
        }
      }
      
      if ( !drawOnlyNodeLayer && (needDraw[CanvasRenderer.DRAG] || drawAllLayers) ) {
        
        var context = forcedContext || data.contexts[CanvasRenderer.DRAG];
        
        setContextTransform( context, motionBlur ? 'motionBlur' : undefined );
        drawElements(eles.drag, context);
        
        if( !drawAllLayers ){
          needDraw[CanvasRenderer.DRAG] = false;
        }
      }
      
      if( r.showFps || (!drawOnlyNodeLayer && (needDraw[CanvasRenderer.SELECT_BOX] && !drawAllLayers)) ) {
        // console.log('redrawing selection box');
        
        var context = forcedContext || data.contexts[CanvasRenderer.SELECT_BOX];

        setContextTransform( context );

        if( data.select[4] == 1 && r.hoverData.selecting ){
          var zoom = data.cy.zoom();
          var borderWidth = coreStyle['selection-box-border-width'].value / zoom;
          
          context.lineWidth = borderWidth;
          context.fillStyle = "rgba(" 
            + coreStyle['selection-box-color'].value[0] + ","
            + coreStyle['selection-box-color'].value[1] + ","
            + coreStyle['selection-box-color'].value[2] + ","
            + coreStyle['selection-box-opacity'].value + ")";
          
          context.fillRect(
            data.select[0],
            data.select[1],
            data.select[2] - data.select[0],
            data.select[3] - data.select[1]);
          
          if (borderWidth > 0) {
            context.strokeStyle = "rgba(" 
              + coreStyle['selection-box-border-color'].value[0] + ","
              + coreStyle['selection-box-border-color'].value[1] + ","
              + coreStyle['selection-box-border-color'].value[2] + ","
              + coreStyle['selection-box-opacity'].value + ")";
            
            context.strokeRect(
              data.select[0],
              data.select[1],
              data.select[2] - data.select[0],
              data.select[3] - data.select[1]);
          }
        }

        if( data.bgActivePosistion && !r.hoverData.selecting ){
          var zoom = data.cy.zoom();
          var pos = data.bgActivePosistion;

          context.fillStyle = "rgba(" 
            + coreStyle['active-bg-color'].value[0] + ","
            + coreStyle['active-bg-color'].value[1] + ","
            + coreStyle['active-bg-color'].value[2] + ","
            + coreStyle['active-bg-opacity'].value + ")";

          context.beginPath();
          context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pxValue / zoom, 0, 2 * Math.PI); 
          context.fill();
        }
        
        var timeToRender = r.averageRedrawTime;
        if( r.showFps && timeToRender ){
          timeToRender = Math.round( timeToRender );
          var fps = Math.round(1000/timeToRender);

          context.setTransform(1, 0, 0, 1, 0, 0);

          //context.font = '20px helvetica';
          context.fillStyle = 'rgba(255, 0, 0, 0.75)';
          context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
          context.lineWidth = 1;
          context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

          var maxFps = 60;
          context.strokeRect(0, 30, 250, 20);
          context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);
        }

        if( !drawAllLayers ){
          needDraw[CanvasRenderer.SELECT_BOX] = false; 
        }
      }


      var endTime = +new Date();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      r.redrawTotalTime += endTime - startTime;
      r.lastRedrawTime = endTime - startTime;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime/2 + (endTime - startTime)/2;
      //console.log('actual: %i, average: %i', endTime - startTime, this.averageRedrawTime);

      r.currentlyDrawing = false;

      // console.profileEnd('draw' + startTime)

      if( r.clearingMotionBlur ){
        r.clearingMotionBlur = false;
        r.motionBlurCleared = true;
        r.motionBlur = true;
      }

      if( motionBlur ){ 
        r.motionBlurTimeout = setTimeout(function(){
          r.motionBlurTimeout = null;
          // console.log('motion blur clear');

          r.clearedNodeLayerForMotionBlur = false;
          r.motionBlur = false;
          r.clearingMotionBlur = true;

          needDraw[CanvasRenderer.NODE] = true; 
          needDraw[CanvasRenderer.DRAG] = true; 

          r.redraw();
        }, CanvasRenderer.motionBlurDelay);
      }
    } // draw to context

    if( !forcedContext ){
      $$.util.requestAnimationFrame(drawToContext); // makes direct renders to screen a bit more responsive
    } else {
      drawToContext();
    }

    if( !forcedContext && !r.initrender ){
      r.initrender = true;
      cy.trigger('initrender');
    }
    
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // @O Polygon drawing
  CanvasRenderer.prototype.drawPolygonPath = function(
    context, x, y, width, height, points) {

    var halfW = width / 2;
    var halfH = height / 2;

    if( context.beginPath ){ context.beginPath(); }

    context.moveTo( x + halfW * points[0], y + halfH * points[1] );

    for (var i = 1; i < points.length / 2; i++) {
      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );
    }
    
    context.closePath();
  };
  
  CanvasRenderer.prototype.drawPolygon = function(
    context, x, y, width, height, points) {

    // Draw path
    this.drawPolygonPath(context, x, y, width, height, points);
    
    // Fill path
    context.fill();
  };
  
  // Round rectangle drawing
  CanvasRenderer.prototype.drawRoundRectanglePath = function(
    context, x, y, width, height, radius) {
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
    
    if( context.beginPath ){ context.beginPath(); }
    
    // Start at top middle
    context.moveTo(x, y - halfHeight);
    // Arc from middle top to right side
    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
    // Arc from right side to bottom
    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
    // Arc from bottom to left side
    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
    // Arc from left side to topBorder
    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
    // Join line
    context.lineTo(x, y - halfHeight);
    
    
    context.closePath();
  };
  
  CanvasRenderer.prototype.drawRoundRectangle = function(
    context, x, y, width, height, radius) {
    
    this.drawRoundRectanglePath(context, x, y, width, height, radius);
    
    context.fill();
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  CanvasRenderer.prototype.createBuffer = function(w, h) {
    var buffer = document.createElement('canvas');
    buffer.width = w;
    buffer.height = h;
    
    return [buffer, buffer.getContext('2d')];
  };

  CanvasRenderer.prototype.bufferCanvasImage = function( options ){
    var data = this.data;
    var cy = data.cy;
    var bb = cy.elements().boundingBox();
    var width = options.full ? Math.ceil(bb.w) : this.data.container.clientWidth;
    var height = options.full ? Math.ceil(bb.h) : this.data.container.clientHeight;
    var scale = 1;

    if( options.scale !== undefined ){
      width *= options.scale;
      height *= options.scale;

      scale = options.scale;
    }

    var buffCanvas = document.createElement('canvas');

    buffCanvas.width = width;
    buffCanvas.height = height;

    buffCanvas.style.width = width + 'px';
    buffCanvas.style.height = height + 'px';

    var buffCxt = buffCanvas.getContext('2d');

    // Rasterize the layers, but only if container has nonzero size
    if (width > 0 && height > 0) {

      buffCxt.clearRect( 0, 0, width, height );

      if( options.bg ){
        buffCxt.fillStyle = options.bg;
        buffCxt.rect( 0, 0, width, height );
        buffCxt.fill();
      }

      buffCxt.globalCompositeOperation = 'source-over';

      if( options.full ){ // draw the full bounds of the graph
        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: scale,
          forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },
          forcedPxRatio: 1
        });
      } else { // draw the current view
        var cyPan = cy.pan();
        var pan = {
          x: cyPan.x * scale,
          y: cyPan.y * scale
        };
        var zoom = cy.zoom() * scale;

        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: zoom,
          forcedPan: pan,
          forcedPxRatio: 1
        });
      }
    }

    return buffCanvas;
  }; 

  CanvasRenderer.prototype.png = function( options ){
    return this.bufferCanvasImage( options ).toDataURL('image/png');
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  CanvasRenderer.prototype.registerBinding = function(target, event, handler, useCapture){
    this.bindings.push({
      target: target,
      event: event,
      handler: handler,
      useCapture: useCapture
    });

    target.addEventListener(event, handler, useCapture);
  };

  CanvasRenderer.prototype.nodeIsDraggable = function(node) {
    if (node._private.style['opacity'].value !== 0
      && node._private.style['visibility'].value == 'visible'
      && node._private.style['display'].value == 'element'
      && !node.locked()
      && node.grabbable() ) {

      return true;
    }
    
    return false;
  };

  CanvasRenderer.prototype.load = function() {
    var r = this;

    var getDragListIds = function(opts){
      var listHasId;

      if( opts.addToList && r.data.cy.hasCompoundNodes() ){ // only needed for compound graphs
        if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
          opts.addToList.hasId = {};

          for( var i = 0; i < opts.addToList.length; i++ ){
            var ele = opts.addToList[i];

            opts.addToList.hasId[ ele.id() ] = true;
          }
        }

        listHasId = opts.addToList.hasId;
      }

      return listHasId || {};
    };

    // helper function to determine which child nodes and inner edges
    // of a compound node to be dragged as well as the grabbed and selected nodes
    var addDescendantsToDrag = function(node, opts){
      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      var listHasId = getDragListIds( opts );

      var innerNodes = node.descendants();

      // TODO do not drag hidden children & children of hidden children?
      for( var i = 0; i < innerNodes.size(); i++ ){
        var iNode = innerNodes[i];
        var _p = iNode._private;

        if( opts.inDragLayer ){
          _p.rscratch.inDragLayer = true;
        }

        if( opts.addToList && !listHasId[ iNode.id() ] ){
          opts.addToList.push( iNode );
          listHasId[ iNode.id() ] = true;

          _p.grabbed = true; 
        }

        var edges = _p.edges;
        for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){
          edges[j]._private.rscratch.inDragLayer = true;
        }
      }
    };

    // adds the given nodes, and its edges to the drag layer
    var addNodeToDrag = function(node, opts){

      var _p = node._private;
      var listHasId = getDragListIds( opts );

      if( opts.inDragLayer ){
        _p.rscratch.inDragLayer = true;
      }

      if( opts.addToList && !listHasId[ node.id() ] ){
        opts.addToList.push( node );
        listHasId[ node.id() ] = true;

        _p.grabbed = true; 
      }

      var edges = _p.edges;
      for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){
        edges[i]._private.rscratch.inDragLayer = true;
      }

      addDescendantsToDrag( node, opts ); // always add to drag

      // also add nodes and edges related to the topmost ancestor
      updateAncestorsInDragLayer( node, {
        inDragLayer: true
      } );
    };

    // helper function to determine which ancestor nodes and edges should go
    // to the drag layer (or should be removed from drag layer).
    var updateAncestorsInDragLayer = function(node, opts) {
      // find top-level parent
      var parent = node;

      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      while( parent.parent().nonempty() ){
        parent = parent.parent()[0];
      }

      // no parent node: no nodes to add to the drag layer
      if( parent == node ){
        return;
      }

      var nodes = parent
        .descendants()
        .add( parent )
        .not( node )
        .not( node.descendants() )
      ;

      var edges = nodes.connectedEdges();

      var listHasId = getDragListIds( opts );

      for( var i = 0; i < nodes.size(); i++ ){
        if( opts.inDragLayer !== undefined ){
          nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;
        }

        if( opts.addToList && !listHasId[ nodes[i].id() ] ){
          opts.addToList.push( nodes[i] );
          listHasId[ nodes[i].id() ] = true;

          nodes[i]._private.grabbed = true;
        }
      }

      for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {
        edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;
      }
    };

    if( typeof MutationObserver !== 'undefined' ){
      r.removeObserver = new MutationObserver(function( mutns ){
        for( var i = 0; i < mutns.length; i++ ){
          var mutn = mutns[i];
          var rNodes = mutn.removedNodes;

          if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
            var rNode = rNodes[j];

            if( rNode === r.data.container ){
              r.destroy();
              break;
            }
          } }
        }
      });

      r.removeObserver.observe( r.data.container.parentNode, { childList: true } );
    } else {
      r.registerBinding(r.data.container, 'DOMNodeRemoved', function(e){
        r.destroy();
      });
    }



    // auto resize
    r.registerBinding(window, 'resize', $$.util.debounce( function(e) {
      r.invalidateContainerClientCoordsCache();

      r.matchCanvasSize(r.data.container);
      r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
      r.redraw();
    }, 100 ) );

    var invalCtnrBBOnScroll = function(domEle){
      r.registerBinding(domEle, 'scroll', function(e){
        r.invalidateContainerClientCoordsCache();
      } );
    };

    var bbCtnr = r.data.cy.container();

    for( ;; ){
      
      invalCtnrBBOnScroll( bbCtnr );

      if( bbCtnr.parentNode ){
        bbCtnr = bbCtnr.parentNode;
      } else {
        break;
      }
      
    }

    // stop right click menu from appearing on cy
    r.registerBinding(r.data.container, 'contextmenu', function(e){
      e.preventDefault();
    });

    var inBoxSelection = function(){
      return r.data.select[4] !== 0;
    };

    // Primary key
    r.registerBinding(r.data.container, 'mousedown', function(e) { 
      e.preventDefault();
      r.hoverData.capture = true;
      r.hoverData.which = e.which;
      
      var cy = r.data.cy; 
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true);
      var draggedElements = r.dragData.possibleDragElements;

      r.hoverData.mdownPos = pos;

      var checkForTaphold = function(){
        r.hoverData.tapholdCancelled = false;

        clearTimeout( r.hoverData.tapholdTimeout );

        r.hoverData.tapholdTimeout = setTimeout(function(){

          if( r.hoverData.tapholdCancelled ){
            return;
          } else {
            var ele = r.hoverData.down;

            if( ele ){
              ele.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            } else {
              cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            }
          }

        }, r.tapholdDuration);
      };

      // Right click button
      if( e.which == 3 ){

        r.hoverData.cxtStarted = true;

        var cxtEvt = new $$.Event(e, {
          type: 'cxttapstart', 
          cyPosition: { x: pos[0], y: pos[1] } 
        });

        if( near ){
          near.activate();
          near.trigger( cxtEvt );

          r.hoverData.down = near;
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.downTime = (new Date()).getTime();
        r.hoverData.cxtDragged = false;

      // Primary button
      } else if (e.which == 1) {
        
        if( near ){
          near.activate();
        }

        // Element dragging
        {
          // If something is under the cursor and it is draggable, prepare to grab it
          if (near != null) {

            if( r.nodeIsDraggable(near) ){

              var grabEvent = new $$.Event(e, {
                type: 'grab',
                cyPosition: { x: pos[0], y: pos[1] }
              });

              if ( near.isNode() && !near.selected() ){

                draggedElements = r.dragData.possibleDragElements = [];
                addNodeToDrag( near, { addToList: draggedElements } );

                near.trigger(grabEvent);

              } else if ( near.isNode() && near.selected() ){
                draggedElements = r.dragData.possibleDragElements = [  ];

                var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });

                for( var i = 0; i < selectedNodes.length; i++ ){

                  // Only add this selected node to drag if it is draggable, eg. has nonzero opacity
                  if( r.nodeIsDraggable( selectedNodes[i] ) ){
                    addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );
                  }
                }

                near.trigger( grabEvent );
              }

              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
              r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

            }
            
            near
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
            
          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }
          
          r.hoverData.down = near;
          r.hoverData.downTime = (new Date()).getTime();

        }
      
        // Selection box
        if ( near == null || near.isEdge() ) {
          select[4] = 1;
          var timeUntilActive = Math.max( 0, CanvasRenderer.panOrBoxSelectDelay - (+new Date() - r.hoverData.downTime) );

          clearTimeout( r.bgActiveTimeout );

          if( cy.boxSelectionEnabled() || ( near && near.isEdge() ) ){
            r.bgActiveTimeout = setTimeout(function(){
              if( near ){
                near.unactivate();
              }

              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };

              checkForTaphold();

              r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
      
              r.redraw();
            }, timeUntilActive);
          } else {
            r.data.bgActivePosistion = {
              x: pos[0],
              y: pos[1]
            };

            checkForTaphold();

            r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
    
            r.redraw();
          }
          
        }
      
      } 
      
      // Initialize selection box coordinates
      select[0] = select[2] = pos[0];
      select[1] = select[3] = pos[1];
      
    }, false);
    
    r.registerBinding(window, 'mousemove', $$.util.throttle( function(e) {
      var preventDefault = false;
      var capture = r.hoverData.capture;

      // save cycles if mouse events aren't to be captured
      if ( !capture ){
        var containerPageCoords = r.findContainerClientCoords();

        if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth
          && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight
        ) {
          // inside container bounds so OK
        } else {
          return;
        }

        var cyContainer = r.data.container;
        var target = e.target;
        var tParent = target.parentNode;
        var containerIsTarget = false;

        while( tParent ){
          if( tParent === cyContainer ){
            containerIsTarget = true;
            break;
          }

          tParent = tParent.parentNode;
        }

        if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us
      }

      var cy = r.data.cy;
      var zoom = cy.zoom();
      var pan = cy.pan();
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      
      var near = null;
      if( !r.hoverData.draggingEles ){
        near = r.findNearestElement(pos[0], pos[1], true);
      }
      var last = r.hoverData.last;
      var down = r.hoverData.down;
      
      var disp = [pos[0] - select[2], pos[1] - select[3]];

      var draggedElements = r.dragData.possibleDragElements;

      var dx = select[2] - select[0];
      var dx2 = dx * dx;
      var dy = select[3] - select[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      r.hoverData.tapholdCancelled = true;

      var updateDragDelta = function(){
        var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

        if( dragDelta.length === 0 ){
          dragDelta.push(0);
          dragDelta.push(0);
        } else {
          dragDelta[0] += disp[0];
          dragDelta[1] += disp[1];
        }
      };
      

      preventDefault = true;

      // Mousemove event
      {
        if (near != null) {
          near
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;
          
        } else if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;
        }

      }

      // trigger context drag if rmouse down
      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.cxtDragged = true;

        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

          if( r.hoverData.cxtOver ){
            r.hoverData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragout ' + r.hoverData.cxtOver.id());
          }

          r.hoverData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragover ' + near.id());
          }

        }

      // Check if we are drag panning the entire graph
      } else if (r.hoverData.dragging) {
        preventDefault = true;

        if( cy.panningEnabled() && cy.userPanningEnabled() ){
          var deltaP;

          if( r.hoverData.justStartedPan ){
            var mdPos = r.hoverData.mdownPos;

            deltaP = {
              x: ( pos[0] - mdPos[0] ) * zoom,
              y: ( pos[1] - mdPos[1] ) * zoom
            };

            r.hoverData.justStartedPan = false;

          } else {
            deltaP = {
              x: disp[0] * zoom,
              y: disp[1] * zoom
            };

          }

          cy.panBy( deltaP );
          
        }
        
        // Needs reproject due to pan changing viewport
        pos = r.projectIntoViewport(e.clientX, e.clientY);

      // Checks primary button down & out of time & mouse not moved much
      } else if(
          select[4] == 1 && (down == null || down.isEdge())
          && ( !cy.boxSelectionEnabled() || (+new Date() - r.hoverData.downTime >= CanvasRenderer.panOrBoxSelectDelay) )
          //&& (Math.abs(select[3] - select[1]) + Math.abs(select[2] - select[0]) < 4)
          && !r.hoverData.selecting
          && rdist2 >= r.tapThreshold2
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){
        r.hoverData.dragging = true;
        r.hoverData.selecting = false;
        r.hoverData.justStartedPan = true;
        select[4] = 0;

      } else {
        // deactivate bg on box selection
        if (cy.boxSelectionEnabled() && Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]){
          clearTimeout( r.bgActiveTimeout );
          r.data.bgActivePosistion = undefined;
          r.hoverData.selecting = true;

          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          r.redraw();
        }
        
        if( down && down.isEdge() && down.active() ){ down.unactivate(); }

        if (near != last) {
          
          if (last) {
            last.trigger( new $$.Event(e, {
              type: 'mouseout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) ); 

            last.trigger( new $$.Event(e, {
              type: 'tapdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) ); 
          }
          
          if (near) {
            near.trigger( new $$.Event(e, {
              type: 'mouseover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) ); 

            near.trigger( new $$.Event(e, {
              type: 'tapdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) ); 
          }
          
          r.hoverData.last = near;
        }

        if( down && down.isNode() && r.nodeIsDraggable(down) ){

          if( rdist2 >= r.tapThreshold2 ){ // then drag

            var justStartedDrag = !r.dragData.didDrag;

            if( justStartedDrag ) {
              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            for( var i = 0; i < draggedElements.length; i++ ){
              var dEle = draggedElements[i];

              // now, add the elements to the drag layer if not done already
              if( !r.hoverData.draggingEles ){ 
                addNodeToDrag( dEle, { inDragLayer: true } );
              }

              // Locked nodes not draggable, as well as non-visible nodes
              if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){
                var dPos = dEle._private.position;

                toTrigger.push( dEle );
                
                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];

                  if( justStartedDrag ){
                    var dragDelta = r.hoverData.dragDelta;

                    if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }

              }
            }

            r.hoverData.draggingEles = true;
            
            var tcol = (new $$.Collection(cy, toTrigger));

            tcol.updateCompoundBounds();
            tcol.trigger('position drag');
            
            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
            r.redraw();

          } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
            updateDragDelta();
          }
        }

        // prevent the dragging from triggering text selection on the page
        preventDefault = true;
      }
      
      select[2] = pos[0]; select[3] = pos[1];
      
      if( preventDefault ){ 
        if(e.stopPropagation) e.stopPropagation();
          if(e.preventDefault) e.preventDefault();
          return false;
        }
    }, 1000/30, { trailing: true }), false);
    
    r.registerBinding(window, 'mouseup', function(e) {
      // console.log('--\nmouseup', e)

      var capture = r.hoverData.capture;
      if (!capture) { return; }
      r.hoverData.capture = false;
    
      var cy = r.data.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true); 
      var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
      var shiftDown = e.shiftKey;
      
      if( r.data.bgActivePosistion ){
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
        r.redraw();
      }

      r.data.bgActivePosistion = undefined; // not active bg now
      clearTimeout( r.bgActiveTimeout );

      r.hoverData.cxtStarted = false;
      r.hoverData.draggingEles = false;
      r.hoverData.selecting = false;

      if( down ){
        down.unactivate();
      }

      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( !r.hoverData.cxtDragged ){
          var cxtTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: pos[0], y: pos[1] }
          });

          if( down ){
            down.trigger( cxtTap );
          } else {
            cy.trigger( cxtTap );
          }
        }

        r.hoverData.cxtDragged = false;
        r.hoverData.which = null;

      // if not right mouse
      } else {

        // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
        if ( (down == null) // not mousedown on node
          && !r.dragData.didDrag // didn't move the node around
          && !(Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]) // not box selection
          && !r.hoverData.dragging // not panning
        ) {

          cy.$(function(){
            return this.selected();
          }).unselect();
          
          if (draggedElements.length > 0) {
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
          }
          
          r.dragData.possibleDragElements = draggedElements = [];
        }
      
        
        // Mouseup event
        {
          // console.log('trigger mouseup et al');

          if (near != null) {
            near
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }
        }
        
        // Click event
        {
          // console.log('trigger click et al');

          if (Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) === 0) {
            if (near != null) {
              near
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            } else if (near == null) {
              cy
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            }
          }
        }

        // Single selection
        if (near == down && !r.dragData.didDrag) {
          if (near != null && near._private.selectable) {
            
            // console.log('single selection')

            if( r.hoverData.dragging ){
              // if panning, don't change selection state
            } else if( cy.selectionType() === 'additive' || shiftDown ){
              if( near.selected() ){
                near.unselect();
              } else {
                near.select();
              }
            } else {
              if( !shiftDown ){
                cy.$(':selected').not( near ).unselect();
                near.select();
              }               
            }
            
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
            
          }
      
        } 
        
        if ( cy.boxSelectionEnabled() &&  Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4] ) {         
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

          if( box.length > 0 ) { 
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          }

          for( var i = 0; i < box.length; i++ ){ 
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'additive' ){
            newlySelCol.select();
          } else {
            if( !shiftDown ){
              cy.$(':selected').not( newlySelCol ).unselect();
            }

            newlySelCol.select();
          }

          // always need redraw in case eles unselectable
          r.redraw();
          
        }
        
        // Cancel drag pan
        if( r.hoverData.dragging ){
          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          r.redraw();
        }

        r.hoverData.dragging = false;
        
        if (!select[4]) {
          // console.log('free at end', draggedElements)

          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true; 
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          
          for (var i=0; i < draggedElements.length; i++) {
            
            if(draggedElements[i]._private.group === 'nodes') { 
              draggedElements[i]._private.rscratch.inDragLayer = false;
              draggedElements[i]._private.grabbed = false;
              
              var sEdges = draggedElements[i]._private.edges;
              for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }

              // for compound nodes, also remove related nodes and edges from the drag layer
              updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });
              
            } else if( draggedElements[i]._private.group === 'edges' ){
              draggedElements[i]._private.rscratch.inDragLayer = false;
            }
            
          }

          if( down ){ down.trigger('free'); }

  //        draggedElements = r.dragData.possibleDragElements = [];
          
        }
      
      } // else not right mouse

      select[4] = 0; r.hoverData.down = null;
      
      //r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true; 
      
//      console.log('mu', pos[0], pos[1]);
//      console.log('ss', select);
      
      r.dragData.didDrag = false;
      r.hoverData.dragDelta = [];
      
    }, false);

    var wheelHandler = function(e) { 
      if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

      var cy = r.data.cy;
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var rpos = [pos[0] * cy.zoom() + cy.pan().x,
                    pos[1] * cy.zoom() + cy.pan().y];
      
      if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
        e.preventDefault();
        return;
      }

      if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
        e.preventDefault();
        
        r.data.wheelZooming = true;
        clearTimeout( r.data.wheelTimeout );
        r.data.wheelTimeout = setTimeout(function(){
          r.data.wheelZooming = false;

          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          r.redraw();
        }, 150);

        var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;
        diff = diff * r.wheelSensitivity;

        var needsWheelFix = e.deltaMode === 1;
        if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
          diff *= 33;
        }

        cy.zoom({
          level: cy.zoom() * Math.pow(10, diff),
          renderedPosition: { x: rpos[0], y: rpos[1] }
        });
      }

    };
    
    // Functions to help with whether mouse wheel should trigger zooming
    // --
    r.registerBinding(r.data.container, 'wheel', wheelHandler, true);

    // disable nonstandard wheel events
    // r.registerBinding(r.data.container, 'mousewheel', wheelHandler, true);
    // r.registerBinding(r.data.container, 'DOMMouseScroll', wheelHandler, true);
    // r.registerBinding(r.data.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

    r.registerBinding(window, 'scroll', function(e){
      r.scrollingPage = true;

      clearTimeout( r.scrollingPageTimeout );
      r.scrollingPageTimeout = setTimeout(function(){
        r.scrollingPage = false;
      }, 250);
    }, true);
    
    // Functions to help with handling mouseout/mouseover on the Cytoscape container
          // Handle mouseout on Cytoscape container
    r.registerBinding(r.data.container, 'mouseout', function(e) { 
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseout',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);
    
    r.registerBinding(r.data.container, 'mouseover', function(e) { 
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseover',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);
    
    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
    var center1, modelCenter1; // center point on start pinch to zoom
    var offsetLeft, offsetTop;
    var containerWidth, containerHeight;
    var twoFingersStartInside;

    var distance = function(x1, y1, x2, y2){
      return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
    };

    var distanceSq = function(x1, y1, x2, y2){
      return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
    };

    r.registerBinding(r.data.container, 'touchstart', function(e) {

      clearTimeout( this.threeFingerSelectTimeout );

      if( e.target !== r.data.link ){
        e.preventDefault();
      }
    
      r.touchData.capture = true;
      r.data.bgActivePosistion = undefined;

      var cy = r.data.cy; 
      var nodes = r.getCachedNodes();
      var edges = r.getCachedEdges();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;
      
      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
    

      // record starting points for pinch-to-zoom
      if( e.touches[1] ){

        // anything in the set of dragged eles should be released
        var release = function( eles ){
          for( var i = 0; i < eles.length; i++ ){
            eles[i]._private.grabbed = false;
            eles[i]._private.rscratch.inDragLayer = false;
            if( eles[i].active() ){ eles[i].unactivate(); }
          }
        };
        release(nodes);
        release(edges);

        var offsets = r.findContainerClientCoords();
        offsetLeft = offsets[0];
        offsetTop = offsets[1];
        containerWidth = offsets[2];
        containerHeight = offsets[3];

        f1x1 = e.touches[0].clientX - offsetLeft;
        f1y1 = e.touches[0].clientY - offsetTop;
        
        f2x1 = e.touches[1].clientX - offsetLeft;
        f2y1 = e.touches[1].clientY - offsetTop;

        twoFingersStartInside = 
             0 <= f1x1 && f1x1 <= containerWidth
          && 0 <= f2x1 && f2x1 <= containerWidth
          && 0 <= f1y1 && f1y1 <= containerHeight
          && 0 <= f2y1 && f2y1 <= containerHeight
        ;

        var pan = cy.pan();
        var zoom = cy.zoom();

        distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
        distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
        center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];
        modelCenter1 = [ 
          (center1[0] - pan.x) / zoom,
          (center1[1] - pan.y) / zoom
        ];

        // consider context tap
        var cxtDistThreshold = 200;
        var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
        if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

          var near1 = r.findNearestElement(now[0], now[1], true);
          var near2 = r.findNearestElement(now[2], now[3], true);

          //console.log(distance1)

          if( near1 && near1.isNode() ){
            near1.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near1;
          
          } else if( near2 && near2.isNode() ){
            near2.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near2;
          
          } else {
            cy.trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = null;
          } 

          if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
          r.touchData.cxt = true;
          r.touchData.cxtDragged = false;
          r.data.bgActivePosistion = undefined;

          //console.log('cxttapstart')

          r.redraw();
          return;
          
        }

        // console.log(center1);
        // console.log('touchstart ptz');
        // console.log(offsetLeft, offsetTop);
        // console.log(f1x1, f1y1);
        // console.log(f2x1, f2y1);
        // console.log(distance1);
        // console.log(center1);
      }

      // console.log('another tapstart')
      
      
      if (e.touches[2]) {
      
      } else if (e.touches[1]) {
        
      } else if (e.touches[0]) {
        var near = r.findNearestElement(now[0], now[1], true);

        if (near != null) {
          near.activate();

          r.touchData.start = near;
          
          if( near.isNode() && r.nodeIsDraggable(near) ){

            var draggedEles = r.dragData.touchDragEles = [];
            
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

            if( near.selected() ){
              // reset drag elements, since near will be added again

              var selectedNodes = cy.$(function(){
                return this.isNode() && this.selected();
              });

              for( var k = 0; k < selectedNodes.length; k++ ){
                var selectedNode = selectedNodes[k];

                if( r.nodeIsDraggable(selectedNode) ){
                  addNodeToDrag( selectedNode, { addToList: draggedEles } );
                }
              }
            } else {
              addNodeToDrag( near, { addToList: draggedEles } );
            }

            near.trigger( new $$.Event(e, {
              type: 'grab',
              cyPosition: { x: now[0], y: now[1] }
            }) );
          }
          
          near
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousdown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;
        } if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousedown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;

          r.data.bgActivePosistion = {
            x: pos[0],
            y: pos[1]
          };

          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          r.redraw();
        }
        
        
        // Tap, taphold
        // -----
        
        for (var i=0; i<now.length; i++) {
          earlier[i] = now[i];
          r.touchData.startPosition[i] = now[i];
        }
        
        r.touchData.singleTouchMoved = false;
        r.touchData.singleTouchStartTime = +new Date();
        
        clearTimeout( r.touchData.tapholdTimeout );
        r.touchData.tapholdTimeout = setTimeout(function() {
          if(
              r.touchData.singleTouchMoved === false
              && !r.pinching // if pinching, then taphold unselect shouldn't take effect

              // This time double constraint prevents multiple quick taps
              // followed by a taphold triggering multiple taphold events
              //&& Date.now() - r.touchData.singleTouchStartTime > 250
          ){
            if (r.touchData.start) {
              r.touchData.start.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            } else {
              r.data.cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.$(':selected').unselect();
            }

//            console.log('taphold');
          }
        }, r.tapholdDuration);
      }
      
      //r.redraw();
      
    }, false);
    
// console.log = function(m){ $('#console').append('<div>'+m+'</div>'); };

    r.registerBinding(window, 'touchmove', $$.util.throttle(function(e) {
    
      var select = r.data.select;
      var capture = r.touchData.capture; //if (!capture) { return; }; 
      if( capture ){ e.preventDefault(); }
    
      var cy = r.data.cy; 
      var now = r.touchData.now; var earlier = r.touchData.earlier;
      var zoom = cy.zoom();
      
      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }
      
      var startPos = r.touchData.startPosition;

      var dx = now[0] - startPos[0];
      var dx2 = dx * dx;
      var dy = now[1] - startPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      if( capture && r.touchData.cxt ){
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
        // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        var factorSq = distance2Sq / distance1Sq;

        var distThreshold = 150;
        var distThresholdSq = distThreshold * distThreshold;
        var factorThreshold = 1.5;
        var factorThresholdSq = factorThreshold * factorThreshold;

        //console.log(factor, distance2)

        // cancel ctx gestures if the distance b/t the fingers increases
        if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
          r.touchData.cxt = false;
          if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }
          r.data.bgActivePosistion = undefined;
          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

          var cxtEvt = new $$.Event(e, {
            type: 'cxttapend',
            cyPosition: { x: now[0], y: now[1] }
          });
          if( r.touchData.start ){
            r.touchData.start.trigger( cxtEvt );
          } else {
            cy.trigger( cxtEvt );
          }
        }

      }  

      if( capture && r.touchData.cxt ){ 
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: now[0], y: now[1] }
        });
        r.data.bgActivePosistion = undefined;
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

        if( r.touchData.start ){
          r.touchData.start.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxtDragged = true;

        //console.log('cxtdrag')

        var near = r.findNearestElement(now[0], now[1], true);

        if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

          if( r.touchData.cxtOver ){
            r.touchData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragout');
          }

          r.touchData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragover');
          }

        }

      } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){ 
        r.data.bgActivePosistion = undefined;
        clearTimeout( this.threeFingerSelectTimeout );
        this.lastThreeTouch = +new Date();

        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

        if( !select || select.length === 0 || select[0] === undefined ){
          select[0] = (now[0] + now[2] + now[4])/3;
          select[1] = (now[1] + now[3] + now[5])/3;
          select[2] = (now[0] + now[2] + now[4])/3 + 1;
          select[3] = (now[1] + now[3] + now[5])/3 + 1;
        } else {
          select[2] = (now[0] + now[2] + now[4])/3;
          select[3] = (now[1] + now[3] + now[5])/3;
        }

        select[4] = 1;

        r.redraw();

      } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom
        r.data.bgActivePosistion = undefined;
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

        var draggedEles = r.dragData.touchDragEles;
        if( draggedEles ){ 
          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

          for( var i = 0; i < draggedEles.length; i++ ){
            draggedEles[i]._private.grabbed = false;
            draggedEles[i]._private.rscratch.inDragLayer = false;
          }
        }

        // console.log('touchmove ptz');

        // (x2, y2) for fingers 1 and 2
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;

        // console.log( f1x2, f1y2 )
        // console.log( f2x2, f2y2 )

        var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
        var factor = distance2 / distance1;

        // console.log(distance2)
        // console.log(factor)

        if( factor != 1 && twoFingersStartInside){

          // console.log(factor)
          // console.log(distance2 + ' / ' + distance1);
          // console.log('--');

          // delta finger1
          var df1x = f1x2 - f1x1;
          var df1y = f1y2 - f1y1;

          // delta finger 2
          var df2x = f2x2 - f2x1;
          var df2y = f2y2 - f2y1;

          // translation is the normalised vector of the two fingers movement
          // i.e. so pinching cancels out and moving together pans
          var tx = (df1x + df2x)/2;
          var ty = (df1y + df2y)/2;

          // adjust factor by the speed multiplier
          // var speed = 1.5;
          // if( factor > 1 ){
          //   factor = (factor - 1) * speed + 1;
          // } else {
          //   factor = 1 - (1 - factor) * speed;
          // }

          // now calculate the zoom
          var zoom1 = cy.zoom();
          var zoom2 = zoom1 * factor;
          var pan1 = cy.pan();

          // the model center point converted to the current rendered pos
          var ctrx = modelCenter1[0] * zoom1 + pan1.x;
          var ctry = modelCenter1[1] * zoom1 + pan1.y;

          var pan2 = {
            x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,
            y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry
          };

          // console.log(pan2);
          // console.log(zoom2);

          // remove dragged eles
          if( r.touchData.start ){
            var draggedEles = r.dragData.touchDragEles;

            if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){
              draggedEles[i]._private.grabbed = false;
              draggedEles[i]._private.rscratch.inDragLayer = false;
            } }

            r.touchData.start._private.active = false;
            r.touchData.start._private.grabbed = false;
            r.touchData.start._private.rscratch.inDragLayer = false;

            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

            r.touchData.start
              .trigger('free')
              .trigger('unactivate')
            ;
          }

          cy.viewport({
            zoom: zoom2,
            pan: pan2,
            cancelOnFailedZoom: true
          });

          distance1 = distance2;  
          f1x1 = f1x2;
          f1y1 = f1y2;
          f2x1 = f2x2;
          f2y1 = f2y2;

          r.pinching = true;
        }
        
        // Re-project
        if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
        if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
        if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

      } else if (e.touches[0]) {
        var start = r.touchData.start;
        var last = r.touchData.last;
        var near = near || r.findNearestElement(now[0], now[1], true);

        if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){

          if( rdist2 >= r.tapThreshold2 ){ // then dragging can happen
            var draggedEles = r.dragData.touchDragEles;

            for( var k = 0; k < draggedEles.length; k++ ){
              var draggedEle = draggedEles[k];

              if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){
                r.dragData.didDrag = true;
                var dPos = draggedEle._private.position;
                var justStartedDrag = !r.hoverData.draggingEles;

                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];
                }

                if( justStartedDrag ){
                  addNodeToDrag( draggedEle, { inDragLayer: true } );

                  var dragDelta = r.touchData.dragDelta;

                  if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                    dPos.x += dragDelta[0];
                    dPos.y += dragDelta[1];
                  }

                }
              }
            }

            var tcol = new $$.Collection(cy, draggedEle);
            
            tcol.updateCompoundBounds();
            tcol.trigger('position drag');

            r.hoverData.draggingEles = true;
            
            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

            if( 
                 r.touchData.startPosition[0] == earlier[0]
              && r.touchData.startPosition[1] == earlier[1]
            ){
              
              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
            }
            
            r.redraw();
          } else { // otherise keep track of drag delta for later
            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

            if( dragDelta.length === 0 ){
              dragDelta.push(0);
              dragDelta.push(0);
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          }
        }
        
        // Touchmove event
        {

          if (start != null) {
            start.trigger( new $$.Event(e, {
              type: 'touchmove',
              cyPosition: { x: now[0], y: now[1] }
            }) ); 

            start.trigger( new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: now[0], y: now[1] }
            }) ); 

            start.trigger( new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: now[0], y: now[1] }
            }) ); 
          }
          
          if (start == null) { 

            if (near != null) { 
              near.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) ); 

              near.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              near.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            }

            if (near == null) { 
              cy.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) ); 

              cy.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) ); 

              cy.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) ); 
            }
          }

          if (near != last) {
            if (last) { last.trigger(new $$.Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }
            if (near) { near.trigger(new $$.Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }
          }

          r.touchData.last = near;
        }
        
        // Check to cancel taphold
        for (var i=0;i<now.length;i++) {
          if (now[i] 
            && r.touchData.startPosition[i]
            && Math.abs(now[i] - r.touchData.startPosition[i]) > 4) {
            
            r.touchData.singleTouchMoved = true;
          }
        }
        
        if(
            capture
            && ( start == null || start.isEdge() )
            && cy.panningEnabled() && cy.userPanningEnabled()
        ){

          if( r.swipePanning ){
            cy.panBy({
              x: disp[0] * zoom,
              y: disp[1] * zoom
            });

          } else if( rdist2 >= r.tapThreshold2 ){
            r.swipePanning = true;

            cy.panBy({
              x: dx * zoom,
              y: dy * zoom
            });
          }

          if( start ){
            start.unactivate();

            if( !r.data.bgActivePosistion ){
              r.data.bgActivePosistion = {
                x: now[0],
                y: now[1]
              };
            }

            r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

            r.touchData.start = null;
          }
          
          // Re-project
          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0]; now[1] = pos[1];
        }
      }

      for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }
      //r.redraw();
      
    }, 1000/30, { trailing: true }), false);
    
    r.registerBinding(window, 'touchcancel', function(e) {
      var start = r.touchData.start;

      r.touchData.capture = false;

      if( start ){
        start.unactivate();
      }
    });

    r.registerBinding(window, 'touchend', function(e) {
      var start = r.touchData.start;

      var capture = r.touchData.capture; 

      if( capture ){
        r.touchData.capture = false;
      } else {
        return;
      }
      
      e.preventDefault();
      var select = r.data.select;

      r.swipePanning = false;
      r.hoverData.draggingEles = false;
      
      var cy = r.data.cy; 
      var zoom = cy.zoom();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
      
      if( start ){
        start.unactivate();
      }

      var ctxTapend;
      if( r.touchData.cxt ){
        ctxTapend = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: now[0], y: now[1] }
        });

        if( start ){
          start.trigger( ctxTapend );
        } else {
          cy.trigger( ctxTapend );
        }

        //console.log('cxttapend')

        if( !r.touchData.cxtDragged ){
          var ctxTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: now[0], y: now[1] }
          });

          if( start ){
            start.trigger( ctxTap );
          } else {
            cy.trigger( ctxTap );
          }

          //console.log('cxttap')
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = false;
        r.touchData.start = null;

        r.redraw();
        return;
      }

      // no more box selection if we don't have three fingers
      if( !e.touches[2] && cy.boxSelectionEnabled() ){
        clearTimeout( this.threeFingerSelectTimeout );
        //this.threeFingerSelectTimeout = setTimeout(function(){
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          select[0] = undefined;
          select[1] = undefined;
          select[2] = undefined;
          select[3] = undefined;
          select[4] = 0;

          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

          // console.log(box);
          for( var i = 0; i< box.length; i++ ) { 
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').not( newlySelCol ).unselect();
          }

          newlySelCol.select();
          
          if( newlySelCol.length > 0 ) { 
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          } else {
            r.redraw();
          }

        //}, 100);
      }

      var updateStartStyle = false;

      if( start != null ){
        start._private.active = false;
        updateStartStyle = true;
        start.unactivate();
      }

      if (e.touches[2]) {
        r.data.bgActivePosistion = undefined;
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
      } else if (e.touches[1]) {
        
      } else if (e.touches[0]) {
      
      // Last touch released
      } else if (!e.touches[0]) {
        
        r.data.bgActivePosistion = undefined;
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

        if (start != null ) {

          if( start._private.grabbed ){
            start._private.grabbed = false;
            start.trigger('free');
            start._private.rscratch.inDragLayer = false;
          }
          
          var sEdges = start._private.edges;
          for (var j=0;j<sEdges.length;j++) { sEdges[j]._private.rscratch.inDragLayer = false; }
          updateAncestorsInDragLayer(start, false);
          
          if( start.selected() ){
            var selectedNodes = cy.$('node:selected');

            for( var k = 0; k < selectedNodes.length; k++ ){

              var selectedNode = selectedNodes[k];
              selectedNode._private.rscratch.inDragLayer = false;
              selectedNode._private.grabbed = false;

              var sEdges = selectedNode._private.edges;
              for (var j=0; j<sEdges.length; j++) {
                sEdges[j]._private.rscratch.inDragLayer = false;
              }

              updateAncestorsInDragLayer(selectedNode, false);
            }
          }

          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true; 
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          
          start
            .trigger(new $$.Event(e, {
              type: 'touchend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmouseup',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;
          
          start.unactivate();

          r.touchData.start = null;
          
        } else {
          var near = r.findNearestElement(now[0], now[1], true);
        
          if (near != null) { 
            near
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }

          if (near == null) { 
            cy
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }
        }

        var dx = r.touchData.startPosition[0] - now[0];
        var dx2 = dx * dx;
        var dy = r.touchData.startPosition[1] - now[1];
        var dy2 = dy * dy;
        var dist2 = dx2 + dy2;
        var rdist2 = dist2 * zoom * zoom;
        
        // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
        if (start != null 
            && !r.dragData.didDrag // didn't drag nodes around
            && start._private.selectable 
            && rdist2 < r.tapThreshold2
            && !r.pinching // pinch to zoom should not affect selection
        ) {

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').not( start ).unselect();
            start.select();
          } else {
            if( start.selected() ){
              start.unselect();
            } else {
              start.select();
            }
          }

          updateStartStyle = true;

          
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
        }
        
        // Tap event, roughly same as mouse click event for touch
        if ( r.touchData.singleTouchMoved === false ) {

          if (start) {
            start
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          } else {
            cy
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }
          
//          console.log('tap');
        }
        
        r.touchData.singleTouchMoved = true;
      }
      
      for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }

      r.dragData.didDrag = false; // reset for next mousedown

      if( e.touches[0] ){
        r.touchData.dragDelta = [];
      }

      if( updateStartStyle && start ){
        start.updateStyle(false);
      }

      if( e.touches.length < 2 ){
        r.pinching = false;
        r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
        r.redraw();
      }

      //r.redraw();
      
    }, false);
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var renderer = CanvasRenderer.prototype;
  var usePaths = CanvasRenderer.usePaths();

  // Node shape contract:
  //
  // draw: draw
  // intersectLine: report intersection from x, y, to node center
  // checkPoint: check x, y in node

  var nodeShapes = CanvasRenderer.nodeShapes = {};

  var sin0 = Math.sin(0);
  var cos0 = Math.cos(0);

  var sin = {};
  var cos = {};

  var ellipseStepSize = 0.1;

  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
    sin[i] = Math.sin(i);
    cos[i] = Math.cos(i);
  }

  nodeShapes['ellipse'] = {
    draw: function(context, centerX, centerY, width, height) {
      nodeShapes['ellipse'].drawPath(context, centerX, centerY, width, height);
      context.fill();
      
//      console.log('drawing ellipse');
//      console.log(arguments);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      
      if( usePaths ){
        if( context.beginPath ){ context.beginPath(); }

        var xPos, yPos;
        var rw = width/2;
        var rh = height/2;
        for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
            xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;
            yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;

            if (i === 0) {
                context.moveTo(xPos, yPos);
            } else {
                context.lineTo(xPos, yPos);
            }
        }
        context.closePath();

      } else {

        if( context.beginPath ){ context.beginPath(); }
        context.translate(centerX, centerY);
        context.scale(width / 2, height / 2);
        // At origin, radius 1, 0 to 2pi
        context.arc(0, 0, 1, 0, Math.PI * 2 * 0.999, false); // *0.999 b/c chrome rendering bug on full circle
        context.closePath();

        context.scale(2/width, 2/height);
        context.translate(-centerX, -centerY);

      }
      
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      var intersect = $$.math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding);
      
      return intersect;
    },
    
    intersectBox: function(
      x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      return $$.math.boxIntersectEllipse(
        x1, y1, x2, y2, padding, width, height, centerX, centerY);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
//      console.log(arguments);
      
      x -= centerX;
      y -= centerY;
      
      x /= (width / 2 + padding);
      y /= (height / 2 + padding);
      
      return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
    }
  };
  
  nodeShapes['triangle'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(3, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['triangle'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['triangle'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.polygonIntersectLine(
        x, y,
        nodeShapes['triangle'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    
      /*
      polygonIntersectLine(x, y, basePoints, centerX, centerY, 
        width, height, padding);
      */
      
      
      /*
      return renderer.polygonIntersectLine(
        node, width, height,
        x, y, nodeShapes['triangle'].points);
      */
    },
    
    intersectBox: function(
      x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['triangle'].points;
      
      return $$.math.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(
        x, y, nodeShapes['triangle'].points,
        centerX, centerY, width, height,
        [0, -1], padding);
    }
  };
  
  nodeShapes['square'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['square'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['square'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.polygonIntersectLine(
          x, y,
          nodeShapes['square'].points,
          nodeX,
          nodeY,
          width / 2, height / 2,
          padding);
    },
    
    intersectBox: function(
      x1, y1, x2, y2,
      width, height, centerX, 
      centerY, padding) {
      
      var points = nodeShapes['square'].points;
      
      return $$.math.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, 
        centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['square'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  nodeShapes['rectangle'] = nodeShapes['square'];
  
  nodeShapes['octogon'] = {};
  
  nodeShapes['roundrectangle'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectangle(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectanglePath(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.roundRectangleIntersectLine(
          x, y,
          nodeX,
          nodeY,
          width, height,
          padding);
    },
    
    intersectBox: function(
      x1, y1, x2, y2,
      width, height, centerX, 
      centerY, padding) {

      return $$.math.roundRectangleIntersectBox(
        x1, y1, x2, y2, 
        width, height, centerX, centerY, padding);
    },
    
    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
      
      // Check hBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding)) {
        return true;
      }
      
      // Check vBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding)) {
        return true;
      }
      
      var checkInEllipse = function(x, y, centerX, centerY, width, height, padding) {
        x -= centerX;
        y -= centerY;
        
        x /= (width / 2 + padding);
        y /= (height / 2 + padding);
        
        return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
      };
      
      
      // Check top left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      /*
      if (renderer.boxIntersectEllipse(x, y, x, y, padding, 
        cornerRadius * 2, cornerRadius * 2,
        centerX - width + cornerRadius,
        centerY - height + cornerRadius)) {
        return true;
      }
      */
      
      // Check top right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      return false;
    }
  };
  
  nodeShapes['pentagon'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(5, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height, nodeShapes['pentagon'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height, nodeShapes['pentagon'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return renderer.polygonIntersectLine(
        x, y,
        nodeShapes['pentagon'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
      x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['pentagon'].points;
      
      return $$.math.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['pentagon'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  nodeShapes['hexagon'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(6, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['hexagon'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['hexagon'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.polygonIntersectLine(
        x, y,
        nodeShapes['hexagon'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
        x1, y1, x2, y2, width, height, centerX, centerY, padding) {
        
      var points = nodeShapes['hexagon'].points;
      
      return $$.math.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['hexagon'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  nodeShapes['heptagon'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(7, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['heptagon'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['heptagon'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return renderer.polygonIntersectLine(
        x, y,
        nodeShapes['heptagon'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
        x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['heptagon'].points;
      
      return renderer.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, centerY, [0, -1], padding);
    },

    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['heptagon'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  nodeShapes['octagon'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(8, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['octagon'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['octagon'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return renderer.polygonIntersectLine(
        x, y,
        nodeShapes['octagon'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
        x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['octagon'].points;
      
      return renderer.boxIntersectPolygon(
          x1, y1, x2, y2,
          points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['octagon'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  var star5Points = new Array(20);
  {
    var outerPoints = $$.math.generateUnitNgonPoints(5, 0);
    var innerPoints = $$.math.generateUnitNgonPoints(5, Math.PI / 5);
    
//    console.log(outerPoints);
//    console.log(innerPoints);
    
    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;
    
    for (var i=0;i<innerPoints.length/2;i++) {
      innerPoints[i*2] *= innerRadius;
      innerPoints[i*2+1] *= innerRadius;
    }
    
    for (var i=0;i<20/4;i++) {
      star5Points[i*4] = outerPoints[i*2];
      star5Points[i*4+1] = outerPoints[i*2+1];
      
      star5Points[i*4+2] = innerPoints[i*2];
      star5Points[i*4+3] = innerPoints[i*2+1];
    }
    
//    console.log(star5Points);
  }

  star5Points = $$.math.fitPolygonToSquare( star5Points );
  
  nodeShapes['star5'] = nodeShapes['star'] = {
    points: star5Points,
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['star5'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['star5'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return renderer.polygonIntersectLine(
        x, y,
        nodeShapes['star5'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
        x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['star5'].points;
      
      return renderer.boxIntersectPolygon(
          x1, y1, x2, y2,
          points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['star5'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };

})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout

    // callbacks on layout events
    ready: undefined, // callback on layoutready 
    stop: undefined, // callback on layoutstop

    // forces used by arbor (use arbor default on undefined)
    repulsion: undefined,
    stiffness: undefined,
    friction: undefined,
    gravity: true,
    fps: undefined,
    precision: undefined,

    // static numbers or functions that dynamically return what these
    // values should be for each element
    // e.g. nodeMass: function(n){ return n.data('weight') }
    nodeMass: undefined, 
    edgeLength: undefined,

    stepSize: 0.1, // smoothing of arbor bounding box

    // function that returns true if the system is stable to indicate
    // that the layout can be stopped
    stableEnergy: function( energy ){
      var e = energy; 
      return (e.max <= 0.5) || (e.mean <= 0.3);
    },

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };
  
  function ArborLayout(options){
    this._private = {};

    this._private.options = $$.util.extend({}, defaults, options);
  }
    
  ArborLayout.prototype.run = function(){
    var layout = this;
    var options = this._private.options;

    $$.util.require('arbor', function(arbor){

      var cy = options.cy;
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      var simUpdatingPos = false;

      layout.trigger({ type: 'layoutstart', layout: layout });

      // backward compatibility for old animation option
      if( options.liveUpdate !== undefined ){
        options.animate = options.liveUpdate;
      }

      // arbor doesn't work with just 1 node 
      if( cy.nodes().size() <= 1 ){
        if( options.fit ){
          cy.reset();
        }

        cy.nodes().position({
          x: Math.round( (bb.x1 + bb.x2)/2 ),
          y: Math.round( (bb.y1 + bb.y2)/2 )
        });

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        return;
      }

      var sys = layout._private.system = arbor.ParticleSystem();

      sys.parameters({
        repulsion: options.repulsion,
        stiffness: options.stiffness, 
        friction: options.friction, 
        gravity: options.gravity, 
        fps: options.fps, 
        dt: options.dt, 
        precision: options.precision
      });

      if( options.animate && options.fit ){
        cy.fit( bb, options.padding );
      }
      
      var doneTime = 250;
      var doneTimeout;
      
      var ready = false;
      
      var lastDraw = +new Date();
      var sysRenderer = {
        init: function(system){
        },
        redraw: function(){
          var energy = sys.energy();

          // if we're stable (according to the client), we're done
          if( !options.infinite && options.stableEnergy != null && energy != null && energy.n > 0 && options.stableEnergy(energy) ){
            layout.stop();
            return;
          }

          if( !options.infinite && doneTime != Infinity ){
            clearTimeout(doneTimeout);
            doneTimeout = setTimeout(doneHandler, doneTime);
          }
          
          var movedNodes = cy.collection();
          
          sys.eachNode(function(n, point){ 
            var data = n.data;
            var node = data.element;
            
            if( node == null ){
              return;
            }

            if( !node.locked() && !node.grabbed() ){
              node.silentPosition({
                x: bb.x1 + point.x,
                y: bb.y1 + point.y
              });

              movedNodes.merge( node );
            }
          });
          

          if( options.animate && movedNodes.length > 0 ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            lastDraw = +new Date();
            simUpdatingPos = false;
          }

          
          if( !ready ){
            ready = true;
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          }
        }
        
      };
      sys.renderer = sysRenderer;
      sys.screenSize( bb.w, bb.h );
      sys.screenPadding( options.padding, options.padding, options.padding, options.padding );
      sys.screenStep( options.stepSize );

      function calculateValueForElement(element, value){
        if( value == null ){
          return undefined;
        } else if( typeof value == typeof function(){} ){
          return value.apply(element, [element._private.data, {
            nodes: nodes.length,
            edges: edges.length,
            element: element
          }]); 
        } else {
          return value;
        }
      }

      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        if( simUpdatingPos ){ return; }

        var pos = this.position();
        var apos = sys.fromScreen( pos );
        if( !apos ){ return; }

        var p = arbor.Point(apos.x, apos.y);
        var padding = options.padding;

        if(
          bb.x1 + padding <= pos.x && pos.x <= bb.x2 - padding &&
          bb.y1 + padding <= pos.y && pos.y <= bb.y2 - padding
        ){
          this.scratch().arbor.p = p;
        }
        
        switch( e.type ){
        case 'grab':
          this.scratch().arbor.fixed = true;
          break;
        case 'free':
          this.scratch().arbor.fixed = false;
          //this.scratch().arbor.tempMass = 1000;
          break;
        }
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        node.scratch().arbor.fixed = node.locked();
      });
            
      var removeHandler;
      eles.on('remove', removeHandler = function(e){ return; // TODO enable when layout add/remove api added
        // var ele = this;
        // var arborEle = ele.scratch().arbor;

        // if( !arborEle ){ return; }

        // if( ele.isNode() ){
        //   sys.pruneNode( arborEle );
        // } else {
        //   sys.pruneEdge( arborEle );
        // }
      });

      var addHandler;
      cy.on('add', '*', addHandler = function(){ return; // TODO enable when layout add/remove api added
        // var ele = this;

        // if( ele.isNode() ){
        //   addNode( ele );
        // } else {
        //   addEdge( ele );
        // }
      });

      var resizeHandler;
      cy.on('resize', resizeHandler = function(){
        if( options.boundingBox == null && layout._private.system != null ){
          var w = cy.width();
          var h = cy.height();

          sys.screenSize( w, h );
        }
      });

      function addNode( node ){
        if( node.isFullAutoParent() ){ return; } // they don't exist in the sim

        var id = node._private.data.id;
        var mass = calculateValueForElement(node, options.nodeMass);
        var locked = node._private.locked;
        var nPos = node.position();
        
        var pos = sys.fromScreen({
          x: nPos.x,
          y: nPos.y
        });

        node.scratch().arbor = sys.addNode(id, {
          element: node,
          mass: mass,
          fixed: locked,
          x: locked ? pos.x : undefined,
          y: locked ? pos.y : undefined
        });
      }

      function addEdge( edge ){
        var src = edge.source().id();
        var tgt = edge.target().id();
        var length = calculateValueForElement(edge, options.edgeLength);
        
        edge.scratch().arbor = sys.addEdge(src, tgt, {
          length: length
        }); 
      }

      nodes.each(function(i, node){
        addNode( node );
      });
      
      edges.each(function(i, edge){
        addEdge( edge );
      });
      
      var grabbableNodes = nodes.filter(":grabbable");
      // disable grabbing if so set
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }
      
      var doneHandler = layout._private.doneHandler = function(){
        layout._private.doneHandler = null;

        if( !options.animate ){
          if( options.fit ){
            cy.reset();
          }

          nodes.rtrigger('position');
        }

        // unbind handlers
        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);
        eles.off('remove', removeHandler);
        cy.off('add', '*', addHandler);
        cy.off('resize', resizeHandler);
        
        // enable back grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };
      
      sys.start();
      if( !options.infinite && options.maxSimulationTime != null && options.maxSimulationTime > 0 && options.maxSimulationTime !== Infinity ){
        setTimeout(function(){
          layout.stop();
        }, options.maxSimulationTime);
      }
    
    }); // require

    return this; // chaining
  };


  ArborLayout.prototype.stop = function(){
    if( this._private.system != null ){
      this._private.system.stop();
    }

    if( this._private.doneHandler ){
      this._private.doneHandler();
    }

    return this; // chaining
  };
  
  $$('layout', 'arbor', ArborLayout);
  
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
    padding: 30, // padding on fit
    circle: false, // put depths in concentric circles if true, put depths top down if false
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    roots: undefined, // the roots of the trees
    maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function BreadthFirstLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  BreadthFirstLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    var graph = eles;
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var roots;
    if( $$.is.elementOrCollection(options.roots) ){
      roots = options.roots;
    } else if( $$.is.array(options.roots) ){
      var rootsArray = [];

      for( var i = 0; i < options.roots.length; i++ ){
        var id = options.roots[i];
        var ele = cy.getElementById( id );
        rootsArray.push( ele );
      }

      roots = new $$.Collection( cy, rootsArray );
    } else if( $$.is.string(options.roots) ){
      roots = cy.$( options.roots );

    } else {
      if( options.directed ){
        roots = nodes.roots();
      } else {
        var components = [];
        var unhandledNodes = nodes;

        while( unhandledNodes.length > 0 ){
          var currComp = cy.collection();

          eles.bfs({
            roots: unhandledNodes[0],
            visit: function(i, depth, node, edge, pNode){
              currComp = currComp.add( node );
            },
            directed: false
          });

          unhandledNodes = unhandledNodes.not( currComp );
          components.push( currComp );
        }

        roots = cy.collection();
        for( var i = 0; i < components.length; i++ ){
          var comp = components[i];
          var maxDegree = comp.maxDegree( false );
          var compRoots = comp.filter(function(){
            return this.degree(false) === maxDegree;
          });

          roots = roots.add( compRoots );
        }
        
      }
    }


    var depths = [];
    var foundByBfs = {};
    var id2depth = {};
    var prevNode = {};
    var prevEdge = {};
    var successors = {};

    // find the depths of the nodes
    graph.bfs({
      roots: roots,
      directed: options.directed,
      visit: function(i, depth, node, edge, pNode){
        var ele = this[0];
        var id = ele.id();

        if( !depths[depth] ){
          depths[depth] = [];
        }

        depths[depth].push( ele );
        foundByBfs[ id ] = true;
        id2depth[ id ] = depth;
        prevNode[ id ] = pNode;
        prevEdge[ id ] = edge;

        if( pNode ){
          var prevId = pNode.id();
          var succ = successors[ prevId ] = successors[ prevId ] || [];
          
          succ.push( node );
        }
      }
    });

    // check for nodes not found by bfs
    var orphanNodes = [];
    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[i];

      if( foundByBfs[ ele.id() ] ){
        continue;
      } else {
        orphanNodes.push( ele );
      }
    }

    // assign orphan nodes a depth from their neighborhood
    var maxChecks = orphanNodes.length * 3;
    var checks = 0;
    while( orphanNodes.length !== 0 && checks < maxChecks ){
      var node = orphanNodes.shift();
      var neighbors = node.neighborhood().nodes();
      var assignedDepth = false;

      for( var i = 0; i < neighbors.length; i++ ){
        var depth = id2depth[ neighbors[i].id() ];

        if( depth !== undefined ){
          depths[depth].push( node );
          assignedDepth = true;
          break;
        }
      }

      if( !assignedDepth ){
        orphanNodes.push( node );
      }

      checks++;
    }

    // assign orphan nodes that are still left to the depth of their subgraph
    while( orphanNodes.length !== 0 ){
      var node = orphanNodes.shift();
      //var subgraph = graph.bfs( node ).path;
      var assignedDepth = false;

      // for( var i = 0; i < subgraph.length; i++ ){
      //   var depth = id2depth[ subgraph[i].id() ];

      //   if( depth !== undefined ){
      //     depths[depth].push( node );
      //     assignedDepth = true;
      //     break;
      //   }
      // }

      if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
        if( depths.length === 0 ){
          depths.push([]);
        }
        
        depths[0].push( node );
      }
    }

    // assign the nodes a depth and index
    var assignDepthsToEles = function(){
      for( var i = 0; i < depths.length; i++ ){
        var eles = depths[i];

        for( var j = 0; j < eles.length; j++ ){
          var ele = eles[j];

          ele._private.scratch.breadthfirst = {
            depth: i,
            index: j
          };
        }
      }
    };
    assignDepthsToEles();


    var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
      var edges = node.connectedEdges(function(){
        return this.data('target') === node.id();
      });
      var thisInfo = node._private.scratch.breadthfirst;
      var highestDepthOfOther = 0;
      var highestOther;
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];
        var otherNode = edge.source()[0];
        var otherInfo = otherNode._private.scratch.breadthfirst;

        if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
          highestDepthOfOther = otherInfo.depth;
          highestOther = otherNode;
        }
      }

      return highestOther;
    };

     // make maximal if so set by adjusting depths
    for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

      var nDepths = depths.length;
      var elesToMove = [];
      for( var i = 0; i < nDepths; i++ ){
        var depth = depths[i];

        var nDepth = depth.length;
        for( var j = 0; j < nDepth; j++ ){
          var ele = depth[j];
          var info = ele._private.scratch.breadthfirst;
          var intEle = intersectsDepth(ele);

          if( intEle ){
            info.intEle = intEle;
            elesToMove.push( ele );
          }
        }
      }

      for( var i = 0; i < elesToMove.length; i++ ){ 
        var ele = elesToMove[i];
        var info = ele._private.scratch.breadthfirst;
        var intEle = info.intEle;
        var intInfo = intEle._private.scratch.breadthfirst;

        depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

        // add to end of new depth
        var newDepth = intInfo.depth + 1;
        while( newDepth > depths.length - 1 ){
          depths.push([]);
        }
        depths[ newDepth ].push( ele );

        info.depth = newDepth;
        info.index = depths[newDepth].length - 1;
      }

      assignDepthsToEles();
    }

    // find min distance we need to leave between nodes
    var minDistance = 0;
    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var w = nodes[i].outerWidth();
        var h = nodes[i].outerHeight();
        
        minDistance = Math.max(minDistance, w, h);
      }
      minDistance *= 1.75; // just to have some nice spacing
    }

    // get the weighted percent for an element based on its connectivity to other levels
    var cachedWeightedPercent = {};
    var getWeightedPercent = function( ele ){
      if( cachedWeightedPercent[ ele.id() ] ){
        return cachedWeightedPercent[ ele.id() ];
      }

      var eleDepth = ele._private.scratch.breadthfirst.depth;
      var neighbors = ele.neighborhood().nodes();
      var percent = 0;
      var samples = 0;

      for( var i = 0; i < neighbors.length; i++ ){
        var neighbor = neighbors[i];
        var index = neighbor._private.scratch.breadthfirst.index;
        var depth = neighbor._private.scratch.breadthfirst.depth;
        var nDepth = depths[depth].length;

        if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
          percent += index / nDepth;
          samples++;
        }
      }

      samples = Math.max(1, samples);
      percent = percent / samples;

      if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
        percent = undefined;
      }

      cachedWeightedPercent[ ele.id() ] = percent;
      return percent;
    };


    // rearrange the indices in each depth level based on connectivity

    var sortFn = function(a, b){
      var apct = getWeightedPercent( a );
      var bpct = getWeightedPercent( b );

      return apct - bpct;
    };

    for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

      for( var i = 0; i < depths.length; i++ ){
        depths[i] = depths[i].sort( sortFn );
      }
      assignDepthsToEles(); // and update

    }

    var biggestDepthSize = 0;
    for( var i = 0; i < depths.length; i++ ){
      biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );
    }

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.x1 + bb.h/2
    };
   
    var getPosition = function( ele, isBottomDepth ){
      var info = ele._private.scratch.breadthfirst;
      var depth = info.depth;
      var index = info.index;
      var depthSize = depths[depth].length;

      if( options.strictHierarchy ){
        depthSize = biggestDepthSize;
      }

      var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
      var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
      var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
      radiusStepSize = Math.max( radiusStepSize, minDistance );

      if( options.strictHierarchy && !options.circle ){
        
        var epos = {
          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
          y: (depth + 1) * distanceY
        };

        if( isBottomDepth ){
          return epos;
        }

        var succs = successors[ ele.id() ];
        if( succs ){
          epos.x = 0;

          for( var i = 0 ; i < succs.length; i++ ){
            var spos = pos[ succs[i].id() ];
            
            epos.x += spos.x;
          }

          epos.x /= succs.length;
        } else {
          //debugger;
        }

        return epos;

      } else {
        if( options.circle ){
          var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);
          var theta = 2 * Math.PI / depths[depth].length * index;

          if( depth === 0 && depths[0].length === 1 ){
            radius = 1;
          }

          return {
            x: center.x + radius * Math.cos(theta),
            y: center.y + radius * Math.sin(theta)
          };

        } else {
          return {
            x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
            y: (depth + 1) * distanceY
          };
        }
      }
      
    };

    // get positions in reverse depth order
    var pos = {};
    for( var i = depths.length - 1; i >=0; i-- ){
      var depth = depths[i];

      for( var j = 0; j < depth.length; j++ ){
        var node = depth[j];

        pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
      }
    }

    nodes.layoutPositions(this, options, function(){
      return pos[ this.id() ];
    });
    
    return this; // chaining
  };
  
  $$('layout', 'breadthfirst', BreadthFirstLayout);
  
})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
    radius: undefined, // the radius of the circle
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function CircleLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  CircleLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
      
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var theta = options.startAngle;
    var dTheta = 2 * Math.PI / nodes.length;
    var r;

    var minDistance = 0;
    for( var i = 0; i < nodes.length; i++ ){
      var w = nodes[i].outerWidth();
      var h = nodes[i].outerHeight();
      
      minDistance = Math.max(minDistance, w, h);
    }

    if( $$.is.number(options.radius) ){
      r = options.radius;
    } else if( nodes.length <= 1 ){
      r = 0;
    } else {
      r = Math.min( bb.h, bb.w )/2 - minDistance;
    }

    // calculate the radius
    if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      minDistance *= 1.75; // just to have some nice spacing

      var dTheta = 2 * Math.PI / nodes.length;
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
      r = Math.max( rMin, r );
    }

    var getPos = function( i, ele ){
      var rx = r * Math.cos( theta );
      var ry = r * Math.sin( theta );
      var pos = {
        x: center.x + rx,
        y: center.y + ry
      };

      theta = options.counterclockwise ? theta - dTheta : theta + dTheta;
      return pos;
    };
    
    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  $$('layout', 'circle', CircleLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    animate: true, // whether to show the layout as it's running
    refresh: 1, // number of ticks per frame; higher is faster but more jerky
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }

    // layout event callbacks
    ready: function(){}, // on layoutready
    stop: function(){}, // on layoutstop

    // positioning options
    randomize: false, // use random node positions at beginning of layout
    avoidOverlap: true, // if true, prevents overlap of node bounding boxes
    handleDisconnected: true, // if true, avoids disconnected components from overlapping
    nodeSpacing: function( node ){ return 10; }, // extra spacing around nodes
    flow: undefined, // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }
    alignment: undefined, // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }

    // different methods of specifying edge length
    // each can be a constant numerical value or a function like `function( edge ){ return 2; }`
    edgeLength: undefined, // sets edge length directly in simulation
    edgeSymDiffLength: undefined, // symmetric diff edge length in simulation
    edgeJaccardLength: undefined, // jaccard edge length in simulation

    // iterations of cola algorithm; uses default values on undefined
    unconstrIter: undefined, // unconstrained initial layout iterations
    userConstIter: undefined, // initial layout iterations with user-specified constraints
    allConstIter: undefined, // initial layout iterations with all constraints including non-overlap

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };

  // constructor
  // options : object containing layout options
  function ColaLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  ColaLayout.prototype.run = function(){
    var layout = this;
    var options = this.options;

    $$.util.require('cola', function(cola){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;
      var nodes = eles.nodes();
      var edges = eles.edges();
      var ready = false;
      
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var getOptVal = function( val, ele ){
        if( $$.is.fn(val) ){
          var fn = val;
          return fn.apply( ele, [ ele ] );
        } else {
          return val;
        }
      };

      var updateNodePositions = function(){
        var x = { min: Infinity, max: -Infinity };
        var y = { min: Infinity, max: -Infinity };

        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var scratch = node._private.scratch.cola;

          x.min = Math.min( x.min, scratch.x );
          x.max = Math.max( x.max, scratch.x );

          y.min = Math.min( y.min, scratch.y );
          y.max = Math.max( y.max, scratch.y );
        }

        nodes.positions(function(i, node){
          var pos = node._private.position;
          var scratch = node._private.scratch.cola;

          if( !node.grabbed() ){
            pos.x = bb.x1 + scratch.x - x.min;
            pos.y = bb.y1 + scratch.y - y.min;
          }
        });

        if( !ready ){
          onReady();
          ready = true;
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
      };

      var onDone = function(){
        layout.manuallyStopped = false;

        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);

        // trigger layoutstop when the layout stops (e.g. finishes)
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };

      var onReady = function(){
        // trigger layoutready when each node has had its position set at least once
        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      };

      var ticksPerFrame = options.refresh;
      var tickSkip = 1; // frames until a tick; used to slow down sim for debugging

      if( options.refresh < 0 ){
        tickSkip = Math.abs( options.refresh );
        ticksPerFrame = 1;
      } else {
        ticksPerFrame = Math.max( 1, ticksPerFrame ); // at least 1
      }

      var adaptor = cola.adaptor({
        trigger: function( e ){ // on sim event
          switch( e.type ){
            case 'tick':
              if( options.animate ){
                updateNodePositions();
              }
              break;

            case 'end': 
              updateNodePositions();
              if( !options.infinite || layout.manuallyStopped ){ onDone(); }           
              break;
          }
        },

        kick: function( tick ){ // kick off the simulation
          var skip = 0;

          var inftick = function(){
            var ret = tick();

            if( ret && options.infinite ){ // resume layout if done
              adaptor.resume(); // resume => new kick
            }
            
            return ret; // allow regular finish b/c of new kick
          };

          var multitick = function(){ // multiple ticks in a row
            var ret;

            // skip ticks to slow down layout for debugging
            var thisSkip = skip;
            skip = (skip + 1) % tickSkip;
            if( thisSkip !== 0 ){
              return false;
            }

            for( var i = 0; i < ticksPerFrame && !ret; i++ ){
              ret = ret || inftick(); // pick up true ret vals => sim done
            }

            return ret;
          };

          if( options.animate ){
            var frame = function(){
              if( multitick() ){ return; }

              $$.util.requestAnimationFrame( frame );
            };

            $$.util.requestAnimationFrame( frame );
          } else {
            while( !inftick() ){}
          }
        },

        on: function( type, listener ){}, // dummy; not needed

        drag: function(){} // TODO
      });
      layout.adaptor = adaptor;

      // if set no grabbing during layout
      var grabbableNodes = nodes.filter(':grabbable');
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }

      // handle node dragging
      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
        var pos = node._private.position;

        if( node.grabbed() ){
          scrCola.x = pos.x - bb.x1;
          scrCola.y = pos.y - bb.y1;

          adaptor.dragstart( scrCola );
        } else if( $$.is.number(scrCola.x) && $$.is.number(scrCola.y) ){
          pos.x = scrCola.x + bb.x1;
          pos.y = scrCola.y + bb.y1;
        }

        switch( e.type ){
          case 'grab':
            adaptor.dragstart( scrCola );
            adaptor.resume();
            break;
          case 'free':
            adaptor.dragend( scrCola );
            break;
        }
        
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
      
        if( node.locked() ){
          adaptor.dragstart( scrCola );
        } else {
          adaptor.dragend( scrCola );
        }
      });

      var nonparentNodes = nodes.stdFilter(function( node ){
        return !node.isParent();
      });

      // add nodes to cola
      adaptor.nodes( nonparentNodes.map(function( node, i ){
        var padding = getOptVal( options.nodeSpacing, node );
        var pos = node.position();

        var struct = node._private.scratch.cola = {
          x: options.randomize ? Math.round( Math.random() * bb.w ) : pos.x,
          y: options.randomize ? Math.round( Math.random() * bb.h ) : pos.y,
          width: node.outerWidth() + 2*padding,
          height: node.outerHeight() + 2*padding,
          index: i
        };

        return struct;
      }) );

      if( options.alignment ){ // then set alignment constraints

        var offsetsX = [];
        var offsetsY = [];

        nonparentNodes.forEach(function( node ){
          var align = getOptVal( options.alignment, node );
          var scrCola = node._private.scratch.cola;
          var index = scrCola.index;

          if( !align ){ return; }

          if( align.x != null ){
            offsetsX.push({
              node: index,
              offset: align.x
            });
          }

          if( align.y != null ){
            offsetsY.push({
              node: index,
              offset: align.y
            });
          }
        });

        // add alignment constraints on nodes
        var constraints = [];

        if( offsetsX.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'x',
            offsets: offsetsX
          });
        }

        if( offsetsY.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'y',
            offsets: offsetsY
          });
        }
        
        adaptor.constraints( constraints );

      }

      // add compound nodes to cola
      adaptor.groups( nodes.stdFilter(function( node ){
        return node.isParent();
      }).map(function( node, i ){ // add basic group incl leaf nodes
        node._private.scratch.cola = {
          index: i,

          leaves: node.children().stdFilter(function( child ){
            return !child.isParent();
          }).map(function( child ){
            return child[0]._private.scratch.cola.index;
          })
        };

        return node;
      }).map(function( node ){ // add subgroups
        node._private.scratch.cola.groups = node.children().stdFilter(function( child ){
          return child.isParent();
        }).map(function( child ){
          return child._private.scratch.cola.index;
        });

        return node._private.scratch.cola;
      }) );

      // get the edge length setting mechanism
      var length;
      var lengthFnName;
      if( options.edgeLength != null ){
        length = options.edgeLength;
        lengthFnName = 'linkDistance';
      } else if( options.edgeSymDiffLength != null ){
        length = options.edgeSymDiffLength;
        lengthFnName = 'symmetricDiffLinkLengths';
      } else if( options.edgeJaccardLength != null ){
        length = options.edgeJaccardLength;
        lengthFnName = 'jaccardLinkLengths';
      } else {
        length = 100;
        lengthFnName = 'linkDistance';
      }

      var lengthGetter = function( link ){
        return link.calcLength;
      };

      // add the edges to cola
      adaptor.links( edges.stdFilter(function( edge ){
        return !edge.source().isParent() && !edge.target().isParent();
      }).map(function( edge, i ){
        var c = edge._private.scratch.cola = {
          source: edge.source()[0]._private.scratch.cola.index,
          target: edge.target()[0]._private.scratch.cola.index
        };

        if( length != null ){
          c.calcLength = getOptVal( length, edge );
        }

        return c;
      }) );

      adaptor.size([ bb.w, bb.h ]);

      if( length != null ){
        adaptor[ lengthFnName ]( lengthGetter );
      }

      // set the flow of cola
      if( options.flow ){
        var flow;
        var defAxis = 'y';
        var defMinSep = 50;

        if( $$.is.string(options.flow) ){
          flow = {
            axis: options.flow,
            minSeparation: defMinSep
          };
        } else if( $$.is.number(options.flow) ){
          flow = {
            axis: defAxis,
            minSeparation: options.flow
          };
        } else if( $$.is.plainObject(options.flow) ){
          flow = options.flow;

          flow.axis = flow.axis || defAxis;
          flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;
        } else { // e.g. options.flow: true
          flow = {
            axis: defAxis,
            minSeparation: defMinSep
          };
        }

        adaptor.flowLayout( flow.axis , flow.minSeparation );
      }

      adaptor
        .avoidOverlaps( options.avoidOverlap )
        .handleDisconnected( options.handleDisconnected )
        .start( options.unconstrIter, options.userConstIter, options.allConstIter)
      ;

      layout.trigger({ type: 'layoutstart', layout: layout });

      if( !options.infinite ){
        setTimeout(function(){
          adaptor.stop();
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  ColaLayout.prototype.stop = function(){
    if( this.adaptor ){
      this.manuallyStopped = true;
      this.adaptor.stop();
    }

    return this; // chaining
  };

  // register the layout
  $$('layout', 'cola', ColaLayout);

})(cytoscape);
;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise/anticlockwise (true) or clockwise (false)
    minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    height: undefined, // height of layout area (overrides container height)
    width: undefined, // width of layout area (overrides container width)
    concentric: function(){ // returns numeric value for each node, placing higher nodes in levels towards the centre
      return this.degree();
    },
    levelWidth: function(nodes){ // the variation of concentric values in each level
      return nodes.maxDegree() / 4;
    },
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function ConcentricLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  ConcentricLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var nodeValues = []; // { node, value }
    var theta = options.startAngle;
    var maxNodeSize = 0;

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];
      var value;
      
      // calculate the node value
      value = options.concentric.call(node);
      nodeValues.push({
        value: value,
        node: node
      });

      // for style mapping
      node._private.layoutData.concentric = value;
    }

    // in case we used the `concentric` in style
    nodes.updateStyle();

    // calculate max size now based on potentially updated mappers
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];

      maxNodeSize = Math.max( maxNodeSize, node.outerWidth(), node.outerHeight() );
    }

    // sort node values in descreasing order
    nodeValues.sort(function(a, b){
      return b.value - a.value;
    });

    var levelWidth = options.levelWidth( nodes );

    // put the values into levels
    var levels = [ [] ];
    var currentLevel = levels[0];
    for( var i = 0; i < nodeValues.length; i++ ){
      var val = nodeValues[i];

      if( currentLevel.length > 0 ){
        var diff = Math.abs( currentLevel[0].value - val.value );

        if( diff >= levelWidth ){
          currentLevel = [];
          levels.push( currentLevel );
        }
      }

      currentLevel.push( val );
    }

    // create positions from levels

    var pos = {}; // id => position
    var r = 0;
    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

    if( !options.avoidOverlap ){ // then strictly constrain to bb
      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
      var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );
      var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

      minDist = Math.min( minDist, rStep );
    }

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[i];
      var dTheta = 2 * Math.PI / level.length;

      // calculate the radius
      if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
        var dcos = Math.cos(dTheta) - Math.cos(0);
        var dsin = Math.sin(dTheta) - Math.sin(0);
        var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
        r = Math.max( rMin, r );
      }

      for( var j = 0; j < level.length; j++ ){
        var val = level[j];
        var theta = options.startAngle + (options.counterclockwise ? 1 : -1) * dTheta * j;

        var p = {
          x: center.x + r * Math.cos(theta),
          y: center.y + r * Math.sin(theta)
        };

        pos[ val.node.id() ] = p;
      }

      r += minDist;
      
    } 

    // position the nodes
    nodes.layoutPositions(this, options, function(){
      var id = this.id();

      return pos[id];
    });
  
    return this; // chaining
  };
  
  $$('layout', 'concentric', ConcentricLayout);
  
})( cytoscape );

/*
  The CoSE layout was written by Gerardo Huck.

  Modifications tracked on Github.
*/

;(function($$) { 'use strict';

  var DEBUG;

  /**
   * @brief :  default layout options
   */
  var defaults = {
    // Called on `layoutready`
    ready               : function() {},

    // Called on `layoutstop`
    stop                : function() {},

    // Whether to animate while running the layout
    animate             : true,

    // Number of iterations between consecutive screen positions update (0 -> only updated on the end)
    refresh             : 4,
    
    // Whether to fit the network view after when done
    fit                 : true, 

    // Padding on fit
    padding             : 30, 

    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    boundingBox         : undefined,

    // Whether to randomize node positions on the beginning
    randomize           : true,
    
    // Whether to use the JS console to print debug messages
    debug               : false,

    // Node repulsion (non overlapping) multiplier
    nodeRepulsion       : 400000,
    
    // Node repulsion (overlapping) multiplier
    nodeOverlap         : 10,
    
    // Ideal edge (non nested) length
    idealEdgeLength     : 10,
    
    // Divisor to compute edge forces
    edgeElasticity      : 100,
    
    // Nesting factor (multiplier) to compute ideal edge length for nested edges
    nestingFactor       : 5, 
    
    // Gravity force (constant)
    gravity             : 250, 
    
    // Maximum number of iterations to perform
    numIter             : 100,
    
    // Initial temperature (maximum node displacement)
    initialTemp         : 200,
    
    // Cooling factor (how the temperature is reduced between consecutive iterations
    coolingFactor       : 0.95, 
    
    // Lower temperature threshold (below this point the layout will end)
    minTemp             : 1.0
  };


  /**
   * @brief       : constructor
   * @arg options : object containing layout options
   */
  function CoseLayout(options) {
    this.options = $$.util.extend({}, defaults, options); 
  }


  /**
   * @brief : runs the layout
   */
  CoseLayout.prototype.run = function() {
    var options = this.options;
    var cy      = options.cy;
    var layout  = this;

    layout.stopped = false;

    layout.trigger({ type: 'layoutstart', layout: layout });

    // Set DEBUG - Global variable
    if (true === options.debug) {
      DEBUG = true;
    } else {
      DEBUG = false;
    }

    // Get start time
    var startTime = new Date();

    // Initialize layout info
    var layoutInfo = createLayoutInfo(cy, layout, options);
    
    // Show LayoutInfo contents if debugging
    if (DEBUG) {
      printLayoutInfo(layoutInfo);
    }

    // If required, randomize node positions
    if (true === options.randomize) {
      randomizePositions(layoutInfo, cy);
    }

    updatePositions(layoutInfo, cy, options);

    var mainLoop = function(i){
      if( layout.stopped ){
        logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step(layoutInfo, cy, options, i);
      
      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      logDebug("New temperature: " + layoutInfo.temperature);

      if (layoutInfo.temperature < options.minTemp) {
        logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var done = function(){
      refreshPositions(layoutInfo, cy, options);

      // Fit the graph if necessary
      if (true === options.fit) {
        cy.fit( options.padding );
      }
      
      // Get end time
      var endTime = new Date();

      console.info('Layout took ' + (endTime - startTime) + ' ms');

      // Layout has finished
      layout.one('layoutstop', options.stop);
      layout.trigger({ type: 'layoutstop', layout: layout });
    };

    if( options.animate ){
      var i = 0;
      var frame = function(){

        var f = 0;
        var loopRet;
        while( f < options.refresh && i < options.numIter ){
          var loopRet = mainLoop(i);
          if( loopRet === false ){ break; }

          f++;
          i++;
        }

        refreshPositions(layoutInfo, cy, options);
        if( options.fit ){
          cy.fit( options.padding );
        }

        if ( loopRet !== false && i + 1 < options.numIter ) {
          $$.util.requestAnimationFrame( frame );
        } else {
          done();
        }
      };

      $$.util.requestAnimationFrame( frame );
    } else {
      for (var i = 0; i < options.numIter; i++) {
        if( mainLoop(i) === false ){ break; }
      }

      done();
    }
   
    return this; // chaining
  };


  /**
   * @brief : called on continuous layouts to stop them before they finish
   */
  CoseLayout.prototype.stop = function(){
    this.stopped = true;

    return this; // chaining
  };


  /**
   * @brief     : Creates an object which is contains all the data
   *              used in the layout process
   * @arg cy    : cytoscape.js object
   * @return    : layoutInfo object initialized
   */
  var createLayoutInfo = function(cy, layout, options) {
    // Shortcut
    var edges = options.eles.edges();
    var nodes = options.eles.nodes();

    var layoutInfo   = {
      layout       : layout,
      layoutNodes  : [], 
      idToIndex    : {},
      nodeSize     : nodes.size(),
      graphSet     : [],
      indexToGraph : [], 
      layoutEdges  : [],
      edgeSize     : edges.size(),
      temperature  : options.initialTemp,
      clientWidth  : cy.width(),
      clientHeight : cy.width(),
      boundingBox  : $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                       x1: 0, y1: 0, w: cy.width(), h: cy.height()
                     } )
    }; 
    
    // Iterate over all nodes, creating layout nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var tempNode        = {};
      tempNode.id         = nodes[i].data('id');
      tempNode.parentId   = nodes[i].data('parent');      
      tempNode.children   = [];
      tempNode.positionX  = nodes[i].position('x');
      tempNode.positionY  = nodes[i].position('y');
      tempNode.offsetX    = 0;      
      tempNode.offsetY    = 0;
      tempNode.height     = nodes[i].height();
      tempNode.width      = nodes[i].width();
      tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
      tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
      tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
      tempNode.minY       = tempNode.positionY - tempNode.height / 2;
      tempNode.padLeft    = nodes[i]._private.style['padding-left'].pxValue;
      tempNode.padRight   = nodes[i]._private.style['padding-right'].pxValue;
      tempNode.padTop     = nodes[i]._private.style['padding-top'].pxValue;
      tempNode.padBottom  = nodes[i]._private.style['padding-bottom'].pxValue;
      
      // Add new node
      layoutInfo.layoutNodes.push(tempNode);
      // Add entry to id-index map
      layoutInfo.idToIndex[tempNode.id] = i;
    }

    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    var tempGraph = [];

    // Second pass to add child information and 
    // initialize queue for hierarchical traversal
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var p_id = n.parentId;
      // Check if node n has a parent node
      if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
      } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);    
      }
    }
    
    // Add root graph to graphSet
    layoutInfo.graphSet.push(tempGraph);

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var node_id  = queue[start++];
      var node_ix  = layoutInfo.idToIndex[node_id];
      var node     = layoutInfo.layoutNodes[node_ix];
      var children = node.children;
      if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children);
      // Add children to que queue to be visited
      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
      }
    }

    // Create indexToGraph map
    for (var i = 0; i < layoutInfo.graphSet.length; i++) {      
      var graph = layoutInfo.graphSet[i];
      for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
      }
    }
    
    // Iterate over all edges, creating Layout Edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      var e = edges[i];
      var tempEdge = {};      
      tempEdge.id       = e.data('id');
      tempEdge.sourceId = e.data('source');
      tempEdge.targetId = e.data('target');

      // Compute ideal length
      var idealLength = options.idealEdgeLength;

      // Check if it's an inter graph edge
      var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];
      var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];
      var sourceGraph = layoutInfo.indexToGraph[sourceIx];
      var targetGraph = layoutInfo.indexToGraph[targetIx];

      if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[targetIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +  
         ". Index: " + lca + " Contents: " + lcaGraph.toString() + 
         ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
      }

      tempEdge.idealLength = idealLength;

      layoutInfo.layoutEdges.push(tempEdge);
    }

    // Finally, return layoutInfo object
    return layoutInfo;
  };

  
  /**
   * @brief : This function finds the index of the lowest common 
   *          graph ancestor between 2 nodes in the subtree 
   *          (from the graph hierarchy induced tree) whose
   *          root is graphIx
   *
   * @arg node1: node1's ID
   * @arg node2: node2's ID
   * @arg layoutInfo: layoutInfo object
   *
   */
  var findLCA = function(node1, node2, layoutInfo) {
    // Find their common ancester, starting from the root graph
    var res = findLCA_aux(node1, node2, 0, layoutInfo);
    if (2 > res.count) {
      // If aux function couldn't find the common ancester, 
      // then it is the root graph
      return 0;
    } else {
      return res.graph;
    }
  };


  /**
   * @brief          : Auxiliary function used for LCA computation
   * 
   * @arg node1      : node1's ID
   * @arg node2      : node2's ID
   * @arg graphIx    : subgraph index
   * @arg layoutInfo : layoutInfo object
   *
   * @return         : object of the form {count: X, graph: Y}, where:
   *                   X is the number of ancesters (max: 2) found in 
   *                   graphIx (and it's subgraphs),
   *                   Y is the graph index of the lowest graph containing 
   *                   all X nodes
   */
  var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {
    var graph = layoutInfo.graphSet[graphIx];
    // If both nodes belongs to graphIx
    if (-1 < $.inArray(node1, graph) && -1 < $.inArray(node2, graph)) {
      return {count:2, graph:graphIx};
    }

    // Make recursive calls for all subgraphs
    var c = 0;
    for (var i = 0; i < graph.length; i++) {
      var nodeId   = graph[i];
      var nodeIx   = layoutInfo.idToIndex[nodeId];
      var children = layoutInfo.layoutNodes[nodeIx].children;

      // If the node has no child, skip it
      if (0 === children.length) {
      continue;
      }

      var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
      var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
      if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
      } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;
      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
      } else {
      // Both nodes are present in this subgraph
      return result;
      }      
    }
    
    return {count:c, graph:graphIx};
  };


  /**
   * @brief: printsLayoutInfo into js console
   *         Only used for debbuging 
   */
  var printLayoutInfo = function(layoutInfo) {
    if (!DEBUG) {
      return;
    }
    console.debug("layoutNodes:");
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var s = 
      "\nindex: "     + i + 
      "\nId: "        + n.id + 
      "\nChildren: "  + n.children.toString() +  
      "\nparentId: "  + n.parentId  + 
      "\npositionX: " + n.positionX + 
      "\npositionY: " + n.positionY +
      "\nOffsetX: " + n.offsetX + 
      "\nOffsetY: " + n.offsetY + 
      "\npadLeft: " + n.padLeft + 
      "\npadRight: " + n.padRight + 
      "\npadTop: " + n.padTop + 
      "\npadBottom: " + n.padBottom;

      console.debug(s);    
    }  
    
    console.debug('idToIndex');
    for (var i in layoutInfo.idToIndex) {
      console.debug("Id: " + i + "\nIndex: " + layoutInfo.idToIndex[i]);
    }

    console.debug('Graph Set');
    var set = layoutInfo.graphSet;
    for (var i = 0; i < set.length; i ++) {
      console.debug("Set : " + i + ": " + set[i].toString());
    } 

    var s = 'IndexToGraph';
    for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {
      s += "\nIndex : " + i + " Graph: "+ layoutInfo.indexToGraph[i];
    }
    console.debug(s);

    s = 'Layout Edges';
    for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
      var e = layoutInfo.layoutEdges[i];
      s += "\nEdge Index: " + i + " ID: " + e.id + 
      " SouceID: " + e.sourceId + " TargetId: " + e.targetId + 
      " Ideal Length: " + e.idealLength;
    }
    console.debug(s);

    s =  "nodeSize: " + layoutInfo.nodeSize;
    s += "\nedgeSize: " + layoutInfo.edgeSize;
    s += "\ntemperature: " + layoutInfo.temperature;
    console.debug(s);

    return;
  };


  /**
   * @brief : Randomizes the position of all nodes
   */
  var randomizePositions = function(layoutInfo, cy) {
    var width     = layoutInfo.clientWidth;
    var height    = layoutInfo.clientHeight;

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      // No need to randomize compound nodes
      if (true || 0 === n.children.length) {
        n.positionX = Math.random() * width;
        n.positionY = Math.random() * height;
      }
    }
  };

  
  /**
   * @brief          : Updates the positions of nodes in the network
   * @arg layoutInfo : LayoutInfo object
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var refreshPositions = function(layoutInfo, cy, options) {  
    var s = 'Refreshing positions';
    logDebug(s);

    var layout = layoutInfo.layout;
    var nodes = options.eles.nodes();
    var bb = layoutInfo.boundingBox;
    var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
    
    if( options.boundingBox ){
      nodes.forEach(function( node ){
        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

        coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
        coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

        coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
        coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
      });

      coseBB.w = coseBB.x2 - coseBB.x1;
      coseBB.h = coseBB.y2 - coseBB.y1;
    }

    nodes.positions(function(i, ele) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
      s = "Node: " + lnode.id + ". Refreshed position: (" + 
      lnode.positionX + ", " + lnode.positionY + ").";
      logDebug(s);

      if( options.boundingBox ){ // then add extra bounding box constraint
        var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
        var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

        return {
          x: bb.x1 + pctX * bb.w,
          y: bb.y1 + pctY * bb.h
        };
      } else {
        return {
          x: lnode.positionX,
          y: lnode.positionY
        };
      }
    });

    // Trigger layoutReady only on first call
    if (true !== layoutInfo.ready) {
      s = 'Triggering layoutready';
      logDebug(s);
      layoutInfo.ready = true;
      layout.one('layoutready', options.ready);
      layout.trigger({ type: 'layoutready', layout: this });
    }
  };


  /**
   * @brief          : Performs one iteration of the physical simulation
   * @arg layoutInfo : LayoutInfo object already initialized
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var step = function(layoutInfo, cy, options, step) {  
    var s = "\n\n###############################";
    s += "\nSTEP: " + step;
    s += "\n###############################\n";
    logDebug(s);

    // Calculate node repulsions
    calculateNodeForces(layoutInfo, cy, options);
    // Calculate edge forces
    calculateEdgeForces(layoutInfo, cy, options);
    // Calculate gravity forces
    calculateGravityForces(layoutInfo, cy, options);
    // Propagate forces from parent to child
    propagateForces(layoutInfo, cy, options);
    // Update positions based on calculated forces
    updatePositions(layoutInfo, cy, options);
  };

  
  /**
   * @brief : Computes the node repulsion forces
   */
  var calculateNodeForces = function(layoutInfo, cy, options) {
    // Go through each of the graphs in graphSet
    // Nodes only repel each other if they belong to the same graph
    var s = 'calculateNodeForces';
    logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      s = "Set: " + graph.toString();
      logDebug(s);

      // Now get all the pairs of nodes 
      // Only get each pair once, (A, B) = (B, A)
      for (var j = 0; j < numNodes; j++) {
      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
      for (var k = j + 1; k < numNodes; k++) {
        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
        nodeRepulsion(node1, node2, layoutInfo, cy, options);
      } 
      }
    } 
  };


  /**
   * @brief : Compute the node repulsion forces between a pair of nodes
   */
  var nodeRepulsion = function(node1, node2, layoutInfo, cy, options) {
    var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

    // Get direction of line connecting both node centers
    var directionX = node2.positionX - node1.positionX;
    var directionY = node2.positionY - node1.positionY;
    s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

    // If both centers are the same, apply a random force
    if (0 === directionX && 0 === directionY) {
      s += "\nNodes have the same position.";
      return; // TODO
    }

    var overlap = nodesOverlap(node1, node2, directionX, directionY);
    
    if (overlap > 0) {
      s += "\nNodes DO overlap.";
      s += "\nOverlap: " + overlap;
      // If nodes overlap, repulsion force is proportional 
      // to the overlap
      var force    = options.nodeOverlap * overlap;

      // Compute the module and components of the force vector
      var distance = Math.sqrt(directionX * directionX + directionY * directionY);
      s += "\nDistance: " + distance;
      var forceX   = force * directionX / distance;
      var forceY   = force * directionY / distance;

    } else {
      s += "\nNodes do NOT overlap.";
      // If there's no overlap, force is inversely proportional 
      // to squared distance

      // Get clipping points for both nodes
      var point1 = findClippingPoint(node1, directionX, directionY);
      var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

      // Use clipping points to compute distance
      var distanceX   = point2.x - point1.x;
      var distanceY   = point2.y - point1.y;
      var distanceSqr = distanceX * distanceX + distanceY * distanceY;
      var distance    = Math.sqrt(distanceSqr);
      s += "\nDistance: " + distance;

      // Compute the module and components of the force vector
      var force  = options.nodeRepulsion / distanceSqr;
      var forceX = force * distanceX / distance;
      var forceY = force * distanceY / distance;
    }

    // Apply force
    node1.offsetX -= forceX;
    node1.offsetY -= forceY;
    node2.offsetX += forceX;
    node2.offsetY += forceY;

    s += "\nForceX: " + forceX + " ForceY: " + forceY;
    logDebug(s);

    return;
  };


  /**
   * @brief : Finds the point in which an edge (direction dX, dY) intersects 
   *          the rectangular bounding box of it's source/target node 
   */
  var findClippingPoint = function(node, dX, dY) {

    // Shorcuts
    var X = node.positionX;
    var Y = node.positionY;
    var H = node.height;
    var W = node.width;
    var dirSlope     = dY / dX;
    var nodeSlope    = H / W;

    var s = 'Computing clipping point of node ' + node.id + 
      " . Height:  " + H + ", Width: " + W + 
      "\nDirection " + dX + ", " + dY; 
    
    // Compute intersection
    var res = {};
    do {
      // Case: Vertical direction (up)
      if (0 === dX && 0 < dY) {
        res.x = X;
        s += "\nUp direction";
        res.y = Y + H / 2;
        break;
      }

      // Case: Vertical direction (down)
      if (0 === dX && 0 > dY) {
        res.x = X;
        res.y = Y + H / 2;
        s += "\nDown direction";
        break;
      }      

      // Case: Intersects the right border
      if (0 < dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X + W / 2;
        res.y = Y + (W * dY / 2 / dX);
        s += "\nRightborder";
        break;
      }

      // Case: Intersects the left border
      if (0 > dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X - W / 2;
        res.y = Y - (W * dY / 2 / dX);
        s += "\nLeftborder";
        break;
      }

      // Case: Intersects the top border
      if (0 < dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X + (H * dX / 2 / dY);
        res.y = Y + H / 2;
        s += "\nTop border";
        break;
      }

      // Case: Intersects the bottom border
      if (0 > dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X - (H * dX / 2 / dY);
        res.y = Y - H / 2;
        s += "\nBottom border";
        break;
      }

    } while (false);

    s += "\nClipping point found at " + res.x + ", " + res.y;
    logDebug(s);
    return res;
  };


  /**
   * @brief  : Determines whether two nodes overlap or not
   * @return : Amount of overlapping (0 => no overlap)
   */
  var nodesOverlap = function(node1, node2, dX, dY) {

    if (dX > 0) {
      var overlapX = node1.maxX - node2.minX;
    } else {
      var overlapX = node2.maxX - node1.minX;
    }

    if (dY > 0) {
      var overlapY = node1.maxY - node2.minY;
    } else {
      var overlapY = node2.maxY - node1.minY;
    }

    if (overlapX >= 0 && overlapY >= 0) {
      return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
    } else {
      return 0;
    }
  };
    
  
  /**
   * @brief : Calculates all edge forces
   */
  var calculateEdgeForces = function(layoutInfo, cy, options) {
    // Iterate over all edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      // Get edge, source & target nodes
      var edge     = layoutInfo.layoutEdges[i];
      var sourceIx = layoutInfo.idToIndex[edge.sourceId];
      var source   = layoutInfo.layoutNodes[sourceIx];
      var targetIx = layoutInfo.idToIndex[edge.targetId];
      var target   = layoutInfo.layoutNodes[targetIx];

      // Get direction of line connecting both node centers
      var directionX = target.positionX - source.positionX;
      var directionY = target.positionY - source.positionY;
      
      // If both centers are the same, do nothing.
      // A random force has already been applied as node repulsion
      if (0 === directionX && 0 === directionY) {
      return;
      }

      // Get clipping points for both nodes
      var point1 = findClippingPoint(source, directionX, directionY);
      var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);


      var lx = point2.x - point1.x;
      var ly = point2.y - point1.y;
      var l  = Math.sqrt(lx * lx + ly * ly);

      var force  = Math.pow(edge.idealLength - l, 2) / options.edgeElasticity; 

      if (0 !== l) {
        var forceX = force * lx / l;
        var forceY = force * ly / l;
      } else {
        var forceX = 0;
        var forceY = 0;
      }

      // Add this force to target and source nodes
      source.offsetX += forceX;
      source.offsetY += forceY;
      target.offsetX -= forceX;
      target.offsetY -= forceY;

      var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
      s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
      logDebug(s);
    }
  };


  /**
   * @brief : Computes gravity forces for all nodes
   */
  var calculateGravityForces = function(layoutInfo, cy, options) {
    var s = 'calculateGravityForces';
    logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      s = "Set: " + graph.toString();
      logDebug(s);
          
      // Compute graph center
      if (0 === i) {
        var centerX   = layoutInfo.clientHeight / 2;
        var centerY   = layoutInfo.clientWidth  / 2;    
      } else {
        // Get Parent node for this graph, and use its position as center
        var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
        var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
        var centerX = parent.positionX;
        var centerY = parent.positionY;
      }
      s = "Center found at: " + centerX + ", " + centerY;
      logDebug(s);

      // Apply force to all nodes in graph
      for (var j = 0; j < numNodes; j++) {
        var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
        s = "Node: " + node.id;
        var dx = centerX - node.positionX;
        var dy = centerY - node.positionY;
        var d  = Math.sqrt(dx * dx + dy * dy);
        if (d > 1.0) { // TODO: Use global variable for distance threshold
          var fx = options.gravity * dx / d;
          var fy = options.gravity * dy / d;
          node.offsetX += fx;
          node.offsetY += fy;
          s += ": Applied force: " + fx + ", " + fy;
        } else {
          s += ": skypped since it's too close to center";
        }
        logDebug(s);
      }
    }
  };


  /**
   * @brief          : This function propagates the existing offsets from 
   *                   parent nodes to its descendents.
   * @arg layoutInfo : layoutInfo Object
   * @arg cy         : cytoscape Object
   * @arg options    : Layout options
   */
  var propagateForces = function(layoutInfo, cy, options) {  
    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    logDebug('propagateForces');

    // Start by visiting the nodes in the root graph
    queue.push.apply(queue, layoutInfo.graphSet[0]);
    end += layoutInfo.graphSet[0].length;

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var nodeId    = queue[start++];
      var nodeIndex = layoutInfo.idToIndex[nodeId];
      var node      = layoutInfo.layoutNodes[nodeIndex];
      var children  = node.children;

      // We only need to process the node if it's compound
      if (0 < children.length) {    
      var offX = node.offsetX;
      var offY = node.offsetY;

      var s = "Propagating offset from parent node : " + node.id + 
        ". OffsetX: " + offX + ". OffsetY: " + offY;
      s += "\n Children: " + children.toString();
      logDebug(s);
      
      for (var i = 0; i < children.length; i++) {
        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
        // Propagate offset
        childNode.offsetX += offX;
        childNode.offsetY += offY;
        // Add children to queue to be visited
        queue[++end] = children[i];
      }
      
      // Reset parent offsets
      node.offsetX = 0;
      node.offsetY = 0;
      }
      
    }
  };


  /**
   * @brief : Updates the layout model positions, based on 
   *          the accumulated forces
   */
  var updatePositions = function(layoutInfo, cy, options) {
    var s = 'Updating positions';
    logDebug(s);

    // Reset boundaries for compound nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        logDebug("Resetting boundaries of compound node: " + n.id);
        n.maxX = undefined;
        n.minX = undefined;
        n.maxY = undefined;
        n.minY = undefined;
      }
    }

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        // No need to set compound node position
        logDebug("Skipping position update of node: " + n.id);
        continue;
      }
      s = "Node: " + n.id + " Previous position: (" + 
      n.positionX + ", " + n.positionY + ")."; 

      // Limit displacement in order to improve stability
      var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
      n.positionX += tempForce.x; 
      n.positionY += tempForce.y;
      n.offsetX = 0;
      n.offsetY = 0;
      n.minX    = n.positionX - n.width; 
      n.maxX    = n.positionX + n.width; 
      n.minY    = n.positionY - n.height; 
      n.maxY    = n.positionY + n.height; 
      s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
      logDebug(s);

      // Update ancestry boudaries
      updateAncestryBoundaries(n, layoutInfo);
    }

    // Update size, position of compund nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        n.positionX = (n.maxX + n.minX) / 2;
        n.positionY = (n.maxY + n.minY) / 2;
        n.width     = n.maxX - n.minX;
        n.height    = n.maxY - n.minY;
        s = "Updating position, size of compound node " + n.id;
        s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
        s += "\nWidth: " + n.width + ", Height: " + n.height;
        logDebug(s);
      }
    }  
  };


  /**
   * @brief : Limits a force (forceX, forceY) to be not 
   *          greater (in modulo) than max. 
   8          Preserves force direction. 
   */
  var limitForce = function(forceX, forceY, max) {
    var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
    var force = Math.sqrt(forceX * forceX + forceY * forceY);

    if (force > max) {
      var res = {
      x : max * forceX / force,
      y : max * forceY / force
      };      

    } else {
      var res = {
      x : forceX,
      y : forceY
      };
    }

    s += ".\nResult: (" + res.x + ", " + res.y + ")";
    logDebug(s);

    return res;
  };


  /**
   * @brief : Function used for keeping track of compound node 
   *          sizes, since they should bound all their subnodes.
   */
  var updateAncestryBoundaries = function(node, layoutInfo) {
    var s = "Propagating new position/size of node " + node.id;
    var parentId = node.parentId;
    if (null == parentId) {
      // If there's no parent, we are done
      s += ". No parent node.";
      logDebug(s);
      return;
    }

    // Get Parent Node
    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
    var flag = false;

    // MaxX
    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
      p.maxX = node.maxX + p.padRight;
      flag = true;
      s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
    }

    // MinX
    if (null == p.minX || node.minX - p.padLeft < p.minX) {
      p.minX = node.minX - p.padLeft;
      flag = true;
      s += "\nNew minX for parent node " + p.id + ": " + p.minX;
    }

    // MaxY
    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
      p.maxY = node.maxY + p.padBottom;
      flag = true;
      s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
    }

    // MinY
    if (null == p.minY || node.minY - p.padTop < p.minY) {
      p.minY = node.minY - p.padTop;
      flag = true;
      s += "\nNew minY for parent node " + p.id + ": " + p.minY;
    }

    // If updated boundaries, propagate changes upward
    if (flag) {
      logDebug(s);
      return updateAncestryBoundaries(p, layoutInfo);
    } 

    s += ". No changes in boundaries/position of parent node " + p.id;  
    logDebug(s);
    return;
  };


  /**
   * @brief : Logs a debug message in JS console, if DEBUG is ON
   */
  var logDebug = function(text) {
    if (DEBUG) {
      console.debug(text);
    }
  };


  // register the layout
  $$('layout', 'cose', CoseLayout);

})(cytoscape);
;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    // dagre algo options, uses default value on undefined
    nodeSep: undefined, // the separation between adjacent nodes in the same rank
    edgeSep: undefined, // the separation between adjacent edges in the same rank
    rankSep: undefined, // the separation between adjacent nodes in the same rank
    rankDir: undefined, // 'TB' for top to bottom flow, 'LR' for left to right
    minLen: function( edge ){ return 1; }, // number of ranks to keep between the source and target of the edge
    
    // general layout options
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function DagreLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  DagreLayout.prototype.run = function(){
    var options = this.options;
    var layout = this;

    $$.util.require('dagre', function(dagre){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;

      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var g = new dagre.Digraph();

      // add nodes to dagre
      var nodes = eles.nodes().not(':parent');
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];

        g.addNode( node.id(), {
          width: node.width(),
          height: node.height()
        } );
      }

      // add edges to dagre
      var edges = eles.edges();
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];

        g.addEdge( edge.id(), edge.source().id(), edge.target().id(), {
          minLen: $$.is.fn(options.minLen) ? options.minLen.apply( edge, [ edge ] ) : options.minLen
        } );
      }

      var d = dagre.layout();

      if( options.nodeSep ){
        d.nodeSep( options.nodeSep );
      }

      if( options.edgeSep ){
        d.edgeSep( options.edgeSep );
      }
      
      if( options.rankSep ){
        d.rankSep( options.rankSep );
      }

      if( options.rankDir ){
        d.rankDir( options.rankDir );
      }
        
      d = d.run(g);

      d.eachNode(function(id, n) {
        cy.getElementById(id).scratch().dagre = n;
      });

      var dagreBB;

      if( options.boundingBox ){
        dagreBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
        nodes.forEach(function( node ){
          var dModel = node.scratch().dagre;

          dagreBB.x1 = Math.min( dagreBB.x1, dModel.x );
          dagreBB.x2 = Math.max( dagreBB.x2, dModel.x );

          dagreBB.y1 = Math.min( dagreBB.y1, dModel.y );
          dagreBB.y2 = Math.max( dagreBB.y2, dModel.y );
        });

        dagreBB.w = dagreBB.x2 - dagreBB.x1;
        dagreBB.h = dagreBB.y2 - dagreBB.y1;
      } else {
        dagreBB = bb;
      }

      var constrainPos = function( p ){
        if( options.boundingBox ){
          var xPct = (p.x - dagreBB.x1) / dagreBB.w;
          var yPct = (p.y - dagreBB.y1) / dagreBB.h;

          return {
            x: bb.x1 + xPct * bb.w,
            y: bb.y1 + yPct * bb.h
          };
        } else {
          return p;
        }
      };

      nodes.layoutPositions(layout, options, function(){
        var dModel = this.scratch().dagre;

        return constrainPos({
          x: dModel.x,
          y: dModel.y
        });
      });

    }); // require

    return this; // chaining
  };

  // register the layout
  $$('layout', 'dagre', DagreLayout);

})(cytoscape);
;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding used on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    rows: undefined, // force num of rows in the grid
    columns: undefined, // force num of cols in the grid
    position: function( node ){}, // returns { row, col } for element
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function GridLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  GridLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    if( bb.h === 0 || bb.w === 0){
      nodes.layoutPositions(this, options, function(){
        return { x: bb.x1, y: bb.y1 };
      });
      
    } else {
      
      // width/height * splits^2 = cells where splits is number of times to split width
      var cells = nodes.size();
      var splits = Math.sqrt( cells * bb.h/bb.w );
      var rows = Math.round( splits );
      var cols = Math.round( bb.w/bb.h * splits );

      var small = function(val){
        if( val == null ){
          return Math.min(rows, cols);
        } else {
          var min = Math.min(rows, cols);
          if( min == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      var large = function(val){
        if( val == null ){
          return Math.max(rows, cols);
        } else {
          var max = Math.max(rows, cols);
          if( max == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      // if rows or columns were set in options, use those values
      if( options.rows != null && options.columns != null ){
        rows = options.rows;
        cols = options.columns;
      } else if( options.rows != null && options.columns == null ){
        rows = options.rows;
        cols = Math.ceil( cells / rows );
      } else if( options.rows == null && options.columns != null ){
        cols = options.columns;
        rows = Math.ceil( cells / cols );
      }
      
      // otherwise use the automatic values and adjust accordingly
      
      // if rounding was up, see if we can reduce rows or columns
      else if( cols * rows > cells ){
        var sm = small();
        var lg = large();
        
        // reducing the small side takes away the most cells, so try it first
        if( (sm - 1) * lg >= cells ){
          small(sm - 1);
        } else if( (lg - 1) * sm >= cells ){
          large(lg - 1);
        } 
      } else {
        
        // if rounding was too low, add rows or columns
        while( cols * rows < cells ){
          var sm = small();
          var lg = large();
          
          // try to add to larger side first (adds less in multiplication)
          if( (lg + 1) * sm >= cells ){
            large(lg + 1);
          } else {
            small(sm + 1);
          }
        }
      }
      
      var cellWidth = bb.w / cols;
      var cellHeight = bb.h / rows;

      if( options.avoidOverlap ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var w = node.outerWidth();
          var h = node.outerHeight();

          cellWidth = Math.max( cellWidth, w );
          cellHeight = Math.max( cellHeight, h );
        }
      }
      
      var cellUsed = {}; // e.g. 'c-0-2' => true
      
      var used = function(row, col){
        return cellUsed['c-' + row + '-' + col] ? true : false;
      };
      
      var use = function(row, col){
        cellUsed['c-' + row + '-' + col] = true;
      };

      // to keep track of current cell position
      var row = 0;
      var col = 0;
      var moveToNextCell = function(){
        col++;
        if( col >= cols ){
          col = 0;
          row++;
        }
      };

      // get a cache of all the manual positions
      var id2manPos = {};
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var rcPos = options.position( node );

        if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
          var pos = {
            row: rcPos.row,
            col: rcPos.col
          };

          if( pos.col === undefined ){ // find unused col
            pos.col = 0;

            while( used(pos.row, pos.col) ){
              pos.col++;
            }
          } else if( pos.row === undefined ){ // find unused row
            pos.row = 0;

            while( used(pos.row, pos.col) ){
              pos.row++;
            }
          }

          id2manPos[ node.id() ] = pos;
          use( pos.row, pos.col );
        }
      }

      var getPos = function(i, element){
        var x, y;

        if( element.locked() || element.isFullAutoParent() ){
          return false;
        }

        // see if we have a manual position set
        var rcPos = id2manPos[ element.id() ];
        if( rcPos ){
          x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;
          y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;
        
        } else { // otherwise set automatically
        
          while( used(row, col) ){
            moveToNextCell();
          }

          x = col * cellWidth + cellWidth/2 + bb.x1;
          y = row * cellHeight + cellHeight/2 + bb.y1;
          use( row, col );
          
          moveToNextCell();
        }
        
        return { x: x, y: y };
        
      };

      nodes.layoutPositions( this, options, getPos );
    }

    return this; // chaining
    
  };
  
  $$('layout', 'grid', GridLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function NullLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  NullLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles; // elements to consider in the layout
    var layout = this;

    // cy is automatically populated for us in the constructor
    var cy = options.cy; // jshint ignore:line

    layout.trigger('layoutstart');

    // puts all nodes at (0, 0)
    eles.nodes().positions(function(){
      return {
        x: 0,
        y: 0
      };
    });

    // trigger layoutready when each node has had its position set at least once
    layout.one('layoutready', options.ready);
    layout.trigger('layoutready');

    // trigger layoutstop when the layout stops (e.g. finishes)
    layout.one('layoutstop', options.stop);
    layout.trigger('layoutstop');

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  NullLayout.prototype.stop = function(){
    return this; // chaining
  };

  // register the layout
  $$('layout', 'null', NullLayout);

})(cytoscape);
;(function($$){ 'use strict';
  
  var defaults = {
    positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
    zoom: undefined, // the zoom level to set (prob want fit = false if set)
    pan: undefined, // the pan level to set (prob want fit = false if set)
    fit: true, // whether to fit to viewport
    padding: 30, // padding on fit
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function PresetLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  PresetLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles;

    var nodes = eles.nodes();
    var posIsFn = $$.is.fn( options.positions );

    function getPosition(node){
      if( options.positions == null ){
        return null;
      }

      if( posIsFn ){
        return options.positions.apply( node, [ node ] );
      }
      
      var pos = options.positions[node._private.data.id];

      if( pos == null ){
        return null;
      }
      
      return pos;
    }
    
    nodes.layoutPositions(this, options, function(i, node){
      var position = getPosition(node);
      
      if( node.locked() || position == null ){
        return false;
      }
      
      return position;
    });
        
    return this; // chaining
  };
  
  $$('layout', 'preset', PresetLayout);
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function RandomLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  RandomLayout.prototype.run = function(){
    var options = this.options;
    var cy = options.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var getPos = function( i, node ){
      return {
        x: bb.x1 + Math.round( Math.random() * bb.w ),
        y: bb.y1 + Math.round( Math.random() * bb.h )
      };
    };

    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  // register the layout
  $$(
    'layout', // we're registering a layout
    'random', // the layout name
    RandomLayout // the layout prototype
  );
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    random: false, // whether to use random initial positions
    infinite: false, // overrides all other options for a forces-all-the-time mode
    ready: undefined, // callback on layoutready
    stop: undefined, // callback on layoutstop

    // springy forces
    stiffness: 400,
    repulsion: 400,
    damping: 0.5
  };

  function SpringyLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  SpringyLayout.prototype.run = function(){
    var layout = this;
    var self = this;
    var options = this.options;

    $$.util.require('Springy', function(Springy){

      var simUpdatingPos = false;

      var cy = options.cy;
      layout.trigger({ type: 'layoutstart', layout: layout });
      
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
   
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      
      // make a new graph
      var graph = new Springy.Graph();

      // make some nodes
      nodes.each(function(i, node){
        node.scratch('springy', {
          model: graph.newNode({
            element: node
          })
        });
      });

      // connect them with edges
      edges.each(function(i, edge){
        var fdSrc = edge.source().scratch('springy').model;
        var fdTgt = edge.target().scratch('springy').model;
        
        edge.scratch('springy', {
          model: graph.newEdge(fdSrc, fdTgt, {
            element: edge
          })
        });
      });
      
      var sim = window.sim = new Springy.Layout.ForceDirected(graph, options.stiffness, options.repulsion, options.damping);

      if( options.infinite ){
        sim.minEnergyThreshold = -Infinity;
      }

      var currentBB = sim.getBoundingBox();
      // var targetBB = {bottomleft: new Springy.Vector(-2, -2), topright: new Springy.Vector(2, 2)};
      
      // convert to/from screen coordinates
      var toScreen = function(p) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var sx = p.subtract(currentBB.bottomleft).divide(size.x).x * bb.w + bb.x1;
        var sy = p.subtract(currentBB.bottomleft).divide(size.y).y * bb.h + bb.x1;

        return new Springy.Vector(sx, sy);
      };

      var fromScreen = function(s) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var px = ((s.x - bb.x1) / bb.w) * size.x + currentBB.bottomleft.x;
        var py = ((s.y - bb.y1) / bb.h) * size.y + currentBB.bottomleft.y;

        return new Springy.Vector(px, py);
      };
      
      var movedNodes = cy.collection();
      
      var numNodes = cy.nodes().size();
      var drawnNodes = 1;
      var fdRenderer = new Springy.Renderer(sim,
        function clear() {
          if( movedNodes.length > 0 && options.animate ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            movedNodes = cy.collection();

            simUpdatingPos = false;
          }
        },

        function drawEdge(edge, p1, p2) {
          // draw an edge
        },

        function drawNode(node, p) {
          var v = toScreen(p);
          var element = node.data.element;
          
          if( !element.locked() && !element.grabbed() ){
              element._private.position = {
                x: v.x,
                y: v.y
              };
              movedNodes.merge(element);
          } else {
            //setLayoutPositionForElement(element);
          }
          
          if( drawnNodes == numNodes ){
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          } 
          
          drawnNodes++;
        
        }
      );
      
      // set initial node points
      nodes.each(function(i, ele){
        if( !options.random ){
          setLayoutPositionForElement(ele);
        }
      });
      
      // update node positions when dragging
      var dragHandler;
      nodes.on('position', dragHandler = function(){
        if( simUpdatingPos ){ return; }

        setLayoutPositionForElement(this);
      });
      
      function setLayoutPositionForElement(element){
        var fdId = element.scratch('springy').model.id;
        var fdP = fdRenderer.layout.nodePoints[fdId].p;
        var pos = element.position();
        var positionInFd = (pos.x != null && pos.y != null) ? fromScreen(element.position()) : {
          x: Math.random() * 4 - 2,
          y: Math.random() * 4 - 2
        };
        
        fdP.x = positionInFd.x;
        fdP.y = positionInFd.y;
      }
      
      var grabbableNodes = nodes.filter(":grabbable");
      
      function start(){
        // disable grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.ungrabify();
        }
        
        fdRenderer.start();
      }
      
      self.stopSystem = function(){
        graph.filterNodes(function(){
          return false; // remove all nodes
        });
        
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
        
        nodes.off('drag position', dragHandler);

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        self.stopSystem = null;
      };
      
      start();
      if( !options.infinite ){
        setTimeout(function(){
          self.stop();
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  SpringyLayout.prototype.stop = function(){
    if( this.stopSystem != null ){
      this.stopSystem();
    }

    return this; // chaining
  };
  
  $$('layout', 'springy', SpringyLayout);

  
})(cytoscape);

;(function($$){ 'use strict';
    
  function NullRenderer(options){
    this.options = options;
  }
  
  NullRenderer.prototype.recalculateRenderedStyle = function(){
  };

  NullRenderer.prototype.notify = function(){
    // the null renderer does nothing
  };
  
  $$('renderer', 'null', NullRenderer);
  
})( cytoscape );

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/cytoscape/dist/cytoscape.js","/../node_modules/cytoscape/dist")
},{"1YiZ5S":18,"buffer":15}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/index.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer")
},{"1YiZ5S":18,"base64-js":16,"buffer":15,"ieee754":17}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib")
},{"1YiZ5S":18,"buffer":15}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754")
},{"1YiZ5S":18,"buffer":15}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/process/browser.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/process")
},{"1YiZ5S":18,"buffer":15}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/underscore/underscore.js","/../node_modules/underscore")
},{"1YiZ5S":18,"buffer":15}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdmlsbGF2ZWNlcy9TaXRlcy9iaW9qcy12aXMtUFNJQ1FVSUNHcmFwaC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvanMvZmFrZV82ZWMwMTdkNy5qcyIsIi9Vc2Vycy9qdmlsbGF2ZWNlcy9TaXRlcy9iaW9qcy12aXMtUFNJQ1FVSUNHcmFwaC9qcy9wR3JhcGguanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLW1pdGFiL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1pby1taXRhYi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvaW5kZXguanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcyIsIi9Vc2Vycy9qdmlsbGF2ZWNlcy9TaXRlcy9iaW9qcy12aXMtUFNJQ1FVSUNHcmFwaC9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvZm9yLWVhY2gvbm9kZV9tb2R1bGVzL2lzLWZ1bmN0aW9uL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUvZGlzdC9jeXRvc2NhcGUuanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9qdmlsbGF2ZWNlcy9TaXRlcy9iaW9qcy12aXMtUFNJQ1FVSUNHcmFwaC9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN3N0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmJpb2pzdmlzcHNpY3F1aWMgPSByZXF1aXJlKCcuL3BHcmFwaC5qcycpO1xubW9kdWxlLmV4cG9ydHMgPSBiaW9qc3Zpc3BzaWNxdWljO1xuLy9MaWJyYXJpZXNcbnZhciBwc2ljcXVpYyA9IHJlcXVpcmUoJ2Jpb2pzLXJlc3QtcHNpY3F1aWMnKTtcbnZhciBjeXRvc2NhcGUgPSByZXF1aXJlKCdjeXRvc2NhcGUnKTtcbnZhciBNSVRhYiA9IHJlcXVpcmUoJ2Jpb2pzLWlvLW1pdGFiJyk7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuLy9Qcml2YXRlIG1lbWJlcnNcbnZhciBfc2VsZWN0b3IgPSAnYm9keScsIF9kaXYgPSBudWxsO1xuXG4vL0N5dG9zY2FwZSB2YXJzXG52YXIgX2N5b3B0cyA9IHt9O1xuXG4vLyBwc2ljcXVpYyB2YXJzXG52YXIgX3VybCA9ICcnLCBfcHJveHkgPSBudWxsLCBfbWV0aG9kID0gJ3F1ZXJ5JywgX3BhcmFtcyA9IG51bGwsIF9xdWVyeT0nJztcblxudmFyIF9pbml0U2VsZWN0b3IgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgX2RpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIF9kaXYuc3R5bGUubGVmdCA9IDA7XG4gICAgX2Rpdi5zdHlsZS50b3AgPSAwO1xuICAgIF9kaXYuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgX2Rpdi5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgX2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG59O1xuXG4vLyBQdWJsaWMgbWVtYmVyc1xudmFyIHBHcmFwaCA9IGZ1bmN0aW9uKCl7fTtcblxucEdyYXBoLnVybCA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF91cmw7XG4gICAgX3VybCA9IF87XG4gICAgcmV0dXJuIHBHcmFwaDtcbn07XG5cbnBHcmFwaC5wcm94eSA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9wcm94eTtcbiAgICBfcHJveHkgPSBfO1xuICAgIHJldHVybiBwR3JhcGg7XG59O1xuXG5wR3JhcGgubWV0aG9kID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX21ldGhvZDtcbiAgICBfbWV0aG9kID0gXztcbiAgICByZXR1cm4gcEdyYXBoO1xufTtcblxucEdyYXBoLnBhcmFtcyA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9wYXJhbXM7XG4gICAgX3BhcmFtcyA9IF87XG4gICAgcmV0dXJuIHBHcmFwaDtcbn07XG5cbnBHcmFwaC5xdWVyeSA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9xdWVyeTtcbiAgICBfcXVlcnkgPSBfO1xuICAgIHJldHVybiBwR3JhcGg7XG59O1xuXG5wR3JhcGguc2VsZWN0b3IgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfc2VsZWN0b3I7XG4gICAgXG4gICAgX3NlbGVjdG9yID0gXztcbiAgICByZXR1cm4gcEdyYXBoO1xufTtcblxuLy9DeXRvc2NhcGUgcmVsYXRlZCBvcHRpb25zXG5wR3JhcGguY3lvcHRzID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX2N5b3B0cztcbiAgICBcbiAgICBfY3lvcHRzID0gXztcbiAgICByZXR1cm4gcEdyYXBoO1xufTtcblxucEdyYXBoLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoX2RpdiA9PT0gbnVsbCkgX2luaXRTZWxlY3Rvcihfc2VsZWN0b3IpO1xuICAgIFxuICAgIHBzaWNxdWljLnVybChfdXJsKS5wYXJhbXMoX3BhcmFtcykubWV0aG9kKF9tZXRob2QpLnByb3h5KF9wcm94eSkucXVlcnkoX3F1ZXJ5LCBmdW5jdGlvbihlcnIsIHJlc3AsIGJvZHkpe1xuICAgICAgICB2YXIgcGFyc2VkID0gTUlUYWIucGFyc2UoYm9keSk7XG4gICAgICAgIFxuICAgICAgICBfY3lvcHRzLmVsZW1lbnRzID0ge1xuICAgICAgICAgICAgbm9kZXM6IF8ubWFwKHBhcnNlZC5ub2RlcywgZnVuY3Rpb24obil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtkYXRhOm59O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBlZGdlcyA6IF8ubWFwKHBhcnNlZC5saW5rcywgZnVuY3Rpb24obil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtkYXRhOm59O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIF9jeW9wdHMuY29udGFpbmVyID0gX2RpdjtcbiAgICAgICAgdmFyIGN5ID0gY3l0b3NjYXBlKF9jeW9wdHMpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwR3JhcGg7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2Zha2VfNmVjMDE3ZDcuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vL0xpYnJhcmllc1xudmFyIHBzaWNxdWljID0gcmVxdWlyZSgnYmlvanMtcmVzdC1wc2ljcXVpYycpO1xudmFyIGN5dG9zY2FwZSA9IHJlcXVpcmUoJ2N5dG9zY2FwZScpO1xudmFyIE1JVGFiID0gcmVxdWlyZSgnYmlvanMtaW8tbWl0YWInKTtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vL1ByaXZhdGUgbWVtYmVyc1xudmFyIF9zZWxlY3RvciA9ICdib2R5JywgX2RpdiA9IG51bGw7XG5cbi8vQ3l0b3NjYXBlIHZhcnNcbnZhciBfY3lvcHRzID0ge307XG5cbi8vIHBzaWNxdWljIHZhcnNcbnZhciBfdXJsID0gJycsIF9wcm94eSA9IG51bGwsIF9tZXRob2QgPSAncXVlcnknLCBfcGFyYW1zID0gbnVsbCwgX3F1ZXJ5PScnO1xuXG52YXIgX2luaXRTZWxlY3RvciA9IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICBfZGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgX2Rpdi5zdHlsZS5sZWZ0ID0gMDtcbiAgICBfZGl2LnN0eWxlLnRvcCA9IDA7XG4gICAgX2Rpdi5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBfZGl2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBfZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbn07XG5cbi8vIFB1YmxpYyBtZW1iZXJzXG52YXIgcEdyYXBoID0gZnVuY3Rpb24oKXt9O1xuXG5wR3JhcGgudXJsID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX3VybDtcbiAgICBfdXJsID0gXztcbiAgICByZXR1cm4gcEdyYXBoO1xufTtcblxucEdyYXBoLnByb3h5ID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX3Byb3h5O1xuICAgIF9wcm94eSA9IF87XG4gICAgcmV0dXJuIHBHcmFwaDtcbn07XG5cbnBHcmFwaC5tZXRob2QgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfbWV0aG9kO1xuICAgIF9tZXRob2QgPSBfO1xuICAgIHJldHVybiBwR3JhcGg7XG59O1xuXG5wR3JhcGgucGFyYW1zID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX3BhcmFtcztcbiAgICBfcGFyYW1zID0gXztcbiAgICByZXR1cm4gcEdyYXBoO1xufTtcblxucEdyYXBoLnF1ZXJ5ID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX3F1ZXJ5O1xuICAgIF9xdWVyeSA9IF87XG4gICAgcmV0dXJuIHBHcmFwaDtcbn07XG5cbnBHcmFwaC5zZWxlY3RvciA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9zZWxlY3RvcjtcbiAgICBcbiAgICBfc2VsZWN0b3IgPSBfO1xuICAgIHJldHVybiBwR3JhcGg7XG59O1xuXG4vL0N5dG9zY2FwZSByZWxhdGVkIG9wdGlvbnNcbnBHcmFwaC5jeW9wdHMgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfY3lvcHRzO1xuICAgIFxuICAgIF9jeW9wdHMgPSBfO1xuICAgIHJldHVybiBwR3JhcGg7XG59O1xuXG5wR3JhcGgudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICBpZihfZGl2ID09PSBudWxsKSBfaW5pdFNlbGVjdG9yKF9zZWxlY3Rvcik7XG4gICAgXG4gICAgcHNpY3F1aWMudXJsKF91cmwpLnBhcmFtcyhfcGFyYW1zKS5tZXRob2QoX21ldGhvZCkucHJveHkoX3Byb3h5KS5xdWVyeShfcXVlcnksIGZ1bmN0aW9uKGVyciwgcmVzcCwgYm9keSl7XG4gICAgICAgIHZhciBwYXJzZWQgPSBNSVRhYi5wYXJzZShib2R5KTtcbiAgICAgICAgXG4gICAgICAgIF9jeW9wdHMuZWxlbWVudHMgPSB7XG4gICAgICAgICAgICBub2RlczogXy5tYXAocGFyc2VkLm5vZGVzLCBmdW5jdGlvbihuKXtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2RhdGE6bn07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVkZ2VzIDogXy5tYXAocGFyc2VkLmxpbmtzLCBmdW5jdGlvbihuKXtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2RhdGE6bn07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgX2N5b3B0cy5jb250YWluZXIgPSBfZGl2O1xuICAgICAgICB2YXIgY3kgPSBjeXRvc2NhcGUoX2N5b3B0cyk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBHcmFwaDtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvcEdyYXBoLmpzXCIsXCIvXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gTUlUYWIgPSAoZnVuY3Rpb24oKSB7XG4gICAgIFxuICAgIHZhciBub2RlcyA9IHt9OyBcbiAgICB2YXIgbGlua3MgPSBbXTtcbiAgICB2YXIgc2NvcmVzID0ge307XG4gICAgdmFyIHRleHRJblBhcmVudGhlc2lzID0gL1xcKCguKj8pXFwpLztcbiAgICB2YXIgdGV4dEluUXVvdGVzID0gL1xcXCIoLio/KVxcXCIvO1xuICAgIHZhciB0ZXh0SW5UYXggPSAvXFw6KC4qPylcXCgvO1xuICAgIFxuICAgIC8vIENyZWF0ZXMgYSBub2RlIGZyb20gaWRlbnRpZmllcnMsIGFsdGVybmF0aXZlIGlkZW5pZmllcnMsXG4gICAgLy8gYW5kIHRheG9ub215IHZhbHVlc1xuICAgIHZhciBfZ2V0Tm9kZSA9IGZ1bmN0aW9uKGlkU3RyLCBhbHRJZHNTdHIsIHRheFN0cil7XG4gICAgICAgIFxuICAgICAgICB2YXIgaWRzID0gXy5tYXAoaWRTdHIuc3BsaXQoJ3wnKSwgX21hcFB1Yik7XG4gICAgICAgIHZhciBub2RlID0ge1xuICAgICAgICAgICAgaWQ6IGlkc1swXS52YWx1ZSxcbiAgICAgICAgICAgIGlkczogaWRzLFxuICAgICAgICAgICAgYWx0SWRzOiBfLm1hcChhbHRJZHNTdHIuc3BsaXQoJ3wnKSwgX21hcFB1YiksXG4gICAgICAgICAgICB0YXhvbm9teTogXy51bmlxKF8ubWFwKHRheFN0ci5zcGxpdCgnfCcpLCBfbWFwVGF4b25vbXkpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBcbiAgICAvLyBQYXJzZXMgYSBzdHJpbmcgYW5kIHJldHVybnMgYW4gaW50ZXJhY3Rpb25cbiAgICB2YXIgX3BhcnNlID0gZnVuY3Rpb24obGluZSwgaSl7XG4gICAgICAgIFxuICAgICAgICBpZiAoISBfLmlzU3RyaW5nKGxpbmUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01JVGFiIGNhbm5vdCBwYXJzZSBsaW5lICcgKyBpKTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGZpZWxkcyA9IGxpbmUuc3BsaXQoJ1xcdCcpO1xuICAgICAgICBcbiAgICAgICAgaWYoZmllbGRzLmxlbmd0aCA8IDE1KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ01JVGFiIGNhbm5vdCBwYXJzZSBsaW5lICcgKyBpKTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIG5vZGVBID0gX2dldE5vZGUoZmllbGRzWzBdLCBmaWVsZHNbMl0sIGZpZWxkc1s5XSk7XG4gICAgICAgIHZhciBub2RlQiA9IF9nZXROb2RlKGZpZWxkc1sxXSwgZmllbGRzWzNdLCBmaWVsZHNbMTBdKTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB2YXIgaW50ZXJhY3Rpb24gPSB7XG4gICAgICAgICAgICBzb3VyY2U6IG5vZGVBLmlkLFxuICAgICAgICAgICAgdGFyZ2V0OiBub2RlQi5pZCxcbiAgICAgICAgICAgIGRldE1ldGhvZHM6IF8ubWFwKGZpZWxkc1s2XS5zcGxpdCgnfCcpLCBfbWFwRmllbGQpLFxuICAgICAgICAgICAgZmlyc3RBdXRob3I6IGZpZWxkc1s3XS5zcGxpdCgnfCcpLFxuICAgICAgICAgICAgcHVibGljYXRpb25zOiBfLm1hcChmaWVsZHNbOF0uc3BsaXQoJ3wnKSwgX21hcFB1YiksXG4gICAgICAgICAgICBpbnRUeXBlczogXy5tYXAoZmllbGRzWzExXS5zcGxpdCgnfCcpLCBfbWFwRmllbGQpLFxuICAgICAgICAgICAgc291cmNlRGJzOiBfLm1hcChmaWVsZHNbMTJdLnNwbGl0KCd8JyksIF9tYXBGaWVsZCksXG4gICAgICAgICAgICBpbnRJZHMgOiBfLm1hcChmaWVsZHNbMTNdLnNwbGl0KCd8JyksIF9tYXBQdWIpLFxuICAgICAgICAgICAgc2NvcmVzOiBfLm1hcChmaWVsZHNbMTRdLnNwbGl0KCd8JyksIF9tYXBTY29yZSlcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIG5vZGVzW25vZGVBLmlkXSA9IG5vZGVBO1xuICAgICAgICBub2Rlc1tub2RlQi5pZF0gPSBub2RlQjtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBpbnRlcmFjdGlvbjtcbiAgICB9XG4gICAgXG4gICAgdmFyIF9tYXBTY29yZSA9IGZ1bmN0aW9uKHNjb3JlU3RyKXtcbiAgICAgICAgdmFyIGFyciA9IHNjb3JlU3RyLnNwbGl0KCc6JyksIHNjb3JlID0ge25hbWU6YXJyWzBdLCBzY29yZTorYXJyWzFdfTtcbiAgICAgICAgXG4gICAgICAgIF9hZGRTY29yZShzY29yZSk7XG4gICAgICAgIHJldHVybiBzY29yZTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBfbWFwRmllbGQgPSBmdW5jdGlvbihmaWVsZFN0cil7XG4gICAgICAgIGlmKGZpZWxkU3RyLm1hdGNoKHRleHRJblF1b3RlcykgPT0gbnVsbCB8fCBmaWVsZFN0ci5tYXRjaCh0ZXh0SW5QYXJlbnRoZXNpcykgPT0gbnVsbCl7XG4gICAgICAgICAgICB2YXIgYXJyID0gZmllbGRTdHIuc3BsaXQoJzonKTtcbiAgICAgICAgICAgIHJldHVybiB7bmFtZTphcnJbMF0sIHNjb3JlOmFyclsxXX07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtuYW1lOmZpZWxkU3RyLm1hdGNoKHRleHRJblF1b3RlcylbMV0sIHZhbHVlOmZpZWxkU3RyLm1hdGNoKHRleHRJblBhcmVudGhlc2lzKVsxXX07XG4gICAgfTtcbiAgICBcbiAgICB2YXIgX21hcFB1YiA9IGZ1bmN0aW9uKHB1YlN0cil7XG4gICAgICAgIHZhciBhcnIgPSBwdWJTdHIuc3BsaXQoJzonKTtcbiAgICAgICAgcmV0dXJuIHtuYW1lOmFyclswXSwgdmFsdWU6YXJyWzFdfTtcbiAgICB9O1xuICAgIFxuICAgIHZhciBfbWFwVGF4b25vbXkgPSBmdW5jdGlvbih0YXhTdHIpe1xuICAgICAgICBpZih0YXhTdHIgIT0gJy0nKXtcbiAgICAgICAgICAgIHJldHVybiAodGF4U3RyLm1hdGNoKHRleHRJblRheCkgPT0gbnVsbCkgPyB0YXhTdHIuc3BsaXQoJzonKVsxXSA6IHRheFN0ci5tYXRjaCh0ZXh0SW5UYXgpWzFdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgX2FkZFNjb3JlID0gZnVuY3Rpb24oc2NvcmUpe1xuICAgICAgICBpZiggIV8uaXNOYU4oc2NvcmUuc2NvcmUpICYmIF8uaXNOdW1iZXIoc2NvcmUuc2NvcmUpKXtcbiAgICAgICAgICAgIGlmKF8uaGFzKHNjb3Jlcywgc2NvcmUubmFtZSkpe1xuICAgICAgICAgICAgICAgIGlmKHNjb3Jlc1tzY29yZS5uYW1lXS5taW4gPiBzY29yZS5zY29yZSkgc2NvcmVzW3Njb3JlLm5hbWVdLm1pbiA9IHNjb3JlLnNjb3JlO1xuICAgICAgICAgICAgICAgIGlmKHNjb3Jlc1tzY29yZS5uYW1lXS5tYXggPCBzY29yZS5zY29yZSkgc2NvcmVzW3Njb3JlLm5hbWVdLm1heCA9IHNjb3JlLnNjb3JlO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgc2NvcmVzW3Njb3JlLm5hbWVdID0ge25hbWU6c2NvcmUubmFtZSwgbWluOnNjb3JlLnNjb3JlLCBtYXg6c2NvcmUuc2NvcmV9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiBNSVRhYigpIHt9XG4gICAgXG4gICAgTUlUYWIucGFyc2UgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgIFxuICAgICAgICBpZiAoISBfLmlzU3RyaW5nKHRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyAnTUlUYWIgY2Fubm90IHBhcnNlICcgKyB0eXBlb2YgdGV4dDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB2YXJpYWJsZXNcbiAgICAgICAgbm9kZXMgPSB7fTsgXG4gICAgICAgIGxpbmtzID0gW107XG4gICAgICAgIHNjb3JlcyA9IHt9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIFxuICAgICAgICB2YXIgaW50ZXJhY3Rpb25zID0gXy5yZWplY3QoXy5tYXAobGluZXMsIF9wYXJzZSksIF8uaXNFbXB0eSk7XG4gICAgICAgIHZhciBub2RldmFsID0gXy52YWx1ZXMobm9kZXMpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmtzOiBpbnRlcmFjdGlvbnMsXG4gICAgICAgICAgICBub2Rlczogbm9kZXZhbCxcbiAgICAgICAgICAgIGlkczogXy5wbHVjayhub2RldmFsLCAnaWQnKSxcbiAgICAgICAgICAgIHRheGE6IF8uY29tcGFjdChfLnJlZHVjZShub2RldmFsLCBmdW5jdGlvbihtZW1vLG4peyByZXR1cm4gXy51bmlvbihtZW1vLG4udGF4b25vbXkpfSxbXSkpLFxuICAgICAgICAgICAgc2NvcmVzOiBfLnZhbHVlcyhzY29yZXMpXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gTUlUYWI7XG59KSgpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtaW8tbWl0YWIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtaW8tbWl0YWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyAgICAgVW5kZXJzY29yZS5qcyAxLjguMlxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXG4vLyAgICAgKGMpIDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbihmdW5jdGlvbigpIHtcblxuICAvLyBCYXNlbGluZSBzZXR1cFxuICAvLyAtLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSwgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxuICB2YXJcbiAgICBwdXNoICAgICAgICAgICAgID0gQXJyYXlQcm90by5wdXNoLFxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxuICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSAgID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgLy8gQWxsICoqRUNNQVNjcmlwdCA1KiogbmF0aXZlIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9ucyB0aGF0IHdlIGhvcGUgdG8gdXNlXG4gIC8vIGFyZSBkZWNsYXJlZCBoZXJlLlxuICB2YXJcbiAgICBuYXRpdmVJc0FycmF5ICAgICAgPSBBcnJheS5pc0FycmF5LFxuICAgIG5hdGl2ZUtleXMgICAgICAgICA9IE9iamVjdC5rZXlzLFxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUNyZWF0ZSAgICAgICA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZSBvbGQgYHJlcXVpcmUoKWAgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XG4gICAgfVxuICAgIGV4cG9ydHMuXyA9IF87XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5fID0gXztcbiAgfVxuXG4gIC8vIEN1cnJlbnQgdmVyc2lvbi5cbiAgXy5WRVJTSU9OID0gJzEuOC4yJztcblxuICAvLyBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZWZmaWNpZW50IChmb3IgY3VycmVudCBlbmdpbmVzKSB2ZXJzaW9uXG4gIC8vIG9mIHRoZSBwYXNzZWQtaW4gY2FsbGJhY2ssIHRvIGJlIHJlcGVhdGVkbHkgYXBwbGllZCBpbiBvdGhlciBVbmRlcnNjb3JlXG4gIC8vIGZ1bmN0aW9ucy5cbiAgdmFyIG9wdGltaXplQ2IgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHJldHVybiBmdW5jO1xuICAgIHN3aXRjaCAoYXJnQ291bnQgPT0gbnVsbCA/IDMgOiBhcmdDb3VudCkge1xuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxuICAvLyB0byBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXJcbiAgLy8gaWRlbnRpdHksIGFuIGFyYml0cmFyeSBjYWxsYmFjaywgYSBwcm9wZXJ0eSBtYXRjaGVyLCBvciBhIHByb3BlcnR5IGFjY2Vzc29yLlxuICB2YXIgY2IgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG4gIF8uaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhc3NpZ25lciBmdW5jdGlvbnMuXG4gIHZhciBjcmVhdGVBc3NpZ25lciA9IGZ1bmN0aW9uKGtleXNGdW5jLCB1bmRlZmluZWRPbmx5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIXVuZGVmaW5lZE9ubHkgfHwgb2JqW2tleV0gPT09IHZvaWQgMCkgb2JqW2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gdmFsdWUgKHVzaW5nIGA9PT1gKS5cbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZXNgIGFuZCBgaW5jbHVkZWAuXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGVzID0gXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQsIGZyb21JbmRleCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgdGFyZ2V0LCB0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInICYmIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gaW5wdXQgJiYgaW5wdXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIGlmICghXy5pc0Jvb2xlYW4oaXNTb3J0ZWQpKSB7XG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XG4gICAgICBpdGVyYXRlZSA9IGlzU29ydGVkO1xuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGVlICE9IG51bGwpIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IGFyZ3NMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaiA9PT0gYXJnc0xlbmd0aCkgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXG4gIC8vIGFuIGluZGV4IGdvIHRvZ2V0aGVyLlxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuemlwKGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXNcbiAgXy51bnppcCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ICYmIF8ubWF4KGFycmF5LCAnbGVuZ3RoJykubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QgJiYgbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpc1NvcnRlZCkge1xuICAgIHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkgJiYgYXJyYXkubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ251bWJlcicpIHtcbiAgICAgIGkgPSBpc1NvcnRlZCA8IDAgPyBNYXRoLm1heCgwLCBsZW5ndGggKyBpc1NvcnRlZCkgOiBpc1NvcnRlZDtcbiAgICB9IGVsc2UgaWYgKGlzU29ydGVkICYmIGxlbmd0aCkge1xuICAgICAgaSA9IF8uc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgIH1cbiAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZmluZEluZGV4KHNsaWNlLmNhbGwoYXJyYXksIGkpLCBfLmlzTmFOKTtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykgaWYgKGFycmF5W2ldID09PSBpdGVtKSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcbiAgICBpZiAodHlwZW9mIGZyb20gPT0gJ251bWJlcicpIHtcbiAgICAgIGlkeCA9IGZyb20gPCAwID8gaWR4ICsgZnJvbSArIDEgOiBNYXRoLm1pbihpZHgsIGZyb20gKyAxKTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmZpbmRMYXN0SW5kZXgoc2xpY2UuY2FsbChhcnJheSwgMCwgaWR4KSwgXy5pc05hTik7XG4gICAgfVxuICAgIHdoaWxlICgtLWlkeCA+PSAwKSBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSAhPSBudWxsICYmIGFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEluZGV4ID0gY3JlYXRlSW5kZXhGaW5kZXIoMSk7XG5cbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICBcbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcbiAgXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLW1pdGFiL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtaW8tbWl0YWIvbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmVcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgeGhyID0gcmVxdWlyZSgnbmV0cycpXG5cbnZhciBfdXJsID0gJycsIF9wcm94eSA9IG51bGwsIF9tZXRob2QgPSAncXVlcnknLCBfcGFyYW1zID0gbnVsbDtcblxuLy9Qcml2YXRlIG1lbWJlcnNcbnZhciBfZmV0Y2ggPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKXtcbiAgICB4aHIoe1xuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgbWV0aG9kOiAnR0VUJ1xuICAgIH0sIFxuICAgIGNhbGxiYWNrKVxufVxuXG52YXIgX2V2YWxfcGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKXtcbiAgICB2YXIgc3RyID0gJyc7XG4gICAgaWYodHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpe1xuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH1lbHNlIGlmKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKXtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gcGFyYW1zKXtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkgc3RyICs9IGtleSsnPScrcGFyYW1zW2tleV0rJyYnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbnZhciBfY3JlYXRlVXJsID0gZnVuY3Rpb24obWV0aG9kLCBxdWVyeSwgcGFyYW1zKXtcbiAgICBcbiAgICB2YXIgcGFyYW1zU3RyID0gJyc7IFxuICAgIGlmKHBhcmFtcyAhPT0gbnVsbClcbiAgICAgICAgcGFyYW1zU3RyID0gJz8nK19ldmFsX3BhcmFtcyhwYXJhbXMpO1xuICAgIFxuICAgIHZhciB1cmwgPSBfdXJsKycvJyttZXRob2QrJy8nK3F1ZXJ5K3BhcmFtc1N0cjtcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgnLy8nK21ldGhvZCwgJy8nK21ldGhvZClcbiAgICBcbiAgICBpZihfcHJveHkgPT09IG51bGwpIHJldHVybiB1cmw7XG4gICAgXG4gICAgcmV0dXJuIF9wcm9jZXNzUHJveHkodXJsKTtcbn1cblxudmFyIF9wcm9jZXNzUHJveHkgPSBmdW5jdGlvbih1cmwpe1xuICAgIGlmICh0eXBlb2YgX3Byb3h5ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gX3Byb3h5KHVybCk7XG4gICAgXG4gICAgaWYodHlwZW9mIF9wcm94eSA9PT0gJ3N0cmluZycpIHJldHVybiBfcHJveHkgKyc/dXJsPScrdXJsO1xuICAgIFxuICAgIHJldHVybiB1cmw7XG59XG5cbi8vUHVibGljIG1lbWJlcnNcbnZhciBwc2ljcXVpY1NlcnZlciA9IGZ1bmN0aW9uKCl7fVxuICAgIFxucHNpY3F1aWNTZXJ2ZXIudXJsID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX3VybDtcbiAgICBfdXJsID0gXztcbiAgICByZXR1cm4gcHNpY3F1aWNTZXJ2ZXI7XG59O1xuXG5wc2ljcXVpY1NlcnZlci5wcm94eSA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9wcm94eTtcbiAgICBfcHJveHkgPSBfO1xuICAgIHJldHVybiBwc2ljcXVpY1NlcnZlcjtcbn07XG5cbnBzaWNxdWljU2VydmVyLm1ldGhvZCA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9tZXRob2Q7XG4gICAgX21ldGhvZCA9IF87XG4gICAgcmV0dXJuIHBzaWNxdWljU2VydmVyO1xufTtcblxucHNpY3F1aWNTZXJ2ZXIucGFyYW1zID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX3BhcmFtcztcbiAgICBfcGFyYW1zID0gXztcbiAgICByZXR1cm4gcHNpY3F1aWNTZXJ2ZXI7XG59O1xuXG5wc2ljcXVpY1NlcnZlci5xdWVyeSA9IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjayl7XG4gICAgdmFyIHVybCA9IF9jcmVhdGVVcmwoX21ldGhvZCwgcXVlcnksIF9wYXJhbXMpO1xuICAgIF9mZXRjaCh1cmwsIGNhbGxiYWNrKTtcbn07XG5cbnBzaWNxdWljU2VydmVyLmNvdW50ID0gZnVuY3Rpb24ocXVlcnksIGNhbGxiYWNrKXtcbiAgICB2YXIgdXJsID0gX2NyZWF0ZVVybChfbWV0aG9kLCBxdWVyeSwge2Zvcm1hdDonY291bnQnfSk7XG4gICAgX2ZldGNoKHVybCwgY2FsbGJhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBzaWNxdWljU2VydmVyO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHJlcSA9IHJlcXVpcmUoJ3JlcXVlc3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldHNcblxuZnVuY3Rpb24gTmV0cyh1cmksIG9wdHMsIGNiKSB7XG4gIHJlcSh1cmksIG9wdHMsIGNiKVxufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpXG52YXIgb25jZSA9IHJlcXVpcmUoXCJvbmNlXCIpXG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgncGFyc2UtaGVhZGVycycpXG5cbnZhciBtZXNzYWdlcyA9IHtcbiAgICBcIjBcIjogXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiLFxuICAgIFwiNFwiOiBcIjR4eCBDbGllbnQgRXJyb3JcIixcbiAgICBcIjVcIjogXCI1eHggU2VydmVyIEVycm9yXCJcbn1cblxudmFyIFhIUiA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG52YXIgWERSID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAobmV3IFhIUigpKSA/IFhIUiA6IHdpbmRvdy5YRG9tYWluUmVxdWVzdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVhIUlxuXG5mdW5jdGlvbiBjcmVhdGVYSFIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgdXJpOiBvcHRpb25zIH1cbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWERSKClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWEhSKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmxcbiAgICB2YXIgbWV0aG9kID0geGhyLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGFcbiAgICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgdmFyIHN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICAgIHZhciBpc0pzb24gPSBmYWxzZVxuICAgIHZhciBrZXlcbiAgICB2YXIgbG9hZCA9IG9wdGlvbnMucmVzcG9uc2UgPyBsb2FkUmVzcG9uc2UgOiBsb2FkWGhyXG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucykge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRcbiAgICB4aHIub25lcnJvciA9IGVycm9yXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgLy8gaGF0ZSBJRVxuICAgIHhoci5vbnRpbWVvdXQgPSBub29wXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgaWYgKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzIHx8IChvcHRpb25zLmNvcnMgJiYgb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgIT09IGZhbHNlKSkge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAgIGlmICghc3luYykge1xuICAgICAgICB4aHIudGltZW91dCA9IFwidGltZW91dFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnRpbWVvdXQgOiA1MDAwXG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKVxuICAgIH1cblxuICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IG9wdGlvbnMucmVzcG9uc2VUeXBlXG4gICAgfVxuICAgIFxuICAgIGlmIChcImJlZm9yZVNlbmRcIiBpbiBvcHRpb25zICYmIFxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kKHhocilcbiAgICB9XG5cbiAgICB4aHIuc2VuZChib2R5KVxuXG4gICAgcmV0dXJuIHhoclxuXG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBsb2FkKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICAgIC8vIENocm9tZSB3aXRoIHJlcXVlc3RUeXBlPWJsb2IgdGhyb3dzIGVycm9ycyBhcnJvdW5kIHdoZW4gZXZlbiB0ZXN0aW5nIGFjY2VzcyB0byByZXNwb25zZVRleHRcbiAgICAgICAgdmFyIGJvZHkgPSBudWxsXG5cbiAgICAgICAgaWYgKHhoci5yZXNwb25zZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVxuICAgICAgICB9IGVsc2UgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCAheGhyLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgYm9keSA9IHhoci5yZXNwb25zZVRleHQgfHwgeGhyLnJlc3BvbnNlWE1MXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNKc29uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZHlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTdGF0dXNDb2RlKCkge1xuICAgICAgICByZXR1cm4geGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHhoci5zdGF0dXNcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSdyZSBnZXR0aW5nIGEgbm9uZS1vayBzdGF0dXNDb2RlLCBidWlsZCAmIHJldHVybiBhbiBlcnJvclxuICAgIGZ1bmN0aW9uIGVycm9yRnJvbVN0YXR1c0NvZGUoc3RhdHVzLCBib2R5KSB7XG4gICAgICAgIHZhciBlcnJvciA9IG51bGxcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCB8fCAoc3RhdHVzID49IDQwMCAmJiBzdGF0dXMgPCA2MDApKSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9ICh0eXBlb2YgYm9keSA9PT0gXCJzdHJpbmdcIiA/IGJvZHkgOiBmYWxzZSkgfHxcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1tTdHJpbmcoc3RhdHVzKS5jaGFyQXQoMCldXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgICAgICAgICAgZXJyb3Iuc3RhdHVzQ29kZSA9IHN0YXR1c1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9yXG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRSZXNwb25zZSgpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IGdldFN0YXR1c0NvZGUoKVxuICAgICAgICB2YXIgYm9keSA9IGdldEJvZHkoKVxuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckZyb21TdGF0dXNDb2RlKHN0YXR1cywgYm9keSlcbiAgICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgcmF3OiB4aHJcbiAgICAgICAgfVxuICAgICAgICBpZih4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKXsgLy9yZW1lbWJlciB4aHIgY2FuIGluIGZhY3QgYmUgWERSIGZvciBDT1JTIGluIElFXG4gICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLmhlYWRlcnMgPSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KVxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSBhbmQgYWRkIHNvbWUgcmVzcG9uc2UgcHJvcGVydGllcyB0byB0aGUgc291cmNlIHhoclxuICAgIC8vIGFuZCB0aGVuIHJlc3BvbmQgd2l0aCB0aGF0XG4gICAgZnVuY3Rpb24gbG9hZFhocigpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IGdldFN0YXR1c0NvZGUoKVxuICAgICAgICB2YXIgZXJyb3IgPSBlcnJvckZyb21TdGF0dXNDb2RlKHN0YXR1cylcblxuICAgICAgICB4aHIuc3RhdHVzID0geGhyLnN0YXR1c0NvZGUgPSBzdGF0dXNcbiAgICAgICAgeGhyLmJvZHkgPSBnZXRCb2R5KClcbiAgICAgICAgeGhyLmhlYWRlcnMgPSBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCB4aHIsIHhoci5ib2R5KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKGV2dCkge1xuICAgICAgICBjYWxsYmFjayhldnQsIHhocilcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNlbGY7XG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge307XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL2dsb2JhbFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gb25jZVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG59KVxuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm5cbiAgICBjYWxsZWQgPSB0cnVlXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL29uY2Uvb25jZS5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL29uY2VcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHN0cmluZyA9IHRvU3RyaW5nLmNhbGwoZm4pXG4gIHJldHVybiBzdHJpbmcgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHN0cmluZyAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHx8XG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgIC8vIElFOCBhbmQgYmVsb3dcbiAgICAgKGZuID09PSB3aW5kb3cuc2V0VGltZW91dCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5hbGVydCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5jb25maXJtIHx8XG4gICAgICBmbiA9PT0gd2luZG93LnByb21wdCkpXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL25vZGVfbW9kdWxlcy9pcy1mdW5jdGlvbi9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL25vZGVfbW9kdWxlcy9pcy1mdW5jdGlvblwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHJpbTtcblxuZnVuY3Rpb24gdHJpbShzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cblxuZXhwb3J0cy5sZWZ0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbn07XG5cbmV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccyokLywgJycpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy90cmltL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvdHJpbVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcbiAgLCBpc0FycmF5ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICAgICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICAgICAgaWYgKHR5cGVvZihyZXN1bHRba2V5XSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICAgICAgfVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyohXG4gKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBDeXRvc2NhcGUuanMgMi4zLjkuXG4gKiBcbiAqIEN5dG9zY2FwZS5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWVcbiAqIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55XG4gKiBsYXRlciB2ZXJzaW9uLlxuICogXG4gKiBDeXRvc2NhcGUuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcbiAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTXG4gKiBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlXG4gKiBkZXRhaWxzLlxuICogXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYWxvbmcgd2l0aFxuICogQ3l0b3NjYXBlLmpzLiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4gKi9cbiBcblxuLy8gdGhpcyBpcyBwdXQgYXMgYSBnbG9iYWwgdmFyIGluIHRoZSBicm93c2VyXG4vLyBvciBpdCdzIGp1c3QgYSBnbG9iYWwgdG8gdGhpcyBtb2R1bGUgaWYgY29tbW9uanNcblxudmFyIGN5dG9zY2FwZTtcblxuKGZ1bmN0aW9uKHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyB0aGUgb2JqZWN0IGl0ZXNlbGYgaXMgYSBmdW5jdGlvbiB0aGF0IGluaXQncyBhbiBpbnN0YW5jZSBvZiBjeXRvc2NhcGVcblxuICB2YXIgJCQgPSBjeXRvc2NhcGUgPSBmdW5jdGlvbigpeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICByZXR1cm4gY3l0b3NjYXBlLmluaXQuYXBwbHkoY3l0b3NjYXBlLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gICQkLnZlcnNpb24gPSAnMi4zLjknO1xuICBcbiAgLy8gYWxsb3cgZnVuY3Rpb25hbCBhY2Nlc3MgdG8gY3l0b3NjYXBlLmpzXG4gIC8vIGUuZy4gdmFyIGN5dG8gPSAkLmN5dG9zY2FwZSh7IHNlbGVjdG9yOiBcIiNmb29cIiwgLi4uIH0pO1xuICAvLyAgICAgIHZhciBub2RlcyA9IGN5dG8ubm9kZXMoKTtcbiAgJCQuaW5pdCA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgXG4gICAgLy8gaWYgbm8gb3B0aW9ucyBzcGVjaWZpZWQsIHVzZSBkZWZhdWx0XG4gICAgaWYoIG9wdGlvbnMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBpbnN0YW5jZVxuICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdCggb3B0aW9ucyApICl7XG4gICAgICByZXR1cm4gbmV3ICQkLkNvcmUoIG9wdGlvbnMgKTtcbiAgICB9IFxuICAgIFxuICAgIC8vIGFsbG93IGZvciByZWdpc3RyYXRpb24gb2YgZXh0ZW5zaW9uc1xuICAgIC8vIGUuZy4gJC5jeXRvc2NhcGUoJ3JlbmRlcmVyJywgJ3N2ZycsIFN2Z1JlbmRlcmVyKTtcbiAgICAvLyBlLmcuICQuY3l0b3NjYXBlKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZXNoYXBlJywgJ2VsbGlwc2UnLCBTdmdFbGxpcHNlTm9kZVNoYXBlKTtcbiAgICAvLyBlLmcuICQuY3l0b3NjYXBlKCdjb3JlJywgJ2RvU29tZXRoaW5nJywgZnVuY3Rpb24oKXsgLyogZG9Tb21ldGhpbmcgY29kZSAqLyB9KTtcbiAgICAvLyBlLmcuICQuY3l0b3NjYXBlKCdjb2xsZWN0aW9uJywgJ2RvU29tZXRoaW5nJywgZnVuY3Rpb24oKXsgLyogZG9Tb21ldGhpbmcgY29kZSAqLyB9KTtcbiAgICBlbHNlIGlmKCAkJC5pcy5zdHJpbmcoIG9wdGlvbnMgKSApIHtcbiAgICAgIHJldHVybiAkJC5leHRlbnNpb24uYXBwbHkoJCQuZXh0ZW5zaW9uLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBkZWZpbmUgdGhlIGZ1bmN0aW9uIG5hbWVzcGFjZSBoZXJlLCBzaW5jZSBpdCBoYXMgbWVtYmVycyBpbiBtYW55IHBsYWNlc1xuICAkJC5mbiA9IHt9O1xuXG4gIGlmKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyApeyAvLyBleHBvc2UgYXMgYSBjb21tb25qcyBtb2R1bGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGN5dG9zY2FwZTtcbiAgfVxuXG4gIGlmKCB0eXBlb2YgZGVmaW5lICE9PSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kICl7IC8vIGV4cG9zZSBhcyBhbiBhbWQvcmVxdWlyZWpzIG1vZHVsZVxuICAgIGRlZmluZSgnY3l0b3NjYXBlJywgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBjeXRvc2NhcGU7XG4gICAgfSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgYWx3YXlzIHJlZ2lzdGVyIGluIHRoZSB3aW5kb3cganVzdCBpbiBjYXNlIChlLmcuIHcvIGRlcmJ5anMpXG4gIGlmKCB3aW5kb3cgKXtcbiAgICB3aW5kb3cuY3l0b3NjYXBlID0gY3l0b3NjYXBlO1xuICB9XG4gIFxufSkoIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuXG4vLyB0eXBlIHRlc3RpbmcgdXRpbGl0eSBmdW5jdGlvbnNcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmlzID0ge1xuICAgIGRlZmluZWQ6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGw7IC8vIG5vdCB1bmRlZmluZWQgb3IgbnVsbFxuICAgIH0sXG5cbiAgICBzdHJpbmc6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PSB0eXBlb2YgJyc7XG4gICAgfSxcbiAgICBcbiAgICBmbjogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgZnVuY3Rpb24oKXt9O1xuICAgIH0sXG4gICAgXG4gICAgYXJyYXk6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkob2JqKSA6IG9iaiAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xuICAgIH0sXG4gICAgXG4gICAgcGxhaW5PYmplY3Q6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mIHt9ICYmICEkJC5pcy5hcnJheShvYmopICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiAxICYmICFpc05hTihvYmopO1xuICAgIH0sXG5cbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiggb2JqICl7XG4gICAgICByZXR1cm4gJCQuaXMubnVtYmVyKG9iaikgJiYgTWF0aC5mbG9vcihvYmopID09PSBvYmo7XG4gICAgfSxcbiAgICBcbiAgICBjb2xvcjogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgJycgJiYgJC5Db2xvcihvYmopLnRvU3RyaW5nKCkgIT09ICcnO1xuICAgIH0sXG4gICAgXG4gICAgYm9vbDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIGVsZW1lbnRPckNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gJCQuaXMuZWxlbWVudChvYmopIHx8ICQkLmlzLmNvbGxlY3Rpb24ob2JqKTtcbiAgICB9LFxuICAgIFxuICAgIGVsZW1lbnQ6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuRWxlbWVudCAmJiBvYmouX3ByaXZhdGUuc2luZ2xlO1xuICAgIH0sXG4gICAgXG4gICAgY29sbGVjdGlvbjogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5Db2xsZWN0aW9uICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xuICAgIH0sXG4gICAgXG4gICAgY29yZTogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5Db3JlO1xuICAgIH0sXG5cbiAgICBzdHlsZTogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5TdHlsZTtcbiAgICB9LFxuXG4gICAgc3R5bGVzaGVldDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5TdHlsZXNoZWV0O1xuICAgIH0sXG5cbiAgICBldmVudDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5FdmVudDtcbiAgICB9LFxuXG4gICAgZW1wdHlTdHJpbmc6IGZ1bmN0aW9uKG9iail7XG4gICAgICBpZiggIW9iaiApeyAvLyBudWxsIGlzIGVtcHR5XG4gICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKG9iaikgKXtcbiAgICAgICAgaWYoIG9iaiA9PT0gJycgfHwgb2JqLm1hdGNoKC9eXFxzKyQvKSApe1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7IC8vIG90aGVyd2lzZSwgd2UgZG9uJ3Qga25vdyB3aGF0IHdlJ3ZlIGdvdFxuICAgIH0sXG4gICAgXG4gICAgbm9uZW1wdHlTdHJpbmc6IGZ1bmN0aW9uKG9iail7XG4gICAgICBpZiggb2JqICYmICQkLmlzLnN0cmluZyhvYmopICYmIG9iaiAhPT0gJycgJiYgIW9iai5tYXRjaCgvXlxccyskLykgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZG9tRWxlbWVudDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIGlmKCB0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnICl7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBib3VuZGluZ0JveDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiAkJC5pcy5wbGFpbk9iamVjdChvYmopICYmIFxuICAgICAgICAkJC5pcy5udW1iZXIob2JqLngxKSAmJiAkJC5pcy5udW1iZXIob2JqLngyKSAmJlxuICAgICAgICAkJC5pcy5udW1iZXIob2JqLnkxKSAmJiAkJC5pcy5udW1iZXIob2JqLnkyKVxuICAgICAgO1xuICAgIH0sXG5cbiAgICB0b3VjaDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB3aW5kb3cgJiYgKCAoJ29udG91Y2hzdGFydCcgaW4gd2luZG93KSB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2ggKTtcbiAgICB9LFxuXG4gICAgZ2Vja286IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJyB8fCAoJ01vekFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG4gICAgfSxcblxuICAgIHdlYmtpdDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2Ygd2Via2l0VVJMICE9PSAndW5kZWZpbmVkJyB8fCAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSk7XG4gICAgfSxcblxuICAgIGNocm9taXVtOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH0sXG5cbiAgICBraHRtbDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBuYXZpZ2F0b3IudmVuZG9yLm1hdGNoKC9rZGUvaSk7IC8vIFRPRE8gcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGRldGVjdCB0aGlzLi4uXG4gICAgfSxcblxuICAgIGtodG1sRXRjOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICQkLmlzLmtodG1sKCkgfHwgJCQuaXMud2Via2l0KCkgfHwgJCQuaXMuYmxpbmsoKTtcbiAgICB9LFxuXG4gICAgdHJpZGVudDogZnVuY3Rpb24oKXtcbiAgICAgICByZXR1cm4gdHlwZW9mIEFjdGl2ZVhPYmplY3QgIT09ICd1bmRlZmluZWQnIHx8IC8qQGNjX29uIUAqL2ZhbHNlO1xuICAgIH0sXG5cbiAgICB3aW5kb3dzOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9XaW4vaSk7XG4gICAgfSxcblxuICAgIG1hYzogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvTWFjL2kpO1xuICAgIH0sXG5cbiAgICBsaW51eDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvTGludXgvaSk7XG4gICAgfSxcblxuICAgIHVuaXg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL1gxMS9pKTtcbiAgICB9XG4gIH07ICBcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gdXRpbGl0eSBmdW5jdGlvbnMgb25seSBmb3IgaW50ZXJuYWwgdXNlXG5cbiAgJCQudXRpbCA9IHtcblxuICAgIC8vIHRoZSBqcXVlcnkgZXh0ZW5kKCkgZnVuY3Rpb25cbiAgICAvLyBOQjogbW9kaWZpZWQgdG8gdXNlICQkLmlzIGV0YyBzaW5jZSB3ZSBjYW4ndCB1c2UganF1ZXJ5IGZ1bmN0aW9uc1xuICAgIGV4dGVuZDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgIGRlZXAgPSBmYWxzZTtcblxuICAgICAgLy8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ID09PSAnYm9vbGVhbicgKSB7XG4gICAgICAgIGRlZXAgPSB0YXJnZXQ7XG4gICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICAgICAgLy8gc2tpcCB0aGUgYm9vbGVhbiBhbmQgdGhlIHRhcmdldFxuICAgICAgICBpID0gMjtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG4gICAgICBpZiAoIHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnICYmICEkJC5pcy5mbih0YXJnZXQpICkge1xuICAgICAgICB0YXJnZXQgPSB7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXG4gICAgICBpZiAoIGxlbmd0aCA9PT0gaSApIHtcbiAgICAgICAgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLS1pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICBpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XG4gICAgICAgICAgLy8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuICAgICAgICAgIGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcbiAgICAgICAgICAgIHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuICAgICAgICAgICAgLy8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuICAgICAgICAgICAgaWYgKCB0YXJnZXQgPT09IGNvcHkgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcbiAgICAgICAgICAgIGlmICggZGVlcCAmJiBjb3B5ICYmICggJCQuaXMucGxhaW5PYmplY3QoY29weSkgfHwgKGNvcHlJc0FycmF5ID0gJCQuaXMuYXJyYXkoY29weSkpICkgKSB7XG4gICAgICAgICAgICAgIGlmICggY29weUlzQXJyYXkgKSB7XG4gICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiAkJC5pcy5hcnJheShzcmMpID8gc3JjIDogW107XG5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiAkJC5pcy5wbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cbiAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSAkJC51dGlsLmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgICAgICAgfSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICB0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvLyByZXF1aXJlIHRoYXQgcHVsbHMgaW4gbW9kdWxlIGZyb20gY29tbW9uanMsIGFtZCwgb3Igd2luZG93IChmYWxsaW5nIGJhY2sgdW50aWwgZm91bmQpXG4gICAgcmVxdWlyZTogZnVuY3Rpb24oIG5hbWUsIGNhbGxiYWNrLCBvcHRpb25zICl7XG4gICAgICB2YXIgcmV0O1xuICAgICAgb3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHtcbiAgICAgICAgbXNnSWZOb3RGb3VuZDogdHJ1ZVxuICAgICAgfSwgb3B0aW9ucyk7XG5cbiAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICB2YXIgZnVsZmlsID0gZnVuY3Rpb24oIHJldCApe1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soIHJldCApO1xuICAgICAgfTtcblxuICAgICAgdmFyIGNoZWNrV2luZG93ID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgICAgaWYoIHdpbmRvdyApeyAvLyBkZXRlY3RlZCBicm93c2VyL3dpbmRvdyBlbnZcbiAgICAgICAgICByZXQgPSB3aW5kb3dbIG5hbWUgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXQgIT09IHVuZGVmaW5lZCApeyBmdWxmaWwocmV0KTsgfVxuICAgICAgICBpZiggbmV4dCApeyBuZXh0KCk7IH1cbiAgICAgIH07XG4gICAgICB2YXIgb25DaGVja1dpbmRvd0RvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggIWRvbmUgKXtcbiAgICAgICAgICBjaGVja0NvbW1vbkpzKCBvbkNoZWNrQ29tbW9uSnNEb25lICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGVja0NvbW1vbkpzID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgICAgaWYoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICYmIHJlcXVpcmUgKXsgLy8gZGV0ZWN0ZWQgY29tbW9uanMgZW52XG4gICAgICAgICAgcmV0ID0gcmVxdWlyZSggbmFtZSApOyAvLyByZWd1bGFyIHJlcXVpcmVcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXQgIT09IHVuZGVmaW5lZCApeyBmdWxmaWwocmV0KTsgfVxuICAgICAgICBpZiggbmV4dCApeyBuZXh0KCk7IH1cbiAgICAgIH07XG4gICAgICB2YXIgb25DaGVja0NvbW1vbkpzRG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCAhZG9uZSApe1xuICAgICAgICAgIGNoZWNrQW1kKCBvbkNoZWNrQW1kRG9uZSApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2tBbWQgPSBmdW5jdGlvbiggbmV4dCApe1xuICAgICAgICBpZiggdHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCAmJiByZXF1aXJlICl7IC8vIGRldGVjdGVkIGFtZCBlbnYgdy8gZGVmaW5lZCBtb2R1bGVcbiAgICAgICAgICByZXF1aXJlKFsgbmFtZSBdLCBmdW5jdGlvbiggbmFtZUltcGwgKXtcbiAgICAgICAgICAgIHJldCA9IG5hbWVJbXBsO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgZnVsZmlsKHJldCk7IH1cbiAgICAgICAgICAgIGlmKCBuZXh0ICl7IG5leHQoKTsgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIG9uQ2hlY2tBbWREb25lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoICFkb25lICYmIG9wdGlvbnMubXNnSWZOb3RGb3VuZCApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ0N5dG9zY2FwZS5qcyB0cmllZCB0byBwdWxsIGluIGRlcGVuZGVuY3kgYCcgKyBuYW1lICsgJ2AgYnV0IG5vIG1vZHVsZSAoaS5lLiBDb21tb25KUywgQU1ELCBvciB3aW5kb3cpIHdhcyBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBraWNrIG9mZiAxc3QgY2hlY2s6IHdpbmRvd1xuICAgICAgY2hlY2tXaW5kb3coIG9uQ2hlY2tXaW5kb3dEb25lICk7XG5cbiAgICB9LFxuXG4gICAgLy8gbXVsdGlwbGUgcmVxdWlyZXMgaW4gb25lIGNhbGxiYWNrXG4gICAgcmVxdWlyZXM6IGZ1bmN0aW9uKCBuYW1lcywgY2FsbGJhY2sgKXtcbiAgICAgIHZhciBpbXBscyA9IFtdO1xuICAgICAgdmFyIGdvdEltcGwgPSBbXTtcblxuICAgICAgdmFyIGNoZWNrRG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKysgKXsgLy8gY2hlY2sgaGF2ZSBhbGwgaW1wbHNcbiAgICAgICAgICBpZiggIWdvdEltcGxbaV0gKXsgcmV0dXJuOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UsIGFsbCBnb3QgYWxsIGltcGxzID0+IGRvbmVcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoIGNhbGxiYWNrLCBpbXBscyApOyBcbiAgICAgIH07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKysgKXsgKGZ1bmN0aW9uKCl7IC8vIHcvc2NvcGVcbiAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgICAgdmFyIGluZGV4ID0gaTtcblxuICAgICAgICAkJC51dGlsLnJlcXVpcmUobmFtZSwgZnVuY3Rpb24oaW1wbCl7XG4gICAgICAgICAgaW1wbHNbaW5kZXhdID0gaW1wbDtcbiAgICAgICAgICBnb3RJbXBsW2luZGV4XSA9IHRydWU7XG5cbiAgICAgICAgICBjaGVja0RvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSgpOyB9XG4gICAgfSxcblxuICAgIC8vIHBvcnRlZCBsb2Rhc2ggdGhyb3R0bGUgZnVuY3Rpb25cbiAgICB0aHJvdHRsZTogZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlLFxuICAgICAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGxlYWRpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoJCQuaXMucGxhaW5PYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy5sZWFkaW5nIDogbGVhZGluZztcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIG9wdGlvbnMubGVhZGluZyA9IGxlYWRpbmc7XG4gICAgICBvcHRpb25zLm1heFdhaXQgPSB3YWl0O1xuICAgICAgb3B0aW9ucy50cmFpbGluZyA9IHRyYWlsaW5nO1xuXG4gICAgICByZXR1cm4gJCQudXRpbC5kZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgbm93OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICtuZXcgRGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvLyBwb3J0ZWQgbG9kYXNoIGRlYm91bmNlIGZ1bmN0aW9uXG4gICAgZGVib3VuY2U6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBhcmdzLFxuICAgICAgICAgIG1heFRpbWVvdXRJZCxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgc3RhbXAsXG4gICAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgICB0aW1lb3V0SWQsXG4gICAgICAgICAgdHJhaWxpbmdDYWxsLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwLFxuICAgICAgICAgIG1heFdhaXQgPSBmYWxzZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmICghJCQuaXMuZm4oZnVuYykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2FpdCA9IE1hdGgubWF4KDAsIHdhaXQpIHx8IDA7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbGVhZGluZyA9IHRydWU7XG4gICAgICAgIHRyYWlsaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heFdhaXQgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucyAmJiAoTWF0aC5tYXgod2FpdCwgb3B0aW9ucy5tYXhXYWl0KSB8fCAwKTtcbiAgICAgICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyBvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgZGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtICgkJC51dGlsLm5vdygpIC0gc3RhbXApO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQobWF4VGltZW91dElkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlzQ2FsbGVkID0gdHJhaWxpbmdDYWxsO1xuICAgICAgICAgIG1heFRpbWVvdXRJZCA9IHRpbWVvdXRJZCA9IHRyYWlsaW5nQ2FsbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGxhc3RDYWxsZWQgPSAkJC51dGlsLm5vdygpO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBtYXhEZWxheWVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0cmFpbGluZyB8fCAobWF4V2FpdCAhPT0gd2FpdCkpIHtcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gJCQudXRpbC5ub3coKTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgc3RhbXAgPSAkJC51dGlsLm5vdygpO1xuICAgICAgICB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgdHJhaWxpbmdDYWxsID0gdHJhaWxpbmcgJiYgKHRpbWVvdXRJZCB8fCAhbGVhZGluZyk7XG5cbiAgICAgICAgaWYgKG1heFdhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIGxlYWRpbmdDYWxsID0gbGVhZGluZyAmJiAhdGltZW91dElkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbWF4VGltZW91dElkICYmICFsZWFkaW5nKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZW1haW5pbmcgPSBtYXhXYWl0IC0gKHN0YW1wIC0gbGFzdENhbGxlZCksXG4gICAgICAgICAgICAgIGlzQ2FsbGVkID0gcmVtYWluaW5nIDw9IDA7XG5cbiAgICAgICAgICBpZiAoaXNDYWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgICAgbWF4VGltZW91dElkID0gY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICghbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBtYXhUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KG1heERlbGF5ZWQsIHJlbWFpbmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiB0aW1lb3V0SWQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGltZW91dElkICYmIHdhaXQgIT09IG1heFdhaXQpIHtcbiAgICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xuICAgICAgICAgIGlzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NhbGxlZCAmJiAhdGltZW91dElkICYmICFtYXhUaW1lb3V0SWQpIHtcbiAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGVycm9yOiBmdW5jdGlvbiggbXNnICl7XG4gICAgICBpZiggY29uc29sZSApe1xuICAgICAgICBpZiggY29uc29sZS5lcnJvciApe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApO1xuICAgICAgICB9IGVsc2UgaWYoIGNvbnNvbGUubG9nICl7XG4gICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoIGNvbnNvbGUsIGFyZ3VtZW50cyApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG1zZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbXNnO1xuICAgICAgfVxuICAgIH0sICAgIFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmICggb2JqLmhhc093blByb3BlcnR5KGkpICkgeyAvLyBUT0RPIGlzIHRoaXMgaGFzT3duUHJvcGVydHkoKSBjYWxsIG5lY2Vzc2FyeSBmb3Igb3VyIHVzZT9cbiAgICAgICAgICB0YXJnZXRbaV0gPSBvYmpbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSxcblxuICAgIC8vIGdldHMgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGFyZ3VtZW50XG4gICAgY29weTogZnVuY3Rpb24oIG9iaiApe1xuICAgICAgaWYoIG9iaiA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGlmKCAkJC5pcy5hcnJheShvYmopICl7XG4gICAgICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3Qob2JqKSApe1xuICAgICAgICByZXR1cm4gJCQudXRpbC5jbG9uZSggb2JqICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgLy8gbWFrZXMgYSBmdWxsIGJiICh4MSwgeTEsIHgyLCB5MiwgdywgaCkgZnJvbSBpbXBsaWNpdCBwYXJhbXNcbiAgICBtYWtlQm91bmRpbmdCb3g6IGZ1bmN0aW9uKCBiYiApe1xuICAgICAgaWYoIGJiLngxICE9IG51bGwgJiYgYmIueTEgIT0gbnVsbCApe1xuICAgICAgICBpZiggYmIueDIgIT0gbnVsbCAmJiBiYi55MiAhPSBudWxsICYmIGJiLngyID49IGJiLngxICYmIGJiLnkyID49IGJiLnkxICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgICAgIHgyOiBiYi54MixcbiAgICAgICAgICAgIHkyOiBiYi55MixcbiAgICAgICAgICAgIHc6IGJiLngyIC0gYmIueDEsXG4gICAgICAgICAgICBoOiBiYi55MiAtIGJiLnkxXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKCBiYi53ICE9IG51bGwgJiYgYmIuaCAhPSBudWxsICYmIGJiLncgPj0gMCAmJiBiYi5oID49IDAgKXtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDE6IGJiLngxLFxuICAgICAgICAgICAgeTE6IGJiLnkxLFxuICAgICAgICAgICAgeDI6IGJiLngxICsgYmIudyxcbiAgICAgICAgICAgIHkyOiBiYi55MSArIGJiLmgsXG4gICAgICAgICAgICB3OiBiYi53LFxuICAgICAgICAgICAgaDogYmIuaFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgfSxcblxuICAgIC8vIGhhcyBhbnl0aGluZyBiZWVuIHNldCBpbiB0aGUgbWFwXG4gICAgbWFwRW1wdHk6IGZ1bmN0aW9uKCBtYXAgKXtcbiAgICAgIHZhciBlbXB0eSA9IHRydWU7XG5cbiAgICAgIGlmKCBtYXAgIT0gbnVsbCApe1xuICAgICAgICBmb3IodmFyIGkgaW4gbWFwKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW1wdHk7XG4gICAgfSxcblxuICAgIC8vIHB1c2hlcyB0byB0aGUgYXJyYXkgYXQgdGhlIGVuZCBvZiBhIG1hcCAobWFwIG1heSBub3QgYmUgYnVpbHQpXG4gICAgcHVzaE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBhcnJheSA9ICQkLnV0aWwuZ2V0TWFwKG9wdGlvbnMpO1xuXG4gICAgICBpZiggYXJyYXkgPT0gbnVsbCApeyAvLyBpZiBlbXB0eSwgcHV0IGluaXRpYWwgYXJyYXlcbiAgICAgICAgJCQudXRpbC5zZXRNYXAoICQuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgdmFsdWU6IFsgb3B0aW9ucy52YWx1ZSBdXG4gICAgICAgIH0pICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheS5wdXNoKCBvcHRpb25zLnZhbHVlICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIHNldHMgdGhlIHZhbHVlIGluIGEgbWFwIChtYXAgbWF5IG5vdCBiZSBidWlsdClcbiAgICBzZXRNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgICB2YXIga2V5O1xuICAgICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1RyaWVkIHRvIHNldCBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaSA8IGtleXMubGVuZ3RoIC0gMSApe1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGV4dGVuZCB0aGUgbWFwIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIGlmKCBvYmpba2V5XSA9PSBudWxsICl7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzZXQgdGhlIHZhbHVlXG4gICAgICAgICAgb2JqW2tleV0gPSBvcHRpb25zLnZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICAvLyBnZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCBldmVuIGlmIGl0J3Mgbm90IGJ1aWx0IGluIHBsYWNlc1xuICAgIGdldE1hcDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBvYmogPSBvcHRpb25zLm1hcDtcbiAgICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdUcmllZCB0byBnZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIFxuICAgICAgICBpZiggb2JqID09IG51bGwgKXtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8vIGRlbGV0ZXMgdGhlIGVudHJ5IGluIHRoZSBtYXBcbiAgICBkZWxldGVNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgICB2YXIga2VlcENoaWxkcmVuID0gb3B0aW9ucy5rZWVwQ2hpbGRyZW47XG4gICAgICBcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspe1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignVHJpZWQgdG8gZGVsZXRlIG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0S2V5ID0gaSA9PT0gb3B0aW9ucy5rZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmKCBsYXN0S2V5ICl7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGtlZXBDaGlsZHJlbiApeyAvLyB0aGVuIG9ubHkgZGVsZXRlIGNoaWxkIGZpZWxkcyBub3QgaW4ga2VlcENoaWxkcmVuXG4gICAgICAgICAgICBmb3IoIHZhciBjaGlsZCBpbiBvYmogKXtcbiAgICAgICAgICAgICAgaWYoICFrZWVwQ2hpbGRyZW5bY2hpbGRdICl7XG4gICAgICAgICAgICAgICAgb2JqW2NoaWxkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmogPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKXtcbiAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhzdHIpICl7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xuICAgIH0sXG5cbiAgICBjYW1lbDJkYXNoOiBmdW5jdGlvbiggc3RyICl7XG4gICAgICB2YXIgcmV0ID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICAgICAgdmFyIGNoTG93ZXJDYXNlID0gY2gudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGlzVXBwZXJDYXNlID0gY2ggIT09IGNoTG93ZXJDYXNlO1xuXG4gICAgICAgIGlmKCBpc1VwcGVyQ2FzZSApe1xuICAgICAgICAgIHJldC5wdXNoKCAnLScgKTtcbiAgICAgICAgICByZXQucHVzaCggY2hMb3dlckNhc2UgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQucHVzaCggY2ggKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9VcHBlckNhc2VzID0gcmV0Lmxlbmd0aCA9PT0gc3RyLmxlbmd0aDtcbiAgICAgIGlmKCBub1VwcGVyQ2FzZXMgKXsgcmV0dXJuIHN0cjsgfSAvLyBjaGVhcGVyIHRoYW4gLmpvaW4oKVxuXG4gICAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBkYXNoMmNhbWVsOiBmdW5jdGlvbiggc3RyICl7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICB2YXIgbmV4dElzVXBwZXIgPSBmYWxzZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGNoID0gc3RyW2ldO1xuICAgICAgICB2YXIgaXNEYXNoID0gY2ggPT09ICctJztcblxuICAgICAgICBpZiggaXNEYXNoICl7XG4gICAgICAgICAgbmV4dElzVXBwZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCBuZXh0SXNVcHBlciApe1xuICAgICAgICAgICAgcmV0LnB1c2goIGNoLnRvVXBwZXJDYXNlKCkgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0LnB1c2goIGNoICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dElzVXBwZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBzdHJpcCBzcGFjZXMgZnJvbSBiZWdpbm5pbmcgb2Ygc3RyaW5nIGFuZCBlbmQgb2Ygc3RyaW5nXG4gICAgdHJpbTogZnVuY3Rpb24oIHN0ciApe1xuICAgICAgdmFyIGZpcnN0LCBsYXN0O1xuXG4gICAgICAvLyBmaW5kIGZpcnN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICBmb3IoIGZpcnN0ID0gMDsgZmlyc3QgPCBzdHIubGVuZ3RoICYmIHN0cltmaXJzdF0gPT09ICcgJzsgZmlyc3QrKyApe31cblxuICAgICAgLy8gZmluZCBsYXN0IG5vbi1zcGFjZSBjaGFyXG4gICAgICBmb3IoIGxhc3QgPSBzdHIubGVuZ3RoIC0gMTsgbGFzdCA+IGZpcnN0ICYmIHN0cltsYXN0XSA9PT0gJyAnOyBsYXN0LS0gKXt9XG5cbiAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKGZpcnN0LCBsYXN0ICsgMSk7XG4gICAgfSxcblxuICAgIC8vIGdldCBbciwgZywgYl0gZnJvbSAjYWJjIG9yICNhYWJiY2NcbiAgICBoZXgydHVwbGU6IGZ1bmN0aW9uKCBoZXggKXtcbiAgICAgIGlmKCAhKGhleC5sZW5ndGggPT09IDQgfHwgaGV4Lmxlbmd0aCA9PT0gNykgfHwgaGV4WzBdICE9PSBcIiNcIiApeyByZXR1cm47IH1cblxuICAgICAgdmFyIHNob3J0SGV4ID0gaGV4Lmxlbmd0aCA9PT0gNDtcbiAgICAgIHZhciByLCBnLCBiO1xuICAgICAgdmFyIGJhc2UgPSAxNjtcblxuICAgICAgaWYoIHNob3J0SGV4ICl7XG4gICAgICAgIHIgPSBwYXJzZUludCggaGV4WzFdICsgaGV4WzFdLCBiYXNlICk7XG4gICAgICAgIGcgPSBwYXJzZUludCggaGV4WzJdICsgaGV4WzJdLCBiYXNlICk7XG4gICAgICAgIGIgPSBwYXJzZUludCggaGV4WzNdICsgaGV4WzNdLCBiYXNlICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gcGFyc2VJbnQoIGhleFsxXSArIGhleFsyXSwgYmFzZSApO1xuICAgICAgICBnID0gcGFyc2VJbnQoIGhleFszXSArIGhleFs0XSwgYmFzZSApO1xuICAgICAgICBiID0gcGFyc2VJbnQoIGhleFs1XSArIGhleFs2XSwgYmFzZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgW3IsIGcsIGIsIGFdIGZyb20gaHNsKDAsIDAsIDApIG9yIGhzbGEoMCwgMCwgMCwgMClcbiAgICBoc2wydHVwbGU6IGZ1bmN0aW9uKCBoc2wgKXtcbiAgICAgIHZhciByZXQ7XG4gICAgICB2YXIgaCwgcywgbCwgYSwgciwgZywgYjtcbiAgICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCl7XG4gICAgICAgIGlmKHQgPCAwKSB0ICs9IDE7XG4gICAgICAgIGlmKHQgPiAxKSB0IC09IDE7XG4gICAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgICBpZih0IDwgMS8yKSByZXR1cm4gcTtcbiAgICAgICAgaWYodCA8IDIvMykgcmV0dXJuIHAgKyAocSAtIHApICogKDIvMyAtIHQpICogNjtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9XG5cbiAgICAgIHZhciBtID0gbmV3IFJlZ0V4cChcIl5cIiArICQkLnV0aWwucmVnZXguaHNsYSArIFwiJFwiKS5leGVjKGhzbCk7XG4gICAgICBpZiggbSApe1xuXG4gICAgICAgIC8vIGdldCBodWVcbiAgICAgICAgaCA9IHBhcnNlSW50KCBtWzFdICk7IFxuICAgICAgICBpZiggaCA8IDAgKXtcbiAgICAgICAgICBoID0gKCAzNjAgLSAoLTEqaCAlIDM2MCkgKSAlIDM2MDtcbiAgICAgICAgfSBlbHNlIGlmKCBoID4gMzYwICl7XG4gICAgICAgICAgaCA9IGggJSAzNjA7XG4gICAgICAgIH1cbiAgICAgICAgaCAvPSAzNjA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgICBzID0gcGFyc2VGbG9hdCggbVsyXSApO1xuICAgICAgICBpZiggcyA8IDAgfHwgcyA+IDEwMCApeyByZXR1cm47IH0gLy8gc2F0dXJhdGlvbiBpcyBbMCwgMTAwXVxuICAgICAgICBzID0gcy8xMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgICBsID0gcGFyc2VGbG9hdCggbVszXSApO1xuICAgICAgICBpZiggbCA8IDAgfHwgbCA+IDEwMCApeyByZXR1cm47IH0gLy8gbGlnaHRuZXNzIGlzIFswLCAxMDBdXG4gICAgICAgIGwgPSBsLzEwMDsgLy8gbm9ybWFsaXNlIG9uIFswLCAxXVxuXG4gICAgICAgIGEgPSBtWzRdO1xuICAgICAgICBpZiggYSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgYSA9IHBhcnNlRmxvYXQoIGEgKTtcblxuICAgICAgICAgIGlmKCBhIDwgMCB8fCBhID4gMSApeyByZXR1cm47IH0gLy8gYWxwaGEgaXMgWzAsIDFdXG4gICAgICAgIH1cblxuICAgICAgICAvLyBub3csIGNvbnZlcnQgdG8gcmdiXG4gICAgICAgIC8vIGNvZGUgZnJvbSBodHRwOi8vbWppamFja3Nvbi5jb20vMjAwOC8wMi9yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNvbnZlcnNpb24tYWxnb3JpdGhtcy1pbi1qYXZhc2NyaXB0XG4gICAgICAgIGlmKCBzID09PSAwICl7XG4gICAgICAgICAgciA9IGcgPSBiID0gTWF0aC5yb3VuZChsICogMjU1KTsgLy8gYWNocm9tYXRpY1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgICAgICByID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYihwLCBxLCBoICsgMS8zKSApO1xuICAgICAgICAgIGcgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKHAsIHEsIGgpICk7XG4gICAgICAgICAgYiA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCAtIDEvMykgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IFtyLCBnLCBiLCBhXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIHJnYigwLCAwLCAwKSBvciByZ2JhKDAsIDAsIDAsIDApXG4gICAgcmdiMnR1cGxlOiBmdW5jdGlvbiggcmdiICl7XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICB2YXIgbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyAkJC51dGlsLnJlZ2V4LnJnYmEgKyBcIiRcIikuZXhlYyhyZ2IpO1xuICAgICAgaWYoIG0gKXtcbiAgICAgICAgcmV0ID0gW107XG5cbiAgICAgICAgdmFyIGlzUGN0ID0gW107XG4gICAgICAgIGZvciggdmFyIGkgPSAxOyBpIDw9IDM7IGkrKyApe1xuICAgICAgICAgIHZhciBjaGFubmVsID0gbVtpXTtcblxuICAgICAgICAgIGlmKCBjaGFubmVsWyBjaGFubmVsLmxlbmd0aCAtIDEgXSA9PT0gXCIlXCIgKXtcbiAgICAgICAgICAgIGlzUGN0W2ldID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2hhbm5lbCA9IHBhcnNlRmxvYXQoIGNoYW5uZWwgKTtcblxuICAgICAgICAgIGlmKCBpc1BjdFtpXSApe1xuICAgICAgICAgICAgY2hhbm5lbCA9IGNoYW5uZWwvMTAwICogMjU1OyAvLyBub3JtYWxpc2UgdG8gWzAsIDI1NV1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggY2hhbm5lbCA8IDAgfHwgY2hhbm5lbCA+IDI1NSApeyByZXR1cm47IH0gLy8gaW52YWxpZCBjaGFubmVsIHZhbHVlXG5cbiAgICAgICAgICByZXQucHVzaCggTWF0aC5mbG9vcihjaGFubmVsKSApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF0TGVhc3RPbmVJc1BjdCA9IGlzUGN0WzFdIHx8IGlzUGN0WzJdIHx8IGlzUGN0WzNdO1xuICAgICAgICB2YXIgYWxsQXJlUGN0ID0gaXNQY3RbMV0gJiYgaXNQY3RbMl0gJiYgaXNQY3RbM107XG4gICAgICAgIGlmKCBhdExlYXN0T25lSXNQY3QgJiYgIWFsbEFyZVBjdCApeyByZXR1cm47IH0gLy8gbXVzdCBhbGwgYmUgcGVyY2VudCB2YWx1ZXMgaWYgb25lIGlzXG5cbiAgICAgICAgdmFyIGFscGhhID0gbVs0XTtcbiAgICAgICAgaWYoIGFscGhhICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBhbHBoYSA9IHBhcnNlRmxvYXQoIGFscGhhICk7XG5cbiAgICAgICAgICBpZiggYWxwaGEgPCAwIHx8IGFscGhhID4gMSApeyByZXR1cm47IH0gLy8gaW52YWxpZCBhbHBoYSB2YWx1ZVxuXG4gICAgICAgICAgcmV0LnB1c2goIGFscGhhICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgY29sb3JuYW1lMnR1cGxlOiBmdW5jdGlvbiggY29sb3IgKXtcbiAgICAgIHJldHVybiAkJC51dGlsLmNvbG9yc1sgY29sb3IudG9Mb3dlckNhc2UoKSBdO1xuICAgIH0sXG5cbiAgICBjb2xvcjJ0dXBsZTogZnVuY3Rpb24oIGNvbG9yICl7XG4gICAgICByZXR1cm4gKCAkJC5pcy5hcnJheShjb2xvcikgPyBjb2xvciA6IG51bGwgKSBcbiAgICAgICAgfHwgJCQudXRpbC5jb2xvcm5hbWUydHVwbGUoY29sb3IpXG4gICAgICAgIHx8ICQkLnV0aWwuaGV4MnR1cGxlKGNvbG9yKVxuICAgICAgICB8fCAkJC51dGlsLnJnYjJ0dXBsZShjb2xvcilcbiAgICAgICAgfHwgJCQudXRpbC5oc2wydHVwbGUoY29sb3IpO1xuICAgIH0sXG5cbiAgICB0dXBsZTJoZXg6IGZ1bmN0aW9uKCB0dXBsZSApe1xuICAgICAgdmFyIHIgPSB0dXBsZVswXTtcbiAgICAgIHZhciBnID0gdHVwbGVbMV07XG4gICAgICB2YXIgYiA9IHR1cGxlWzJdO1xuXG4gICAgICBmdW5jdGlvbiBjaDJoZXgoIGNoICl7XG4gICAgICAgIHZhciBoZXggPSBjaC50b1N0cmluZygxNik7XG5cbiAgICAgICAgaWYoIGhleC5sZW5ndGggPT09IDEgKXtcbiAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyMnICsgY2gyaGV4KHIpICsgY2gyaGV4KGcpICsgY2gyaGV4KGIpO1xuICAgIH0sXG5cbiAgICBjb2xvcnM6IHtcbiAgICAgIC8vIHNwZWNpYWwgY29sb3VyIG5hbWVzXG4gICAgICB0cmFuc3BhcmVudDogICAgICBbMCwwLDAsMF0sIC8vIE5CIGFscGhhID09PSAwXG5cbiAgICAgIC8vIHJlZ3VsYXIgY29sb3Vyc1xuICAgICAgYWxpY2VibHVlOiAgICAgICAgWzI0MCwyNDgsMjU1XSxcbiAgICAgIGFudGlxdWV3aGl0ZTogICAgICBbMjUwLDIzNSwyMTVdLFxuICAgICAgYXF1YTogICAgICAgICAgWzAsMjU1LDI1NV0sXG4gICAgICBhcXVhbWFyaW5lOiAgICAgICAgWzEyNywyNTUsMjEyXSxcbiAgICAgIGF6dXJlOiAgICAgICAgICBbMjQwLDI1NSwyNTVdLFxuICAgICAgYmVpZ2U6ICAgICAgICAgIFsyNDUsMjQ1LDIyMF0sXG4gICAgICBiaXNxdWU6ICAgICAgICAgIFsyNTUsMjI4LDE5Nl0sXG4gICAgICBibGFjazogICAgICAgICAgWzAsMCwwXSxcbiAgICAgIGJsYW5jaGVkYWxtb25kOiAgICAgIFsyNTUsMjM1LDIwNV0sXG4gICAgICBibHVlOiAgICAgICAgICBbMCwwLDI1NV0sXG4gICAgICBibHVldmlvbGV0OiAgICAgICAgWzEzOCw0MywyMjZdLFxuICAgICAgYnJvd246ICAgICAgICAgIFsxNjUsNDIsNDJdLFxuICAgICAgYnVybHl3b29kOiAgICAgICAgWzIyMiwxODQsMTM1XSxcbiAgICAgIGNhZGV0Ymx1ZTogICAgICAgIFs5NSwxNTgsMTYwXSxcbiAgICAgIGNoYXJ0cmV1c2U6ICAgICAgICBbMTI3LDI1NSwwXSxcbiAgICAgIGNob2NvbGF0ZTogICAgICAgIFsyMTAsMTA1LDMwXSxcbiAgICAgIGNvcmFsOiAgICAgICAgICBbMjU1LDEyNyw4MF0sXG4gICAgICBjb3JuZmxvd2VyYmx1ZTogICAgICBbMTAwLDE0OSwyMzddLFxuICAgICAgY29ybnNpbGs6ICAgICAgICBbMjU1LDI0OCwyMjBdLFxuICAgICAgY3JpbXNvbjogICAgICAgIFsyMjAsMjAsNjBdLFxuICAgICAgY3lhbjogICAgICAgICAgWzAsMjU1LDI1NV0sXG4gICAgICBkYXJrYmx1ZTogICAgICAgIFswLDAsMTM5XSxcbiAgICAgIGRhcmtjeWFuOiAgICAgICAgWzAsMTM5LDEzOV0sXG4gICAgICBkYXJrZ29sZGVucm9kOiAgICAgIFsxODQsMTM0LDExXSxcbiAgICAgIGRhcmtncmF5OiAgICAgICAgWzE2OSwxNjksMTY5XSxcbiAgICAgIGRhcmtncmVlbjogICAgICAgIFswLDEwMCwwXSxcbiAgICAgIGRhcmtncmV5OiAgICAgICAgWzE2OSwxNjksMTY5XSxcbiAgICAgIGRhcmtraGFraTogICAgICAgIFsxODksMTgzLDEwN10sXG4gICAgICBkYXJrbWFnZW50YTogICAgICBbMTM5LDAsMTM5XSxcbiAgICAgIGRhcmtvbGl2ZWdyZWVuOiAgICAgIFs4NSwxMDcsNDddLFxuICAgICAgZGFya29yYW5nZTogICAgICAgIFsyNTUsMTQwLDBdLFxuICAgICAgZGFya29yY2hpZDogICAgICAgIFsxNTMsNTAsMjA0XSxcbiAgICAgIGRhcmtyZWQ6ICAgICAgICBbMTM5LDAsMF0sXG4gICAgICBkYXJrc2FsbW9uOiAgICAgICAgWzIzMywxNTAsMTIyXSxcbiAgICAgIGRhcmtzZWFncmVlbjogICAgICBbMTQzLDE4OCwxNDNdLFxuICAgICAgZGFya3NsYXRlYmx1ZTogICAgICBbNzIsNjEsMTM5XSxcbiAgICAgIGRhcmtzbGF0ZWdyYXk6ICAgICAgWzQ3LDc5LDc5XSxcbiAgICAgIGRhcmtzbGF0ZWdyZXk6ICAgICAgWzQ3LDc5LDc5XSxcbiAgICAgIGRhcmt0dXJxdW9pc2U6ICAgICAgWzAsMjA2LDIwOV0sXG4gICAgICBkYXJrdmlvbGV0OiAgICAgICAgWzE0OCwwLDIxMV0sXG4gICAgICBkZWVwcGluazogICAgICAgIFsyNTUsMjAsMTQ3XSxcbiAgICAgIGRlZXBza3libHVlOiAgICAgIFswLDE5MSwyNTVdLFxuICAgICAgZGltZ3JheTogICAgICAgIFsxMDUsMTA1LDEwNV0sXG4gICAgICBkaW1ncmV5OiAgICAgICAgWzEwNSwxMDUsMTA1XSxcbiAgICAgIGRvZGdlcmJsdWU6ICAgICAgICBbMzAsMTQ0LDI1NV0sXG4gICAgICBmaXJlYnJpY2s6ICAgICAgICBbMTc4LDM0LDM0XSxcbiAgICAgIGZsb3JhbHdoaXRlOiAgICAgIFsyNTUsMjUwLDI0MF0sXG4gICAgICBmb3Jlc3RncmVlbjogICAgICBbMzQsMTM5LDM0XSxcbiAgICAgIGZ1Y2hzaWE6ICAgICAgICBbMjU1LDAsMjU1XSxcbiAgICAgIGdhaW5zYm9ybzogICAgICAgIFsyMjAsMjIwLDIyMF0sXG4gICAgICBnaG9zdHdoaXRlOiAgICAgICAgWzI0OCwyNDgsMjU1XSxcbiAgICAgIGdvbGQ6ICAgICAgICAgIFsyNTUsMjE1LDBdLFxuICAgICAgZ29sZGVucm9kOiAgICAgICAgWzIxOCwxNjUsMzJdLFxuICAgICAgZ3JheTogICAgICAgICAgWzEyOCwxMjgsMTI4XSxcbiAgICAgIGdyZXk6ICAgICAgICAgIFsxMjgsMTI4LDEyOF0sXG4gICAgICBncmVlbjogICAgICAgICAgWzAsMTI4LDBdLFxuICAgICAgZ3JlZW55ZWxsb3c6ICAgICAgWzE3MywyNTUsNDddLFxuICAgICAgaG9uZXlkZXc6ICAgICAgICBbMjQwLDI1NSwyNDBdLFxuICAgICAgaG90cGluazogICAgICAgIFsyNTUsMTA1LDE4MF0sXG4gICAgICBpbmRpYW5yZWQ6ICAgICAgICBbMjA1LDkyLDkyXSxcbiAgICAgIGluZGlnbzogICAgICAgICAgWzc1LDAsMTMwXSxcbiAgICAgIGl2b3J5OiAgICAgICAgICBbMjU1LDI1NSwyNDBdLFxuICAgICAga2hha2k6ICAgICAgICAgIFsyNDAsMjMwLDE0MF0sXG4gICAgICBsYXZlbmRlcjogICAgICAgIFsyMzAsMjMwLDI1MF0sXG4gICAgICBsYXZlbmRlcmJsdXNoOiAgICAgIFsyNTUsMjQwLDI0NV0sXG4gICAgICBsYXduZ3JlZW46ICAgICAgICBbMTI0LDI1MiwwXSxcbiAgICAgIGxlbW9uY2hpZmZvbjogICAgICBbMjU1LDI1MCwyMDVdLFxuICAgICAgbGlnaHRibHVlOiAgICAgICAgWzE3MywyMTYsMjMwXSxcbiAgICAgIGxpZ2h0Y29yYWw6ICAgICAgICBbMjQwLDEyOCwxMjhdLFxuICAgICAgbGlnaHRjeWFuOiAgICAgICAgWzIyNCwyNTUsMjU1XSxcbiAgICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAgWzI1MCwyNTAsMjEwXSxcbiAgICAgIGxpZ2h0Z3JheTogICAgICAgIFsyMTEsMjExLDIxMV0sXG4gICAgICBsaWdodGdyZWVuOiAgICAgICAgWzE0NCwyMzgsMTQ0XSxcbiAgICAgIGxpZ2h0Z3JleTogICAgICAgIFsyMTEsMjExLDIxMV0sXG4gICAgICBsaWdodHBpbms6ICAgICAgICBbMjU1LDE4MiwxOTNdLFxuICAgICAgbGlnaHRzYWxtb246ICAgICAgWzI1NSwxNjAsMTIyXSxcbiAgICAgIGxpZ2h0c2VhZ3JlZW46ICAgICAgWzMyLDE3OCwxNzBdLFxuICAgICAgbGlnaHRza3libHVlOiAgICAgIFsxMzUsMjA2LDI1MF0sXG4gICAgICBsaWdodHNsYXRlZ3JheTogICAgICBbMTE5LDEzNiwxNTNdLFxuICAgICAgbGlnaHRzbGF0ZWdyZXk6ICAgICAgWzExOSwxMzYsMTUzXSxcbiAgICAgIGxpZ2h0c3RlZWxibHVlOiAgICAgIFsxNzYsMTk2LDIyMl0sXG4gICAgICBsaWdodHllbGxvdzogICAgICBbMjU1LDI1NSwyMjRdLFxuICAgICAgbGltZTogICAgICAgICAgWzAsMjU1LDBdLFxuICAgICAgbGltZWdyZWVuOiAgICAgICAgWzUwLDIwNSw1MF0sXG4gICAgICBsaW5lbjogICAgICAgICAgWzI1MCwyNDAsMjMwXSxcbiAgICAgIG1hZ2VudGE6ICAgICAgICBbMjU1LDAsMjU1XSxcbiAgICAgIG1hcm9vbjogICAgICAgICAgWzEyOCwwLDBdLFxuICAgICAgbWVkaXVtYXF1YW1hcmluZTogICAgWzEwMiwyMDUsMTcwXSxcbiAgICAgIG1lZGl1bWJsdWU6ICAgICAgICBbMCwwLDIwNV0sXG4gICAgICBtZWRpdW1vcmNoaWQ6ICAgICAgWzE4Niw4NSwyMTFdLFxuICAgICAgbWVkaXVtcHVycGxlOiAgICAgIFsxNDcsMTEyLDIxOV0sXG4gICAgICBtZWRpdW1zZWFncmVlbjogICAgICBbNjAsMTc5LDExM10sXG4gICAgICBtZWRpdW1zbGF0ZWJsdWU6ICAgIFsxMjMsMTA0LDIzOF0sXG4gICAgICBtZWRpdW1zcHJpbmdncmVlbjogICAgWzAsMjUwLDE1NF0sXG4gICAgICBtZWRpdW10dXJxdW9pc2U6ICAgIFs3MiwyMDksMjA0XSxcbiAgICAgIG1lZGl1bXZpb2xldHJlZDogICAgWzE5OSwyMSwxMzNdLFxuICAgICAgbWlkbmlnaHRibHVlOiAgICAgIFsyNSwyNSwxMTJdLFxuICAgICAgbWludGNyZWFtOiAgICAgICAgWzI0NSwyNTUsMjUwXSxcbiAgICAgIG1pc3R5cm9zZTogICAgICAgIFsyNTUsMjI4LDIyNV0sXG4gICAgICBtb2NjYXNpbjogICAgICAgIFsyNTUsMjI4LDE4MV0sXG4gICAgICBuYXZham93aGl0ZTogICAgICBbMjU1LDIyMiwxNzNdLFxuICAgICAgbmF2eTogICAgICAgICAgWzAsMCwxMjhdLFxuICAgICAgb2xkbGFjZTogICAgICAgIFsyNTMsMjQ1LDIzMF0sXG4gICAgICBvbGl2ZTogICAgICAgICAgWzEyOCwxMjgsMF0sXG4gICAgICBvbGl2ZWRyYWI6ICAgICAgICBbMTA3LDE0MiwzNV0sXG4gICAgICBvcmFuZ2U6ICAgICAgICAgIFsyNTUsMTY1LDBdLFxuICAgICAgb3JhbmdlcmVkOiAgICAgICAgWzI1NSw2OSwwXSxcbiAgICAgIG9yY2hpZDogICAgICAgICAgWzIxOCwxMTIsMjE0XSxcbiAgICAgIHBhbGVnb2xkZW5yb2Q6ICAgICAgWzIzOCwyMzIsMTcwXSxcbiAgICAgIHBhbGVncmVlbjogICAgICAgIFsxNTIsMjUxLDE1Ml0sXG4gICAgICBwYWxldHVycXVvaXNlOiAgICAgIFsxNzUsMjM4LDIzOF0sXG4gICAgICBwYWxldmlvbGV0cmVkOiAgICAgIFsyMTksMTEyLDE0N10sXG4gICAgICBwYXBheWF3aGlwOiAgICAgICAgWzI1NSwyMzksMjEzXSxcbiAgICAgIHBlYWNocHVmZjogICAgICAgIFsyNTUsMjE4LDE4NV0sXG4gICAgICBwZXJ1OiAgICAgICAgICBbMjA1LDEzMyw2M10sXG4gICAgICBwaW5rOiAgICAgICAgICBbMjU1LDE5MiwyMDNdLFxuICAgICAgcGx1bTogICAgICAgICAgWzIyMSwxNjAsMjIxXSxcbiAgICAgIHBvd2RlcmJsdWU6ICAgICAgICBbMTc2LDIyNCwyMzBdLFxuICAgICAgcHVycGxlOiAgICAgICAgICBbMTI4LDAsMTI4XSxcbiAgICAgIHJlZDogICAgICAgICAgWzI1NSwwLDBdLFxuICAgICAgcm9zeWJyb3duOiAgICAgICAgWzE4OCwxNDMsMTQzXSxcbiAgICAgIHJveWFsYmx1ZTogICAgICAgIFs2NSwxMDUsMjI1XSxcbiAgICAgIHNhZGRsZWJyb3duOiAgICAgIFsxMzksNjksMTldLFxuICAgICAgc2FsbW9uOiAgICAgICAgICBbMjUwLDEyOCwxMTRdLFxuICAgICAgc2FuZHlicm93bjogICAgICAgIFsyNDQsMTY0LDk2XSxcbiAgICAgIHNlYWdyZWVuOiAgICAgICAgWzQ2LDEzOSw4N10sXG4gICAgICBzZWFzaGVsbDogICAgICAgIFsyNTUsMjQ1LDIzOF0sXG4gICAgICBzaWVubmE6ICAgICAgICAgIFsxNjAsODIsNDVdLFxuICAgICAgc2lsdmVyOiAgICAgICAgICBbMTkyLDE5MiwxOTJdLFxuICAgICAgc2t5Ymx1ZTogICAgICAgIFsxMzUsMjA2LDIzNV0sXG4gICAgICBzbGF0ZWJsdWU6ICAgICAgICBbMTA2LDkwLDIwNV0sXG4gICAgICBzbGF0ZWdyYXk6ICAgICAgICBbMTEyLDEyOCwxNDRdLFxuICAgICAgc2xhdGVncmV5OiAgICAgICAgWzExMiwxMjgsMTQ0XSxcbiAgICAgIHNub3c6ICAgICAgICAgIFsyNTUsMjUwLDI1MF0sXG4gICAgICBzcHJpbmdncmVlbjogICAgICBbMCwyNTUsMTI3XSxcbiAgICAgIHN0ZWVsYmx1ZTogICAgICAgIFs3MCwxMzAsMTgwXSxcbiAgICAgIHRhbjogICAgICAgICAgWzIxMCwxODAsMTQwXSxcbiAgICAgIHRlYWw6ICAgICAgICAgIFswLDEyOCwxMjhdLFxuICAgICAgdGhpc3RsZTogICAgICAgIFsyMTYsMTkxLDIxNl0sXG4gICAgICB0b21hdG86ICAgICAgICAgIFsyNTUsOTksNzFdLFxuICAgICAgdHVycXVvaXNlOiAgICAgICAgWzY0LDIyNCwyMDhdLFxuICAgICAgdmlvbGV0OiAgICAgICAgICBbMjM4LDEzMCwyMzhdLFxuICAgICAgd2hlYXQ6ICAgICAgICAgIFsyNDUsMjIyLDE3OV0sXG4gICAgICB3aGl0ZTogICAgICAgICAgWzI1NSwyNTUsMjU1XSxcbiAgICAgIHdoaXRlc21va2U6ICAgICAgICBbMjQ1LDI0NSwyNDVdLFxuICAgICAgeWVsbG93OiAgICAgICAgICBbMjU1LDI1NSwwXSxcbiAgICAgIHllbGxvd2dyZWVuOiAgICAgIFsxNTQsMjA1LDUwXVxuICAgIH1cbiAgICAgIFxuICB9O1xuXG4gICQkLnV0aWwucmVnZXggPSB7fTtcbiAgXG4gICQkLnV0aWwucmVnZXgubnVtYmVyID0gXCIoPzpbLV0/XFxcXGQqXFxcXC5cXFxcZCt8Wy1dP1xcXFxkK3xbLV0/XFxcXGQqXFxcXC5cXFxcZCtbZUVdXFxcXGQrKVwiO1xuICBcbiAgJCQudXRpbC5yZWdleC5yZ2JhID0gXCJyZ2JbYV0/XFxcXCgoXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KSg/OlxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIikpP1xcXFwpXCI7XG4gICQkLnV0aWwucmVnZXgucmdiYU5vQmFja1JlZnMgPSBcInJnYlthXT9cXFxcKCg/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KVxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKD86XCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pKD86XFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICBcbiAgJCQudXRpbC5yZWdleC5oc2xhID0gXCJoc2xbYV0/XFxcXCgoXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIilcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0pXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdKSg/OlxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIikpP1xcXFwpXCI7XG4gICQkLnV0aWwucmVnZXguaHNsYU5vQmFja1JlZnMgPSBcImhzbFthXT9cXFxcKCg/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpXFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0pXFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0pKD86XFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICBcbiAgJCQudXRpbC5yZWdleC5oZXgzID0gXCJcXFxcI1swLTlhLWZBLUZdezN9XCI7XG4gICQkLnV0aWwucmVnZXguaGV4NiA9IFwiXFxcXCNbMC05YS1mQS1GXXs2fVwiO1xuXG4gIHZhciByYWYgPSAhd2luZG93ID8gbnVsbCA6ICggd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8ICBcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKTtcblxuICByYWYgPSByYWYgfHwgZnVuY3Rpb24oZm4peyBpZihmbil7IHNldFRpbWVvdXQoZm4sIDEwMDAvNjApOyB9IH07XG5cbiAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihmbil7XG4gICAgcmFmKCBmbiApO1xuICB9O1xuXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5tYXRoID0ge307XG4gIFxuICAkJC5tYXRoLnNpZ251bSA9IGZ1bmN0aW9uKHgpe1xuICAgIGlmKCB4ID4gMCApe1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmKCB4IDwgMCApe1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG5cbiAgJCQubWF0aC5kaXN0YW5jZSA9IGZ1bmN0aW9uKCBwMSwgcDIgKXtcbiAgICB2YXIgZHggPSBwMi54IC0gcDEueDtcbiAgICB2YXIgZHkgPSBwMi55IC0gcDEueTtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoIGR4KmR4ICsgZHkqZHkgKTtcbiAgfTtcblxuICAvLyBmcm9tIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQsOpemllcl9jdXJ2ZSNRdWFkcmF0aWNfY3VydmVzXG4gICQkLm1hdGgucWJlemllckF0ID0gZnVuY3Rpb24ocDAsIHAxLCBwMiwgdCl7XG4gICAgcmV0dXJuICgxIC0gdCkqKDEgLSB0KSpwMCArIDIqKDEgLSB0KSp0KnAxICsgdCp0KnAyO1xuICB9O1xuXG4gICQkLm1hdGgucWJlemllclB0QXQgPSBmdW5jdGlvbihwMCwgcDEsIHAyLCB0KXtcbiAgICByZXR1cm4ge1xuICAgICAgeDogJCQubWF0aC5xYmV6aWVyQXQoIHAwLngsIHAxLngsIHAyLngsIHQgKSxcbiAgICAgIHk6ICQkLm1hdGgucWJlemllckF0KCBwMC55LCBwMS55LCBwMi55LCB0IClcbiAgICB9O1xuICB9O1xuXG4gICQkLm1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdCA9IGZ1bmN0aW9uKCBiYjEsIGJiMiApe1xuICAgIC8vIGNhc2U6IG9uZSBiYiB0byByaWdodCBvZiBvdGhlclxuICAgIGlmKCBiYjEueDEgPiBiYjIueDIgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYoIGJiMi54MSA+IGJiMS54MiApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIGNhc2U6IG9uZSBiYiB0byBsZWZ0IG9mIG90aGVyXG4gICAgaWYoIGJiMS54MiA8IGJiMi54MSApeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiggYmIyLngyIDwgYmIxLngxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gY2FzZTogb25lIGJiIGFib3ZlIG90aGVyXG4gICAgaWYoIGJiMS55MiA8IGJiMi55MSApeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiggYmIyLnkyIDwgYmIxLnkxICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gY2FzZTogb25lIGJiIGJlbG93IG90aGVyXG4gICAgaWYoIGJiMS55MSA+IGJiMi55MiApeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiggYmIyLnkxID4gYmIxLnkyICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBtdXN0IGhhdmUgc29tZSBvdmVybGFwXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgJCQubWF0aC5pbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiLCB4LCB5ICl7XG4gICAgcmV0dXJuIGJiLngxIDw9IHggJiYgeCA8PSBiYi54MiAmJiBiYi55MSA8PSB5ICYmIHkgPD0gYmIueTI7XG4gIH07XG5cbiAgJCQubWF0aC5wb2ludEluQm91bmRpbmdCb3ggPSBmdW5jdGlvbiggYmIsIHB0ICl7XG4gICAgcmV0dXJuIHRoaXMuaW5Cb3VuZGluZ0JveCggYmIsIHB0LngsIHB0LnkgKTtcbiAgfTtcblxuICAkJC5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICAgIHgsIHksIG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICAgIFxuICAgIHZhciBjb3JuZXJSYWRpdXMgPSB0aGlzLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIFxuICAgIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gICAgdmFyIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgXG4gICAgLy8gVG9wIHNlZ21lbnQsIGxlZnQgdG8gcmlnaHRcbiAgICB7XG4gICAgICB2YXIgdG9wU3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgICAgdmFyIHRvcFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCAtIHBhZGRpbmc7XG4gICAgICB2YXIgdG9wRW5kWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIHZhciB0b3BFbmRZID0gdG9wU3RhcnRZO1xuICAgICAgXG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCB0b3BTdGFydFgsIHRvcFN0YXJ0WSwgdG9wRW5kWCwgdG9wRW5kWSwgZmFsc2UpO1xuICAgICAgXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBSaWdodCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG4gICAge1xuICAgICAgdmFyIHJpZ2h0U3RhcnRYID0gbm9kZVggKyBoYWxmV2lkdGggKyBwYWRkaW5nO1xuICAgICAgdmFyIHJpZ2h0U3RhcnRZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciByaWdodEVuZFggPSByaWdodFN0YXJ0WDtcbiAgICAgIHZhciByaWdodEVuZFkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgICAgXG4gICAgICBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCByaWdodFN0YXJ0WCwgcmlnaHRTdGFydFksIHJpZ2h0RW5kWCwgcmlnaHRFbmRZLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEJvdHRvbSBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gICAge1xuICAgICAgdmFyIGJvdHRvbVN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciBib3R0b21TdGFydFkgPSBub2RlWSArIGhhbGZIZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgdmFyIGJvdHRvbUVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICB2YXIgYm90dG9tRW5kWSA9IGJvdHRvbVN0YXJ0WTtcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgYm90dG9tU3RhcnRYLCBib3R0b21TdGFydFksIGJvdHRvbUVuZFgsIGJvdHRvbUVuZFksIGZhbHNlKTtcbiAgICAgIFxuICAgICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTGVmdCBzZWdtZW50LCB0b3AgdG8gYm90dG9tXG4gICAge1xuICAgICAgdmFyIGxlZnRTdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCAtIHBhZGRpbmc7XG4gICAgICB2YXIgbGVmdFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgbGVmdEVuZFggPSBsZWZ0U3RhcnRYO1xuICAgICAgdmFyIGxlZnRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgbGVmdFN0YXJ0WCwgbGVmdFN0YXJ0WSwgbGVmdEVuZFgsIGxlZnRFbmRZLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGludGVyc2VjdGlvbnMgd2l0aCBhcmMgc2VnbWVudHNcbiAgICB2YXIgYXJjSW50ZXJzZWN0aW9ucztcbiAgICBcbiAgICAvLyBUb3AgTGVmdFxuICAgIHtcbiAgICAgIHZhciB0b3BMZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHRvcExlZnRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgdG9wTGVmdENlbnRlclgsIHRvcExlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gdG9wTGVmdENlbnRlclhcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BMZWZ0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBUb3AgUmlnaHRcbiAgICB7XG4gICAgICB2YXIgdG9wUmlnaHRDZW50ZXJYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgdG9wUmlnaHRDZW50ZXJZID0gbm9kZVkgLSBoYWxmSGVpZ2h0ICsgY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgdG9wUmlnaHRDZW50ZXJYLCB0b3BSaWdodENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA+PSB0b3BSaWdodENlbnRlclhcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA8PSB0b3BSaWdodENlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQm90dG9tIFJpZ2h0XG4gICAge1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0Q2VudGVyWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgXG4gICAgICAgIGJvdHRvbVJpZ2h0Q2VudGVyWCwgYm90dG9tUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gYm90dG9tUmlnaHRDZW50ZXJYXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPj0gYm90dG9tUmlnaHRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEJvdHRvbSBMZWZ0XG4gICAge1xuICAgICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJYID0gbm9kZVggLSBoYWxmV2lkdGggKyBjb3JuZXJSYWRpdXM7XG4gICAgICB2YXIgYm90dG9tTGVmdENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgICB4LCB5LCBub2RlWCwgbm9kZVksIFxuICAgICAgICBib3R0b21MZWZ0Q2VudGVyWCwgYm90dG9tTGVmdENlbnRlclksIGNvcm5lclJhZGl1cyArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIGludGVyc2VjdGlvbiBpcyBvbiB0aGUgZGVzaXJlZCBxdWFydGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgIGlmIChhcmNJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDBcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1swXSA8PSBib3R0b21MZWZ0Q2VudGVyWFxuICAgICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbUxlZnRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdOyAvLyBpZiBub3RoaW5nXG4gIH07XG4gIFxuICAkJC5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0Qm94ID0gZnVuY3Rpb24oXG4gICAgYm94WDEsIGJveFkxLCBib3hYMiwgYm94WTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICBcbiAgICAvLyBXZSBoYXZlIHRoZSBmb2xsb3dpbmcgc2hwYWVcbiAgICBcbiAgICAvLyAgICBfX19fX1xuICAgIC8vICBffCAgICAgfF9cbiAgICAvLyB8ICAgICAgICAgfFxuICAgIC8vIHxfICAgICAgIF98XG4gICAgLy8gICB8X19fX198XG4gICAgLy9cbiAgICAvLyBXaXRoIGEgcXVhcnRlciBjaXJjbGUgYXQgZWFjaCBjb3JuZXIuXG4gICAgXG4gICAgdmFyIGNvcm5lclJhZGl1cyA9IHRoaXMuZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgXG4gICAgdmFyIGhCb3hUb3BMZWZ0WCA9IGNlbnRlclggLSB3aWR0aCAvIDIgLSBwYWRkaW5nO1xuICAgIHZhciBoQm94VG9wTGVmdFkgPSBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIGhCb3hCb3R0b21SaWdodFggPSBjZW50ZXJYICsgd2lkdGggLyAyICsgcGFkZGluZztcbiAgICB2YXIgaEJveEJvdHRvbVJpZ2h0WSA9IGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICBcbiAgICB2YXIgdkJveFRvcExlZnRYID0gY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgdmFyIHZCb3hUb3BMZWZ0WSA9IGNlbnRlclkgLSBoZWlnaHQgLyAyIC0gcGFkZGluZztcbiAgICB2YXIgdkJveEJvdHRvbVJpZ2h0WCA9IGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgIHZhciB2Qm94Qm90dG9tUmlnaHRZID0gY2VudGVyWSArIGhlaWdodCAvIDIgKyBwYWRkaW5nO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZSBib3ggaXMgb3V0IG9mIGJvdW5kc1xuICAgIHZhciBib3hNaW5YID0gTWF0aC5taW4oYm94WDEsIGJveFgyKTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KGJveFgxLCBib3hYMik7XG4gICAgdmFyIGJveE1pblkgPSBNYXRoLm1pbihib3hZMSwgYm94WTIpO1xuICAgIHZhciBib3hNYXhZID0gTWF0aC5tYXgoYm94WTEsIGJveFkyKTtcbiAgICBcbiAgICBpZiAoYm94TWF4WCA8IGhCb3hUb3BMZWZ0WCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoYm94TWluWCA+IGhCb3hCb3R0b21SaWdodFgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGJveE1heFkgPCB2Qm94VG9wTGVmdFkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGJveE1pblkgPiB2Qm94Qm90dG9tUmlnaHRZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGFuIGhCb3ggcG9pbnQgaXMgaW4gZ2l2ZW4gYm94XG4gICAgaWYgKGhCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIGhCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIGhCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIGhCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGhCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiBoQm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgaEJveFRvcExlZnRZID49IGJveE1pblkgJiYgaEJveFRvcExlZnRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaEJveEJvdHRvbVJpZ2h0WCA+PSBib3hNaW5YICYmIGhCb3hCb3R0b21SaWdodFggPD0gYm94TWF4WFxuICAgICAgICAmJiBoQm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgaEJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGhCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIGhCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIGhCb3hCb3R0b21SaWdodFkgPj0gYm94TWluWSAmJiBoQm94Qm90dG9tUmlnaHRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhIGdpdmVuIHBvaW50IGJveCBpcyBpbiB0aGUgaEJveFxuICAgIGlmIChib3hNaW5YID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gaEJveFRvcExlZnRZICYmIGJveE1pblkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gaEJveFRvcExlZnRZICYmIGJveE1pblkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gaEJveFRvcExlZnRZICYmIGJveE1heFkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNaW5YID49IGhCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IGhCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gaEJveFRvcExlZnRZICYmIGJveE1heFkgPD0gaEJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGFuIHZCb3ggcG9pbnQgaXMgaW4gZ2l2ZW4gYm94XG4gICAgaWYgKHZCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIHZCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIHZCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIHZCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHZCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiB2Qm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgdkJveFRvcExlZnRZID49IGJveE1pblkgJiYgdkJveFRvcExlZnRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAodkJveEJvdHRvbVJpZ2h0WCA+PSBib3hNaW5YICYmIHZCb3hCb3R0b21SaWdodFggPD0gYm94TWF4WFxuICAgICAgICAmJiB2Qm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgdkJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHZCb3hUb3BMZWZ0WCA+PSBib3hNaW5YICYmIHZCb3hUb3BMZWZ0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIHZCb3hCb3R0b21SaWdodFkgPj0gYm94TWluWSAmJiB2Qm94Qm90dG9tUmlnaHRZIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhIGdpdmVuIHBvaW50IGJveCBpcyBpbiB0aGUgdkJveFxuICAgIGlmIChib3hNaW5YID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gdkJveFRvcExlZnRZICYmIGJveE1pblkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1pblkgPj0gdkJveFRvcExlZnRZICYmIGJveE1pblkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhYID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNYXhYIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gdkJveFRvcExlZnRZICYmIGJveE1heFkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNaW5YID49IHZCb3hUb3BMZWZ0WCAmJiBib3hNaW5YIDw9IHZCb3hCb3R0b21SaWdodFhcbiAgICAgICYmIGJveE1heFkgPj0gdkJveFRvcExlZnRZICYmIGJveE1heFkgPD0gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIExhc3RseSwgY2hlY2sgaWYgb25lIG9mIHRoZSBlbGxpcHNlcyBjb2luY2lkZSB3aXRoIHRoZSBib3hcbiAgICBcbiAgICBpZiAodGhpcy5ib3hJbnRlcnNlY3RFbGxpcHNlKGJveE1pblgsIGJveE1pblksIGJveE1heFgsIGJveE1heFksIHBhZGRpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hUb3BMZWZ0WCArIHBhZGRpbmcsIGhCb3hUb3BMZWZ0WSArIHBhZGRpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuYm94SW50ZXJzZWN0RWxsaXBzZShib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94Qm90dG9tUmlnaHRYIC0gcGFkZGluZywgaEJveFRvcExlZnRZICsgcGFkZGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5ib3hJbnRlcnNlY3RFbGxpcHNlKGJveE1pblgsIGJveE1pblksIGJveE1heFgsIGJveE1heFksIHBhZGRpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hCb3R0b21SaWdodFggLSBwYWRkaW5nLCBoQm94Qm90dG9tUmlnaHRZIC0gcGFkZGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5ib3hJbnRlcnNlY3RFbGxpcHNlKGJveE1pblgsIGJveE1pblksIGJveE1heFgsIGJveE1heFksIHBhZGRpbmcsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hUb3BMZWZ0WCArIHBhZGRpbmcsIGhCb3hCb3R0b21SaWdodFkgLSBwYWRkaW5nKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIC8vIEBPIEFwcHJveGltYXRlIGNvbGxpc2lvbiBmdW5jdGlvbnNcbiAgJCQubWF0aC5jaGVja0luQm91bmRpbmdDaXJjbGUgPSBmdW5jdGlvbihcbiAgICB4LCB5LCBmYXJ0aGVzdFBvaW50U3FEaXN0YW5jZSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgIFxuICAgIHggPSAoeCAtIGNlbnRlclgpIC8gKHdpZHRoICsgcGFkZGluZyk7XG4gICAgeSA9ICh5IC0gY2VudGVyWSkgLyAoaGVpZ2h0ICsgcGFkZGluZyk7XG4gICAgXG4gICAgcmV0dXJuICh4ICogeCArIHkgKiB5KSA8PSBmYXJ0aGVzdFBvaW50U3FEaXN0YW5jZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguYm94SW5CZXppZXJWaWNpbml0eSA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UpIHtcbiAgICBcbiAgICAvLyBSZXR1cm4gdmFsdWVzOlxuICAgIC8vIDAgLSBjdXJ2ZSBpcyBub3QgaW4gYm94XG4gICAgLy8gMSAtIGN1cnZlIG1heSBiZSBpbiBib3g7IG5lZWRzIHByZWNpc2UgY2hlY2tcbiAgICAvLyAyIC0gY3VydmUgaXMgaW4gYm94XG4gICAgXG4gICAgLy8gbWlkcG9pbnRcbiAgICB2YXIgbWlkWCA9IDAuMjUgKiB4MSArIDAuNSAqIHgyICsgMC4yNSAqIHgzO1xuICAgIHZhciBtaWRZID0gMC4yNSAqIHkxICsgMC41ICogeTIgKyAwLjI1ICogeTM7XG5cbiAgICB2YXIgYm94TWluWCA9IE1hdGgubWluKHgxYm94LCB4MmJveCkgLSB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1pblkgPSBNYXRoLm1pbih5MWJveCwgeTJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNYXhYID0gTWF0aC5tYXgoeDFib3gsIHgyYm94KSArIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WSA9IE1hdGgubWF4KHkxYm94LCB5MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgXG4gICAgaWYgKHgxID49IGJveE1pblggJiYgeDEgPD0gYm94TWF4WCAmJiB5MSA+PSBib3hNaW5ZICYmIHkxIDw9IGJveE1heFkpIHsgLy8gKHgxLCB5MSkgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHgzID49IGJveE1pblggJiYgeDMgPD0gYm94TWF4WCAmJiB5MyA+PSBib3hNaW5ZICYmIHkzIDw9IGJveE1heFkpIHsgLy8gKHgzLCB5MykgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKG1pZFggPj0gYm94TWluWCAmJiBtaWRYIDw9IGJveE1heFggJiYgbWlkWSA+PSBib3hNaW5ZICYmIG1pZFkgPD0gYm94TWF4WSkgeyAvLyAobWlkWCwgbWlkWSkgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHgyID49IGJveE1pblggJiYgeDIgPD0gYm94TWF4WCAmJiB5MiA+PSBib3hNaW5ZICYmIHkyIDw9IGJveE1heFkpIHsgLy8gY3RybCBwdCBpbiBib3hcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY3VydmVNaW5YID0gTWF0aC5taW4oeDEsIG1pZFgsIHgzKTtcbiAgICB2YXIgY3VydmVNaW5ZID0gTWF0aC5taW4oeTEsIG1pZFksIHkzKTtcbiAgICB2YXIgY3VydmVNYXhYID0gTWF0aC5tYXgoeDEsIG1pZFgsIHgzKTtcbiAgICB2YXIgY3VydmVNYXhZID0gTWF0aC5tYXgoeTEsIG1pZFksIHkzKTtcbiAgICBcbiAgICAvKlxuICAgIGNvbnNvbGUubG9nKGN1cnZlTWluWCArIFwiLCBcIiArIGN1cnZlTWluWSArIFwiLCBcIiArIGN1cnZlTWF4WCBcbiAgICAgICsgXCIsIFwiICsgY3VydmVNYXhZKTtcbiAgICBpZiAoY3VydmVNaW5YID09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5sb2coXCJ1bmRlZmluZWQgY3VydmVNaW5YOiBcIiArIHgxICsgXCIsIFwiICsgeDIgKyBcIiwgXCIgKyB4Myk7XG4gICAgfVxuICAgICovXG4gICAgXG4gICAgaWYgKGN1cnZlTWluWCA+IGJveE1heFhcbiAgICAgIHx8IGN1cnZlTWF4WCA8IGJveE1pblhcbiAgICAgIHx8IGN1cnZlTWluWSA+IGJveE1heFlcbiAgICAgIHx8IGN1cnZlTWF4WSA8IGJveE1pblkpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuIDA7ICBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIDE7XG4gIH07XG5cbiAgJCQubWF0aC5jaGVja0JlemllckluQm94ID0gZnVuY3Rpb24oXG4gICAgeDFib3gsIHkxYm94LCB4MmJveCwgeTJib3gsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSkge1xuXG4gICAgZnVuY3Rpb24gc2FtcGxlSW5Cb3godCl7XG4gICAgICB2YXIgeCA9ICQkLm1hdGgucWJlemllckF0KHgxLCB4MiwgeDMsIHQpO1xuICAgICAgdmFyIHkgPSAkJC5tYXRoLnFiZXppZXJBdCh5MSwgeTIsIHkzLCB0KTtcblxuICAgICAgcmV0dXJuIHgxYm94IDw9IHggJiYgeCA8PSB4MmJveFxuICAgICAgICAmJiB5MWJveCA8PSB5ICYmIHkgPD0geTJib3hcbiAgICAgIDtcbiAgICB9XG5cbiAgICBmb3IoIHZhciB0ID0gMDsgdCA8PSAxOyB0ICs9IDAuMjUgKXtcbiAgICAgIGlmKCAhc2FtcGxlSW5Cb3godCkgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgJCQubWF0aC5jaGVja1N0cmFpZ2h0RWRnZUluQm94ID0gZnVuY3Rpb24oXG4gICAgeDFib3gsIHkxYm94LCB4MmJveCwgeTJib3gsIHgxLCB5MSwgeDIsIHkyLCB0b2xlcmFuY2UpIHtcblxuICAgIHJldHVybiB4MWJveCA8PSB4MSAmJiB4MSA8PSB4MmJveFxuICAgICAgJiYgeDFib3ggPD0geDIgJiYgeDIgPD0geDJib3hcbiAgICAgICYmIHkxYm94IDw9IHkxICYmIHkxIDw9IHkyYm94XG4gICAgICAmJiB5MWJveCA8PSB5MiAmJiB5MiA8PSB5MmJveFxuICAgIDtcbiAgfTtcblxuICAkJC5tYXRoLmNoZWNrU3RyYWlnaHRFZGdlQ3Jvc3Nlc0JveCA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgdG9sZXJhbmNlKSB7XG4gICAgXG4gICAvL2NvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgXG4gICAgdmFyIGJveE1pblggPSBNYXRoLm1pbih4MWJveCwgeDJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oeTFib3gsIHkyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KHgxYm94LCB4MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFkgPSBNYXRoLm1heCh5MWJveCwgeTJib3gpICsgdG9sZXJhbmNlO1xuICAgIFxuICAgIC8vIENoZWNrIGxlZnQgKyByaWdodCBib3VuZHNcbiAgICB2YXIgYVggPSB4MiAtIHgxO1xuICAgIHZhciBiWCA9IHgxO1xuICAgIHZhciB5VmFsdWU7XG4gICAgXG4gICAgLy8gVG9wIGFuZCBib3R0b21cbiAgICB2YXIgYVkgPSB5MiAtIHkxO1xuICAgIHZhciBiWSA9IHkxO1xuICAgIHZhciB4VmFsdWU7XG4gICAgXG4gICAgaWYgKE1hdGguYWJzKGFYKSA8IDAuMDAwMSkge1xuICAgICAgcmV0dXJuICh4MSA+PSBib3hNaW5YICYmIHgxIDw9IGJveE1heFhcbiAgICAgICAgJiYgTWF0aC5taW4oeTEsIHkyKSA8PSBib3hNaW5ZXG4gICAgICAgICYmIE1hdGgubWF4KHkxLCB5MikgPj0gYm94TWF4WSk7ICBcbiAgICB9XG4gICAgXG4gICAgdmFyIHRMZWZ0ID0gKGJveE1pblggLSBiWCkgLyBhWDtcbiAgICBpZiAodExlZnQgPiAwICYmIHRMZWZ0IDw9IDEpIHtcbiAgICAgIHlWYWx1ZSA9IGFZICogdExlZnQgKyBiWTtcbiAgICAgIGlmICh5VmFsdWUgPj0gYm94TWluWSAmJiB5VmFsdWUgPD0gYm94TWF4WSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIHZhciB0UmlnaHQgPSAoYm94TWF4WCAtIGJYKSAvIGFYO1xuICAgIGlmICh0UmlnaHQgPiAwICYmIHRSaWdodCA8PSAxKSB7XG4gICAgICB5VmFsdWUgPSBhWSAqIHRSaWdodCArIGJZO1xuICAgICAgaWYgKHlWYWx1ZSA+PSBib3hNaW5ZICYmIHlWYWx1ZSA8PSBib3hNYXhZKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBcbiAgICB9XG4gICAgXG4gICAgdmFyIHRUb3AgPSAoYm94TWluWSAtIGJZKSAvIGFZO1xuICAgIGlmICh0VG9wID4gMCAmJiB0VG9wIDw9IDEpIHtcbiAgICAgIHhWYWx1ZSA9IGFYICogdFRvcCArIGJYO1xuICAgICAgaWYgKHhWYWx1ZSA+PSBib3hNaW5YICYmIHhWYWx1ZSA8PSBib3hNYXhYKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBcbiAgICB9XG4gICAgXG4gICAgdmFyIHRCb3R0b20gPSAoYm94TWF4WSAtIGJZKSAvIGFZO1xuICAgIGlmICh0Qm90dG9tID4gMCAmJiB0Qm90dG9tIDw9IDEpIHtcbiAgICAgIHhWYWx1ZSA9IGFYICogdEJvdHRvbSArIGJYO1xuICAgICAgaWYgKHhWYWx1ZSA+PSBib3hNaW5YICYmIHhWYWx1ZSA8PSBib3hNYXhYKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5jaGVja0JlemllckNyb3NzZXNCb3ggPSBmdW5jdGlvbihcbiAgICB4MWJveCwgeTFib3gsIHgyYm94LCB5MmJveCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gICAgXG4gICAgdmFyIGJveE1pblggPSBNYXRoLm1pbih4MWJveCwgeDJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oeTFib3gsIHkyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KHgxYm94LCB4MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFkgPSBNYXRoLm1heCh5MWJveCwgeTJib3gpICsgdG9sZXJhbmNlO1xuICAgIFxuICAgIGlmICh4MSA+PSBib3hNaW5YICYmIHgxIDw9IGJveE1heFggJiYgeTEgPj0gYm94TWluWSAmJiB5MSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHgzID49IGJveE1pblggJiYgeDMgPD0gYm94TWF4WCAmJiB5MyA+PSBib3hNaW5ZICYmIHkzIDw9IGJveE1heFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICB2YXIgYVggPSB4MSAtIDIgKiB4MiArIHgzO1xuICAgIHZhciBiWCA9IC0yICogeDEgKyAyICogeDI7XG4gICAgdmFyIGNYID0geDE7XG5cbiAgICB2YXIgeEludGVydmFscyA9IFtdO1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhhWCkgPCAwLjAwMDEpIHtcbiAgICAgIHZhciBsZWZ0UGFyYW0gPSAoYm94TWluWCAtIHgxKSAvIGJYO1xuICAgICAgdmFyIHJpZ2h0UGFyYW0gPSAoYm94TWF4WCAtIHgxKSAvIGJYO1xuICAgICAgXG4gICAgICB4SW50ZXJ2YWxzLnB1c2gobGVmdFBhcmFtLCByaWdodFBhcmFtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmluZCB3aGVuIHggY29vcmRpbmF0ZSBvZiB0aGUgY3VydmUgY3Jvc3NlcyB0aGUgbGVmdCBzaWRlIG9mIHRoZSBib3hcbiAgICAgIHZhciBkaXNjcmltaW5hbnRYMSA9IGJYICogYlggLSA0ICogYVggKiAoY1ggLSBib3hNaW5YKTtcbiAgICAgIHZhciB0WDEsIHRYMjtcbiAgICAgIGlmIChkaXNjcmltaW5hbnRYMSA+IDApIHtcbiAgICAgICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQoZGlzY3JpbWluYW50WDEpO1xuICAgICAgICB0WDEgPSAoLWJYICsgc3FydCkgLyAoMiAqIGFYKTtcbiAgICAgICAgdFgyID0gKC1iWCAtIHNxcnQpIC8gKDIgKiBhWCk7XG4gICAgICAgIFxuICAgICAgICB4SW50ZXJ2YWxzLnB1c2godFgxLCB0WDIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZGlzY3JpbWluYW50WDIgPSBiWCAqIGJYIC0gNCAqIGFYICogKGNYIC0gYm94TWF4WCk7XG4gICAgICB2YXIgdFgzLCB0WDQ7XG4gICAgICBpZiAoZGlzY3JpbWluYW50WDIgPiAwKSB7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudFgyKTtcbiAgICAgICAgdFgzID0gKC1iWCArIHNxcnQpIC8gKDIgKiBhWCk7XG4gICAgICAgIHRYNCA9ICgtYlggLSBzcXJ0KSAvICgyICogYVgpO1xuICAgICAgICBcbiAgICAgICAgeEludGVydmFscy5wdXNoKHRYMywgdFg0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgeEludGVydmFscy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcbiAgICBcbiAgICB2YXIgYVkgPSB5MSAtIDIgKiB5MiArIHkzO1xuICAgIHZhciBiWSA9IC0yICogeTEgKyAyICogeTI7XG4gICAgdmFyIGNZID0geTE7XG4gICAgXG4gICAgdmFyIHlJbnRlcnZhbHMgPSBbXTtcbiAgICBcbiAgICBpZiAoTWF0aC5hYnMoYVkpIDwgMC4wMDAxKSB7XG4gICAgICB2YXIgdG9wUGFyYW0gPSAoYm94TWluWSAtIHkxKSAvIGJZO1xuICAgICAgdmFyIGJvdHRvbVBhcmFtID0gKGJveE1heFkgLSB5MSkgLyBiWTtcbiAgICAgIFxuICAgICAgeUludGVydmFscy5wdXNoKHRvcFBhcmFtLCBib3R0b21QYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkaXNjcmltaW5hbnRZMSA9IGJZICogYlkgLSA0ICogYVkgKiAoY1kgLSBib3hNaW5ZKTtcbiAgICAgIFxuICAgICAgdmFyIHRZMSwgdFkyO1xuICAgICAgaWYgKGRpc2NyaW1pbmFudFkxID4gMCkge1xuICAgICAgICB2YXIgc3FydCA9IE1hdGguc3FydChkaXNjcmltaW5hbnRZMSk7XG4gICAgICAgIHRZMSA9ICgtYlkgKyBzcXJ0KSAvICgyICogYVkpO1xuICAgICAgICB0WTIgPSAoLWJZIC0gc3FydCkgLyAoMiAqIGFZKTtcbiAgICAgICAgXG4gICAgICAgIHlJbnRlcnZhbHMucHVzaCh0WTEsIHRZMik7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGRpc2NyaW1pbmFudFkyID0gYlkgKiBiWSAtIDQgKiBhWSAqIChjWSAtIGJveE1heFkpO1xuICAgICAgXG4gICAgICB2YXIgdFkzLCB0WTQ7XG4gICAgICBpZiAoZGlzY3JpbWluYW50WTIgPiAwKSB7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudFkyKTtcbiAgICAgICAgdFkzID0gKC1iWSArIHNxcnQpIC8gKDIgKiBhWSk7XG4gICAgICAgIHRZNCA9ICgtYlkgLSBzcXJ0KSAvICgyICogYVkpO1xuICAgICAgICBcbiAgICAgICAgeUludGVydmFscy5wdXNoKHRZMywgdFk0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAgIFxuICAgIHlJbnRlcnZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgeEludGVydmFscy5sZW5ndGg7IGluZGV4ICs9IDIpIHtcbiAgICAgIGZvciAodmFyIHlJbmRleCA9IDE7IHlJbmRleCA8IHlJbnRlcnZhbHMubGVuZ3RoOyB5SW5kZXggKz0gMikge1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUgZXhpc3RzIHZhbHVlcyBmb3IgdGhlIEJlemllciBjdXJ2ZVxuICAgICAgICAvLyBwYXJhbWV0ZXIgYmV0d2VlbiAwIGFuZCAxIHdoZXJlIGJvdGggdGhlIGN1cnZlJ3NcbiAgICAgICAgLy8geCBhbmQgeSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoZSBib3VuZHMgc3BlY2lmaWVkIGJ5IHRoZSBib3hcbiAgICAgICAgaWYgKHhJbnRlcnZhbHNbaW5kZXhdIDwgeUludGVydmFsc1t5SW5kZXhdXG4gICAgICAgICAgJiYgeUludGVydmFsc1t5SW5kZXhdID49IDAuMFxuICAgICAgICAgICYmIHhJbnRlcnZhbHNbaW5kZXhdIDw9IDEuMFxuICAgICAgICAgICYmIHhJbnRlcnZhbHNbaW5kZXggKyAxXSA+IHlJbnRlcnZhbHNbeUluZGV4IC0gMV1cbiAgICAgICAgICAmJiB5SW50ZXJ2YWxzW3lJbmRleCAtIDFdIDw9IDEuMFxuICAgICAgICAgICYmIHhJbnRlcnZhbHNbaW5kZXggKyAxXSA+PSAwLjApIHtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICAkJC5tYXRoLmluTGluZVZpY2luaXR5ID0gZnVuY3Rpb24oeCwgeSwgbHgxLCBseTEsIGx4MiwgbHkyLCB0b2xlcmFuY2Upe1xuICAgIHZhciB0ID0gdG9sZXJhbmNlO1xuXG4gICAgdmFyIHgxID0gTWF0aC5taW4obHgxLCBseDIpO1xuICAgIHZhciB4MiA9IE1hdGgubWF4KGx4MSwgbHgyKTtcbiAgICB2YXIgeTEgPSBNYXRoLm1pbihseTEsIGx5Mik7XG4gICAgdmFyIHkyID0gTWF0aC5tYXgobHkxLCBseTIpO1xuXG4gICAgcmV0dXJuIHgxIC0gdCA8PSB4ICYmIHggPD0geDIgKyB0XG4gICAgICAmJiB5MSAtIHQgPD0geSAmJiB5IDw9IHkyICsgdDtcbiAgfTtcblxuICAkJC5tYXRoLmluQmV6aWVyVmljaW5pdHkgPSBmdW5jdGlvbihcbiAgICB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2VTcXVhcmVkKSB7XG5cbiAgICB2YXIgYmIgPSB7XG4gICAgICB4MTogTWF0aC5taW4oIHgxLCB4MywgeDIgKSxcbiAgICAgIHgyOiBNYXRoLm1heCggeDEsIHgzLCB4MiApLFxuICAgICAgeTE6IE1hdGgubWluKCB5MSwgeTMsIHkyICksXG4gICAgICB5MjogTWF0aC5tYXgoIHkxLCB5MywgeTIgKVxuICAgIH07XG5cbiAgICAvLyBpZiBvdXRzaWRlIHRoZSByb3VnaCBib3VuZGluZyBib3ggZm9yIHRoZSBiZXppZXIsIHRoZW4gaXQgY2FuJ3QgYmUgYSBoaXRcbiAgICBpZiggeCA8IGJiLngxIHx8IHggPiBiYi54MiB8fCB5IDwgYmIueTEgfHwgeSA+IGJiLnkyICl7XG4gICAgICAvLyBjb25zb2xlLmxvZygnYmV6aWVyIG91dCBvZiByb3VnaCBiYicpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdkbyBtb3JlIGV4cGVuc2l2ZSBjaGVjaycpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gIH07XG4gIFxuICAkJC5tYXRoLnNvbHZlQ3ViaWMgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCByZXN1bHQpIHtcbiAgICBcbiAgICAvLyBTb2x2ZXMgYSBjdWJpYyBmdW5jdGlvbiwgcmV0dXJucyByb290IGluIGZvcm0gW3IxLCBpMSwgcjIsIGkyLCByMywgaTNdLCB3aGVyZVxuICAgIC8vIHIgaXMgdGhlIHJlYWwgY29tcG9uZW50LCBpIGlzIHRoZSBpbWFnaW5hcnkgY29tcG9uZW50XG5cbiAgICAvLyBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2FyZGFubyBtZXRob2QgZnJvbSB0aGUgeWVhciAxNTQ1XG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19mdW5jdGlvbiNUaGVfbmF0dXJlX29mX3RoZV9yb290c1xuXG4gICAgYiAvPSBhO1xuICAgIGMgLz0gYTtcbiAgICBkIC89IGE7XG4gICAgXG4gICAgdmFyIGRpc2NyaW1pbmFudCwgcSwgciwgZHVtMSwgcywgdCwgdGVybTEsIHIxMztcblxuICAgIHEgPSAoMy4wICogYyAtIChiICogYikpIC8gOS4wO1xuICAgIHIgPSAtKDI3LjAgKiBkKSArIGIgKiAoOS4wICogYyAtIDIuMCAqIChiICogYikpO1xuICAgIHIgLz0gNTQuMDtcbiAgICBcbiAgICBkaXNjcmltaW5hbnQgPSBxICogcSAqIHEgKyByICogcjtcbiAgICByZXN1bHRbMV0gPSAwO1xuICAgIHRlcm0xID0gKGIgLyAzLjApO1xuICAgIFxuICAgIGlmIChkaXNjcmltaW5hbnQgPiAwKSB7XG4gICAgICBzID0gciArIE1hdGguc3FydChkaXNjcmltaW5hbnQpO1xuICAgICAgcyA9ICgocyA8IDApID8gLU1hdGgucG93KC1zLCAoMS4wIC8gMy4wKSkgOiBNYXRoLnBvdyhzLCAoMS4wIC8gMy4wKSkpO1xuICAgICAgdCA9IHIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgIHQgPSAoKHQgPCAwKSA/IC1NYXRoLnBvdygtdCwgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3codCwgKDEuMCAvIDMuMCkpKTtcbiAgICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIHMgKyB0O1xuICAgICAgdGVybTEgKz0gKHMgKyB0KSAvIDIuMDtcbiAgICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC10ZXJtMTtcbiAgICAgIHRlcm0xID0gTWF0aC5zcXJ0KDMuMCkgKiAoLXQgKyBzKSAvIDI7XG4gICAgICByZXN1bHRbM10gPSB0ZXJtMTtcbiAgICAgIHJlc3VsdFs1XSA9IC10ZXJtMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgcmVzdWx0WzVdID0gcmVzdWx0WzNdID0gMDtcbiAgICBcbiAgICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XG4gICAgICByMTMgPSAoKHIgPCAwKSA/IC1NYXRoLnBvdygtciwgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3cociwgKDEuMCAvIDMuMCkpKTtcbiAgICAgIHJlc3VsdFswXSA9IC10ZXJtMSArIDIuMCAqIHIxMztcbiAgICAgIHJlc3VsdFs0XSA9IHJlc3VsdFsyXSA9IC0ocjEzICsgdGVybTEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBxID0gLXE7XG4gICAgZHVtMSA9IHEgKiBxICogcTtcbiAgICBkdW0xID0gTWF0aC5hY29zKHIgLyBNYXRoLnNxcnQoZHVtMSkpO1xuICAgIHIxMyA9IDIuMCAqIE1hdGguc3FydChxKTtcbiAgICByZXN1bHRbMF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcyhkdW0xIC8gMy4wKTtcbiAgICByZXN1bHRbMl0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDIuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgICByZXN1bHRbNF0gPSAtdGVybTEgKyByMTMgKiBNYXRoLmNvcygoZHVtMSArIDQuMCAqIE1hdGguUEkpIC8gMy4wKTtcbiAgICBcbiAgICByZXR1cm47XG4gIH07XG5cbiAgJCQubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIgPSBmdW5jdGlvbihcbiAgICB4LCB5LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgXG4gICAgLy8gRmluZCBtaW5pbXVtIGRpc3RhbmNlIGJ5IHVzaW5nIHRoZSBtaW5pbXVtIG9mIHRoZSBkaXN0YW5jZSBcbiAgICAvLyBmdW5jdGlvbiBiZXR3ZWVuIHRoZSBnaXZlbiBwb2ludCBhbmQgdGhlIGN1cnZlXG4gICAgXG4gICAgLy8gVGhpcyBnaXZlcyB0aGUgY29lZmZpY2llbnRzIG9mIHRoZSByZXN1bHRpbmcgY3ViaWMgZXF1YXRpb25cbiAgICAvLyB3aG9zZSByb290cyB0ZWxsIHVzIHdoZXJlIGEgcG9zc2libGUgbWluaW11bSBpc1xuICAgIC8vIChDb2VmZmljaWVudHMgYXJlIGRpdmlkZWQgYnkgNClcbiAgICBcbiAgICB2YXIgYSA9IDEuMCAqIHgxKngxIC0gNCp4MSp4MiArIDIqeDEqeDMgKyA0KngyKngyIC0gNCp4Mip4MyArIHgzKngzXG4gICAgICArIHkxKnkxIC0gNCp5MSp5MiArIDIqeTEqeTMgKyA0KnkyKnkyIC0gNCp5Mip5MyArIHkzKnkzO1xuICAgIFxuICAgIHZhciBiID0gMS4wICogOSp4MSp4MiAtIDMqeDEqeDEgLSAzKngxKngzIC0gNip4Mip4MiArIDMqeDIqeDNcbiAgICAgICsgOSp5MSp5MiAtIDMqeTEqeTEgLSAzKnkxKnkzIC0gNip5Mip5MiArIDMqeTIqeTM7XG4gICAgXG4gICAgdmFyIGMgPSAxLjAgKiAzKngxKngxIC0gNip4MSp4MiArIHgxKngzIC0geDEqeCArIDIqeDIqeDIgKyAyKngyKnggLSB4Myp4XG4gICAgICArIDMqeTEqeTEgLSA2KnkxKnkyICsgeTEqeTMgLSB5MSp5ICsgMip5Mip5MiArIDIqeTIqeSAtIHkzKnk7XG4gICAgICBcbiAgICB2YXIgZCA9IDEuMCAqIHgxKngyIC0geDEqeDEgKyB4MSp4IC0geDIqeFxuICAgICAgKyB5MSp5MiAtIHkxKnkxICsgeTEqeSAtIHkyKnk7XG4gICAgXG4gICAgLy8gZGVidWcoXCJjb2VmZmljaWVudHM6IFwiICsgYSAvIGEgKyBcIiwgXCIgKyBiIC8gYSArIFwiLCBcIiArIGMgLyBhICsgXCIsIFwiICsgZCAvIGEpO1xuICAgIFxuICAgIHZhciByb290cyA9IFtdO1xuICAgIFxuICAgIC8vIFVzZSB0aGUgY3ViaWMgc29sdmluZyBhbGdvcml0aG1cbiAgICB0aGlzLnNvbHZlQ3ViaWMoYSwgYiwgYywgZCwgcm9vdHMpO1xuICAgIFxuICAgIHZhciB6ZXJvVGhyZXNob2xkID0gMC4wMDAwMDAxO1xuICAgIFxuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgNjsgaW5kZXggKz0gMikge1xuICAgICAgaWYgKE1hdGguYWJzKHJvb3RzW2luZGV4ICsgMV0pIDwgemVyb1RocmVzaG9sZFxuICAgICAgICAgICYmIHJvb3RzW2luZGV4XSA+PSAwXG4gICAgICAgICAgJiYgcm9vdHNbaW5kZXhdIDw9IDEuMCkge1xuICAgICAgICBwYXJhbXMucHVzaChyb290c1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBwYXJhbXMucHVzaCgxLjApO1xuICAgIHBhcmFtcy5wdXNoKDAuMCk7XG4gICAgXG4gICAgdmFyIG1pbkRpc3RhbmNlU3F1YXJlZCA9IC0xO1xuICAgIHZhciBjbG9zZXN0UGFyYW07XG4gICAgXG4gICAgdmFyIGN1clgsIGN1clksIGRpc3RTcXVhcmVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJYID0gTWF0aC5wb3coMS4wIC0gcGFyYW1zW2ldLCAyLjApICogeDFcbiAgICAgICAgKyAyLjAgKiAoMSAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB4MlxuICAgICAgICArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHgzO1xuICAgICAgICBcbiAgICAgIGN1clkgPSBNYXRoLnBvdygxIC0gcGFyYW1zW2ldLCAyLjApICogeTFcbiAgICAgICAgKyAyICogKDEuMCAtIHBhcmFtc1tpXSkgKiBwYXJhbXNbaV0gKiB5MlxuICAgICAgICArIHBhcmFtc1tpXSAqIHBhcmFtc1tpXSAqIHkzO1xuICAgICAgICBcbiAgICAgIGRpc3RTcXVhcmVkID0gTWF0aC5wb3coY3VyWCAtIHgsIDIpICsgTWF0aC5wb3coY3VyWSAtIHksIDIpO1xuICAgICAgLy8gZGVidWcoJ2Rpc3RhbmNlIGZvciBwYXJhbSAnICsgcGFyYW1zW2ldICsgXCI6IFwiICsgTWF0aC5zcXJ0KGRpc3RTcXVhcmVkKSk7XG4gICAgICBpZiAobWluRGlzdGFuY2VTcXVhcmVkID49IDApIHtcbiAgICAgICAgaWYgKGRpc3RTcXVhcmVkIDwgbWluRGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICAgICAgY2xvc2VzdFBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5EaXN0YW5jZVNxdWFyZWQgPSBkaXN0U3F1YXJlZDtcbiAgICAgICAgY2xvc2VzdFBhcmFtID0gcGFyYW1zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvKlxuICAgIGRlYnVnU3RhdHMuY2xpY2tYID0geDtcbiAgICBkZWJ1Z1N0YXRzLmNsaWNrWSA9IHk7XG4gICAgXG4gICAgZGVidWdTdGF0cy5jbG9zZXN0WCA9IE1hdGgucG93KDEuMCAtIGNsb3Nlc3RQYXJhbSwgMi4wKSAqIHgxXG4gICAgICAgICsgMi4wICogKDEuMCAtIGNsb3Nlc3RQYXJhbSkgKiBjbG9zZXN0UGFyYW0gKiB4MlxuICAgICAgICArIGNsb3Nlc3RQYXJhbSAqIGNsb3Nlc3RQYXJhbSAqIHgzO1xuICAgICAgICBcbiAgICBkZWJ1Z1N0YXRzLmNsb3Nlc3RZID0gTWF0aC5wb3coMS4wIC0gY2xvc2VzdFBhcmFtLCAyLjApICogeTFcbiAgICAgICAgKyAyLjAgKiAoMS4wIC0gY2xvc2VzdFBhcmFtKSAqIGNsb3Nlc3RQYXJhbSAqIHkyXG4gICAgICAgICsgY2xvc2VzdFBhcmFtICogY2xvc2VzdFBhcmFtICogeTM7XG4gICAgKi9cbiAgICBcbiAgICAvLyBkZWJ1ZyhcImdpdmVuOiBcIiBcbiAgICAvLyAgICsgXCIoIFwiICsgeCArIFwiLCBcIiArIHkgKyBcIiksIFwiIFxuICAgIC8vICAgKyBcIiggXCIgKyB4MSArIFwiLCBcIiArIHkxICsgXCIpLCBcIiBcbiAgICAvLyAgICsgXCIoIFwiICsgeDIgKyBcIiwgXCIgKyB5MiArIFwiKSwgXCJcbiAgICAvLyAgICsgXCIoIFwiICsgeDMgKyBcIiwgXCIgKyB5MyArIFwiKVwiKTtcbiAgICBcbiAgICBcbiAgICAvLyBkZWJ1ZyhcInJvb3RzOiBcIiArIHJvb3RzKTtcbiAgICAvLyBkZWJ1ZyhcInBhcmFtczogXCIgKyBwYXJhbXMpO1xuICAgIC8vIGRlYnVnKFwiY2xvc2VzdCBwYXJhbTogXCIgKyBjbG9zZXN0UGFyYW0pO1xuICAgIHJldHVybiBtaW5EaXN0YW5jZVNxdWFyZWQ7XG4gIH07XG4gIFxuICAkJC5tYXRoLnNxRGlzdGFuY2VUb0Zpbml0ZUxpbmUgPSBmdW5jdGlvbih4LCB5LCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBvZmZzZXQgPSBbeCAtIHgxLCB5IC0geTFdO1xuICAgIHZhciBsaW5lID0gW3gyIC0geDEsIHkyIC0geTFdO1xuICAgIFxuICAgIHZhciBsaW5lU3EgPSBsaW5lWzBdICogbGluZVswXSArIGxpbmVbMV0gKiBsaW5lWzFdO1xuICAgIHZhciBoeXBTcSA9IG9mZnNldFswXSAqIG9mZnNldFswXSArIG9mZnNldFsxXSAqIG9mZnNldFsxXTtcbiAgICBcbiAgICB2YXIgZG90UHJvZHVjdCA9IG9mZnNldFswXSAqIGxpbmVbMF0gKyBvZmZzZXRbMV0gKiBsaW5lWzFdO1xuICAgIHZhciBhZGpTcSA9IGRvdFByb2R1Y3QgKiBkb3RQcm9kdWN0IC8gbGluZVNxO1xuICAgIFxuICAgIGlmIChkb3RQcm9kdWN0IDwgMCkge1xuICAgICAgcmV0dXJuIGh5cFNxO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYWRqU3EgPiBsaW5lU3EpIHtcbiAgICAgIHJldHVybiAoeCAtIHgyKSAqICh4IC0geDIpICsgKHkgLSB5MikgKiAoeSAtIHkyKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGh5cFNxIC0gYWRqU3E7XG4gIH07XG5cbiAgJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24gPSBmdW5jdGlvbihcbiAgICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcblxuICAgIC8vdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50c1s2XTtcbiAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuXG4gICAgLy8gR2l2ZXMgbmVnYXRpdmUgYW5nbGVcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZGlyZWN0aW9uWzFdIC8gKE1hdGguc3FydChkaXJlY3Rpb25bMF0gKiBkaXJlY3Rpb25bMF0gXG4gICAgICArIGRpcmVjdGlvblsxXSAqIGRpcmVjdGlvblsxXSkpKTtcbiAgICBcbiAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIH1cbiAgICAgICAgXG4gICAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgXG4vLyAgICBjb25zb2xlLmxvZyhcImJhc2U6IFwiICsgYmFzZVBvaW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IFxuICAgICAgICB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3NcbiAgICAgICAgICAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG4gICAgICBcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBcbiAgICAgICAgaGVpZ2h0IC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBjb3MgXG4gICAgICAgICAgKyBiYXNlUG9pbnRzW2kgKiAyXSAqIHNpbik7XG5cbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSArPSBjZW50ZXJZO1xuICAgIH1cbiAgICBcbiAgICB2YXIgcG9pbnRzO1xuICAgIFxuICAgIGlmIChwYWRkaW5nID4gMCkge1xuICAgICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IHRoaXMuZXhwYW5kUG9seWdvbihcbiAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMsXG4gICAgICAgIC1wYWRkaW5nKTtcbiAgICAgIFxuICAgICAgcG9pbnRzID0gdGhpcy5qb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICAgIFxuICAgIHZhciB4MSwgeTEsIHgyLCB5MjtcbiAgICB2YXIgeTM7XG4gICAgXG4gICAgLy8gSW50ZXJzZWN0IHdpdGggdmVydGljYWwgbGluZSB0aHJvdWdoICh4LCB5KVxuICAgIHZhciB1cCA9IDA7XG4gICAgdmFyIGRvd24gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgXG4gICAgICB4MSA9IHBvaW50c1tpICogMl07XG4gICAgICB5MSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgXG4gICAgICBpZiAoaSArIDEgPCBwb2ludHMubGVuZ3RoIC8gMikge1xuICAgICAgICB4MiA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIHkyID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHBvaW50c1soaSArIDEgLSBwb2ludHMubGVuZ3RoIC8gMikgKiAyXTtcbiAgICAgICAgeTIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMiArIDFdO1xuICAgICAgfVxuICAgICAgXG4vLyogICAgICBjb25zb2xlLmxvZyhcImxpbmUgZnJvbSAoXCIgKyB4MSArIFwiLCBcIiArIHkxICsgXCIpIHRvIChcIiArIHgyICsgXCIsIFwiICsgeTIgKyBcIilcIik7XG5cbi8vJiAgICAgIGNvbnNvbGUubG9nKHgxLCB4LCB4Mik7XG5cbiAgICAgIGlmICh4MSA9PSB4ICYmIHgyID09IHgpIHtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKCh4MSA+PSB4ICYmIHggPj0geDIpXG4gICAgICAgIHx8ICh4MSA8PSB4ICYmIHggPD0geDIpKSB7XG4gICAgICAgIFxuICAgICAgICB5MyA9ICh4IC0geDEpIC8gKHgyIC0geDEpICogKHkyIC0geTEpICsgeTE7XG4gICAgICAgIFxuICAgICAgICBpZiAoeTMgPiB5KSB7XG4gICAgICAgICAgdXArKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHkzIDwgeSkge1xuICAgICAgICAgIGRvd24rKztcbiAgICAgICAgfVxuICAgICAgICBcbi8vKiAgICAgICAgY29uc29sZS5sb2coeTMsIHkpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4vLyogICAgICAgIGNvbnNvbGUubG9nKCcyMicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgICBcbi8vKiAgICBjb25zb2xlLmxvZyhcInVwOiBcIiArIHVwICsgXCIsIGRvd246IFwiICsgZG93bik7XG4gICAgXG4gICAgaWYgKHVwICUgMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgJCQubWF0aC5qb2luTGluZXMgPSBmdW5jdGlvbihsaW5lU2V0KSB7XG4gICAgXG4gICAgdmFyIHZlcnRpY2VzID0gbmV3IEFycmF5KGxpbmVTZXQubGVuZ3RoIC8gMik7XG4gICAgXG4gICAgdmFyIGN1cnJlbnRMaW5lU3RhcnRYLCBjdXJyZW50TGluZVN0YXJ0WSwgY3VycmVudExpbmVFbmRYLCBjdXJyZW50TGluZUVuZFk7XG4gICAgdmFyIG5leHRMaW5lU3RhcnRYLCBuZXh0TGluZVN0YXJ0WSwgbmV4dExpbmVFbmRYLCBuZXh0TGluZUVuZFk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQ7IGkrKykge1xuICAgICAgY3VycmVudExpbmVTdGFydFggPSBsaW5lU2V0W2kgKiA0XTtcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRZID0gbGluZVNldFtpICogNCArIDFdO1xuICAgICAgY3VycmVudExpbmVFbmRYID0gbGluZVNldFtpICogNCArIDJdO1xuICAgICAgY3VycmVudExpbmVFbmRZID0gbGluZVNldFtpICogNCArIDNdO1xuICAgICAgXG4gICAgICBpZiAoaSA8IGxpbmVTZXQubGVuZ3RoIC8gNCAtIDEpIHtcbiAgICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WyhpICsgMSkgKiA0XTtcbiAgICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMV07XG4gICAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAyXTtcbiAgICAgICAgbmV4dExpbmVFbmRZID0gbGluZVNldFsoaSArIDEpICogNCArIDNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dExpbmVTdGFydFggPSBsaW5lU2V0WzBdO1xuICAgICAgICBuZXh0TGluZVN0YXJ0WSA9IGxpbmVTZXRbMV07XG4gICAgICAgIG5leHRMaW5lRW5kWCA9IGxpbmVTZXRbMl07XG4gICAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbM107XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgICBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksXG4gICAgICAgIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZLFxuICAgICAgICBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksXG4gICAgICAgIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZLFxuICAgICAgICB0cnVlKTtcbiAgICAgIFxuICAgICAgdmVydGljZXNbaSAqIDJdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgICAgdmVydGljZXNbaSAqIDIgKyAxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHZlcnRpY2VzO1xuICB9O1xuXG4gICQkLm1hdGguZXhwYW5kUG9seWdvbiA9IGZ1bmN0aW9uKHBvaW50cywgcGFkKSB7XG4gICAgXG4gICAgdmFyIGV4cGFuZGVkTGluZVNldCA9IG5ldyBBcnJheShwb2ludHMubGVuZ3RoICogMik7XG4gICAgXG4gICAgdmFyIGN1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFksIG5leHRQb2ludFgsIG5leHRQb2ludFk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBjdXJyZW50UG9pbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIGN1cnJlbnRQb2ludFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIFxuICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgbmV4dFBvaW50WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRQb2ludFggPSBwb2ludHNbMF07XG4gICAgICAgIG5leHRQb2ludFkgPSBwb2ludHNbMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEN1cnJlbnQgbGluZTogW2N1cnJlbnRQb2ludFgsIGN1cnJlbnRQb2ludFldIHRvIFtuZXh0UG9pbnRYLCBuZXh0UG9pbnRZXVxuICAgICAgXG4gICAgICAvLyBBc3N1bWUgQ0NXIHBvbHlnb24gd2luZGluZ1xuICAgICAgXG4gICAgICB2YXIgb2Zmc2V0WCA9IChuZXh0UG9pbnRZIC0gY3VycmVudFBvaW50WSk7XG4gICAgICB2YXIgb2Zmc2V0WSA9IC0obmV4dFBvaW50WCAtIGN1cnJlbnRQb2ludFgpO1xuICAgICAgXG4gICAgICAvLyBOb3JtYWxpemVcbiAgICAgIHZhciBvZmZzZXRMZW5ndGggPSBNYXRoLnNxcnQob2Zmc2V0WCAqIG9mZnNldFggKyBvZmZzZXRZICogb2Zmc2V0WSk7XG4gICAgICB2YXIgbm9ybWFsaXplZE9mZnNldFggPSBvZmZzZXRYIC8gb2Zmc2V0TGVuZ3RoO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRZID0gb2Zmc2V0WSAvIG9mZnNldExlbmd0aDtcbiAgICAgIFxuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0XSA9IGN1cnJlbnRQb2ludFggKyBub3JtYWxpemVkT2Zmc2V0WCAqIHBhZDtcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDFdID0gY3VycmVudFBvaW50WSArIG5vcm1hbGl6ZWRPZmZzZXRZICogcGFkO1xuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgMl0gPSBuZXh0UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAzXSA9IG5leHRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGV4cGFuZGVkTGluZVNldDtcbiAgfTtcblxuICAkJC5tYXRoLmludGVyc2VjdExpbmVFbGxpcHNlID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgZWxsaXBzZVdyYWRpdXMsIGVsbGlwc2VIcmFkaXVzKSB7XG4gICAgXG4gICAgdmFyIGRpc3BYID0gY2VudGVyWCAtIHg7XG4gICAgdmFyIGRpc3BZID0gY2VudGVyWSAtIHk7XG4gICAgXG4gICAgZGlzcFggLz0gZWxsaXBzZVdyYWRpdXM7XG4gICAgZGlzcFkgLz0gZWxsaXBzZUhyYWRpdXM7XG4gICAgXG4gICAgdmFyIGxlbiA9IE1hdGguc3FydChkaXNwWCAqIGRpc3BYICsgZGlzcFkgKiBkaXNwWSk7XG4gICAgXG4gICAgdmFyIG5ld0xlbmd0aCA9IGxlbiAtIDE7XG4gICAgXG4gICAgaWYgKG5ld0xlbmd0aCA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGxlblByb3BvcnRpb24gPSBuZXdMZW5ndGggLyBsZW47XG4gICAgXG4gICAgcmV0dXJuIFsoY2VudGVyWCAtIHgpICogbGVuUHJvcG9ydGlvbiArIHgsIChjZW50ZXJZIC0geSkgKiBsZW5Qcm9wb3J0aW9uICsgeV07XG4gIH07XG4gIFxuICAkJC5tYXRoLmRvdFByb2R1Y3QgPSBmdW5jdGlvbihcbiAgICB2ZWMxLCB2ZWMyKSB7XG4gICAgXG4gICAgaWYgKHZlYzEubGVuZ3RoICE9IDIgfHwgdmVjMi5sZW5ndGggIT0gMikge1xuICAgICAgdGhyb3cgJ2RvdCBwcm9kdWN0OiBhcmd1bWVudHMgYXJlIG5vdCB2ZWN0b3JzJztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICh2ZWMxWzBdICogdmVjMlswXSArIHZlYzFbMV0gKiB2ZWMyWzFdKTtcbiAgfTtcbiAgXG4gIC8vIFJldHVybnMgaW50ZXJzZWN0aW9ucyBvZiBpbmNyZWFzaW5nIGRpc3RhbmNlIGZyb20gbGluZSdzIHN0YXJ0IHBvaW50XG4gICQkLm1hdGguaW50ZXJzZWN0TGluZUNpcmNsZSA9IGZ1bmN0aW9uKFxuICAgIHgxLCB5MSwgeDIsIHkyLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMpIHtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgZCwgZGlyZWN0aW9uIHZlY3RvciBvZiBsaW5lXG4gICAgdmFyIGQgPSBbeDIgLSB4MSwgeTIgLSB5MV07IC8vIERpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICAgIHZhciBjID0gW2NlbnRlclgsIGNlbnRlclldOyAvLyBDZW50ZXIgb2YgY2lyY2xlXG4gICAgdmFyIGYgPSBbeDEgLSBjZW50ZXJYLCB5MSAtIGNlbnRlclldO1xuICAgIFxuICAgIHZhciBhID0gZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXTtcbiAgICB2YXIgYiA9IDIgKiAoZlswXSAqIGRbMF0gKyBmWzFdICogZFsxXSk7XG4gICAgdmFyIGMgPSAoZlswXSAqIGZbMF0gKyBmWzFdICogZlsxXSkgLSByYWRpdXMgKiByYWRpdXMgO1xuICAgIFxuICAgIHZhciBkaXNjcmltaW5hbnQgPSBiKmItNCphKmM7XG4gICAgXG4gICAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoZGlzY3JpbWluYW50KSkgLyAoMiAqIGEpO1xuICAgIFxuICAgIHZhciB0TWluID0gTWF0aC5taW4odDEsIHQyKTtcbiAgICB2YXIgdE1heCA9IE1hdGgubWF4KHQxLCB0Mik7XG4gICAgdmFyIGluUmFuZ2VQYXJhbXMgPSBbXTtcbiAgICBcbiAgICBpZiAodE1pbiA+PSAwICYmIHRNaW4gPD0gMSkge1xuICAgICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNaW4pO1xuICAgIH1cbiAgICBcbiAgICBpZiAodE1heCA+PSAwICYmIHRNYXggPD0gMSkge1xuICAgICAgaW5SYW5nZVBhcmFtcy5wdXNoKHRNYXgpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgXG4gICAgdmFyIG5lYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMF0gKyB4MTtcbiAgICB2YXIgbmVhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzBdICogZFsxXSArIHkxO1xuICAgIFxuICAgIGlmIChpblJhbmdlUGFyYW1zLmxlbmd0aCA+IDEpIHtcbiAgICBcbiAgICAgIGlmIChpblJhbmdlUGFyYW1zWzBdID09IGluUmFuZ2VQYXJhbXNbMV0pIHtcbiAgICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25YID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMF0gKyB4MTtcbiAgICAgICAgdmFyIGZhckludGVyc2VjdGlvblkgPSBpblJhbmdlUGFyYW1zWzFdICogZFsxXSArIHkxO1xuICAgICAgXG4gICAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZLCBmYXJJbnRlcnNlY3Rpb25YLCBmYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWV07XG4gICAgfVxuICAgIFxuICB9O1xuICBcbiAgJCQubWF0aC5maW5kQ2lyY2xlTmVhclBvaW50ID0gZnVuY3Rpb24oY2VudGVyWCwgY2VudGVyWSwgXG4gICAgcmFkaXVzLCBmYXJYLCBmYXJZKSB7XG4gICAgXG4gICAgdmFyIGRpc3BsYWNlbWVudFggPSBmYXJYIC0gY2VudGVyWDtcbiAgICB2YXIgZGlzcGxhY2VtZW50WSA9IGZhclkgLSBjZW50ZXJZO1xuICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXNwbGFjZW1lbnRYICogZGlzcGxhY2VtZW50WCBcbiAgICAgICsgZGlzcGxhY2VtZW50WSAqIGRpc3BsYWNlbWVudFkpO1xuICAgIFxuICAgIHZhciB1bml0RGlzcGxhY2VtZW50WCA9IGRpc3BsYWNlbWVudFggLyBkaXN0YW5jZTtcbiAgICB2YXIgdW5pdERpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnRZIC8gZGlzdGFuY2U7XG4gICAgXG4gICAgcmV0dXJuIFtjZW50ZXJYICsgdW5pdERpc3BsYWNlbWVudFggKiByYWRpdXMsIFxuICAgICAgY2VudGVyWSArIHVuaXREaXNwbGFjZW1lbnRZICogcmFkaXVzXTtcbiAgfTtcbiAgXG4gICQkLm1hdGguZmluZE1heFNxRGlzdGFuY2VUb09yaWdpbiA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHZhciBtYXhTcURpc3RhbmNlID0gMC4wMDAwMDE7XG4gICAgdmFyIHNxRGlzdGFuY2U7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBcbiAgICAgIHNxRGlzdGFuY2UgPSBwb2ludHNbaSAqIDJdICogcG9pbnRzW2kgKiAyXSBcbiAgICAgICAgKyBwb2ludHNbaSAqIDIgKyAxXSAqIHBvaW50c1tpICogMiArIDFdO1xuICAgICAgXG4gICAgICBpZiAoc3FEaXN0YW5jZSA+IG1heFNxRGlzdGFuY2UpIHtcbiAgICAgICAgbWF4U3FEaXN0YW5jZSA9IHNxRGlzdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBtYXhTcURpc3RhbmNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdCA9IGZ1bmN0aW9uKFxuICAgIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgaW5maW5pdGVMaW5lcykge1xuICAgIFxuICAgIHZhciB1YV90ID0gKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpO1xuICAgIHZhciB1Yl90ID0gKHgyIC0geDEpICogKHkxIC0geTMpIC0gKHkyIC0geTEpICogKHgxIC0geDMpO1xuICAgIHZhciB1X2IgPSAoeTQgLSB5MykgKiAoeDIgLSB4MSkgLSAoeDQgLSB4MykgKiAoeTIgLSB5MSk7XG5cbiAgICBpZiAodV9iICE9PSAwKSB7XG4gICAgICB2YXIgdWEgPSB1YV90IC8gdV9iO1xuICAgICAgdmFyIHViID0gdWJfdCAvIHVfYjtcbiAgICAgIFxuICAgICAgaWYgKDAgPD0gdWEgJiYgdWEgPD0gMSAmJiAwIDw9IHViICYmIHViIDw9IDEpIHsgIFxuICAgICAgICByZXR1cm4gW3gxICsgdWEgKiAoeDIgLSB4MSksIHkxICsgdWEgKiAoeTIgLSB5MSldO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaW5maW5pdGVMaW5lcykge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW3gxICsgdWEgKiAoeDIgLSB4MSksIHkxICsgdWEgKiAoeTIgLSB5MSldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh1YV90ID09PSAwIHx8IHViX3QgPT09IDApIHtcblxuICAgICAgICAvLyBQYXJhbGxlbCwgY29pbmNpZGVudCBsaW5lcy4gQ2hlY2sgaWYgb3ZlcmxhcFxuXG4gICAgICAgIC8vIENoZWNrIGVuZHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICAgIGlmIChbeDEsIHgyLCB4NF0uc29ydCgpWzFdID09PSB4NCkge1xuICAgICAgICAgIHJldHVybiBbeDQsIHk0XTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgc3RhcnQgcG9pbnQgb2Ygc2Vjb25kIGxpbmVcbiAgICAgICAgaWYgKFt4MSwgeDIsIHgzXS5zb3J0KClbMV0gPT09IHgzKSB7XG4gICAgICAgICAgcmV0dXJuIFt4MywgeTNdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBFbmRwb2ludCBvZiBmaXJzdCBsaW5lXG4gICAgICAgIGlmIChbeDMsIHg0LCB4Ml0uc29ydCgpWzFdID09PSB4Mikge1xuICAgICAgICAgIHJldHVybiBbeDIsIHkyXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIFxuICAgICAgICAvLyBQYXJhbGxlbCwgbm9uLWNvaW5jaWRlbnRcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgXG4gIC8vIChib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAvLyAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHZCb3hUb3BMZWZ0WCArIHBhZGRpbmcsIGhCb3hUb3BMZWZ0WSArIHBhZGRpbmcpKSB7XG4gIFxuICAkJC5tYXRoLmJveEludGVyc2VjdEVsbGlwc2UgPSBmdW5jdGlvbihcbiAgICB4MSwgeTEsIHgyLCB5MiwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgIFxuICAgIGlmICh4MiA8IHgxKSB7XG4gICAgICB2YXIgb2xkWDEgPSB4MTtcbiAgICAgIHgxID0geDI7XG4gICAgICB4MiA9IG9sZFgxO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTIgPCB5MSkge1xuICAgICAgdmFyIG9sZFkxID0geTE7XG4gICAgICB5MSA9IHkyO1xuICAgICAgeTIgPSBvbGRZMTtcbiAgICB9XG4gICAgXG4gICAgLy8gNCBvcnRobyBleHRyZW1lIHBvaW50c1xuICAgIHZhciB3ZXN0ID0gW2NlbnRlclggLSB3aWR0aCAvIDIgLSBwYWRkaW5nLCBjZW50ZXJZXTtcbiAgICB2YXIgZWFzdCA9IFtjZW50ZXJYICsgd2lkdGggLyAyICsgcGFkZGluZywgY2VudGVyWV07XG4gICAgdmFyIG5vcnRoID0gW2NlbnRlclgsIGNlbnRlclkgLSBoZWlnaHQgLyAyIC0gcGFkZGluZ107XG4gICAgdmFyIHNvdXRoID0gW2NlbnRlclgsIGNlbnRlclkgKyBoZWlnaHQgLyAyICsgcGFkZGluZ107XG4gICAgXG4gICAgLy8gb3V0IG9mIGJvdW5kczogcmV0dXJuIGZhbHNlXG4gICAgaWYgKHgyIDwgd2VzdFswXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPiBlYXN0WzBdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MSA+IHNvdXRoWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MiA8IG5vcnRoWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIDEgb2YgNCBvcnRobyBleHRyZW1lIHBvaW50cyBpbiBib3g6IHJldHVybiB0cnVlXG4gICAgaWYgKHgxIDw9IGVhc3RbMF0gJiYgZWFzdFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSBlYXN0WzFdICYmIGVhc3RbMV0gPD0geTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPD0gd2VzdFswXSAmJiB3ZXN0WzBdIDw9IHgyXG4gICAgICAgICYmIHkxIDw9IHdlc3RbMV0gJiYgd2VzdFsxXSA8PSB5Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSA8PSBub3J0aFswXSAmJiBub3J0aFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSBub3J0aFsxXSAmJiBub3J0aFsxXSA8PSB5Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSA8PSBzb3V0aFswXSAmJiBzb3V0aFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSBzb3V0aFsxXSAmJiBzb3V0aFsxXSA8PSB5Mikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIGJveCBjb3JuZXIgaW4gZWxsaXBzZTogcmV0dXJuIHRydWUgICAgXG4gICAgeDEgPSAoeDEgLSBjZW50ZXJYKSAvICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICB4MiA9ICh4MiAtIGNlbnRlclgpIC8gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgIFxuICAgIHkxID0gKHkxIC0gY2VudGVyWSkgLyAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgIHkyID0gKHkyIC0gY2VudGVyWSkgLyAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgIFxuICAgIGlmICh4MSAqIHgxICsgeTEgKiB5MSA8PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgyICogeDIgKyB5MSAqIHkxIDw9IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDIgKiB4MiArIHkyICogeTIgPD0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSAqIHgxICsgeTIgKiB5MiA8PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5ib3hJbnRlcnNlY3RQb2x5Z29uID0gZnVuY3Rpb24oXG4gICAgeDEsIHkxLCB4MiwgeTIsIGJhc2VQb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgIFxuLy8gICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcbiAgICBcbiAgICBpZiAoeDIgPCB4MSkge1xuICAgICAgdmFyIG9sZFgxID0geDE7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeDIgPSBvbGRYMTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHkyIDwgeTEpIHtcbiAgICAgIHZhciBvbGRZMSA9IHkxO1xuICAgICAgeTEgPSB5MjtcbiAgICAgIHkyID0gb2xkWTE7XG4gICAgfVxuICAgIFxuICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gICAgXG4gICAgLy8gR2l2ZXMgbmVnYXRpdmUgb2YgYW5nbGVcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZGlyZWN0aW9uWzFdIC8gKE1hdGguc3FydChkaXJlY3Rpb25bMF0gKiBkaXJlY3Rpb25bMF0gXG4gICAgICArIGRpcmVjdGlvblsxXSAqIGRpcmVjdGlvblsxXSkpKTtcbiAgICBcbiAgICBpZiAoZGlyZWN0aW9uWzBdIDwgMCkge1xuICAgICAgYW5nbGUgPSBhbmdsZSArIE1hdGguUEkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmdsZSA9IC1hbmdsZSAtIE1hdGguUEkgLyAyO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICB2YXIgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gXG4gICAgICAgIHdpZHRoIC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyXSAqIGNvc1xuICAgICAgICAgIC0gYmFzZVBvaW50c1tpICogMiArIDFdICogc2luKTtcbiAgICAgIFxuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IFxuICAgICAgICBoZWlnaHQgLyAyICogKGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGNvcyBcbiAgICAgICAgICArIGJhc2VQb2ludHNbaSAqIDJdICogc2luKTtcbiAgICAgIFxuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdICs9IGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdICs9IGNlbnRlclk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFzc3VtZSB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggPiAwLCBhbmQgY2hlY2sgaWYgaW50ZXJzZWN0aW9uIGlzIHBvc3NpYmxlXG4gICAgdmFyIG1pblRyYW5zZm9ybWVkWCA9IHRyYW5zZm9ybWVkUG9pbnRzWzBdO1xuICAgIHZhciBtYXhUcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1swXTtcbiAgICB2YXIgbWluVHJhbnNmb3JtZWRZID0gdHJhbnNmb3JtZWRQb2ludHNbMV07XG4gICAgdmFyIG1heFRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzWzFdO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID4gbWF4VHJhbnNmb3JtZWRYKSB7XG4gICAgICAgIG1heFRyYW5zZm9ybWVkWCA9IHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA8IG1pblRyYW5zZm9ybWVkWCkge1xuICAgICAgICBtaW5UcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID4gbWF4VHJhbnNmb3JtZWRZKSB7XG4gICAgICAgIG1heFRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdIDwgbWluVHJhbnNmb3JtZWRZKSB7XG4gICAgICAgIG1pblRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICh4MiA8IG1pblRyYW5zZm9ybWVkWCAtIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgxID4gbWF4VHJhbnNmb3JtZWRYICsgcGFkZGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTIgPCBtaW5UcmFuc2Zvcm1lZFkgLSBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MSA+IG1heFRyYW5zZm9ybWVkWSArIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ29udGludWUgY2hlY2tpbmcgd2l0aCBwYWRkaW5nLWNvcnJlY3RlZCBwb2ludHNcbiAgICB2YXIgcG9pbnRzO1xuICAgIFxuICAgIGlmIChwYWRkaW5nID4gMCkge1xuICAgICAgdmFyIGV4cGFuZGVkTGluZVNldCA9ICQkLm1hdGguZXhwYW5kUG9seWdvbihcbiAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMsXG4gICAgICAgIC1wYWRkaW5nKTtcbiAgICAgIFxuICAgICAgcG9pbnRzID0gJCQubWF0aC5qb2luTGluZXMoZXhwYW5kZWRMaW5lU2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGEgcG9pbnQgaXMgaW4gYm94XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGlmICh4MSA8PSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl1cbiAgICAgICAgICAmJiB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPD0geDIpIHtcbiAgICAgICAgXG4gICAgICAgIGlmICh5MSA8PSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdXG4gICAgICAgICAgICAmJiB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdIDw9IHkyKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgXG4gICAgLy8gQ2hlY2sgZm9yIGludGVyc2VjdGlvbnMgd2l0aCB0aGUgc2VsZWN0aW9uIGJveFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgXG4gICAgICB2YXIgY3VycmVudFggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgdmFyIGN1cnJlbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICB2YXIgbmV4dFg7XG4gICAgICB2YXIgbmV4dFk7XG4gICAgICBcbiAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTtcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWzBdO1xuICAgICAgICBuZXh0WSA9IHBvaW50c1sxXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW50ZXJzZWN0aW9uIHdpdGggdG9wIG9mIHNlbGVjdGlvbiBib3hcbiAgICAgIGlmICgkJC5tYXRoLmZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZLCB4MSwgeTEsIHgyLCB5MSwgZmFsc2UpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEludGVyc2VjdGlvbiB3aXRoIGJvdHRvbSBvZiBzZWxlY3Rpb24gYm94XG4gICAgICBpZiAoJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSwgeDEsIHkyLCB4MiwgeTIsIGZhbHNlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJbnRlcnNlY3Rpb24gd2l0aCBsZWZ0IHNpZGUgb2Ygc2VsZWN0aW9uIGJveFxuICAgICAgaWYgKCQkLm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QoY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFksIHgxLCB5MSwgeDEsIHkyLCBmYWxzZSkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW50ZXJzZWN0aW9uIHdpdGggcmlnaHQgc2lkZSBvZiBzZWxlY3Rpb24gYm94XG4gICAgICBpZiAoJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSwgeDIsIHkxLCB4MiwgeTIsIGZhbHNlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qXG4gICAgLy8gQ2hlY2sgaWYgYm94IGNvcm5lciBpbiB0aGUgcG9seWdvblxuICAgIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgIHgxLCB5MSwgcG9pbnRzLCAwLCAwLCAxLCAxLCAwLCBkaXJlY3Rpb24pKSB7XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICB4MSwgeTIsIHBvaW50cywgMCwgMCwgMSwgMSwgMCwgZGlyZWN0aW9uKSkge1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgeDIsIHkyLCBwb2ludHMsIDAsIDAsIDEsIDEsIDAsIGRpcmVjdGlvbikpIHtcbiAgICAgICBcbiAgICAgIHJldHVybiB0cnVlOyBcbiAgICB9IGVsc2UgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgeDIsIHkxLCBwb2ludHMsIDAsIDAsIDEsIDEsIDAsIGRpcmVjdGlvbikpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgICovXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZSA9IGZ1bmN0aW9uKFxuICAgIHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgICBcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIHZhciBpbnRlcnNlY3Rpb247XG4gICAgXG4gICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdID0gYmFzZVBvaW50c1tpICogMl0gKiB3aWR0aCArIGNlbnRlclg7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gYmFzZVBvaW50c1tpICogMiArIDFdICogaGVpZ2h0ICsgY2VudGVyWTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHBvaW50cztcbiAgICBcbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSAkJC5tYXRoLmV4cGFuZFBvbHlnb24oXG4gICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzLFxuICAgICAgICAtcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHBvaW50cyA9ICQkLm1hdGguam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgICAvLyB2YXIgcG9pbnRzID0gdHJhbnNmb3JtZWRQb2ludHM7XG4gICAgXG4gICAgdmFyIGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgIFxuICAgICAgY3VycmVudFggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgY3VycmVudFkgPSBwb2ludHNbaSAqIDIgKyAxXTtcblxuICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC8gMiAtIDEpIHtcbiAgICAgICAgbmV4dFggPSBwb2ludHNbKGkgKyAxKSAqIDJdOyBcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbKGkgKyAxKSAqIDIgKyAxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWzBdOyBcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGludGVyc2VjdGlvbiA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIGN1cnJlbnRYLCBjdXJyZW50WSxcbiAgICAgICAgbmV4dFgsIG5leHRZKTtcbiAgICAgIFxuICAgICAgaWYgKGludGVyc2VjdGlvbi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaW50ZXJzZWN0aW9ucy5wdXNoKGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH07XG4gIFxuICAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihcbiAgICBpbnRlcnNlY3Rpb24sIG9mZnNldCwgYW1vdW50KSB7XG4gICAgXG4gICAgdmFyIGRpc3AgPSBbaW50ZXJzZWN0aW9uWzBdIC0gb2Zmc2V0WzBdLCBpbnRlcnNlY3Rpb25bMV0gLSBvZmZzZXRbMV1dO1xuICAgIFxuICAgIHZhciBsZW5ndGggPSBNYXRoLnNxcnQoZGlzcFswXSAqIGRpc3BbMF0gKyBkaXNwWzFdICogZGlzcFsxXSk7XG4gICAgXG4gICAgdmFyIGxlblJhdGlvID0gKGxlbmd0aCAtIGFtb3VudCkgLyBsZW5ndGg7XG4gICAgXG4gICAgaWYgKGxlblJhdGlvIDwgMCkge1xuICAgICAgbGVuUmF0aW8gPSAwLjAwMDAxO1xuICAgIH1cblxuICAgIHJldHVybiBbb2Zmc2V0WzBdICsgbGVuUmF0aW8gKiBkaXNwWzBdLCBvZmZzZXRbMV0gKyBsZW5SYXRpbyAqIGRpc3BbMV1dO1xuICB9O1xuXG4gICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlID0gZnVuY3Rpb24oc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICAgIHZhciBwb2ludHMgPSAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoc2lkZXMsIHJvdGF0aW9uUmFkaWFucyk7XG4gICAgcG9pbnRzID0gJCQubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUocG9pbnRzKTtcblxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgJCQubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUgPSBmdW5jdGlvbihwb2ludHMpe1xuICAgIHZhciB4LCB5O1xuICAgIHZhciBzaWRlcyA9IHBvaW50cy5sZW5ndGgvMjtcbiAgICB2YXIgbWluWCA9IEluZmluaXR5LCBtaW5ZID0gSW5maW5pdHksIG1heFggPSAtSW5maW5pdHksIG1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgIHggPSBwb2ludHNbMiAqIGldO1xuICAgICAgeSA9IHBvaW50c1syICogaSArIDFdO1xuXG4gICAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICAgIG1heFggPSBNYXRoLm1heCggbWF4WCwgeCApO1xuICAgICAgbWluWSA9IE1hdGgubWluKCBtaW5ZLCB5ICk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gc3RyZXRjaCBmYWN0b3JzXG4gICAgdmFyIHN4ID0gMiAvIChtYXhYIC0gbWluWCk7XG4gICAgdmFyIHN5ID0gMiAvIChtYXhZIC0gbWluWSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspe1xuICAgICAgeCA9IHBvaW50c1syICogaV0gPSBwb2ludHNbMiAqIGldICogc3g7XG4gICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSAqIHN5O1xuXG4gICAgICBtaW5YID0gTWF0aC5taW4oIG1pblgsIHggKTtcbiAgICAgIG1heFggPSBNYXRoLm1heCggbWF4WCwgeCApO1xuICAgICAgbWluWSA9IE1hdGgubWluKCBtaW5ZLCB5ICk7XG4gICAgICBtYXhZID0gTWF0aC5tYXgoIG1heFksIHkgKTtcbiAgICB9XG5cbiAgICBpZiggbWluWSA8IC0xICl7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspe1xuICAgICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBwb2ludHNbMiAqIGkgKyAxXSArICgtMSAtbWluWSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzID0gZnVuY3Rpb24oc2lkZXMsIHJvdGF0aW9uUmFkaWFucykge1xuICAgIFxuICAgIHZhciBpbmNyZW1lbnQgPSAxLjAgLyBzaWRlcyAqIDIgKiBNYXRoLlBJO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2lkZXMgJSAyID09PSAwID8gXG4gICAgICBNYXRoLlBJIC8gMi4wICsgaW5jcmVtZW50IC8gMi4wIDogTWF0aC5QSSAvIDIuMDtcbi8vICAgIGNvbnNvbGUubG9nKG5vZGVTaGFwZXNbJ3NxdWFyZSddKTtcbiAgICBzdGFydEFuZ2xlICs9IHJvdGF0aW9uUmFkaWFucztcbiAgICBcbiAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHNpZGVzICogMik7XG5cbiAgICB2YXIgY3VycmVudEFuZ2xlLCB4LCB5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKykge1xuICAgICAgY3VycmVudEFuZ2xlID0gaSAqIGluY3JlbWVudCArIHN0YXJ0QW5nbGU7XG4gICAgICBcbiAgICAgIHggPSBwb2ludHNbMiAqIGldID0gTWF0aC5jb3MoY3VycmVudEFuZ2xlKTsvLyAqICgxICsgaS8yKTtcbiAgICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXSA9IE1hdGguc2luKC1jdXJyZW50QW5nbGUpOy8vICAqICgxICsgaS8yKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfTtcblxuICAkJC5tYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgIFxuICAgIC8vIFNldCB0aGUgZGVmYXVsdCByYWRpdXMsIHVubGVzcyBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodCBpcyBzbWFsbGVyIHRoYW4gZGVmYXVsdFxuICAgIHJldHVybiBNYXRoLm1pbih3aWR0aCAvIDQsIGhlaWdodCAvIDQsIDgpO1xuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIHJlZ2lzdGVyZWQgZXh0ZW5zaW9ucyB0byBjeXRvc2NhcGUsIGluZGV4ZWQgYnkgbmFtZVxuICB2YXIgZXh0ZW5zaW9ucyA9IHt9O1xuICAkJC5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgXG4gIC8vIHJlZ2lzdGVyZWQgbW9kdWxlcyBmb3IgZXh0ZW5zaW9ucywgaW5kZXhlZCBieSBuYW1lXG4gIHZhciBtb2R1bGVzID0ge307XG4gICQkLm1vZHVsZXMgPSBtb2R1bGVzO1xuICBcbiAgZnVuY3Rpb24gc2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUsIHJlZ2lzdHJhbnQpe1xuICAgIHZhciBpbXBsID0ge307XG4gICAgaW1wbFtuYW1lXSA9IHJlZ2lzdHJhbnQ7XG4gICAgXG4gICAgc3dpdGNoKCB0eXBlICl7XG4gICAgY2FzZSAnY29yZSc6XG4gICAgY2FzZSAnY29sbGVjdGlvbic6XG4gICAgICAkJC5mblt0eXBlXSggaW1wbCApO1xuICAgIH1cbiAgICBcbiAgICAvLyBmaWxsIGluIG1pc3NpbmcgbGF5b3V0IGZ1bmN0aW9ucyBpbiB0aGUgcHJvdG90eXBlXG4gICAgaWYoIHR5cGUgPT09ICdsYXlvdXQnICl7XG4gICAgICB2YXIgbGF5b3V0UHJvdG8gPSByZWdpc3RyYW50LnByb3RvdHlwZTtcbiAgICAgIHZhciBvcHRMYXlvdXRGbnMgPSBbJ3N0b3AnXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRMYXlvdXRGbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZuTmFtZSA9IG9wdExheW91dEZuc1tpXTtcblxuICAgICAgICBsYXlvdXRQcm90b1tmbk5hbWVdID0gbGF5b3V0UHJvdG9bZm5OYW1lXSB8fCBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZWl0aGVyIC5zdGFydCgpIG9yIC5ydW4oKSBpcyBkZWZpbmVkLCBzbyBhdXRvZ2VuIHRoZSBvdGhlclxuICAgICAgaWYoIGxheW91dFByb3RvLnN0YXJ0ICYmICFsYXlvdXRQcm90by5ydW4gKXtcbiAgICAgICAgbGF5b3V0UHJvdG8ucnVuID0gZnVuY3Rpb24oKXsgdGhpcy5zdGFydCgpOyByZXR1cm4gdGhpczsgfTtcbiAgICAgIH0gZWxzZSBpZiggIWxheW91dFByb3RvLnN0YXJ0ICYmIGxheW91dFByb3RvLnJ1biApe1xuICAgICAgICBsYXlvdXRQcm90by5zdGFydCA9IGZ1bmN0aW9uKCl7IHRoaXMucnVuKCk7IHJldHVybiB0aGlzOyB9O1xuICAgICAgfVxuXG4gICAgICBsYXlvdXRQcm90by5vbiA9ICQkLmRlZmluZS5vbih7IGxheW91dDogdHJ1ZSB9KTtcbiAgICAgIGxheW91dFByb3RvLm9uZSA9ICQkLmRlZmluZS5vbih7IGxheW91dDogdHJ1ZSwgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9KTtcbiAgICAgIGxheW91dFByb3RvLm9uY2UgPSAkJC5kZWZpbmUub24oeyBsYXlvdXQ6IHRydWUsIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHRydWUgfSk7XG4gICAgICBsYXlvdXRQcm90by5vZmYgPSAkJC5kZWZpbmUub2ZmKHsgbGF5b3V0OiB0cnVlIH0pO1xuICAgICAgbGF5b3V0UHJvdG8udHJpZ2dlciA9ICQkLmRlZmluZS50cmlnZ2VyKHsgbGF5b3V0OiB0cnVlIH0pO1xuXG4gICAgICAvLyBhbGlhc2VzIGZvciB0aG9zZSBmb2xrcyB3aG8gbGlrZSBvbGQgc3R1ZmY6XG4gICAgICBsYXlvdXRQcm90by5iaW5kID0gbGF5b3V0UHJvdG8ub247XG4gICAgICBsYXlvdXRQcm90by51bmJpbmQgPSBsYXlvdXRQcm90by5vZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuICQkLnV0aWwuc2V0TWFwKHtcbiAgICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICAgIGtleXM6IFsgdHlwZSwgbmFtZSBdLFxuICAgICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgICB9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKHR5cGUsIG5hbWUpe1xuICAgIHJldHVybiAkJC51dGlsLmdldE1hcCh7XG4gICAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAgICBrZXlzOiBbIHR5cGUsIG5hbWUgXVxuICAgIH0pO1xuICB9XG4gIFxuICBmdW5jdGlvbiBzZXRNb2R1bGUodHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSwgcmVnaXN0cmFudCl7XG4gICAgcmV0dXJuICQkLnV0aWwuc2V0TWFwKHtcbiAgICAgIG1hcDogbW9kdWxlcyxcbiAgICAgIGtleXM6IFsgdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSBdLFxuICAgICAgdmFsdWU6IHJlZ2lzdHJhbnRcbiAgICB9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gZ2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUpe1xuICAgIHJldHVybiAkJC51dGlsLmdldE1hcCh7XG4gICAgICBtYXA6IG1vZHVsZXMsXG4gICAgICBrZXlzOiBbIHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUgXVxuICAgIH0pO1xuICB9XG4gIFxuICAkJC5leHRlbnNpb24gPSBmdW5jdGlvbigpe1xuICAgIC8vIGUuZy4gJCQuZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnKVxuICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoID09IDIgKXtcbiAgICAgIHJldHVybiBnZXRFeHRlbnNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gZS5nLiAkJC5leHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsIHsgLi4uIH0pXG4gICAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PSAzICl7XG4gICAgICByZXR1cm4gc2V0RXh0ZW5zaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFxuICAgIC8vIGUuZy4gJCQuZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnKVxuICAgIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT0gNCApe1xuICAgICAgcmV0dXJuIGdldE1vZHVsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBlLmcuICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJywgeyAuLi4gfSlcbiAgICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09IDUgKXtcbiAgICAgIHJldHVybiBzZXRNb2R1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgXG4gICAgZWxzZSB7XG4gICAgICAkJC51dGlsLmVycm9yKCdJbnZhbGlkIGV4dGVuc2lvbiBhY2Nlc3Mgc3ludGF4Jyk7XG4gICAgfVxuICBcbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCwgJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICBpZiggISQgKXsgcmV0dXJuOyB9IC8vIG5vIGpxdWVyeSA9PiBkb24ndCBuZWVkIHRoaXNcblxuICB2YXIgY3lSZWcgPSBmdW5jdGlvbiggJGVsZSApe1xuICAgIHZhciBkID0gJGVsZVswXS5fY3lyZWcgPSAkZWxlWzBdLl9jeXJlZyB8fCB7fTtcblxuICAgIHJldHVybiBkO1xuICB9O1xuXG4gIC8vIGFsbG93IGNhbGxzIG9uIGEgalF1ZXJ5IHNlbGVjdG9yIGJ5IHByb3h5aW5nIGNhbGxzIHRvICQuY3l0b3NjYXBlXG4gIC8vIGUuZy4gJChcIiNmb29cIikuY3l0b3NjYXBlKG9wdGlvbnMpID0+ICQuY3l0b3NjYXBlKG9wdGlvbnMpIG9uICNmb29cbiAgJC5mbi5jeXRvc2NhcGUgPSBmdW5jdGlvbihvcHRzKXtcbiAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXG4gICAgLy8gZ2V0IG9iamVjdFxuICAgIGlmKCBvcHRzID09PSAnZ2V0JyApe1xuICAgICAgcmV0dXJuIGN5UmVnKCAkdGhpcyApLmN5O1xuICAgIH1cbiAgICBcbiAgICAvLyBiaW5kIHRvIHJlYWR5XG4gICAgZWxzZSBpZiggJCQuaXMuZm4ob3B0cykgKXtcblxuICAgICAgdmFyIHJlYWR5ID0gb3B0cztcbiAgICAgIHZhciBjeSA9IGN5UmVnKCAkdGhpcyApLmN5O1xuICAgICAgXG4gICAgICBpZiggY3kgJiYgY3kuaXNSZWFkeSgpICl7IC8vIGFscmVhZHkgcmVhZHkgc28ganVzdCB0cmlnZ2VyIG5vd1xuICAgICAgICBjeS50cmlnZ2VyKCdyZWFkeScsIFtdLCByZWFkeSk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIG5vdCB5ZXQgcmVhZHksIHNvIGFkZCB0byByZWFkaWVzIGxpc3RcbiAgICAgICAgdmFyIGRhdGEgPSBjeVJlZyggJHRoaXMgKTtcbiAgICAgICAgdmFyIHJlYWRpZXMgPSBkYXRhLnJlYWRpZXMgPSBkYXRhLnJlYWRpZXMgfHwgW107XG5cbiAgICAgICAgcmVhZGllcy5wdXNoKCByZWFkeSApO1xuICAgICAgfSBcbiAgICAgIFxuICAgIH1cbiAgICBcbiAgICAvLyBwcm94eSB0byBjcmVhdGUgaW5zdGFuY2VcbiAgICBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdChvcHRzKSApe1xuICAgICAgcmV0dXJuICR0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgb3B0cywge1xuICAgICAgICAgIGNvbnRhaW5lcjogJCh0aGlzKVswXVxuICAgICAgICB9KTtcbiAgICAgIFxuICAgICAgICBjeXRvc2NhcGUob3B0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBhbGxvdyBhY2Nlc3MgdG8gdGhlIGdsb2JhbCBjeXRvc2NhcGUgb2JqZWN0IHVuZGVyIGpxdWVyeSBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgJC5jeXRvc2NhcGUgPSBjeXRvc2NhcGU7XG4gIFxuICAvLyB1c2Ugc2hvcnQgYWxpYXMgKGN5KSBpZiBub3QgYWxyZWFkeSBkZWZpbmVkXG4gIGlmKCAkLmZuLmN5ID09IG51bGwgJiYgJC5jeSA9PSBudWxsICl7XG4gICAgJC5mbi5jeSA9ICQuZm4uY3l0b3NjYXBlO1xuICAgICQuY3kgPSAkLmN5dG9zY2FwZTtcbiAgfVxuICBcbn0pKHR5cGVvZiBqUXVlcnkgIT09ICd1bmRlZmluZWQnID8galF1ZXJ5IDogbnVsbCAsIGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyBzaGFtZWxlc3NseSB0YWtlbiBmcm9tIGpRdWVyeVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL21hc3Rlci9zcmMvZXZlbnQuanNcblxuICAkJC5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuICAgIC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuICAgIGlmICggISh0aGlzIGluc3RhbmNlb2YgJCQuRXZlbnQpICkge1xuICAgICAgcmV0dXJuIG5ldyAkJC5FdmVudCggc3JjLCBwcm9wcyApO1xuICAgIH1cblxuICAgIC8vIEV2ZW50IG9iamVjdFxuICAgIGlmICggc3JjICYmIHNyYy50eXBlICkge1xuICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gc3JjO1xuICAgICAgdGhpcy50eXBlID0gc3JjLnR5cGU7XG5cbiAgICAgIC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG4gICAgICAvLyBieSBhIGhhbmRsZXIgbG93ZXIgZG93biB0aGUgdHJlZTsgcmVmbGVjdCB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gKCBzcmMuZGVmYXVsdFByZXZlbnRlZCApID8gcmV0dXJuVHJ1ZSA6IHJldHVybkZhbHNlO1xuXG4gICAgLy8gRXZlbnQgdHlwZVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnR5cGUgPSBzcmM7XG4gICAgfVxuXG4gICAgLy8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3RcbiAgICBpZiAoIHByb3BzICkge1xuICAgICAgLy8gJCQudXRpbC5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cbiAgICAgIC8vIG1vcmUgZWZmaWNpZW50IHRvIG1hbnVhbGx5IGNvcHkgZmllbGRzIHdlIHVzZVxuICAgICAgdGhpcy50eXBlID0gcHJvcHMudHlwZSAhPT0gdW5kZWZpbmVkID8gcHJvcHMudHlwZSA6IHRoaXMudHlwZTtcbiAgICAgIHRoaXMuY3kgPSBwcm9wcy5jeTtcbiAgICAgIHRoaXMuY3lUYXJnZXQgPSBwcm9wcy5jeVRhcmdldDtcbiAgICAgIHRoaXMuY3lQb3NpdGlvbiA9IHByb3BzLmN5UG9zaXRpb247XG4gICAgICB0aGlzLmN5UmVuZGVyZWRQb3NpdGlvbiA9IHByb3BzLmN5UmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgIHRoaXMubmFtZXNwYWNlID0gcHJvcHMubmFtZXNwYWNlO1xuICAgICAgdGhpcy5sYXlvdXQgPSBwcm9wcy5sYXlvdXQ7XG4gICAgICB0aGlzLmRhdGEgPSBwcm9wcy5kYXRhO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG4gICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCArbmV3IERhdGUoKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAgJCQuRXZlbnQucHJvdG90eXBlID0ge1xuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICBpZiAoICFlICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgICBpZiAoIGUucHJldmVudERlZmF1bHQgKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICBpZiAoICFlICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICAgIGlmICggZS5zdG9wUHJvcGFnYXRpb24gKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG4gICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG4gIH07XG4gIFxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyB1c2UgdGhpcyBtb2R1bGUgdG8gY2hlcnJ5IHBpY2sgZnVuY3Rpb25zIGludG8geW91ciBwcm90b3R5cGVcbiAgLy8gKHVzZWZ1bCBmb3IgZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIHRoZSBjb3JlIGFuZCBjb2xsZWN0aW9ucywgZm9yIGV4YW1wbGUpXG5cbiAgLy8gZS5nLlxuICAvLyAkJC5mbi5jb2xsZWN0aW9uKHtcbiAgLy8gICBmb286ICQkLmRlZmluZS5mb28oeyAvKiBwYXJhbXMuLi4gKi8gfSlcbiAgLy8gfSk7XG5cbiAgJCQuZGVmaW5lID0ge1xuXG4gICAgLy8gYWNjZXNzIGRhdGEgZmllbGRcbiAgICBkYXRhOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7IFxuICAgICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgICAgYWxsb3dTZXR0aW5nOiBmYWxzZSxcbiAgICAgICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgICBpbW11dGFibGVLZXlzOiB7fSwgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZSxcbiAgICAgICAgb25TZXQ6IGZ1bmN0aW9uKCBzZWxmICl7fSxcbiAgICAgICAgY2FuU2V0OiBmdW5jdGlvbiggc2VsZiApeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGFJbXBsKCBuYW1lLCB2YWx1ZSApe1xuICAgICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgc2luZ2xlID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZlswXSA6IHNlbGY7XG5cbiAgICAgICAgLy8gLmRhdGEoJ2ZvbycsIC4uLilcbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApeyAvLyBzZXQgb3IgZ2V0IHByb3BlcnR5XG5cbiAgICAgICAgICAvLyAuZGF0YSgnZm9vJylcbiAgICAgICAgICBpZiggcC5hbGxvd0dldHRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApeyAvLyBnZXRcblxuICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgIGlmKCBzaW5nbGUgKXtcbiAgICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gLmRhdGEoJ2ZvbycsICdiYXInKVxuICAgICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHsgLy8gc2V0XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW25hbWVdO1xuICAgICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICAgICAgICAgIGlmKCBwLmNhblNldCggYWxsW2ldICkgKXtcbiAgICAgICAgICAgICAgICAgIGFsbFtpXS5fcHJpdmF0ZVsgcC5maWVsZCBdWyBuYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgICAgICAgIHAub25TZXQoIHNlbGYgKTtcblxuICAgICAgICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLnNldHRpbmdFdmVudCApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIC5kYXRhKHsgJ2Zvbyc6ICdiYXInIH0pXG4gICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgJCQuaXMucGxhaW5PYmplY3QobmFtZSkgKXsgLy8gZXh0ZW5kXG4gICAgICAgICAgdmFyIG9iaiA9IG5hbWU7XG4gICAgICAgICAgdmFyIGssIHY7XG5cbiAgICAgICAgICBmb3IoIGsgaW4gb2JqICl7XG4gICAgICAgICAgICB2ID0gb2JqWyBrIF07XG5cbiAgICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNba107XG4gICAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICAgICAgICAgICAgaWYoIHAuY2FuU2V0KCBhbGxbaV0gKSApe1xuICAgICAgICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlWyBwLmZpZWxkIF1bIGsgXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgICAgaWYoIHAudXBkYXRlU3R5bGUgKXsgc2VsZi51cGRhdGVTdHlsZSgpOyB9XG5cbiAgICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgICAgcC5vblNldCggc2VsZiApO1xuXG4gICAgICAgICAgaWYoIHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQgKXtcbiAgICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLnNldHRpbmdFdmVudCApO1xuICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIC5kYXRhKGZ1bmN0aW9uKCl7IC4uLiB9KVxuICAgICAgICB9IGVsc2UgaWYoIHAuYWxsb3dCaW5kaW5nICYmICQkLmlzLmZuKG5hbWUpICl7IC8vIGJpbmQgdG8gZXZlbnRcbiAgICAgICAgICB2YXIgZm4gPSBuYW1lO1xuICAgICAgICAgIHNlbGYuYmluZCggcC5iaW5kaW5nRXZlbnQsIGZuICk7XG4gICAgICAgIFxuICAgICAgICAvLyAuZGF0YSgpXG4gICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkICl7IC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgIGlmKCBzaW5nbGUgKXtcbiAgICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluYWJpbGl0eVxuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyBkYXRhXG5cbiAgICAvLyByZW1vdmUgZGF0YSBmaWVsZFxuICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHsgXG4gICAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgICAgaW1tdXRhYmxlS2V5czoge30gLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB9O1xuICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlRGF0YUltcGwoIG5hbWVzICl7XG4gICAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIFxuICAgICAgICAvLyAucmVtb3ZlRGF0YSgnZm9vIGJhcicpXG4gICAgICAgIGlmKCAkJC5pcy5zdHJpbmcobmFtZXMpICl7IC8vIHRoZW4gZ2V0IHRoZSBsaXN0IG9mIGtleXMsIGFuZCBkZWxldGUgdGhlbVxuICAgICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsOyBpKysgKXsgLy8gZGVsZXRlIGVhY2ggbm9uLWVtcHR5IGtleVxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoa2V5KSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzWyBrZXkgXTsgLy8gbm90IHZhbGlkIGlmIGltbXV0YWJsZVxuICAgICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICAgIGZvciggdmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKysgKXtcbiAgICAgICAgICAgICAgICBhbGxbIGlfYSBdLl9wcml2YXRlWyBwLmZpZWxkIF1bIGtleSBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5ldmVudCApO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyAucmVtb3ZlRGF0YSgpXG4gICAgICAgIH0gZWxzZSBpZiggbmFtZXMgPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIGRlbGV0ZSBhbGwga2V5c1xuXG4gICAgICAgICAgZm9yKCB2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKyApe1xuICAgICAgICAgICAgdmFyIF9wcml2YXRlRmllbGRzID0gYWxsWyBpX2EgXS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IoIHZhciBrZXkgaW4gX3ByaXZhdGVGaWVsZHMgKXtcbiAgICAgICAgICAgICAgdmFyIHZhbGlkS2V5VG9EZWxldGUgPSAhcC5pbW11dGFibGVLZXlzWyBrZXkgXTtcblxuICAgICAgICAgICAgICBpZiggdmFsaWRLZXlUb0RlbGV0ZSApe1xuICAgICAgICAgICAgICAgIF9wcml2YXRlRmllbGRzWyBrZXkgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBwLnRyaWdnZXJFdmVudCApe1xuICAgICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuZXZlbnQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSwgLy8gcmVtb3ZlRGF0YVxuXG4gICAgLy8gZXZlbnQgZnVuY3Rpb24gcmV1c2FibGUgc3R1ZmZcbiAgICBldmVudDoge1xuICAgICAgcmVnZXg6IC8oXFx3KykoXFwuXFx3Kyk/LywgLy8gcmVnZXggZm9yIG1hdGNoaW5nIGV2ZW50IHN0cmluZ3MgKGUuZy4gXCJjbGljay5uYW1lc3BhY2VcIilcbiAgICAgIG9wdGlvbmFsVHlwZVJlZ2V4OiAvKFxcdyspPyhcXC5cXHcrKT8vLFxuICAgICAgZmFsc2VDYWxsYmFjazogZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSxcblxuICAgIC8vIGV2ZW50IGJpbmRpbmdcbiAgICBvbjogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICB1bmJpbmRTZWxmT25UcmlnZ2VyOiBmYWxzZSxcbiAgICAgICAgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogZmFsc2VcbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgICBcbiAgICAgIHJldHVybiBmdW5jdGlvbiBvbkltcGwoZXZlbnRzLCBzZWxlY3RvciwgZGF0YSwgY2FsbGJhY2spe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBldmVudHNJc1N0cmluZyA9ICQkLmlzLnN0cmluZyhldmVudHMpO1xuICAgICAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3Qoc2VsZWN0b3IpICl7IC8vIHNlbGVjdG9yIGlzIGFjdHVhbGx5IGRhdGFcbiAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgICAgZGF0YSA9IHNlbGVjdG9yO1xuICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLmZuKHNlbGVjdG9yKSB8fCBzZWxlY3RvciA9PT0gZmFsc2UgKXsgLy8gc2VsZWN0b3IgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggJCQuaXMuZm4oZGF0YSkgfHwgZGF0YSA9PT0gZmFsc2UgKXsgLy8gZGF0YSBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXNuJ3QgYSBjYWxsYmFjaywgd2UgY2FuJ3QgcmVhbGx5IGRvIGFueXRoaW5nXG4gICAgICAgIC8vIChjYW4ndCBzcGVhayBmb3IgbWFwcGVkIGV2ZW50cyBhcmcgdmVyc2lvbilcbiAgICAgICAgaWYoICEoJCQuaXMuZm4oY2FsbGJhY2spIHx8IGNhbGxiYWNrID09PSBmYWxzZSkgJiYgZXZlbnRzSXNTdHJpbmcgKXtcbiAgICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBldmVudHNJc1N0cmluZyApeyAvLyB0aGVuIGNvbnZlcnQgdG8gbWFwXG4gICAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICAgIG1hcFsgZXZlbnRzIF0gPSBjYWxsYmFjaztcbiAgICAgICAgICBldmVudHMgPSBtYXA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBldnRzIGluIGV2ZW50cyApe1xuICAgICAgICAgIGNhbGxiYWNrID0gZXZlbnRzW2V2dHNdO1xuICAgICAgICAgIGlmKCBjYWxsYmFjayA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gJCQuZGVmaW5lLmV2ZW50LmZhbHNlQ2FsbGJhY2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICEkJC5pcy5mbihjYWxsYmFjaykgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1tpXTtcbiAgICAgICAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhldnQpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaCggJCQuZGVmaW5lLmV2ZW50LnJlZ2V4ICk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgICAgICAgICAgaWYoIG1hdGNoICl7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssIC8vIGNhbGxiYWNrIHRvIHJ1blxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsIC8vIGV4dHJhIGRhdGEgaW4gZXZlbnRPYmouZGF0YVxuICAgICAgICAgICAgICAgIGRlbGVnYXRlZDogc2VsZWN0b3IgPyB0cnVlIDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGV2dCBpcyBkZWxlZ2F0ZWRcbiAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsIC8vIHRoZSBzZWxlY3RvciB0byBtYXRjaCBmb3IgZGVsZWdhdGVkIGV2ZW50c1xuICAgICAgICAgICAgICAgIHNlbE9iajogbmV3ICQkLlNlbGVjdG9yKHNlbGVjdG9yKSwgLy8gY2FjaGVkIHNlbGVjdG9yIG9iamVjdCB0byBzYXZlIHJlYnVpbGRpbmdcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLCAvLyB0aGUgZXZlbnQgdHlwZSAoZS5nLiAnY2xpY2snKVxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLCAvLyB0aGUgZXZlbnQgbmFtZXNwYWNlIChlLmcuIFwiLmZvb1wiKVxuICAgICAgICAgICAgICAgIHVuYmluZFNlbGZPblRyaWdnZXI6IHAudW5iaW5kU2VsZk9uVHJpZ2dlcixcbiAgICAgICAgICAgICAgICB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiBwLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIsXG4gICAgICAgICAgICAgICAgYmluZGVyczogYWxsIC8vIHdobyBib3VuZCB0b2dldGhlclxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICAgICAgYWxsW2pdLl9wcml2YXRlLmxpc3RlbmVycy5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBmb3IgZXZlbnRzIGFycmF5XG4gICAgICAgIH0gLy8gZm9yIGV2ZW50cyBtYXBcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyBvblxuXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmZJbXBsKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgICBcbiAgICAgIHJldHVybiBmdW5jdGlvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjayl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gJCQuaXMuc3RyaW5nKGV2ZW50cyk7XG5cbiAgICAgICAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgKXsgLy8gdGhlbiB1bmJpbmQgYWxsXG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICQkLmlzLmZuKHNlbGVjdG9yKSB8fCBzZWxlY3RvciA9PT0gZmFsc2UgKXsgLy8gc2VsZWN0b3IgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gY29udmVydCB0byBtYXBcbiAgICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgICAgbWFwWyBldmVudHMgXSA9IGNhbGxiYWNrO1xuICAgICAgICAgIGV2ZW50cyA9IG1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGV2dHMgaW4gZXZlbnRzICl7XG4gICAgICAgICAgY2FsbGJhY2sgPSBldmVudHNbZXZ0c107XG5cbiAgICAgICAgICBpZiggY2FsbGJhY2sgPT09IGZhbHNlICl7XG4gICAgICAgICAgICBjYWxsYmFjayA9ICQkLmRlZmluZS5ldmVudC5mYWxzZUNhbGxiYWNrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgZm9yKCB2YXIgaCA9IDA7IGggPCBldnRzLmxlbmd0aDsgaCsrICl7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1toXTtcbiAgICAgICAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhldnQpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaCggJCQuZGVmaW5lLmV2ZW50Lm9wdGlvbmFsVHlwZVJlZ2V4ICk7IC8vIFt0eXBlXVsubmFtZXNwYWNlXVxuICAgICAgICAgICAgaWYoIG1hdGNoICl7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV0gPyBtYXRjaFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXsgLy9cbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycztcblxuICAgICAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbGlzdGVuZXJzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbal07XG4gICAgICAgICAgICAgICAgICB2YXIgbnNNYXRjaGVzID0gIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT09IGxpc3RlbmVyLm5hbWVzcGFjZTtcbiAgICAgICAgICAgICAgICAgIHZhciB0eXBlTWF0Y2hlcyA9ICF0eXBlIHx8IGxpc3RlbmVyLnR5cGUgPT09IHR5cGU7XG4gICAgICAgICAgICAgICAgICB2YXIgY2JNYXRjaGVzID0gIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09PSBsaXN0ZW5lci5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lck1hdGNoZXMgPSBuc01hdGNoZXMgJiYgdHlwZU1hdGNoZXMgJiYgY2JNYXRjaGVzO1xuXG4gICAgICAgICAgICAgICAgICAvLyBkZWxldGUgbGlzdGVuZXIgaWYgaXQgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgaWYoIGxpc3RlbmVyTWF0Y2hlcyApe1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBmb3IgbGlzdGVuZXJzXG4gICAgICAgICAgICAgIH0gLy8gZm9yIGFsbFxuICAgICAgICAgICAgfSAvLyBpZiBtYXRjaFxuICAgICAgICAgIH0gLy8gZm9yIGV2ZW50cyBhcnJheVxuXG4gICAgICAgIH0gLy8gZm9yIGV2ZW50cyBtYXBcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyBvZmZcblxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gZnVuY3Rpb24gdHJpZ2dlckltcGwoZXZlbnRzLCBleHRyYVBhcmFtcywgZm5Ub1RyaWdnZXIpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBldmVudHNJc1N0cmluZyA9ICQkLmlzLnN0cmluZyhldmVudHMpO1xuICAgICAgICB2YXIgZXZlbnRzSXNPYmplY3QgPSAkJC5pcy5wbGFpbk9iamVjdChldmVudHMpO1xuICAgICAgICB2YXIgZXZlbnRzSXNFdmVudCA9ICQkLmlzLmV2ZW50KGV2ZW50cyk7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcbiAgICAgICAgdmFyIGhhc0NvbXBvdW5kcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBtYWtlIGEgcGxhaW4gZXZlbnQgb2JqZWN0IGZvciBlYWNoIGV2ZW50IG5hbWVcbiAgICAgICAgICB2YXIgZXZ0cyA9IGV2ZW50cy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIGV2ZW50cyA9IFtdO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1tpXTtcbiAgICAgICAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhldnQpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaCggJCQuZGVmaW5lLmV2ZW50LnJlZ2V4ICk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cbiAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgZXZlbnRzLnB1c2goIHtcbiAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggZXZlbnRzSXNPYmplY3QgKXsgLy8gcHV0IGluIGxlbmd0aCAxIGFycmF5XG4gICAgICAgICAgdmFyIGV2ZW50QXJnT2JqID0gZXZlbnRzO1xuXG4gICAgICAgICAgZXZlbnRzID0gWyBldmVudEFyZ09iaiBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGV4dHJhUGFyYW1zICl7XG4gICAgICAgICAgaWYoICEkJC5pcy5hcnJheShleHRyYVBhcmFtcykgKXsgLy8gbWFrZSBzdXJlIGV4dHJhIHBhcmFtcyBhcmUgaW4gYW4gYXJyYXkgaWYgc3BlY2lmaWVkXG4gICAgICAgICAgICBleHRyYVBhcmFtcyA9IFsgZXh0cmFQYXJhbXMgXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSwgd2UndmUgZ290IG5vdGhpbmdcbiAgICAgICAgICBleHRyYVBhcmFtcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKysgKXsgLy8gdHJpZ2dlciBlYWNoIGV2ZW50IGluIG9yZGVyXG4gICAgICAgICAgdmFyIGV2dE9iaiA9IGV2ZW50c1tpXTtcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGFsbC5sZW5ndGg7IGorKyApeyAvLyBmb3IgZWFjaFxuICAgICAgICAgICAgdmFyIHRyaWdnZXJlciA9IGFsbFtqXTtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0cmlnZ2VyZXIuX3ByaXZhdGUubGlzdGVuZXJzO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJlcklzRWxlbWVudCA9ICQkLmlzLmVsZW1lbnQodHJpZ2dlcmVyKTtcbiAgICAgICAgICAgIHZhciBidWJibGVVcCA9IHRyaWdnZXJlcklzRWxlbWVudCB8fCBwYXJhbXMubGF5b3V0O1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGV2ZW50IGZvciB0aGlzIGVsZW1lbnQgZnJvbSB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICB2YXIgZXZ0O1xuXG4gICAgICAgICAgICBpZiggZXZlbnRzSXNFdmVudCApeyAvLyB0aGVuIGp1c3QgZ2V0IHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgZXZ0ID0gZXZ0T2JqO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZXZ0LmN5VGFyZ2V0ID0gZXZ0LmN5VGFyZ2V0IHx8IHRyaWdnZXJlcjtcbiAgICAgICAgICAgICAgZXZ0LmN5ID0gZXZ0LmN5IHx8IGN5O1xuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHdlIGhhdmUgdG8gbWFrZSBvbmVcbiAgICAgICAgICAgICAgZXZ0ID0gbmV3ICQkLkV2ZW50KCBldnRPYmosIHtcbiAgICAgICAgICAgICAgICBjeVRhcmdldDogdHJpZ2dlcmVyLFxuICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dE9iai5uYW1lc3BhY2VcbiAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhIGxheW91dCB3YXMgc3BlY2lmaWVkLCB0aGVuIHB1dCBpdCBpbiB0aGUgdHlwZWQgZXZlbnRcbiAgICAgICAgICAgIGlmKCBldnRPYmoubGF5b3V0ICl7XG4gICAgICAgICAgICAgIGV2dC5sYXlvdXQgPSBldnRPYmoubGF5b3V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0cmlnZ2VyZWQgYnkgbGF5b3V0LCBwdXQgaW4gZXZlbnRcbiAgICAgICAgICAgIGlmKCBwYXJhbXMubGF5b3V0ICl7XG4gICAgICAgICAgICAgIGV2dC5sYXlvdXQgPSB0cmlnZ2VyZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHJlbmRlcmVkIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBwYXNzZWQgcG9zaXRpb25cbiAgICAgICAgICAgIGlmKCBldnQuY3lQb3NpdGlvbiApe1xuICAgICAgICAgICAgICB2YXIgcG9zID0gZXZ0LmN5UG9zaXRpb247XG4gICAgICAgICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG5cbiAgICAgICAgICAgICAgZXZ0LmN5UmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgICAgICAgICB5OiBwb3MueSAqIHpvb20gKyBwYW4ueVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggZm5Ub1RyaWdnZXIgKXsgLy8gdGhlbiBvdmVycmlkZSB0aGUgbGlzdGVuZXJzIGxpc3Qgd2l0aCBqdXN0IHRoZSBvbmUgd2Ugc3BlY2lmaWVkXG4gICAgICAgICAgICAgIGxpc3RlbmVycyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBldnQubmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IGV2dC50eXBlLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmblRvVHJpZ2dlclxuICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBsaXN0ZW5lcnMubGVuZ3RoOyBrKysgKXsgLy8gY2hlY2sgZWFjaCBsaXN0ZW5lclxuICAgICAgICAgICAgICB2YXIgbGlzID0gbGlzdGVuZXJzW2tdO1xuICAgICAgICAgICAgICB2YXIgbnNNYXRjaGVzID0gIWxpcy5uYW1lc3BhY2UgfHwgbGlzLm5hbWVzcGFjZSA9PT0gZXZ0Lm5hbWVzcGFjZTtcbiAgICAgICAgICAgICAgdmFyIHR5cGVNYXRjaGVzID0gbGlzLnR5cGUgPT09IGV2dC50eXBlO1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0TWF0Y2hlcyA9IGxpcy5kZWxlZ2F0ZWQgPyAoIHRyaWdnZXJlciAhPT0gZXZ0LmN5VGFyZ2V0ICYmICQkLmlzLmVsZW1lbnQoZXZ0LmN5VGFyZ2V0KSAmJiBsaXMuc2VsT2JqLm1hdGNoZXMoZXZ0LmN5VGFyZ2V0KSApIDogKHRydWUpOyAvLyB3ZSdyZSBub3QgZ29pbmcgdG8gdmFsaWRhdGUgdGhlIGhpZXJhcmNoeTsgdGhhdCdzIHRvbyBleHBlbnNpdmVcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyTWF0Y2hlcyA9IG5zTWF0Y2hlcyAmJiB0eXBlTWF0Y2hlcyAmJiB0YXJnZXRNYXRjaGVzO1xuXG4gICAgICAgICAgICAgIGlmKCBsaXN0ZW5lck1hdGNoZXMgKXsgLy8gdGhlbiB0cmlnZ2VyIGl0XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbIGV2dCBdO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdCggZXh0cmFQYXJhbXMgKTsgLy8gYWRkIGV4dHJhIHBhcmFtcyB0byBhcmdzIGxpc3RcblxuICAgICAgICAgICAgICAgIGlmKCBsaXMuZGF0YSApeyAvLyBhZGQgb24gZGF0YSBwbHVnZ2VkIGludG8gYmluZGluZ1xuICAgICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSBsaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBvciBjbGVhciBpdCBpbiBjYXNlIHRoZSBldmVudCBvYmogaXMgcmV1c2VkXG4gICAgICAgICAgICAgICAgICBldnQuZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiggbGlzLnVuYmluZFNlbGZPblRyaWdnZXIgfHwgbGlzLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIgKXsgLy8gdGhlbiByZW1vdmUgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIGxpcy51bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyICl7IC8vIHRoZW4gZGVsZXRlIHRoZSBsaXN0ZW5lciBmb3IgYWxsIGJpbmRlcnNcbiAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXJzID0gbGlzLmJpbmRlcnM7XG4gICAgICAgICAgICAgICAgICBmb3IoIHZhciBsID0gMDsgbCA8IGJpbmRlcnMubGVuZ3RoOyBsKysgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlciA9IGJpbmRlcnNbbF07XG4gICAgICAgICAgICAgICAgICAgIGlmKCAhYmluZGVyIHx8IGJpbmRlciA9PT0gdHJpZ2dlcmVyICl7IGNvbnRpbnVlOyB9IC8vIGFscmVhZHkgaGFuZGxlZCB0cmlnZ2VyZXIgb3Igd2UgY2FuJ3QgaGFuZGxlIGl0XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlckxpc3RlbmVycyA9IGJpbmRlci5fcHJpdmF0ZS5saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciggdmFyIG0gPSAwOyBtIDwgYmluZGVyTGlzdGVuZXJzLmxlbmd0aDsgbSsrICl7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlckxpc3RlbmVyID0gYmluZGVyTGlzdGVuZXJzW21dO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYoIGJpbmRlckxpc3RlbmVyID09PSBsaXMgKXsgLy8gZGVsZXRlIGxpc3RlbmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGVyTGlzdGVuZXJzLnNwbGljZShtLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0tLTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBsaXMuZGVsZWdhdGVkID8gZXZ0LmN5VGFyZ2V0IDogdHJpZ2dlcmVyO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBsaXMuY2FsbGJhY2suYXBwbHkoIGNvbnRleHQsIGFyZ3MgKTtcblxuICAgICAgICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlIHx8IGV2dC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICl7XG4gICAgICAgICAgICAgICAgICAvLyB0aGVuIGRvbid0IGJ1YmJsZVxuICAgICAgICAgICAgICAgICAgYnViYmxlVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlIGlzIGEgc2hvcnRoYW5kIGZvciBzdG9wcGluZyBwcm9wYWdhdGlvbiBhbmQgcHJldmVudGluZyB0aGUgZGVmLiBhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gaWYgbGlzdGVuZXIgbWF0Y2hlc1xuICAgICAgICAgICAgfSAvLyBmb3IgZWFjaCBsaXN0ZW5lclxuXG4gICAgICAgICAgICAvLyBidWJibGUgdXAgZXZlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiggYnViYmxlVXAgKXtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kcyA/IHRyaWdnZXJlci5fcHJpdmF0ZS5wYXJlbnQgOiBudWxsO1xuICAgICAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICE9IG51bGwgJiYgcGFyZW50Lmxlbmd0aCAhPT0gMDtcblxuICAgICAgICAgICAgICBpZiggaGFzUGFyZW50ICl7IC8vIHRoZW4gYnViYmxlIHVwIHRvIHBhcmVudFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICAgICAgICBwYXJlbnQudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIGJ1YmJsZSB1cCB0byB0aGUgY29yZVxuICAgICAgICAgICAgICAgIGN5LnRyaWdnZXIoZXZ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSAvLyBmb3IgZWFjaCBvZiBhbGxcbiAgICAgICAgfSAvLyBmb3IgZWFjaCBldmVudFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9OyAvLyBmdW5jdGlvblxuICAgIH0sIC8vIHRyaWdnZXJcblxuXG4gICAgYW5pbWF0ZWQ6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgICBmblBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZWRJbXBsKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgdmFyIGVsZSA9IGFsbFswXTtcblxuICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIC8vIGFuaW1hdGVkXG5cbiAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgZm5QYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyUXVldWVJbXBsKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICAgZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0sIC8vIGNsZWFyUXVldWVcblxuICAgIGRlbGF5OiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgZm5QYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5SW1wbCggdGltZSwgY29tcGxldGUgKXtcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICB0aGlzLmFuaW1hdGUoe1xuICAgICAgICAgIGRlbGF5OiB0aW1lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0sIC8vIGRlbGF5XG5cbiAgICBhbmltYXRlOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgZm5QYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKCBwcm9wZXJ0aWVzLCBwYXJhbXMgKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICAgIHZhciBpc0NvcmUgPSAhc2VsZklzQXJyYXlMaWtlO1xuICAgICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcblxuICAgICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgdmFyIGNhbGxUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICAgIHZhciBxO1xuICAgICAgICBcbiAgICAgICAgaWYoIHBhcmFtcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcGFyYW1zLmR1cmF0aW9uID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBwYXJhbXMuZHVyYXRpb24gPSA0MDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCggcGFyYW1zLmR1cmF0aW9uICl7XG4gICAgICAgIGNhc2UgJ3Nsb3cnOlxuICAgICAgICAgIHBhcmFtcy5kdXJhdGlvbiA9IDYwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmFzdCc6XG4gICAgICAgICAgcGFyYW1zLmR1cmF0aW9uID0gMjAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgcHJvcGVydGllc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgaWYoIHByb3BlcnRpZXMgKXsgZm9yKCB2YXIgaSBpbiBwcm9wZXJ0aWVzICl7XG4gICAgICAgICAgcHJvcGVydGllc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gfVxuXG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzRW1wdHkgKXtcbiAgICAgICAgICByZXR1cm4gdGhpczsgLy8gbm90aGluZyB0byBhbmltYXRlXG4gICAgICAgIH1cblxuICAgICAgICBpZiggcHJvcGVydGllcy5jc3MgJiYgaXNFbGVzICl7XG4gICAgICAgICAgcHJvcGVydGllcy5jc3MgPSBzdHlsZS5nZXRWYWx1ZVN0eWxlKCBwcm9wZXJ0aWVzLmNzcywgeyBhcnJheTogdHJ1ZSB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uICYmIGlzRWxlcyApe1xuICAgICAgICAgIHZhciBycG9zID0gcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgICAgIHByb3BlcnRpZXMucG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiAoIHJwb3MueCAtIHBhbi54ICkgL3pvb20sXG4gICAgICAgICAgICB5OiAoIHJwb3MueSAtIHBhbi55ICkgL3pvb21cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIHBhbkJ5IGlmIHNldFxuICAgICAgICBpZiggcHJvcGVydGllcy5wYW5CeSAmJiBpc0NvcmUgKXtcbiAgICAgICAgICB2YXIgcGFuQnkgPSBwcm9wZXJ0aWVzLnBhbkJ5O1xuICAgICAgICAgIHZhciBjeVBhbiA9IGN5LnBhbigpO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSB7XG4gICAgICAgICAgICB4OiBjeVBhbi54ICsgcGFuQnkueCxcbiAgICAgICAgICAgIHk6IGN5UGFuLnkgKyBwYW5CeS55XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG92ZXJyaWRlIHBhbiB3LyBjZW50ZXIgaWYgc2V0XG4gICAgICAgIHZhciBjZW50ZXIgPSBwcm9wZXJ0aWVzLmNlbnRlciB8fCBwcm9wZXJ0aWVzLmNlbnRyZTtcbiAgICAgICAgaWYoIGNlbnRlciAmJiBpc0NvcmUgKXtcbiAgICAgICAgICB2YXIgY2VudGVyUGFuID0gY3kuZ2V0Q2VudGVyUGFuKCBjZW50ZXIuZWxlcywgcHJvcGVydGllcy56b29tICk7XG5cbiAgICAgICAgICBpZiggY2VudGVyUGFuICl7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGNlbnRlclBhbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVycmlkZSBwYW4gJiB6b29tIHcvIGZpdCBpZiBzZXRcbiAgICAgICAgaWYoIHByb3BlcnRpZXMuZml0ICYmIGlzQ29yZSApe1xuICAgICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgICB2YXIgZml0VnAgPSBjeS5nZXRGaXRWaWV3cG9ydCggZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyApO1xuXG4gICAgICAgICAgaWYoIGZpdFZwICl7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjsgLy97IHg6IGZpdFZwLnBhbi54LCB5OiBmaXRWcC5wYW4ueSB9O1xuICAgICAgICAgICAgcHJvcGVydGllcy56b29tID0gZml0VnAuem9vbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICBcbiAgICAgICAgICBpZiggZWxlLmFuaW1hdGVkKCkgJiYgKHBhcmFtcy5xdWV1ZSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5xdWV1ZSkgKXtcbiAgICAgICAgICAgIHEgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxID0gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHEucHVzaCh7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgZHVyYXRpb246IHBhcmFtcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgY2FsbFRpbWU6IGNhbGxUaW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgICAgY3kuYWRkVG9BbmltYXRpb25Qb29sKCB0aGlzICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICAgIH07XG4gICAgfSwgLy8gYW5pbWF0ZVxuXG4gICAgc3RvcDogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICAgIGZuUGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzdG9wSW1wbCggY2xlYXJRdWV1ZSwganVtcFRvRW5kICl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICAgdmFyIGFuaXMgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQ7XG5cbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGFuaXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBhbmlzW2pdOyAgICBcbiAgICAgICAgICAgIGlmKCBqdW1wVG9FbmQgKXtcbiAgICAgICAgICAgICAgLy8gbmV4dCBpdGVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBsb29wLCB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIC8vIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIGVuZCBhbmQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICBhbmltYXRpb24uZHVyYXRpb24gPSAwOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG4gICAgICAgICAgaWYoIGNsZWFyUXVldWUgKXtcbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIWp1bXBUb0VuZCApe1xuICAgICAgICAgICAgZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIG5vdGlmeSAodGhlIGFuaW1hdGlvbiBsb29wIGRvZXNuJ3QgZG8gaXQgZm9yIHVzIG9uIGBzdG9wYClcbiAgICAgICAgY3kubm90aWZ5KHtcbiAgICAgICAgICBjb2xsZWN0aW9uOiB0aGlzLFxuICAgICAgICAgIHR5cGU6ICdkcmF3J1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9IC8vIHN0b3BcblxuICB9OyAvLyBkZWZpbmVcblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5zZWxlY3RvciA9IGZ1bmN0aW9uKG1hcCwgb3B0aW9ucyl7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBtYXAgKXtcbiAgICAgIHZhciBmbiA9IG1hcFtuYW1lXTtcbiAgICAgICQkLlNlbGVjdG9yLnByb3RvdHlwZVsgbmFtZSBdID0gZm47XG4gICAgfVxuICB9O1xuXG4gICQkLlNlbGVjdG9yID0gZnVuY3Rpb24ob25seVRoaXNHcm91cCwgc2VsZWN0b3Ipe1xuICAgIFxuICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5TZWxlY3RvcikgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuU2VsZWN0b3Iob25seVRoaXNHcm91cCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgXG4gICAgaWYoIHNlbGVjdG9yID09PSB1bmRlZmluZWQgJiYgb25seVRoaXNHcm91cCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICBzZWxlY3RvciA9IG9ubHlUaGlzR3JvdXA7XG4gICAgICBvbmx5VGhpc0dyb3VwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgc2VsZi5fcHJpdmF0ZSA9IHtcbiAgICAgIHNlbGVjdG9yVGV4dDogbnVsbCxcbiAgICAgIGludmFsaWQ6IHRydWVcbiAgICB9O1xuICAgIFxuICAgIGlmKCAhc2VsZWN0b3IgfHwgKCAkJC5pcy5zdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yLm1hdGNoKC9eXFxzKiQvKSApICl7XG4gICAgICBcbiAgICAgIGlmKCBvbmx5VGhpc0dyb3VwID09IG51bGwgKXtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIHNlbGYubGVuZ3RoID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgICAgICBzZWxmWzBdLmdyb3VwID0gb25seVRoaXNHcm91cDtcbiAgICAgICAgc2VsZi5sZW5ndGggPSAxO1xuICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICB9IGVsc2UgaWYoICQkLmlzLmVsZW1lbnQoIHNlbGVjdG9yICkgKXtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gbmV3ICQkLkNvbGxlY3Rpb24oc2VsZi5jeSgpLCBbIHNlbGVjdG9yIF0pO1xuICAgICAgXG4gICAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICAgIHNlbGZbMF0uY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgICBcbiAgICB9IGVsc2UgaWYoICQkLmlzLmNvbGxlY3Rpb24oIHNlbGVjdG9yICkgKXtcbiAgICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgICAgc2VsZlswXS5jb2xsZWN0aW9uID0gc2VsZWN0b3I7XG4gICAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgICBcbiAgICB9IGVsc2UgaWYoICQkLmlzLmZuKCBzZWxlY3RvciApICkge1xuICAgICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICBzZWxmWzBdLmZpbHRlciA9IHNlbGVjdG9yO1xuICAgICAgc2VsZi5sZW5ndGggPSAxO1xuICAgICAgXG4gICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcoIHNlbGVjdG9yICkgKXtcblxuICAgICAgLy8gdGhlIGN1cnJlbnQgc3ViamVjdCBpbiB0aGUgcXVlcnlcbiAgICAgIHZhciBjdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgICBcbiAgICAgIC8vIHN0b3JhZ2UgZm9yIHBhcnNlZCBxdWVyaWVzXG4gICAgICB2YXIgbmV3UXVlcnkgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNsYXNzZXM6IFtdLCBcbiAgICAgICAgICBjb2xvblNlbGVjdG9yczogW10sXG4gICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgZ3JvdXA6IG51bGwsXG4gICAgICAgICAgaWRzOiBbXSxcbiAgICAgICAgICBtZXRhOiBbXSxcblxuICAgICAgICAgIC8vIGZha2Ugc2VsZWN0b3JzXG4gICAgICAgICAgY29sbGVjdGlvbjogbnVsbCwgLy8gYSBjb2xsZWN0aW9uIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgICAgICBmaWx0ZXI6IG51bGwsIC8vIGZpbHRlciBmdW5jdGlvblxuXG4gICAgICAgICAgLy8gdGhlc2UgYXJlIGRlZmluZWQgaW4gdGhlIHVwd2FyZCBkaXJlY3Rpb24gcmF0aGVyIHRoYW4gZG93biAoZS5nLiBjaGlsZClcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gZ28gdXAgaW4gU2VsZWN0b3IuZmlsdGVyKClcbiAgICAgICAgICBwYXJlbnQ6IG51bGwsIC8vIHBhcmVudCBxdWVyeSBvYmpcbiAgICAgICAgICBhbmNlc3RvcjogbnVsbCwgLy8gYW5jZXN0b3IgcXVlcnkgb2JqXG4gICAgICAgICAgc3ViamVjdDogbnVsbCwgLy8gZGVmaW5lcyBzdWJqZWN0IGluIGNvbXBvdW5kIHF1ZXJ5IChzdWJqZWN0IHF1ZXJ5IG9iajsgcG9pbnRzIHRvIHNlbGYgaWYgc3ViamVjdClcblxuICAgICAgICAgIC8vIHVzZSB0aGVzZSBvbmx5IHdoZW4gc3ViamVjdCBoYXMgYmVlbiBkZWZpbmVkXG4gICAgICAgICAgY2hpbGQ6IG51bGwsXG4gICAgICAgICAgZGVzY2VuZGFudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gdG9rZW5zIGluIHRoZSBxdWVyeSBsYW5ndWFnZVxuICAgICAgdmFyIHRva2VucyA9IHtcbiAgICAgICAgbWV0YUNoYXI6ICdbXFxcXCFcXFxcXCJcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC5cXFxcL1xcXFw6XFxcXDtcXFxcPFxcXFw9XFxcXD5cXFxcP1xcXFxAXFxcXFtcXFxcXVxcXFxeXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl0nLCAvLyBjaGFycyB3ZSBuZWVkIHRvIGVzY2FwZSBpbiB2YXIgbmFtZXMsIGV0Y1xuICAgICAgICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLCAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICAgICAgYm9vbE9wOiAnXFxcXD98XFxcXCF8XFxcXF4nLCAvLyBib29sZWFuICh1bmFyeSkgb3BlcmF0b3JzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgICAgICBzdHJpbmc6ICdcIig/OlxcXFxcXFxcXCJ8W15cIl0pK1wiJyArICd8JyArIFwiJyg/OlxcXFxcXFxcJ3xbXiddKSsnXCIsIC8vIHN0cmluZyBsaXRlcmFscyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0gZG91YmxlcXVvdGVzIHwgc2luZ2xlcXVvdGVzXG4gICAgICAgIG51bWJlcjogJCQudXRpbC5yZWdleC5udW1iZXIsIC8vIG51bWJlciBsaXRlcmFsICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLS0gZS5nLiAwLjEyMzQsIDEyMzQsIDEyZTEyM1xuICAgICAgICBtZXRhOiAnZGVncmVlfGluZGVncmVlfG91dGRlZ3JlZScsIC8vIGFsbG93ZWQgbWV0YWRhdGEgZmllbGRzIChpLmUuIGFsbG93ZWQgZnVuY3Rpb25zIHRvIHVzZSBmcm9tICQkLkNvbGxlY3Rpb24pXG4gICAgICAgIHNlcGFyYXRvcjogJ1xcXFxzKixcXFxccyonLCAvLyBxdWVyaWVzIGFyZSBzZXBhcmF0ZWQgYnkgY29tbWFzLCBlLmcuIGVkZ2VbZm9vID0gJ2JhciddLCBub2RlLnNvbWVDbGFzc1xuICAgICAgICBkZXNjZW5kYW50OiAnXFxcXHMrJyxcbiAgICAgICAgY2hpbGQ6ICdcXFxccys+XFxcXHMrJyxcbiAgICAgICAgc3ViamVjdDogJ1xcXFwkJ1xuICAgICAgfTtcbiAgICAgIHRva2Vucy52YXJpYWJsZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcrIHRva2Vucy5tZXRhQ2hhciArJykpKyc7IC8vIGEgdmFyaWFibGUgbmFtZVxuICAgICAgdG9rZW5zLnZhbHVlID0gdG9rZW5zLnN0cmluZyArICd8JyArIHRva2Vucy5udW1iZXI7IC8vIGEgdmFsdWUgbGl0ZXJhbCwgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlclxuICAgICAgdG9rZW5zLmNsYXNzTmFtZSA9IHRva2Vucy52YXJpYWJsZTsgLy8gYSBjbGFzcyBuYW1lIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuICAgICAgdG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4gICAgICAvLyB3aGVuIGEgdG9rZW4gbGlrZSBhIHZhcmlhYmxlIGhhcyBlc2NhcGVkIG1ldGEgY2hhcmFjdGVycywgd2UgbmVlZCB0byBjbGVhbiB0aGUgYmFja3NsYXNoZXMgb3V0XG4gICAgICAvLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcbiAgICAgIHZhciBjbGVhbk1ldGFDaGFycyA9IGZ1bmN0aW9uKHN0cil7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcXFxcXCgnICsgdG9rZW5zLm1ldGFDaGFyICsgJyknLCAnZycpLCBmdW5jdGlvbihtYXRjaCwgJDEsIG9mZnNldCwgb3JpZ2luYWwpe1xuICAgICAgICAgIHJldHVybiAkMTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBhZGQgQCB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcbiAgICAgIHZhciBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgb3AgPSBvcHNbaV07XG4gICAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xAJyArIG9wO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgISB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcbiAgICAgIHZhciBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgb3AgPSBvcHNbaV07XG5cbiAgICAgICAgaWYoIG9wLmluZGV4T2YoJyEnKSA+PSAwICl7IGNvbnRpbnVlOyB9IC8vIHNraXAgb3BzIHRoYXQgZXhwbGljaXRseSBjb250YWluICFcbiAgICAgICAgaWYoIG9wID09PSAnPScgKXsgY29udGludWU7IH0gLy8gc2tpcCA9IGIvYyAhPSBpcyBleHBsaWNpdGx5IGRlZmluZWRcblxuICAgICAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8XFxcXCEnICsgb3A7XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IGFkZCBuZXcgZXhwcmVzc2lvbiBzeW50YXggaGVyZSB0byBoYXZlIGl0IHJlY29nbmlzZWQgYnkgdGhlIHBhcnNlcjtcbiAgICAgIC8vIC0gYSBxdWVyeSBjb250YWlucyBhbGwgYWRqYWNlbnQgKGkuZS4gbm8gc2VwYXJhdG9yIGluIGJldHdlZW4pIGV4cHJlc3Npb25zO1xuICAgICAgLy8gLSB0aGUgY3VycmVudCBxdWVyeSBpcyBzdG9yZWQgaW4gc2VsZltpXSAtLS0geW91IGNhbiB1c2UgdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AgaW4gdGhlIHBvcHVsYXRlIGZ1bmN0aW9uO1xuICAgICAgLy8gLSB5b3UgbmVlZCB0byBjaGVjayB0aGUgcXVlcnkgb2JqZWN0cyBpbiBTZWxlY3Rvci5maWx0ZXIoKSBmb3IgaXQgYWN0dWFsbHkgZmlsdGVyIHByb3Blcmx5LCBidXQgdGhhdCdzIHByZXR0eSBzdHJhaWdodCBmb3J3YXJkXG4gICAgICAvLyAtIHdoZW4geW91IGFkZCBzb21ldGhpbmcgaGVyZSwgYWxzbyBhZGQgdG8gU2VsZWN0b3IudG9TdHJpbmcoKVxuICAgICAgdmFyIGV4cHJzID0ge1xuICAgICAgICBncm91cDoge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnKG5vZGV8ZWRnZXxcXFxcKiknLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggZ3JvdXAgKXtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSBncm91cCA9PSBcIipcIiA/IGdyb3VwIDogZ3JvdXAgKyAncyc7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICAvLyBOQjogaWYgb25lIGNvbG9uIHNlbGVjdG9yIGlzIGEgc3Vic3RyaW5nIG9mIGFub3RoZXIgZnJvbSBpdHMgc3RhcnQsIHBsYWNlIHRoZSBsb25nZXIgb25lIGZpcnN0XG4gICAgICAgICAgLy8gZS5nLiA6Zm9vYmFyfDpmb29cbiAgICAgICAgICByZWdleDogJyg6c2VsZWN0ZWR8OnVuc2VsZWN0ZWR8OmxvY2tlZHw6dW5sb2NrZWR8OnZpc2libGV8OmhpZGRlbnw6dHJhbnNwYXJlbnR8OmdyYWJiZWR8OmZyZWV8OnJlbW92ZWR8Omluc2lkZXw6Z3JhYmJhYmxlfDp1bmdyYWJiYWJsZXw6YW5pbWF0ZWR8OnVuYW5pbWF0ZWR8OnNlbGVjdGFibGV8OnVuc2VsZWN0YWJsZXw6b3JwaGFufDpub25vcnBoYW58OnBhcmVudHw6Y2hpbGR8Omxvb3B8OnNpbXBsZXw6YWN0aXZlfDppbmFjdGl2ZXw6dG91Y2gpJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHN0YXRlICl7XG4gICAgICAgICAgICB0aGlzLmNvbG9uU2VsZWN0b3JzLnB1c2goIHN0YXRlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFwjKCcrIHRva2Vucy5pZCArJyknLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggaWQgKXtcbiAgICAgICAgICAgIHRoaXMuaWRzLnB1c2goIGNsZWFuTWV0YUNoYXJzKGlkKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGNsYXNzTmFtZToge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXC4oJysgdG9rZW5zLmNsYXNzTmFtZSArJyknLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggY2xhc3NOYW1lICl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMucHVzaCggY2xlYW5NZXRhQ2hhcnMoY2xhc3NOYW1lKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRhdGFFeGlzdHM6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcrIHRva2Vucy52YXJpYWJsZSArJylcXFxccypcXFxcXScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCB2YXJpYWJsZSApe1xuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goe1xuICAgICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkYXRhQ29tcGFyZToge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJysgdG9rZW5zLnZhcmlhYmxlICsnKVxcXFxzKignKyB0b2tlbnMuY29tcGFyYXRvck9wICsnKVxcXFxzKignKyB0b2tlbnMudmFsdWUgKycpXFxcXHMqXFxcXF0nLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggdmFyaWFibGUsIGNvbXBhcmF0b3JPcCwgdmFsdWUgKXsgXG4gICAgICAgICAgICB2YXIgdmFsdWVJc1N0cmluZyA9IG5ldyBSZWdFeHAoJ14nICsgdG9rZW5zLnN0cmluZyArICckJykuZXhlYyh2YWx1ZSkgIT0gbnVsbDtcblxuICAgICAgICAgICAgaWYoIHZhbHVlSXNTdHJpbmcgKXtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZGF0YUJvb2w6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcrIHRva2Vucy5ib29sT3AgKycpXFxcXHMqKCcrIHRva2Vucy52YXJpYWJsZSArJylcXFxccypcXFxcXScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBib29sT3AsIHZhcmlhYmxlICl7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIG1ldGFDb21wYXJlOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxbXFxcXHMqKCcrIHRva2Vucy5tZXRhICsnKVxcXFxzKignKyB0b2tlbnMuY29tcGFyYXRvck9wICsnKVxcXFxzKignKyB0b2tlbnMubnVtYmVyICsnKVxcXFxzKlxcXFxdXFxcXF0nLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggbWV0YSwgY29tcGFyYXRvck9wLCBudW1iZXIgKXtcbiAgICAgICAgICAgIHRoaXMubWV0YS5wdXNoKHtcbiAgICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKG1ldGEpLFxuICAgICAgICAgICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmV4dFF1ZXJ5OiB7XG4gICAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiB0b2tlbnMuc2VwYXJhdG9yLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gZ28gb24gdG8gbmV4dCBxdWVyeVxuICAgICAgICAgICAgc2VsZlsrK2ldID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICAgIGN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hpbGQ6IHtcbiAgICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgICAgcmVnZXg6IHRva2Vucy5jaGlsZCxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIHRoaXMgcXVlcnkgaXMgdGhlIHBhcmVudCBvZiB0aGUgZm9sbG93aW5nIHF1ZXJ5XG4gICAgICAgICAgICB2YXIgY2hpbGRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgICAgICBjaGlsZFF1ZXJ5LnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICBjaGlsZFF1ZXJ5LnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcblxuICAgICAgICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkIHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgICAgICAgIHNlbGZbaV0gPSBjaGlsZFF1ZXJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXNjZW5kYW50OiB7XG4gICAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIHRoaXMgcXVlcnkgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50UXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICAgICAgZGVzY2VuZGFudFF1ZXJ5LmFuY2VzdG9yID0gdGhpcztcbiAgICAgICAgICAgIGRlc2NlbmRhbnRRdWVyeS5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG5cbiAgICAgICAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBkZXNjZW5kYW50IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgICAgICAgIHNlbGZbaV0gPSBkZXNjZW5kYW50UXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN1YmplY3Q6IHtcbiAgICAgICAgICBtb2RpZmllcjogdHJ1ZSxcbiAgICAgICAgICByZWdleDogdG9rZW5zLnN1YmplY3QsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiggY3VycmVudFN1YmplY3QgIT0gbnVsbCAmJiB0aGlzLnN1YmplY3QgIT0gdGhpcyApe1xuICAgICAgICAgICAgICAkJC51dGlsLmVycm9yKCdSZWRlZmluaXRpb24gb2Ygc3ViamVjdCBpbiBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50U3ViamVjdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3QgPSB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgaiA9IDA7XG4gICAgICBmb3IoIHZhciBuYW1lIGluIGV4cHJzICl7XG4gICAgICAgIGV4cHJzW2pdID0gZXhwcnNbbmFtZV07XG4gICAgICAgIGV4cHJzW2pdLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIGV4cHJzLmxlbmd0aCA9IGo7XG5cbiAgICAgIHNlbGYuX3ByaXZhdGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgICB2YXIgcmVtYWluaW5nID0gc2VsZWN0b3I7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBcbiAgICAgIC8vIG9mIGFsbCB0aGUgZXhwcmVzc2lvbnMsIGZpbmQgdGhlIGZpcnN0IG1hdGNoIGluIHRoZSByZW1haW5pbmcgdGV4dFxuICAgICAgdmFyIGNvbnN1bWVFeHByID0gZnVuY3Rpb24oIGV4cGVjdGF0aW9uICl7XG4gICAgICAgIHZhciBleHByO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlID0gZXhwcnNbal07XG4gICAgICAgICAgdmFyIG4gPSBlLm5hbWU7XG5cbiAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBleHByZXNzaW9uIGlmIGl0IGRvZXNuJ3QgbWVldCB0aGUgZXhwZWN0YXRpb24gZnVuY3Rpb25cbiAgICAgICAgICBpZiggJCQuaXMuZm4oIGV4cGVjdGF0aW9uICkgJiYgIWV4cGVjdGF0aW9uKG4sIGUpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgbSA9IHJlbWFpbmluZy5tYXRjaChuZXcgUmVnRXhwKCAnXicgKyBlLnJlZ2V4ICkpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBtICE9IG51bGwgKXtcbiAgICAgICAgICAgIG1hdGNoID0gbTtcbiAgICAgICAgICAgIGV4cHIgPSBlO1xuICAgICAgICAgICAgbmFtZSA9IG47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjb25zdW1lZCA9IG1bMF07XG4gICAgICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKCBjb25zdW1lZC5sZW5ndGggKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGJyZWFrOyAvLyB3ZSd2ZSBjb25zdW1lZCBvbmUgZXhwciwgc28gd2UgY2FuIHJldHVybiBub3dcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXhwcjogZXhwcixcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gY29uc3VtZSBhbGwgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgY29uc3VtZVdoaXRlc3BhY2UgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgbWF0Y2ggPSByZW1haW5pbmcubWF0Y2goL15cXHMrLyk7XG4gICAgICAgIFxuICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICB2YXIgY29uc3VtZWQgPSBtYXRjaFswXTtcbiAgICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKCBjb25zdW1lZC5sZW5ndGggKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7IC8vIGdldCBzdGFydGVkXG5cbiAgICAgIGNvbnN1bWVXaGl0ZXNwYWNlKCk7IC8vIGdldCByaWQgb2YgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICBmb3IoOzspeyAgICAgICAgXG4gICAgICAgIHZhciBjaGVjayA9IGNvbnN1bWVFeHByKCk7XG4gICAgICAgIFxuICAgICAgICBpZiggY2hlY2suZXhwciA9PSBudWxsICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignVGhlIHNlbGVjdG9yIGAnKyBzZWxlY3RvciArJ2BpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgZm9yKHZhciBqID0gMTsgaiA8IGNoZWNrLm1hdGNoLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIGFyZ3MucHVzaCggY2hlY2subWF0Y2hbal0gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gbGV0IHRoZSB0b2tlbiBwb3B1bGF0ZSB0aGUgc2VsZWN0b3Igb2JqZWN0IChpLmUuIGluIHNlbGZbaV0pXG4gICAgICAgICAgdmFyIHJldCA9IGNoZWNrLmV4cHIucG9wdWxhdGUuYXBwbHkoIHNlbGZbaV0sIGFyZ3MgKTtcblxuICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7IHJldHVybjsgfSAvLyBleGl0IGlmIHBvcHVsYXRpb24gZmFpbGVkXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHdlJ3JlIGRvbmUgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBwYXJzZVxuICAgICAgICBpZiggcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKSApe1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNlbGYubGVuZ3RoID0gaSArIDE7XG5cbiAgICAgIC8vIGFkanVzdCByZWZlcmVuY2VzIGZvciBzdWJqZWN0XG4gICAgICBmb3IoaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcblxuICAgICAgICBpZiggcXVlcnkuc3ViamVjdCAhPSBudWxsICl7XG4gICAgICAgICAgLy8gZ28gdXAgdGhlIHRyZWUgdW50aWwgd2UgcmVhY2ggdGhlIHN1YmplY3RcbiAgICAgICAgICBmb3IoOzspe1xuICAgICAgICAgICAgaWYoIHF1ZXJ5LnN1YmplY3QgPT0gcXVlcnkgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiBzdWJqZWN0IGlzIHNlbGZcblxuICAgICAgICAgICAgaWYoIHF1ZXJ5LnBhcmVudCAhPSBudWxsICl7IC8vIHN3YXAgcGFyZW50L2NoaWxkIHJlZmVyZW5jZVxuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcXVlcnkucGFyZW50O1xuICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBxdWVyeTtcblxuICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICBwYXJlbnQuY2hpbGQgPSBjaGlsZDtcblxuICAgICAgICAgICAgICBxdWVyeSA9IHBhcmVudDsgLy8gZ28gdXAgdGhlIHRyZWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiggcXVlcnkuYW5jZXN0b3IgIT0gbnVsbCApeyAvLyBzd2FwIGFuY2VzdG9yL2Rlc2NlbmRhbnRcbiAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gcXVlcnkuYW5jZXN0b3I7XG4gICAgICAgICAgICAgIHZhciBkZXNjZW5kYW50ID0gcXVlcnk7XG5cbiAgICAgICAgICAgICAgZGVzY2VuZGFudC5hbmNlc3RvciA9IG51bGw7XG4gICAgICAgICAgICAgIGFuY2VzdG9yLmRlc2NlbmRhbnQgPSBkZXNjZW5kYW50O1xuXG4gICAgICAgICAgICAgIHF1ZXJ5ID0gYW5jZXN0b3I7IC8vIGdvIHVwIHRoZSB0cmVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkJC51dGlsLmVycm9yKCdXaGVuIGFkanVzdGluZyByZWZlcmVuY2VzIGZvciB0aGUgc2VsZWN0b3IgYCcrIHF1ZXJ5ICsnYCwgbmVpdGhlciBwYXJlbnQgbm9yIGFuY2VzdG9yIHdhcyBmb3VuZCcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGZvclxuXG4gICAgICAgICAgc2VsZltqXSA9IHF1ZXJ5LnN1YmplY3Q7IC8vIHN1YmplY3Qgc2hvdWxkIGJlIHRoZSByb290IHF1ZXJ5XG4gICAgICAgIH0gLy8gaWZcbiAgICAgIH0gLy8gZm9yXG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBmb3IgZWFjaCBxdWVyeSB0aGF0IHRoZSBzdWJqZWN0IGdyb3VwIG1hdGNoZXMgdGhlIGltcGxpY2l0IGdyb3VwIGlmIGFueVxuICAgICAgaWYoIG9ubHlUaGlzR3JvdXAgIT0gbnVsbCApe1xuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgaWYoIHNlbGZbal0uZ3JvdXAgIT0gbnVsbCAmJiBzZWxmW2pdLmdyb3VwICE9IG9ubHlUaGlzR3JvdXAgKXtcbiAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ0dyb3VwIGAnKyBzZWxmW2pdLmdyb3VwICsnYCBjb25mbGljdHMgd2l0aCBpbXBsaWNpdCBncm91cCBgJysgb25seVRoaXNHcm91cCArJ2AgaW4gc2VsZWN0b3IgYCcrIHNlbGVjdG9yICsnYCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGZbal0uZ3JvdXAgPSBvbmx5VGhpc0dyb3VwOyAvLyBzZXQgdG8gaW1wbGljaXQgZ3JvdXBcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgICQkLnV0aWwuZXJyb3IoJ0Egc2VsZWN0b3IgbXVzdCBiZSBjcmVhdGVkIGZyb20gYSBzdHJpbmc7IGZvdW5kICcgKyBzZWxlY3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5fcHJpdmF0ZS5pbnZhbGlkID0gZmFsc2U7XG4gICAgXG4gIH07XG5cbiAgJCQuc2VsZm4gPSAkJC5TZWxlY3Rvci5wcm90b3R5cGU7XG4gIFxuICAkJC5zZWxmbi5zaXplID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH07XG4gIFxuICAkJC5zZWxmbi5lcSA9IGZ1bmN0aW9uKGkpe1xuICAgIHJldHVybiB0aGlzW2ldO1xuICB9O1xuICBcbiAgLy8gZ2V0IGVsZW1lbnRzIGZyb20gdGhlIGNvcmUgYW5kIHRoZW4gZmlsdGVyIHRoZW1cbiAgJCQuc2VsZm4uZmluZCA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gVE9ETyBpbXBsIGlmIHdlIGRlY2lkZSB0byB1c2UgYSBEQiBmb3Igc3RvcmluZyBlbGVtZW50c1xuICB9O1xuICBcbiAgdmFyIHF1ZXJ5TWF0Y2hlcyA9IGZ1bmN0aW9uKHF1ZXJ5LCBlbGVtZW50KXtcbiAgICAvLyBjaGVjayBncm91cFxuICAgIGlmKCBxdWVyeS5ncm91cCAhPSBudWxsICYmIHF1ZXJ5Lmdyb3VwICE9ICcqJyAmJiBxdWVyeS5ncm91cCAhPSBlbGVtZW50Ll9wcml2YXRlLmdyb3VwICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gZWxlbWVudC5jeSgpO1xuICAgIFxuICAgIC8vIGNoZWNrIGNvbG9uIHNlbGVjdG9yc1xuICAgIHZhciBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gdHJ1ZTtcbiAgICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnkuY29sb25TZWxlY3RvcnMubGVuZ3RoOyBrKyspe1xuICAgICAgdmFyIHNlbCA9IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzW2tdO1xuICAgICAgXG4gICAgICBzd2l0Y2goc2VsKXtcbiAgICAgIGNhc2UgJzpzZWxlY3RlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnNlbGVjdGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVuc2VsZWN0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuc2VsZWN0ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6c2VsZWN0YWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnNlbGVjdGFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5zZWxlY3RhYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LnNlbGVjdGFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6bG9ja2VkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQubG9ja2VkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVubG9ja2VkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmxvY2tlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp2aXNpYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQudmlzaWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpoaWRkZW4nOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQudmlzaWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp0cmFuc3BhcmVudCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnRyYW5zcGFyZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmdyYWJiZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5ncmFiYmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmZyZWUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuZ3JhYmJlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpyZW1vdmVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQucmVtb3ZlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzppbnNpZGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQucmVtb3ZlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpncmFiYmFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5ncmFiYmFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5ncmFiYmFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuZ3JhYmJhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmFuaW1hdGVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuYW5pbWF0ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5hbmltYXRlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5hbmltYXRlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpwYXJlbnQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc05vZGUoKSAmJiBlbGVtZW50LmNoaWxkcmVuKCkubm9uZW1wdHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6Y2hpbGQnOlxuICAgICAgY2FzZSAnOm5vbm9ycGhhbic6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzTm9kZSgpICYmIGVsZW1lbnQucGFyZW50KCkubm9uZW1wdHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6b3JwaGFuJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNOb2RlKCkgJiYgZWxlbWVudC5wYXJlbnQoKS5lbXB0eSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpsb29wJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNFZGdlKCkgJiYgZWxlbWVudC5kYXRhKCdzb3VyY2UnKSA9PT0gZWxlbWVudC5kYXRhKCd0YXJnZXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6c2ltcGxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNFZGdlKCkgJiYgZWxlbWVudC5kYXRhKCdzb3VyY2UnKSAhPT0gZWxlbWVudC5kYXRhKCd0YXJnZXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6YWN0aXZlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuYWN0aXZlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmluYWN0aXZlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmFjdGl2ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp0b3VjaCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAkJC5pcy50b3VjaCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoICFhbGxDb2xvblNlbGVjdG9yc01hdGNoICkgYnJlYWs7XG4gICAgfVxuICAgIGlmKCAhYWxsQ29sb25TZWxlY3RvcnNNYXRjaCApIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBjaGVjayBpZFxuICAgIHZhciBhbGxJZHNNYXRjaCA9IHRydWU7XG4gICAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGsrKyl7XG4gICAgICB2YXIgaWQgPSBxdWVyeS5pZHNba107XG4gICAgICB2YXIgYWN0dWFsSWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICBcbiAgICAgIGFsbElkc01hdGNoID0gYWxsSWRzTWF0Y2ggJiYgKGlkID09IGFjdHVhbElkKTtcbiAgICAgIFxuICAgICAgaWYoICFhbGxJZHNNYXRjaCApIGJyZWFrO1xuICAgIH1cbiAgICBpZiggIWFsbElkc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIGNoZWNrIGNsYXNzZXNcbiAgICB2YXIgYWxsQ2xhc3Nlc01hdGNoID0gdHJ1ZTtcbiAgICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGsrKyl7XG4gICAgICB2YXIgY2xzID0gcXVlcnkuY2xhc3Nlc1trXTtcbiAgICAgIFxuICAgICAgYWxsQ2xhc3Nlc01hdGNoID0gYWxsQ2xhc3Nlc01hdGNoICYmIGVsZW1lbnQuaGFzQ2xhc3MoY2xzKTtcbiAgICAgIFxuICAgICAgaWYoICFhbGxDbGFzc2VzTWF0Y2ggKSBicmVhaztcbiAgICB9XG4gICAgaWYoICFhbGxDbGFzc2VzTWF0Y2ggKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gZ2VuZXJpYyBjaGVja2luZyBmb3IgZGF0YS9tZXRhZGF0YVxuICAgIHZhciBvcGVyYW5kc01hdGNoID0gZnVuY3Rpb24ocGFyYW1zKXtcbiAgICAgIHZhciBhbGxEYXRhTWF0Y2hlcyA9IHRydWU7XG4gICAgICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnlbcGFyYW1zLm5hbWVdLmxlbmd0aDsgaysrKXtcbiAgICAgICAgdmFyIGRhdGEgPSBxdWVyeVtwYXJhbXMubmFtZV1ba107XG4gICAgICAgIHZhciBvcGVyYXRvciA9IGRhdGEub3BlcmF0b3I7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGEudmFsdWU7XG4gICAgICAgIHZhciBmaWVsZCA9IGRhdGEuZmllbGQ7XG4gICAgICAgIHZhciBtYXRjaGVzO1xuICAgICAgICBcbiAgICAgICAgaWYoIG9wZXJhdG9yICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCApe1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBmaWVsZFZhbCA9IHBhcmFtcy5maWVsZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgICB2YXIgZmllbGRTdHIgPSAhJCQuaXMuc3RyaW5nKGZpZWxkVmFsKSAmJiAhJCQuaXMubnVtYmVyKGZpZWxkVmFsKSA/ICcnIDogJycgKyBmaWVsZFZhbDtcbiAgICAgICAgICB2YXIgdmFsU3RyID0gJycgKyB2YWx1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgY2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gICAgICAgICAgaWYoIG9wZXJhdG9yLmluZGV4T2YoJ0AnKSA+PSAwICl7XG4gICAgICAgICAgICBmaWVsZFN0ciA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YWxTdHIgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCdAJywgJycpO1xuICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbm90RXhwciA9IGZhbHNlO1xuICAgICAgICAgIHZhciBoYW5kbGVkTm90RXhwciA9IGZhbHNlO1xuICAgICAgICAgIGlmKCBvcGVyYXRvci5pbmRleE9mKCchJykgPj0gMCApe1xuICAgICAgICAgICAgb3BlcmF0b3IgPSBvcGVyYXRvci5yZXBsYWNlKCchJywgJycpO1xuICAgICAgICAgICAgbm90RXhwciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGlmIHdlJ3JlIGRvaW5nIGEgY2FzZSBpbnNlbnNpdGl2ZSBjb21wYXJpc29uLCB0aGVuIHdlJ3JlIHVzaW5nIGEgU1RSSU5HIGNvbXBhcmlzb25cbiAgICAgICAgICAvLyBldmVuIGlmIHdlJ3JlIGNvbXBhcmluZyBudW1iZXJzXG4gICAgICAgICAgaWYoIGNhc2VJbnNlbnNpdGl2ZSApe1xuICAgICAgICAgICAgdmFsdWUgPSB2YWxTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZpZWxkVmFsID0gZmllbGRTdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2gob3BlcmF0b3Ipe1xuICAgICAgICAgIGNhc2UgJyo9JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFN0ci5zZWFyY2godmFsU3RyKSA+PSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnJD0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IG5ldyBSZWdFeHAodmFsU3RyICsgJyQnKS5leGVjKGZpZWxkU3RyKSAhPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnXj0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IG5ldyBSZWdFeHAoJ14nICsgdmFsU3RyKS5leGVjKGZpZWxkU3RyKSAhPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICBtYXRjaGVzID0gZmllbGRWYWwgPT09IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnIT0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsICE9PSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPiB2YWx1ZSA6IGZpZWxkVmFsIDw9IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPj0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPj0gdmFsdWUgOiBmaWVsZFZhbCA8IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICBtYXRjaGVzID0gIW5vdEV4cHIgPyBmaWVsZFZhbCA8IHZhbHVlIDogZmllbGRWYWwgPj0gdmFsdWU7XG4gICAgICAgICAgICBoYW5kbGVkTm90RXhwciA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICc8PSc6XG4gICAgICAgICAgICBtYXRjaGVzID0gIW5vdEV4cHIgPyBmaWVsZFZhbCA8PSB2YWx1ZSA6IGZpZWxkVmFsID4gdmFsdWU7XG4gICAgICAgICAgICBoYW5kbGVkTm90RXhwciA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggb3BlcmF0b3IgIT0gbnVsbCApe1xuICAgICAgICAgIHN3aXRjaChvcGVyYXRvcil7XG4gICAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICBtYXRjaGVzID0gcGFyYW1zLmZpZWxkVHJ1dGh5KGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFwYXJhbXMuZmllbGRUcnV0aHkoZmllbGQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICBtYXRjaGVzID0gcGFyYW1zLmZpZWxkVW5kZWZpbmVkKGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgICBcbiAgICAgICAgICBtYXRjaGVzID0gIXBhcmFtcy5maWVsZFVuZGVmaW5lZChmaWVsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggbm90RXhwciAmJiAhaGFuZGxlZE5vdEV4cHIgKXtcbiAgICAgICAgICBtYXRjaGVzID0gIW1hdGNoZXM7XG4gICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggIW1hdGNoZXMgKXtcbiAgICAgICAgICBhbGxEYXRhTWF0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IC8vIGZvclxuICAgICAgXG4gICAgICByZXR1cm4gYWxsRGF0YU1hdGNoZXM7XG4gICAgfTsgLy8gb3BlcmFuZHNNYXRjaFxuICAgIFxuICAgIC8vIGNoZWNrIGRhdGEgbWF0Y2hlc1xuICAgIHZhciBhbGxEYXRhTWF0Y2hlcyA9IG9wZXJhbmRzTWF0Y2goe1xuICAgICAgbmFtZTogJ2RhdGEnLFxuICAgICAgZmllbGRWYWx1ZTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICByZXR1cm4gZWxlbWVudC5fcHJpdmF0ZS5kYXRhW2ZpZWxkXTtcbiAgICAgIH0sXG4gICAgICBmaWVsZFJlZjogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICByZXR1cm4gJ2VsZW1lbnQuX3ByaXZhdGUuZGF0YS4nICsgZmllbGQ7XG4gICAgICB9LFxuICAgICAgZmllbGRVbmRlZmluZWQ6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuX3ByaXZhdGUuZGF0YVtmaWVsZF0gPT09IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICBpZiggZWxlbWVudC5fcHJpdmF0ZS5kYXRhW2ZpZWxkXSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiggIWFsbERhdGFNYXRjaGVzICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIGNoZWNrIG1ldGFkYXRhIG1hdGNoZXNcbiAgICB2YXIgYWxsTWV0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKHtcbiAgICAgIG5hbWU6ICdtZXRhJyxcbiAgICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRbZmllbGRdKCk7XG4gICAgICB9LFxuICAgICAgZmllbGRSZWY6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuICdlbGVtZW50LicgKyBmaWVsZCArICcoKSc7XG4gICAgICB9LFxuICAgICAgZmllbGRVbmRlZmluZWQ6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRbZmllbGRdKCkgPT0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBmaWVsZFRydXRoeTogZnVuY3Rpb24oZmllbGQpe1xuICAgICAgICBpZiggZWxlbWVudFtmaWVsZF0oKSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBpZiggIWFsbE1ldGFNYXRjaGVzICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIGNoZWNrIGNvbGxlY3Rpb25cbiAgICBpZiggcXVlcnkuY29sbGVjdGlvbiAhPSBudWxsICl7XG4gICAgICB2YXIgbWF0Y2hlc0FueSA9IHF1ZXJ5LmNvbGxlY3Rpb24uX3ByaXZhdGUuaWRzWyBlbGVtZW50LmlkKCkgXSAhPSBudWxsO1xuICAgICAgXG4gICAgICBpZiggIW1hdGNoZXNBbnkgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBjaGVjayBmaWx0ZXIgZnVuY3Rpb25cbiAgICBpZiggcXVlcnkuZmlsdGVyICE9IG51bGwgJiYgZWxlbWVudC5jb2xsZWN0aW9uKCkuZmlsdGVyKCBxdWVyeS5maWx0ZXIgKS5zaXplKCkgPT09IDAgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG5cbiAgICAvLyBjaGVjayBwYXJlbnQvY2hpbGQgcmVsYXRpb25zXG4gICAgdmFyIGNvbmZpcm1SZWxhdGlvbnMgPSBmdW5jdGlvbiggcXVlcnksIGVsZW1lbnRzICl7XG4gICAgICBpZiggcXVlcnkgIT0gbnVsbCApe1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCAhY3kuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50cygpOyAvLyBtYWtlIGVsZW1lbnRzIGZ1bmN0aW9uYWwgc28gd2Ugc2F2ZSBjeWNsZXMgaWYgcXVlcnkgPT0gbnVsbFxuXG4gICAgICAgIC8vIHF1ZXJ5IG11c3QgbWF0Y2ggZm9yIGF0IGxlYXN0IG9uZSBlbGVtZW50IChtYXkgYmUgcmVjdXJzaXZlKVxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIGlmKCBxdWVyeU1hdGNoZXMoIHF1ZXJ5LCBlbGVtZW50c1tpXSApICl7XG4gICAgICAgICAgICBtYXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghIGNvbmZpcm1SZWxhdGlvbnMocXVlcnkucGFyZW50LCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQucGFyZW50KCk7XG4gICAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LmFuY2VzdG9yLCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQucGFyZW50cygpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5jaGlsZCwgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuKCk7XG4gICAgfSkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LmRlc2NlbmRhbnQsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZWxlbWVudC5kZXNjZW5kYW50cygpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gd2UndmUgcmVhY2hlZCB0aGUgZW5kLCBzbyB3ZSd2ZSBtYXRjaGVkIGV2ZXJ5dGhpbmcgZm9yIHRoaXMgcXVlcnlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTsgLy8gcXVlcnlNYXRjaGVzXG5cbiAgLy8gZmlsdGVyIGFuIGV4aXN0aW5nIGNvbGxlY3Rpb25cbiAgJCQuc2VsZm4uZmlsdGVyID0gZnVuY3Rpb24oY29sbGVjdGlvbil7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeSA9IGNvbGxlY3Rpb24uY3koKTtcbiAgICBcbiAgICAvLyBkb24ndCBib3RoZXIgdHJ5aW5nIGlmIGl0J3MgaW52YWxpZFxuICAgIGlmKCBzZWxmLl9wcml2YXRlLmludmFsaWQgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3kgKTtcbiAgICB9XG4gIFxuICAgIHZhciBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG4gICAgICAgIFxuICAgICAgICBpZiggcXVlcnlNYXRjaGVzKHF1ZXJ5LCBlbGVtZW50KSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFxuICAgIGlmKCBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9PSBudWxsICl7XG4gICAgICBzZWxlY3RvckZ1bmN0aW9uID0gZnVuY3Rpb24oKXsgcmV0dXJuIHRydWU7IH07XG4gICAgfVxuICAgIFxuICAgIHZhciBmaWx0ZXJlZENvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmZpbHRlciggc2VsZWN0b3JGdW5jdGlvbiApO1xuICAgIFxuICAgIHJldHVybiBmaWx0ZXJlZENvbGxlY3Rpb247XG4gIH07IC8vIGZpbHRlclxuXG4gIC8vIGRvZXMgc2VsZWN0b3IgbWF0Y2ggYSBzaW5nbGUgZWxlbWVudD9cbiAgJCQuc2VsZm4ubWF0Y2hlcyA9IGZ1bmN0aW9uKGVsZSl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIC8vIGRvbid0IGJvdGhlciB0cnlpbmcgaWYgaXQncyBpbnZhbGlkXG4gICAgaWYoIHNlbGYuX3ByaXZhdGUuaW52YWxpZCApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcbiAgICAgIFxuICAgICAgaWYoIHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZWxlKSApe1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9OyAvLyBmaWx0ZXJcbiAgXG4gIC8vIGl0aCBxdWVyeSB0byBzdHJpbmdcbiAgJCQuc2VsZm4udG9TdHJpbmcgPSAkJC5zZWxmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCl7XG4gICAgXG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIFxuICAgIHZhciBjbGVhbiA9IGZ1bmN0aW9uKG9iaiwgaXNWYWx1ZSl7XG4gICAgICBpZiggJCQuaXMuc3RyaW5nKG9iaikgKXtcbiAgICAgICAgcmV0dXJuIGlzVmFsdWUgPyAnXCInICsgb2JqICsgJ1wiJyA6IG9iajtcbiAgICAgIH0gXG4gICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcXVlcnlUb1N0cmluZyA9IGZ1bmN0aW9uKHF1ZXJ5KXtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgaWYoIHF1ZXJ5LnN1YmplY3QgPT09IHF1ZXJ5ICl7XG4gICAgICAgIHN0ciArPSAnJCc7XG4gICAgICB9XG5cbiAgICAgIHZhciBncm91cCA9IGNsZWFuKHF1ZXJ5Lmdyb3VwKTtcbiAgICAgIHN0ciArPSBncm91cC5zdWJzdHJpbmcoMCwgZ3JvdXAubGVuZ3RoIC0gMSk7XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5kYXRhLmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIGRhdGEgPSBxdWVyeS5kYXRhW2pdO1xuICAgICAgICBcbiAgICAgICAgaWYoIGRhdGEudmFsdWUgKXtcbiAgICAgICAgICBzdHIgKz0gJ1snICsgZGF0YS5maWVsZCArIGNsZWFuKGRhdGEub3BlcmF0b3IpICsgY2xlYW4oZGF0YS52YWx1ZSwgdHJ1ZSkgKyAnXSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyICs9ICdbJyArIGNsZWFuKGRhdGEub3BlcmF0b3IpICsgZGF0YS5maWVsZCArICddJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkubWV0YS5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBtZXRhID0gcXVlcnkubWV0YVtqXTtcbiAgICAgICAgc3RyICs9ICdbWycgKyBtZXRhLmZpZWxkICsgY2xlYW4obWV0YS5vcGVyYXRvcikgKyBjbGVhbihtZXRhLnZhbHVlLCB0cnVlKSArICddXSc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5jb2xvblNlbGVjdG9ycy5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBzZWwgPSBxdWVyeS5jb2xvblNlbGVjdG9yc1tpXTtcbiAgICAgICAgc3RyICs9IHNlbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5Lmlkcy5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBzZWwgPSAnIycgKyBxdWVyeS5pZHNbaV07XG4gICAgICAgIHN0ciArPSBzZWw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5jbGFzc2VzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIHNlbCA9ICcuJyArIHF1ZXJ5LmNsYXNzZXNbaV07XG4gICAgICAgIHN0ciArPSBzZWw7XG4gICAgICB9XG5cbiAgICAgIGlmKCBxdWVyeS5wYXJlbnQgIT0gbnVsbCApe1xuICAgICAgICBzdHIgPSBxdWVyeVRvU3RyaW5nKCBxdWVyeS5wYXJlbnQgKSArICcgPiAnICsgc3RyOyBcbiAgICAgIH1cblxuICAgICAgaWYoIHF1ZXJ5LmFuY2VzdG9yICE9IG51bGwgKXtcbiAgICAgICAgc3RyID0gcXVlcnlUb1N0cmluZyggcXVlcnkuYW5jZXN0b3IgKSArICcgJyArIHN0cjsgXG4gICAgICB9XG5cbiAgICAgIGlmKCBxdWVyeS5jaGlsZCAhPSBudWxsICl7XG4gICAgICAgIHN0ciArPSAnID4gJyArIHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5LmNoaWxkICk7IFxuICAgICAgfVxuXG4gICAgICBpZiggcXVlcnkuZGVzY2VuZGFudCAhPSBudWxsICl7XG4gICAgICAgIHN0ciArPSAnICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5kZXNjZW5kYW50ICk7IFxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH07XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzW2ldO1xuICAgICAgXG4gICAgICBzdHIgKz0gcXVlcnlUb1N0cmluZyggcXVlcnkgKTtcbiAgICAgIFxuICAgICAgaWYoIHRoaXMubGVuZ3RoID4gMSAmJiBpIDwgdGhpcy5sZW5ndGggLSAxICl7XG4gICAgICAgIHN0ciArPSAnLCAnO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3RyO1xuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLlN0eWxlID0gZnVuY3Rpb24oIGN5ICl7XG5cbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuU3R5bGUpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLlN0eWxlKGN5KTtcbiAgICB9XG5cbiAgICBpZiggISQkLmlzLmNvcmUoY3kpICl7XG4gICAgICAkJC51dGlsLmVycm9yKCdBIHN0eWxlIG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGNvcmVTdHlsZToge30sXG4gICAgICBuZXdTdHlsZTogdHJ1ZVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuICB9O1xuXG4gIC8vIG5pY2UtdG8taGF2ZSBhbGlhc2VzXG4gICQkLnN0eWxlID0gJCQuU3R5bGU7XG4gICQkLnN0eWZuID0gJCQuU3R5bGUucHJvdG90eXBlO1xuXG4gIC8vIGRlZmluZSBmdW5jdGlvbnMgaW4gdGhlIFN0eWxlIHByb3RvdHlwZVxuICAkJC5mbi5zdHlsZSA9IGZ1bmN0aW9uKCBmbk1hcCwgb3B0aW9ucyApe1xuICAgIGZvciggdmFyIGZuTmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbIGZuTmFtZSBdO1xuICAgICAgJCQuU3R5bGUucHJvdG90eXBlID0gZm47XG4gICAgfVxuICB9O1xuXG4gIChmdW5jdGlvbigpe1xuICAgIHZhciBudW1iZXIgPSAkJC51dGlsLnJlZ2V4Lm51bWJlcjtcbiAgICB2YXIgcmdiYSA9ICQkLnV0aWwucmVnZXgucmdiYU5vQmFja1JlZnM7XG4gICAgdmFyIGhzbGEgPSAkJC51dGlsLnJlZ2V4LmhzbGFOb0JhY2tSZWZzO1xuICAgIHZhciBoZXgzID0gJCQudXRpbC5yZWdleC5oZXgzO1xuICAgIHZhciBoZXg2ID0gJCQudXRpbC5yZWdleC5oZXg2O1xuICAgIHZhciBkYXRhID0gZnVuY3Rpb24oIHByZWZpeCApeyByZXR1cm4gJ14nICsgcHJlZml4ICsgJ1xcXFxzKlxcXFwoXFxcXHMqKFtcXFxcd1xcXFwuXSspXFxcXHMqXFxcXCkkJzsgfTtcbiAgICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uKCBwcmVmaXggKXsgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKChbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKlxcXFwsXFxcXHMqKCcgKyBudW1iZXIgKyAnKVxcXFxzKixcXFxccyooJyArIG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMgKyAnfCcgKyBoZXg2ICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJ3xcXFxcdyt8JyArIHJnYmEgKyAnfCcgKyBoc2xhICsgJ3wnICsgaGV4MyArICd8JyArIGhleDYgKyAnKVxcXFwpJCc7IH07XG5cbiAgICAvLyBlYWNoIHZpc3VhbCBzdHlsZSBwcm9wZXJ0eSBoYXMgYSB0eXBlIGFuZCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIGl0XG4gICAgJCQuc3R5bGUudHlwZXMgPSB7XG4gICAgICB0aW1lOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCB1bml0czogJ3N8bXMnLCBpbXBsaWNpdFVuaXRzOiAnbXMnIH0sXG4gICAgICBwZXJjZW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBtYXg6IDEwMCwgdW5pdHM6ICclJyB9LFxuICAgICAgemVyb09uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgICAgbk9uZU9uZU51bWJlcjogeyBudW1iZXI6IHRydWUsIG1pbjogLTEsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICAgIG5vbk5lZ2F0aXZlSW50OiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBpbnRlZ2VyOiB0cnVlLCB1bml0bGVzczogdHJ1ZSB9LFxuICAgICAgcG9zaXRpb246IHsgZW51bXM6IFsncGFyZW50JywgJ29yaWdpbiddIH0sXG4gICAgICBhdXRvU2l6ZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgZW51bXM6IFsnYXV0byddIH0sXG4gICAgICBudW1iZXI6IHsgbnVtYmVyOiB0cnVlIH0sXG4gICAgICBzaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwIH0sXG4gICAgICBiZ1NpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGFsbG93UGVyY2VudDogdHJ1ZSB9LFxuICAgICAgYmdQb3M6IHsgbnVtYmVyOiB0cnVlLCBhbGxvd1BlcmNlbnQ6IHRydWUgfSxcbiAgICAgIGJnUmVwZWF0OiB7IGVudW1zOiBbJ3JlcGVhdCcsICdyZXBlYXQteCcsICdyZXBlYXQteScsICduby1yZXBlYXQnXSB9LFxuICAgICAgYmdGaXQ6IHsgZW51bXM6IFsnbm9uZScsICdjb250YWluJywgJ2NvdmVyJ10gfSxcbiAgICAgIGJnQ2xpcDogeyBlbnVtczogWydub25lJywgJ25vZGUnXSB9LFxuICAgICAgY29sb3I6IHsgY29sb3I6IHRydWUgfSxcbiAgICAgIGxpbmVTdHlsZTogeyBlbnVtczogWydzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJ10gfSxcbiAgICAgIGJvcmRlclN0eWxlOiB7IGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnLCAnZG91YmxlJ10gfSxcbiAgICAgIGN1cnZlU3R5bGU6IHsgZW51bXM6IFsnYmV6aWVyJywgJ3VuYnVuZGxlZC1iZXppZXInLCAnaGF5c3RhY2snXSB9LFxuICAgICAgZm9udEZhbWlseTogeyByZWdleDogJ14oW1xcXFx3LSBdKyg/OlxcXFxzKixcXFxccypbXFxcXHctIF0rKSopJCcgfSxcbiAgICAgIGZvbnRWYXJpYW50OiB7IGVudW1zOiBbJ3NtYWxsLWNhcHMnLCAnbm9ybWFsJ10gfSxcbiAgICAgIGZvbnRTdHlsZTogeyBlbnVtczogWydpdGFsaWMnLCAnbm9ybWFsJywgJ29ibGlxdWUnXSB9LFxuICAgICAgZm9udFdlaWdodDogeyBlbnVtczogWydub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicsICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc4MDAnLCAnOTAwJywgMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsIDkwMF0gfSxcbiAgICAgIHRleHREZWNvcmF0aW9uOiB7IGVudW1zOiBbJ25vbmUnLCAndW5kZXJsaW5lJywgJ292ZXJsaW5lJywgJ2xpbmUtdGhyb3VnaCddIH0sXG4gICAgICB0ZXh0VHJhbnNmb3JtOiB7IGVudW1zOiBbJ25vbmUnLCAndXBwZXJjYXNlJywgJ2xvd2VyY2FzZSddIH0sXG4gICAgICBub2RlU2hhcGU6IHsgZW51bXM6IFsncmVjdGFuZ2xlJywgJ3JvdW5kcmVjdGFuZ2xlJywgJ2VsbGlwc2UnLCAndHJpYW5nbGUnLCAnc3F1YXJlJywgJ3BlbnRhZ29uJywgJ2hleGFnb24nLCAnaGVwdGFnb24nLCAnb2N0YWdvbicsICdzdGFyJ10gfSxcbiAgICAgIGFycm93U2hhcGU6IHsgZW51bXM6IFsndGVlJywgJ3RyaWFuZ2xlJywgJ3RyaWFuZ2xlLXRlZScsICd0cmlhbmdsZS1iYWNrY3VydmUnLCAnaGFsZi10cmlhbmdsZS1vdmVyc2hvdCcsICdzcXVhcmUnLCAnY2lyY2xlJywgJ2RpYW1vbmQnLCAnbm9uZSddIH0sXG4gICAgICBhcnJvd0ZpbGw6IHsgZW51bXM6IFsnZmlsbGVkJywgJ2hvbGxvdyddIH0sXG4gICAgICBkaXNwbGF5OiB7IGVudW1zOiBbJ2VsZW1lbnQnLCAnbm9uZSddIH0sXG4gICAgICB2aXNpYmlsaXR5OiB7IGVudW1zOiBbJ2hpZGRlbicsICd2aXNpYmxlJ10gfSxcbiAgICAgIHZhbGlnbjogeyBlbnVtczogWyd0b3AnLCAnY2VudGVyJywgJ2JvdHRvbSddIH0sXG4gICAgICBoYWxpZ246IHsgZW51bXM6IFsnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXSB9LFxuICAgICAgdGV4dDogeyBzdHJpbmc6IHRydWUgfSxcbiAgICAgIGRhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ2RhdGEnKSB9LFxuICAgICAgbGF5b3V0RGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSgnbGF5b3V0RGF0YScpIH0sXG4gICAgICBtYXBEYXRhOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBtYXBEYXRhKCdtYXBEYXRhJykgfSxcbiAgICAgIG1hcExheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcExheW91dERhdGEnKSB9LFxuICAgICAgdXJsOiB7IHJlZ2V4OiAnXnVybFxcXFxzKlxcXFwoXFxcXHMqKFteXFxcXHNdKylcXFxccypcXFxccypcXFxcKXxub25lfCguKykkJyB9LFxuICAgICAgcHJvcExpc3Q6IHsgcHJvcExpc3Q6IHRydWUgfSxcbiAgICAgIGFuZ2xlOiB7IG51bWJlcjogdHJ1ZSwgdW5pdHM6ICdkZWd8cmFkJyB9XG4gICAgfTtcblxuICAgIC8vIGRlZmluZSB2aXN1YWwgc3R5bGUgcHJvcGVydGllc1xuICAgIHZhciB0ID0gJCQuc3R5bGUudHlwZXM7XG4gICAgdmFyIHByb3BzID0gJCQuc3R5bGUucHJvcGVydGllcyA9IFtcbiAgICAgIC8vIGxhYmVsc1xuICAgICAgeyBuYW1lOiAndGV4dC12YWxpZ24nLCB0eXBlOiB0LnZhbGlnbiB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1oYWxpZ24nLCB0eXBlOiB0LmhhbGlnbiB9LFxuICAgICAgeyBuYW1lOiAnY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdjb250ZW50JywgdHlwZTogdC50ZXh0IH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtb3V0bGluZS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIC8vIHsgbmFtZTogJ3RleHQtZGVjb3JhdGlvbicsIHR5cGU6IHQudGV4dERlY29yYXRpb24gfSwgLy8gbm90IHN1cHBvcnRlZCBpbiBjYW52YXNcbiAgICAgIHsgbmFtZTogJ3RleHQtdHJhbnNmb3JtJywgdHlwZTogdC50ZXh0VHJhbnNmb3JtIH0sXG4gICAgICAvLyB7IG5hbWU6ICd0ZXh0LXJvdGF0aW9uJywgdHlwZTogdC5hbmdsZSB9LCAvLyBUT0RPIGRpc2FibGVkIGIvYyByb3RhdGlvbiBicmVha3MgYm91bmRpbmcgYm94ZXNcbiAgICAgIHsgbmFtZTogJ2ZvbnQtZmFtaWx5JywgdHlwZTogdC5mb250RmFtaWx5IH0sXG4gICAgICB7IG5hbWU6ICdmb250LXN0eWxlJywgdHlwZTogdC5mb250U3R5bGUgfSxcbiAgICAgIC8vIHsgbmFtZTogJ2ZvbnQtdmFyaWFudCcsIHR5cGU6IHQuZm9udFZhcmlhbnQgfSwgLy8gbm90IHVzZWZ1bFxuICAgICAgeyBuYW1lOiAnZm9udC13ZWlnaHQnLCB0eXBlOiB0LmZvbnRXZWlnaHQgfSxcbiAgICAgIHsgbmFtZTogJ2ZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnbWluLXpvb21lZC1mb250LXNpemUnLCB0eXBlOiB0LnNpemUgfSxcblxuICAgICAgLy8gdmlzaWJpbGl0eVxuICAgICAgeyBuYW1lOiAnZGlzcGxheScsIHR5cGU6IHQuZGlzcGxheSB9LFxuICAgICAgeyBuYW1lOiAndmlzaWJpbGl0eScsIHR5cGU6IHQudmlzaWJpbGl0eSB9LFxuICAgICAgeyBuYW1lOiAnb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnei1pbmRleCcsIHR5cGU6IHQubm9uTmVnYXRpdmVJbnQgfSxcblxuICAgICAgLy8gb3ZlcmxheXNcbiAgICAgIHsgbmFtZTogJ292ZXJsYXktcGFkZGluZycsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnb3ZlcmxheS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ292ZXJsYXktb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuXG4gICAgICAvLyB0cmFuc2l0aW9uIGFuaXNcbiAgICAgIHsgbmFtZTogJ3RyYW5zaXRpb24tcHJvcGVydHknLCB0eXBlOiB0LnByb3BMaXN0IH0sXG4gICAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLWR1cmF0aW9uJywgdHlwZTogdC50aW1lIH0sXG4gICAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLWRlbGF5JywgdHlwZTogdC50aW1lIH0sXG5cbiAgICAgIC8vIG5vZGUgYm9keVxuICAgICAgeyBuYW1lOiAnaGVpZ2h0JywgdHlwZTogdC5hdXRvU2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnd2lkdGgnLCB0eXBlOiB0LmF1dG9TaXplIH0sXG4gICAgICB7IG5hbWU6ICdzaGFwZScsIHR5cGU6IHQubm9kZVNoYXBlIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWJsYWNrZW4nLCB0eXBlOiB0Lm5PbmVPbmVOdW1iZXIgfSxcblxuICAgICAgLy8gbm9kZSBib3JkZXJcbiAgICAgIHsgbmFtZTogJ2JvcmRlci1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ2JvcmRlci1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdib3JkZXItd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ2JvcmRlci1zdHlsZScsIHR5cGU6IHQuYm9yZGVyU3R5bGUgfSxcbiAgICAgIFxuICAgICAgLy8gbm9kZSBiYWNrZ3JvdW5kIGltYWdlc1xuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZScsIHR5cGU6IHQudXJsIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teCcsIHR5cGU6IHQuYmdQb3MgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtcG9zaXRpb24teScsIHR5cGU6IHQuYmdQb3MgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtcmVwZWF0JywgdHlwZTogdC5iZ1JlcGVhdCB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1maXQnLCB0eXBlOiB0LmJnRml0IH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWNsaXAnLCB0eXBlOiB0LmJnQ2xpcCB9LFxuXG4gICAgICAvLyBjb21wb3VuZCBwcm9wc1xuICAgICAgeyBuYW1lOiAncGFkZGluZy1sZWZ0JywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdwYWRkaW5nLXJpZ2h0JywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdwYWRkaW5nLXRvcCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAncGFkZGluZy1ib3R0b20nLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3Bvc2l0aW9uJywgdHlwZTogdC5wb3NpdGlvbiB9LFxuXG4gICAgICAvLyBlZGdlIGxpbmVcbiAgICAgIHsgbmFtZTogJ2xpbmUtc3R5bGUnLCB0eXBlOiB0LmxpbmVTdHlsZSB9LFxuICAgICAgeyBuYW1lOiAnbGluZS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlJywgdHlwZTogdC5udW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdjdXJ2ZS1zdHlsZScsIHR5cGU6IHQuY3VydmVTdHlsZSB9LFxuICAgICAgeyBuYW1lOiAnaGF5c3RhY2stcmFkaXVzJywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG5cbiAgICAgIC8vIGVkZ2UgYXJyb3dzXG4gICAgICB7IG5hbWU6ICdzb3VyY2UtYXJyb3ctc2hhcGUnLCB0eXBlOiB0LmFycm93U2hhcGUgfSxcbiAgICAgIHsgbmFtZTogJ3RhcmdldC1hcnJvdy1zaGFwZScsIHR5cGU6IHQuYXJyb3dTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXNvdXJjZS1hcnJvdy1zaGFwZScsIHR5cGU6IHQuYXJyb3dTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXRhcmdldC1hcnJvdy1zaGFwZScsIHR5cGU6IHQuYXJyb3dTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAnc291cmNlLWFycm93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAndGFyZ2V0LWFycm93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXNvdXJjZS1hcnJvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ21pZC10YXJnZXQtYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdzb3VyY2UtYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH0sXG4gICAgICB7IG5hbWU6ICd0YXJnZXQtYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtc291cmNlLWFycm93LWZpbGwnLCB0eXBlOiB0LmFycm93RmlsbCB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXRhcmdldC1hcnJvdy1maWxsJywgdHlwZTogdC5hcnJvd0ZpbGwgfSxcblxuICAgICAgLy8gdGhlc2UgYXJlIGp1c3QgZm9yIHRoZSBjb3JlXG4gICAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdhY3RpdmUtYmctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdhY3RpdmUtYmctb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH1cbiAgICBdO1xuXG4gICAgLy8gcGllIGJhY2tncm91bmRzIGZvciBub2Rlc1xuICAgICQkLnN0eWxlLnBpZUJhY2tncm91bmROID0gMTY7IC8vIGJlY2F1c2UgdGhlIHBpZSBwcm9wZXJ0aWVzIGFyZSBudW1iZXJlZCwgZ2l2ZSBhY2Nlc3MgdG8gYSBjb25zdGFudCBOIChmb3IgcmVuZGVyZXIgdXNlKVxuICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLXNpemUnLCB0eXBlOiB0LmJnU2l6ZSB9KTtcbiAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAkJC5zdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrICl7XG4gICAgICBwcm9wcy5wdXNoKHsgbmFtZTogJ3BpZS0nK2krJy1iYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9KTtcbiAgICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLScraSsnLWJhY2tncm91bmQtc2l6ZScsIHR5cGU6IHQucGVyY2VudCB9KTtcbiAgICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLScraSsnLWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9KTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBhY2Nlc3Mgb2YgcHJvcGVydGllcyBieSBuYW1lICggZS5nLiAkJC5zdHlsZS5wcm9wZXJ0aWVzLmhlaWdodCApXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIFxuICAgICAgcHJvcHNbIHByb3AubmFtZSBdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgICB9XG4gIH0pKCk7XG5cbiAgLy8gYWRkcyB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IHRvIHRoZSBjdXJyZW50IHN0eWxlXG4gICQkLnN0eWZuLmFkZERlZmF1bHRTdHlsZXNoZWV0ID0gZnVuY3Rpb24oKXtcbiAgICAvLyB0byBiZSBuaWNlLCB3ZSBidWlsZCBmb250IHJlbGF0ZWQgc3R5bGUgcHJvcGVydGllcyBmcm9tIHRoZSBjb3JlIGNvbnRhaW5lclxuICAgIC8vIHNvIHRoYXQgY3l0b3NjYXBlIG1hdGNoZXMgdGhlIHN0eWxlIG9mIGl0cyBjb250YWluZXIgYnkgZGVmYXVsdFxuICAgIC8vIFxuICAgIC8vIHVuZm9ydHVuYXRlbHksIHRoaXMgZG9lc24ndCBzZWVtIHdvcmsgY29uc2lzdGVudGx5IGFuZCBjYW4gZ3JhYiB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IHZhbHVlc1xuICAgIC8vIGluc3RlYWQgb2YgdGhlIGRldmVsb3BlcidzIHZhbHVlcyBzbyBsZXQncyBqdXN0IG1ha2UgaXQgZXhwbGljaXQgZm9yIHRoZSBkZXYgZm9yIG5vd1xuICAgIC8vXG4gICAgLy8gZGVsYXlpbmcgdGhlIHJlYWQgb2YgdGhlc2UgdmFsJ3MgaXMgbm90IGFuIG9wdCduOiB0aGF0IHdvdWxkIGRlbGF5IGluaXQnbCBsb2FkIHRpbWVcbiAgICB2YXIgZm9udEZhbWlseSA9ICdIZWx2ZXRpY2EnIHx8IHRoaXMuY29udGFpbmVyUHJvcGVydHlBc1N0cmluZygnZm9udC1mYW1pbHknKSB8fCAnc2Fucy1zZXJpZic7XG4gICAgdmFyIGZvbnRTdHlsZSA9ICdub3JtYWwnIHx8IHRoaXMuY29udGFpbmVyUHJvcGVydHlBc1N0cmluZygnZm9udC1zdHlsZScpIHx8ICdub3JtYWwnO1xuICAgIC8vIHZhciBmb250VmFyaWFudCA9ICdub3JtYWwnIHx8IHRoaXMuY29udGFpbmVyUHJvcGVydHlBc1N0cmluZygnZm9udC12YXJpYW50JykgfHwgJ25vcm1hbCc7XG4gICAgdmFyIGZvbnRXZWlnaHQgPSAnbm9ybWFsJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtd2VpZ2h0JykgfHwgJ25vcm1hbCc7XG4gICAgdmFyIGNvbG9yID0gJyMwMDAnIHx8IHRoaXMuY29udGFpbmVyUHJvcGVydHlBc1N0cmluZygnY29sb3InKSB8fCAnIzAwMCc7XG4gICAgdmFyIHRleHRUcmFuc2Zvcm0gPSAnbm9uZScgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCd0ZXh0LXRyYW5zZm9ybScpIHx8ICdub25lJztcbiAgICB2YXIgZm9udFNpemUgPSAxNiB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtc2l6ZScpIHx8IDE2O1xuXG4gICAgLy8gZmlsbCB0aGUgc3R5bGUgd2l0aCB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0XG4gICAgdGhpc1xuICAgICAgLnNlbGVjdG9yKCdub2RlLCBlZGdlJykgLy8gY29tbW9uIHByb3BlcnRpZXNcbiAgICAgICAgLmNzcyh7XG4gICAgICAgICAgJ3RleHQtdmFsaWduJzogJ3RvcCcsXG4gICAgICAgICAgJ3RleHQtaGFsaWduJzogJ2NlbnRlcicsXG4gICAgICAgICAgJ2NvbG9yJzogY29sb3IsXG4gICAgICAgICAgJ3RleHQtb3V0bGluZS1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAndGV4dC1vdXRsaW5lLXdpZHRoJzogMCxcbiAgICAgICAgICAndGV4dC1vdXRsaW5lLW9wYWNpdHknOiAxLFxuICAgICAgICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICAgICAgICd0ZXh0LWRlY29yYXRpb24nOiAnbm9uZScsXG4gICAgICAgICAgJ3RleHQtdHJhbnNmb3JtJzogdGV4dFRyYW5zZm9ybSxcbiAgICAgICAgICAnZm9udC1mYW1pbHknOiBmb250RmFtaWx5LFxuICAgICAgICAgICdmb250LXN0eWxlJzogZm9udFN0eWxlLFxuICAgICAgICAgIC8vICdmb250LXZhcmlhbnQnOiBmb250VmFyaWFudCxcbiAgICAgICAgICAnZm9udC13ZWlnaHQnOiBmb250V2VpZ2h0LFxuICAgICAgICAgICdmb250LXNpemUnOiBmb250U2l6ZSxcbiAgICAgICAgICAnbWluLXpvb21lZC1mb250LXNpemUnOiAwLFxuICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICdkaXNwbGF5JzogJ2VsZW1lbnQnLFxuICAgICAgICAgICdvcGFjaXR5JzogMSxcbiAgICAgICAgICAnei1pbmRleCc6IDAsXG4gICAgICAgICAgJ2NvbnRlbnQnOiAnJyxcbiAgICAgICAgICAnb3ZlcmxheS1vcGFjaXR5JzogMCxcbiAgICAgICAgICAnb3ZlcmxheS1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAgICAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAnbm9uZScsXG4gICAgICAgICAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiAwLFxuICAgICAgICAgICd0cmFuc2l0aW9uLWRlbGF5JzogMCxcblxuICAgICAgICAgIC8vIG5vZGUgcHJvcHNcbiAgICAgICAgICAnYmFja2dyb3VuZC1ibGFja2VuJzogMCxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjODg4JyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JzogMSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogJzUwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6ICc1MCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vZGUnLFxuICAgICAgICAgICdib3JkZXItY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ2JvcmRlci1vcGFjaXR5JzogMSxcbiAgICAgICAgICAnYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICAgICAnYm9yZGVyLXN0eWxlJzogJ3NvbGlkJyxcbiAgICAgICAgICAnaGVpZ2h0JzogMzAsXG4gICAgICAgICAgJ3dpZHRoJzogMzAsXG4gICAgICAgICAgJ3NoYXBlJzogJ2VsbGlwc2UnLFxuXG4gICAgICAgICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAgICAgICAncGFkZGluZy10b3AnOiAwLFxuICAgICAgICAgICdwYWRkaW5nLWJvdHRvbSc6IDAsXG4gICAgICAgICAgJ3BhZGRpbmctbGVmdCc6IDAsXG4gICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAwLFxuICAgICAgICAgICdwb3NpdGlvbic6ICdvcmlnaW4nLFxuICAgICAgICAgIFxuXG4gICAgICAgICAgLy8gbm9kZSBwaWUgYmdcbiAgICAgICAgICAncGllLXNpemUnOiAnMTAwJScsXG4gICAgICAgICAgJ3BpZS0xLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMi1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTMtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS00LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtNS1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTYtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS03LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtOC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTktYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xMC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTExLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTItYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xMy1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTE0LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTUtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xNi1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTEtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTItYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTMtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTQtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTUtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTYtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTctYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTgtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTktYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTEwLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xMS1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTItYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTEzLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xNC1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTUtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTE2LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0yLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0zLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS00LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS01LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS02LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS03LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS04LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS05LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xMC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTEtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTEyLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xMy1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTQtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTE1LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xNi1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuXG4gICAgICAgICAgLy8gZWRnZSBwcm9wc1xuICAgICAgICAgICdzb3VyY2UtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ21pZC1zb3VyY2UtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ3RhcmdldC1hcnJvdy1zaGFwZSc6ICdub25lJyxcbiAgICAgICAgICAnbWlkLXRhcmdldC1hcnJvdy1zaGFwZSc6ICdub25lJyxcbiAgICAgICAgICAnc291cmNlLWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdtaWQtc291cmNlLWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctY29sb3InOiAnI2RkZCcsXG4gICAgICAgICAgJ21pZC10YXJnZXQtYXJyb3ctY29sb3InOiAnI2RkZCcsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1maWxsJzogJ2ZpbGxlZCcsXG4gICAgICAgICAgJ21pZC1zb3VyY2UtYXJyb3ctZmlsbCc6ICdmaWxsZWQnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctZmlsbCc6ICdmaWxsZWQnLFxuICAgICAgICAgICdtaWQtdGFyZ2V0LWFycm93LWZpbGwnOiAnZmlsbGVkJyxcbiAgICAgICAgICAnbGluZS1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAgICAgJ2xpbmUtY29sb3InOiAnI2RkZCcsXG4gICAgICAgICAgJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJzogNDAsXG4gICAgICAgICAgJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JzogMC41LFxuICAgICAgICAgICdjdXJ2ZS1zdHlsZSc6ICdiZXppZXInLFxuICAgICAgICAgICdoYXlzdGFjay1yYWRpdXMnOiAwLjhcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignJG5vZGUgPiBub2RlJykgLy8gY29tcG91bmQgKHBhcmVudCkgbm9kZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6ICdhdXRvJyxcbiAgICAgICAgICAnaGVpZ2h0JzogJ2F1dG8nLFxuICAgICAgICAgICdzaGFwZSc6ICdyZWN0YW5nbGUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLW9wYWNpdHknOiAwLjUsXG4gICAgICAgICAgJ3BhZGRpbmctdG9wJzogMTAsXG4gICAgICAgICAgJ3BhZGRpbmctcmlnaHQnOiAxMCxcbiAgICAgICAgICAncGFkZGluZy1sZWZ0JzogMTAsXG4gICAgICAgICAgJ3BhZGRpbmctYm90dG9tJzogMTBcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignZWRnZScpIC8vIGp1c3QgZWRnZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd3aWR0aCc6IDFcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignOmFjdGl2ZScpXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdvdmVybGF5LWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAnb3ZlcmxheS1wYWRkaW5nJzogMTAsXG4gICAgICAgICAgJ292ZXJsYXktb3BhY2l0eSc6IDAuMjVcbiAgICAgICAgfSlcbiAgICAgIC5zZWxlY3RvcignY29yZScpIC8vIGp1c3QgY29yZSBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICdzZWxlY3Rpb24tYm94LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdzZWxlY3Rpb24tYm94LW9wYWNpdHknOiAwLjY1LFxuICAgICAgICAgICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcic6ICcjYWFhJyxcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnOiAxLFxuICAgICAgICAgICdhY3RpdmUtYmctY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdhY3RpdmUtYmctb3BhY2l0eSc6IDAuMTUsXG4gICAgICAgICAgJ2FjdGl2ZS1iZy1zaXplJzogJCQuaXMudG91Y2goKSA/IDQwIDogMTUsXG4gICAgICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknOiAwLjEyNVxuICAgICAgICB9KVxuICAgIDtcblxuICAgIHRoaXMuZGVmYXVsdExlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICB9O1xuXG4gIC8vIHJlbW92ZSBhbGwgY29udGV4dHNcbiAgJCQuc3R5Zm4uY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3ByaXZhdGUubmV3U3R5bGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgJCQuc3R5Zm4ucmVzZXRUb0RlZmF1bHQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLmFkZERlZmF1bHRTdHlsZXNoZWV0KCk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBidWlsZHMgYSBzdHlsZSBvYmplY3QgZm9yIHRoZSAnY29yZScgc2VsZWN0b3JcbiAgJCQuc3R5Zm4uY29yZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlO1xuICB9O1xuXG4gIC8vIHBhcnNlIGEgcHJvcGVydHk7IHJldHVybiBudWxsIG9uIGludmFsaWQ7IHJldHVybiBwYXJzZWQgcHJvcGVydHkgb3RoZXJ3aXNlXG4gIC8vIGZpZWxkcyA6XG4gIC8vIC0gbmFtZSA6IHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAvLyAtIHZhbHVlIDogdGhlIHBhcnNlZCwgbmF0aXZlLXR5cGVkIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eVxuICAvLyAtIHN0clZhbHVlIDogYSBzdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpbiB2YWxpZCBjc3NcbiAgLy8gLSBieXBhc3MgOiB0cnVlIGlmZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHlcbiAgJCQuc3R5Zm4ucGFyc2UgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUsIHByb3BJc0J5cGFzcywgcHJvcElzRmxhdCApe1xuICAgIFxuICAgIG5hbWUgPSAkJC51dGlsLmNhbWVsMmRhc2goIG5hbWUgKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuICAgIHZhciBwcm9wZXJ0eSA9ICQkLnN0eWxlLnByb3BlcnRpZXNbIG5hbWUgXTtcbiAgICB2YXIgcGFzc2VkVmFsdWUgPSB2YWx1ZTtcbiAgICBcbiAgICBpZiggIXByb3BlcnR5ICl7IHJldHVybiBudWxsOyB9IC8vIHJldHVybiBudWxsIG9uIHByb3BlcnR5IG9mIHVua25vd24gbmFtZVxuICAgIGlmKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsICl7IHJldHVybiBudWxsOyB9IC8vIGNhbid0IGFzc2lnbiBudWxsXG5cbiAgICB2YXIgdmFsdWVJc1N0cmluZyA9ICQkLmlzLnN0cmluZyh2YWx1ZSk7XG4gICAgaWYoIHZhbHVlSXNTdHJpbmcgKXsgLy8gdHJpbSB0aGUgdmFsdWUgdG8gbWFrZSBwYXJzaW5nIGVhc2llclxuICAgICAgdmFsdWUgPSAkJC51dGlsLnRyaW0oIHZhbHVlICk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBwcm9wZXJ0eS50eXBlO1xuICAgIGlmKCAhdHlwZSApeyByZXR1cm4gbnVsbDsgfSAvLyBubyB0eXBlLCBubyBsdWNrXG5cbiAgICAvLyBjaGVjayBpZiBieXBhc3MgaXMgbnVsbCBvciBlbXB0eSBzdHJpbmcgKGkuZS4gaW5kaWNhdGlvbiB0byBkZWxldGUgYnlwYXNzIHByb3BlcnR5KVxuICAgIGlmKCBwcm9wSXNCeXBhc3MgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCkgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgYnlwYXNzOiB0cnVlLFxuICAgICAgICBkZWxldGVCeXBhc3M6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgbWFwcGVkXG4gICAgdmFyIGRhdGEsIG1hcERhdGEsIGxheW91dERhdGEsIG1hcExheW91dERhdGE7XG4gICAgaWYoICF2YWx1ZUlzU3RyaW5nIHx8IHByb3BJc0ZsYXQgKXtcbiAgICAgIC8vIHRoZW4gZG9uJ3QgYm90aGVyIHRvIGRvIHRoZSBleHBlbnNpdmUgcmVnZXggY2hlY2tzXG5cbiAgICB9IGVsc2UgaWYoXG4gICAgICAoIGRhdGEgPSBuZXcgUmVnRXhwKCAkJC5zdHlsZS50eXBlcy5kYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApIHx8XG4gICAgICAoIGxheW91dERhdGEgPSBuZXcgUmVnRXhwKCAkJC5zdHlsZS50eXBlcy5sYXlvdXREYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApXG4gICAgKXtcbiAgICAgIGlmKCBwcm9wSXNCeXBhc3MgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG4gICAgICBcbiAgICAgIHZhciBpc0xheW91dCA9IGxheW91dERhdGEgIT09IHVuZGVmaW5lZDtcbiAgICAgIGRhdGEgPSBkYXRhIHx8IGxheW91dERhdGE7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBkYXRhLFxuICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgbWFwcGVkOiBpc0xheW91dCA/ICQkLnN0eWxlLnR5cGVzLmxheW91dERhdGEgOiAkJC5zdHlsZS50eXBlcy5kYXRhLFxuICAgICAgICBmaWVsZDogZGF0YVsxXSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICAgIGhhc1BpZTogbmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKVxuICAgICAgfTtcblxuICAgIH0gZWxzZSBpZihcbiAgICAgICggbWFwRGF0YSA9IG5ldyBSZWdFeHAoICQkLnN0eWxlLnR5cGVzLm1hcERhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAgICggbWFwTGF5b3V0RGF0YSA9IG5ldyBSZWdFeHAoICQkLnN0eWxlLnR5cGVzLm1hcExheW91dERhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApIClcbiAgICApe1xuICAgICAgaWYoIHByb3BJc0J5cGFzcyApeyByZXR1cm4gZmFsc2U7IH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcblxuICAgICAgdmFyIGlzTGF5b3V0ID0gbWFwTGF5b3V0RGF0YSAhPT0gdW5kZWZpbmVkO1xuICAgICAgbWFwRGF0YSA9IG1hcERhdGEgfHwgbWFwTGF5b3V0RGF0YTtcblxuICAgICAgLy8gd2UgY2FuIG1hcCBvbmx5IGlmIHRoZSB0eXBlIGlzIGEgY29sb3VyIG9yIGEgbnVtYmVyXG4gICAgICBpZiggISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgdmFyIHZhbHVlTWluID0gdGhpcy5wYXJzZSggbmFtZSwgbWFwRGF0YVs0XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgICBpZiggIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgICAgdmFyIHZhbHVlTWF4ID0gdGhpcy5wYXJzZSggbmFtZSwgbWFwRGF0YVs1XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgICBpZiggIXZhbHVlTWF4IHx8IHZhbHVlTWF4Lm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgICAgLy8gY2hlY2sgaWYgdmFsdWVNaW4gYW5kIHZhbHVlTWF4IGFyZSB0aGUgc2FtZVxuICAgICAgaWYoIHZhbHVlTWluLnZhbHVlID09PSB2YWx1ZU1heC52YWx1ZSApe1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbid0IG1ha2UgbXVjaCBvZiBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICAgIHZhciBjMSA9IHZhbHVlTWluLnZhbHVlO1xuICAgICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzYW1lID0gYzFbMF0gPT09IGMyWzBdIC8vIHJlZFxuICAgICAgICAgICYmIGMxWzFdID09PSBjMlsxXSAvLyBncmVlblxuICAgICAgICAgICYmIGMxWzJdID09PSBjMlsyXSAvLyBibHVlXG4gICAgICAgICAgJiYgKCAvLyBvcHRpb25hbCBhbHBoYVxuICAgICAgICAgICAgYzFbM10gPT09IGMyWzNdIC8vIHNhbWUgYWxwaGEgb3V0cmlnaHRcbiAgICAgICAgICAgIHx8IChcbiAgICAgICAgICAgICAgKGMxWzNdID09IG51bGwgfHwgYzFbM10gPT09IDEpIC8vIGZ1bGwgb3BhY2l0eSBmb3IgY29sb3VyIDE/XG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAgIChjMlszXSA9PSBudWxsIHx8IGMyWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAyP1xuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgO1xuXG4gICAgICAgIGlmKCBzYW1lICl7IHJldHVybiBmYWxzZTsgfSAvLyBjYW4ndCBtYWtlIGEgbWFwcGVyIHdpdGhvdXQgYSByYW5nZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogbWFwRGF0YSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIG1hcHBlZDogaXNMYXlvdXQgPyAkJC5zdHlsZS50eXBlcy5tYXBMYXlvdXREYXRhIDogJCQuc3R5bGUudHlwZXMubWFwRGF0YSxcbiAgICAgICAgZmllbGQ6IG1hcERhdGFbMV0sXG4gICAgICAgIGZpZWxkTWluOiBwYXJzZUZsb2F0KCBtYXBEYXRhWzJdICksIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgICBmaWVsZE1heDogcGFyc2VGbG9hdCggbWFwRGF0YVszXSApLFxuICAgICAgICB2YWx1ZU1pbjogdmFsdWVNaW4udmFsdWUsXG4gICAgICAgIHZhbHVlTWF4OiB2YWx1ZU1heC52YWx1ZSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICAgIGhhc1BpZTogbmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayB0aGUgdHlwZSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBvYmplY3RcbiAgICBpZiggdHlwZS5udW1iZXIgKXsgXG4gICAgICB2YXIgdW5pdHM7XG4gICAgICB2YXIgaW1wbGljaXRVbml0cyA9ICdweCc7IC8vIG5vdCBzZXQgPT4gcHhcblxuICAgICAgaWYoIHR5cGUudW5pdHMgKXsgLy8gdXNlIHNwZWNpZmllZCB1bml0cyBpZiBzZXRcbiAgICAgICAgdW5pdHMgPSB0eXBlLnVuaXRzO1xuICAgICAgfVxuXG4gICAgICBpZiggdHlwZS5pbXBsaWNpdFVuaXRzICl7XG4gICAgICAgIGltcGxpY2l0VW5pdHMgPSB0eXBlLmltcGxpY2l0VW5pdHM7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdHlwZS51bml0bGVzcyApe1xuICAgICAgICBpZiggdmFsdWVJc1N0cmluZyApe1xuICAgICAgICAgIHZhciB1bml0c1JlZ2V4ID0gJ3B4fGVtJyArICh0eXBlLmFsbG93UGVyY2VudCA/ICd8XFxcXCUnIDogJycpO1xuICAgICAgICAgIGlmKCB1bml0cyApeyB1bml0c1JlZ2V4ID0gdW5pdHM7IH0gLy8gb25seSBhbGxvdyBleHBsaWNpdCB1bml0cyBpZiBzbyBzZXQgXG4gICAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goICdeKCcgKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArICcpKCcgKyB1bml0c1JlZ2V4ICsgJyk/JyArICckJyApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICAgICAgdmFsdWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHVuaXRzID0gbWF0Y2hbMl0gfHwgaW1wbGljaXRVbml0cztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIH0gZWxzZSBpZiggIXVuaXRzIHx8IHR5cGUuaW1wbGljaXRVbml0cyApIHtcbiAgICAgICAgICB1bml0cyA9IGltcGxpY2l0VW5pdHM7IC8vIGltcGxpY2l0bHkgcHggaWYgdW5zcGVjaWZpZWRcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG5cbiAgICAgIC8vIGlmIG5vdCBhIG51bWJlciBhbmQgZW51bXMgbm90IGFsbG93ZWQsIHRoZW4gdGhlIHZhbHVlIGlzIGludmFsaWRcbiAgICAgIGlmKCBpc05hTih2YWx1ZSkgJiYgdHlwZS5lbnVtcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiB0aGlzIG51bWJlciB0eXBlIGFsc28gYWNjZXB0cyBzcGVjaWFsIGtleXdvcmRzIGluIHBsYWNlIG9mIG51bWJlcnNcbiAgICAgIC8vIChpLmUuIGBsZWZ0YCwgYGF1dG9gLCBldGMpXG4gICAgICBpZiggaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB2YWx1ZSA9IHBhc3NlZFZhbHVlO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZS5lbnVtcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbaV07XG5cbiAgICAgICAgICBpZiggZW4gPT09IHZhbHVlICl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZmFpbGVkIG9uIGVudW0gYWZ0ZXIgZmFpbGluZyBvbiBudW1iZXJcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgdmFsdWUgbXVzdCBiZSBhbiBpbnRlZ2VyXG4gICAgICBpZiggdHlwZS5pbnRlZ2VyICYmICEkJC5pcy5pbnRlZ2VyKHZhbHVlKSApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgdmFsdWUgaXMgd2l0aGluIHJhbmdlXG4gICAgICBpZiggKHR5cGUubWluICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCB0eXBlLm1pbikgXG4gICAgICB8fCAodHlwZS5tYXggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IHR5cGUubWF4KVxuICAgICAgKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUgKyAodW5pdHMgPyB1bml0cyA6ICcnKSxcbiAgICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzcyxcbiAgICAgICAgaGFzUGllOiBuYW1lLm1hdGNoKC9waWUtKFxcZCspLWJhY2tncm91bmQtc2l6ZS8pICYmIHZhbHVlICE9IG51bGwgJiYgdmFsdWUgIT09IDAgJiYgdmFsdWUgIT09ICcnXG4gICAgICB9O1xuXG4gICAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gcGl4ZWxzXG4gICAgICBpZiggdHlwZS51bml0bGVzcyB8fCAodW5pdHMgIT09ICdweCcgJiYgdW5pdHMgIT09ICdlbScpICl7XG4gICAgICAgIC8vIHRoZW4gcHhWYWx1ZSBkb2VzIG5vdCBhcHBseVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB4VmFsdWUgPSAoIHVuaXRzID09PSAncHgnIHx8ICF1bml0cyA/ICh2YWx1ZSkgOiAodGhpcy5nZXRFbVNpemVJblBpeGVscygpICogdmFsdWUpICk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBtc1xuICAgICAgaWYoIHVuaXRzID09PSAnbXMnIHx8IHVuaXRzID09PSAncycgKXtcbiAgICAgICAgcmV0Lm1zVmFsdWUgPSB1bml0cyA9PT0gJ21zJyA/IHZhbHVlIDogMTAwMCAqIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuXG4gICAgfSBlbHNlIGlmKCB0eXBlLnByb3BMaXN0ICkge1xuXG4gICAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICAgIHZhciBwcm9wc1N0ciA9ICcnICsgdmFsdWU7ICAgICAgXG4gXG4gICAgICBpZiggcHJvcHNTdHIgPT09ICdub25lJyApe1xuICAgICAgICAvLyBsZWF2ZSBlbXB0eVxuXG4gICAgICB9IGVsc2UgeyAvLyBnbyBvdmVyIGVhY2ggcHJvcFxuXG4gICAgICAgIHZhciBwcm9wc1NwbGl0ID0gcHJvcHNTdHIuc3BsaXQoJywnKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wc1NwbGl0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIHByb3BOYW1lID0gJCQudXRpbC50cmltKCBwcm9wc1NwbGl0W2ldICk7XG5cbiAgICAgICAgICBpZiggJCQuc3R5bGUucHJvcGVydGllc1twcm9wTmFtZV0gKXtcbiAgICAgICAgICAgIHByb3BzLnB1c2goIHByb3BOYW1lICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBwcm9wcyxcbiAgICAgICAgc3RyVmFsdWU6IHByb3BzLmxlbmd0aCA9PT0gMCA/ICdub25lJyA6IHByb3BzLmpvaW4oJywgJyksXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICB2YXIgdHVwbGUgPSAkJC51dGlsLmNvbG9yMnR1cGxlKCB2YWx1ZSApO1xuXG4gICAgICBpZiggIXR1cGxlICl7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB0dXBsZSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIGlmKCB0eXBlLmVudW1zICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHR5cGUuZW51bXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVuID0gdHlwZS5lbnVtc1tpXTtcblxuICAgICAgICBpZiggZW4gPT09IHZhbHVlICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5yZWdleCApe1xuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCggdHlwZS5yZWdleCApOyAvLyBtYWtlIGEgcmVnZXggZnJvbSB0aGUgdHlwZVxuICAgICAgdmFyIG0gPSByZWdleC5leGVjKCB2YWx1ZSApO1xuXG4gICAgICBpZiggbSApeyAvLyByZWdleCBtYXRjaGVzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICB2YWx1ZTogbSxcbiAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHsgLy8gcmVnZXggZG9lc24ndCBtYXRjaFxuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZGlkbid0IG1hdGNoIHRoZSByZWdleCBzbyB0aGUgdmFsdWUgaXMgYm9ndXNcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiggdHlwZS5zdHJpbmcgKXtcbiAgICAgIC8vIGp1c3QgcmV0dXJuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgdHlwZSB3ZSBjYW4gaGFuZGxlXG4gICAgfVxuXG4gIH07XG5cbiAgLy8gY3JlYXRlIGEgbmV3IGNvbnRleHQgZnJvbSB0aGUgc3BlY2lmaWVkIHNlbGVjdG9yIHN0cmluZyBhbmQgc3dpdGNoIHRvIHRoYXQgY29udGV4dFxuICAkJC5zdHlmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWxlY3RvclN0ciApe1xuICAgIC8vICdjb3JlJyBpcyBhIHNwZWNpYWwgY2FzZSBhbmQgZG9lcyBub3QgbmVlZCBhIHNlbGVjdG9yXG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JTdHIgPT09ICdjb3JlJyA/IG51bGwgOiBuZXcgJCQuU2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG5cbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7IC8vIG5ldyBjb250ZXh0IG1lYW5zIG5ldyBpbmRleFxuICAgIHRoaXNbaV0gPSB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICAgIG1hcHBlZFByb3BlcnRpZXM6IFtdLFxuICAgICAgaW5kZXg6IGlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gYWRkIG9uZSBvciBtYW55IGNzcyBydWxlcyB0byB0aGUgY3VycmVudCBjb250ZXh0XG4gICQkLnN0eWZuLmNzcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gICAgY2FzZSAxOlxuICAgICAgdmFyIG1hcCA9IGFyZ3NbMF07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBtYXBWYWwgPSBtYXBbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBtYXBWYWwgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIG1hcFZhbCA9IG1hcFsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBtYXBWYWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHRoaXMuY3NzUnVsZSggcHJvcC5uYW1lLCBtYXBWYWwgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMjpcbiAgICAgIHRoaXMuY3NzUnVsZSggYXJnc1swXSwgYXJnc1sxXSApO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7IC8vIGRvIG5vdGhpbmcgaWYgYXJncyBhcmUgaW52YWxpZFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGFkZCBhIHNpbmdsZSBjc3MgcnVsZSB0byB0aGUgY3VycmVudCBjb250ZXh0XG4gICQkLnN0eWZuLmNzc1J1bGUgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXsgXG4gICAgLy8gbmFtZS12YWx1ZSBwYWlyXG4gICAgdmFyIHByb3BlcnR5ID0gdGhpcy5wYXJzZSggbmFtZSwgdmFsdWUgKTtcblxuICAgIC8vIGFkZCBwcm9wZXJ0eSB0byBjdXJyZW50IGNvbnRleHQgaWYgdmFsaWRcbiAgICBpZiggcHJvcGVydHkgKXtcbiAgICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goIHByb3BlcnR5ICk7XG4gICAgICB0aGlzW2ldLnByb3BlcnRpZXNbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5OyAvLyBhbGxvdyBhY2Nlc3MgYnkgbmFtZSBhcyB3ZWxsXG5cbiAgICAgIGlmKCBwcm9wZXJ0eS5oYXNQaWUgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oYXNQaWUgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggcHJvcGVydHkubWFwcGVkICl7XG4gICAgICAgIHRoaXNbaV0ubWFwcGVkUHJvcGVydGllcy5wdXNoKCBwcm9wZXJ0eSApO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdG8gY29yZSBzdHlsZSBpZiBuZWNlc3NhcnlcbiAgICAgIHZhciBjdXJyZW50U2VsZWN0b3JJc0NvcmUgPSAhdGhpc1tpXS5zZWxlY3RvcjtcbiAgICAgIGlmKCBjdXJyZW50U2VsZWN0b3JJc0NvcmUgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5jb3JlU3R5bGVbIHByb3BlcnR5Lm5hbWUgXSA9IHByb3BlcnR5O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIChwb3RlbnRpYWxseSBleHBlbnNpdmUgY2FsY3VsYXRpb24pXG4gIC8vIGFwcGx5IHRoZSBzdHlsZSB0byB0aGUgZWxlbWVudCBiYXNlZCBvblxuICAvLyAtIGl0cyBieXBhc3NcbiAgLy8gLSB3aGF0IHNlbGVjdG9ycyBtYXRjaCBpdFxuICAkJC5zdHlmbi5hcHBseSA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYoIHNlbGYuX3ByaXZhdGUubmV3U3R5bGUgKXsgLy8gY2xlYXIgc3R5bGUgY2FjaGVzXG4gICAgICB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB7fTtcbiAgICAgIHRoaXMuX3ByaXZhdGUucHJvcERpZmZzID0ge307XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaWUgPSAwOyBpZSA8IGVsZXMubGVuZ3RoOyBpZSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpZV07XG4gICAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoIGVsZSApO1xuICAgICAgdmFyIGN4dFN0eWxlID0gc2VsZi5nZXRDb250ZXh0U3R5bGUoIGN4dE1ldGEgKTtcbiAgICAgIHZhciBhcHAgPSBzZWxmLmFwcGx5Q29udGV4dFN0eWxlKCBjeHRNZXRhLCBjeHRTdHlsZSwgZWxlICk7XG5cbiAgICAgIHNlbGYudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgYXBwLmRpZmZQcm9wcyApO1xuICAgICAgc2VsZi51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcblxuICAgIH0gLy8gZm9yIGVsZW1lbnRzXG5cbiAgICBzZWxmLl9wcml2YXRlLm5ld1N0eWxlID0gZmFsc2U7XG4gIH07XG5cbiAgJCQuc3R5Zm4uZ2V0UHJvcGVydGllc0RpZmYgPSBmdW5jdGlvbiggb2xkQ3h0S2V5LCBuZXdDeHRLZXkgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNhY2hlID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyB8fCB7fTtcbiAgICB2YXIgZHVhbEN4dEtleSA9IG9sZEN4dEtleSArICctJyArIG5ld0N4dEtleTtcbiAgICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZHVhbEN4dEtleV07XG5cbiAgICBpZiggY2FjaGVkVmFsICl7XG4gICAgICByZXR1cm4gY2FjaGVkVmFsO1xuICAgIH1cblxuICAgIHZhciBkaWZmUHJvcHMgPSBbXTtcbiAgICB2YXIgYWRkZWRQcm9wID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgICAgdmFyIG9sZEhhc0N4dCA9IG9sZEN4dEtleVtpXSA9PT0gJ3QnO1xuICAgICAgdmFyIG5ld0hhc0N4dCA9IG5ld0N4dEtleVtpXSA9PT0gJ3QnO1xuICAgICAgdmFyIGN4dEhhc0RpZmZlZCA9IG9sZEhhc0N4dCAhPT0gbmV3SGFzQ3h0O1xuICAgICAgdmFyIGN4dEhhc01hcHBlZFByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXMubGVuZ3RoID4gMDtcblxuICAgICAgaWYoIGN4dEhhc0RpZmZlZCB8fCBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgICB2YXIgcHJvcHM7XG5cbiAgICAgICAgaWYoIGN4dEhhc0RpZmZlZCAmJiBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIHN1ZmZpY2VzIGIvYyBtYXBwZWRQcm9wZXJ0aWVzIGlzIGEgc3Vic2V0IG9mIHByb3BlcnRpZXNcbiAgICAgICAgfSBlbHNlIGlmKCBjeHRIYXNEaWZmZWQgKXtcbiAgICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBuZWVkIHRvIGNoZWNrIHRoZW0gYWxsXG4gICAgICAgIH0gZWxzZSBpZiggY3h0SGFzTWFwcGVkUHJvcHMgKXtcbiAgICAgICAgICBwcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzOyAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgbWFwcGVkXG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcblxuICAgICAgICAgIC8vIGlmIGEgbGF0ZXIgY29udGV4dCBvdmVycmlkZXMgdGhpcyBwcm9wZXJ0eSwgdGhlbiB0aGUgZmFjdCB0aGF0IHRoaXMgY29udGV4dCBoYXMgc3dpdGNoZWQvZGlmZmVkIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgLy8gKHNlbWkgZXhwZW5zaXZlIGNoZWNrIHNpbmNlIGl0IG1ha2VzIHRoaXMgZnVuY3Rpb24gTyhuXjIpIG9uIGNvbnRleHQgbGVuZ3RoLCBidXQgd29ydGggaXQgc2luY2Ugb3ZlcmFsbCByZXN1bHRcbiAgICAgICAgICAvLyBpcyBjYWNoZWQpXG4gICAgICAgICAgdmFyIGxhdGVyQ3h0T3ZlcnJpZGVzID0gZmFsc2U7IFxuICAgICAgICAgIGZvciggdmFyIGsgPSBpICsgMTsgayA8IHNlbGYubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgICAgIHZhciBsYXRlckN4dCA9IHNlbGZba107XG4gICAgICAgICAgICB2YXIgaGFzTGF0ZXJDeHQgPSBuZXdDeHRLZXlba10gPT09ICd0JztcblxuICAgICAgICAgICAgaWYoICFoYXNMYXRlckN4dCApeyBjb250aW51ZTsgfSAvLyBjYW4ndCBvdmVycmlkZSB1bmxlc3MgdGhlIGNvbnRleHQgaXMgYWN0aXZlXG5cbiAgICAgICAgICAgIGxhdGVyQ3h0T3ZlcnJpZGVzID0gbGF0ZXJDeHQucHJvcGVydGllc1sgcHJvcC5uYW1lIF0gIT0gbnVsbDtcblxuICAgICAgICAgICAgaWYoIGxhdGVyQ3h0T3ZlcnJpZGVzICl7IGJyZWFrOyB9IC8vIGV4aXQgZWFybHkgYXMgbG9uZyBhcyBvbmUgbGF0ZXIgY29udGV4dCBvdmVycmlkZXNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIWFkZGVkUHJvcFtuYW1lXSAmJiAhbGF0ZXJDeHRPdmVycmlkZXMgKXtcbiAgICAgICAgICAgIGFkZGVkUHJvcFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICBkaWZmUHJvcHMucHVzaCggbmFtZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3IgcHJvcHNcbiAgICAgIH0gLy8gaWZcblxuICAgIH0gLy8gZm9yIGNvbnRleHRzXG5cbiAgICBjYWNoZVsgZHVhbEN4dEtleSBdID0gZGlmZlByb3BzO1xuICAgIHJldHVybiBkaWZmUHJvcHM7XG4gIH07XG5cbiAgJCQuc3R5Zm4uZ2V0Q29udGV4dE1ldGEgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeHRLZXkgPSAnJztcbiAgICB2YXIgZGlmZlByb3BzO1xuICAgIHZhciBwcmV2S2V5ID0gZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5IHx8ICcnO1xuXG4gICAgaWYoIHNlbGYuX3ByaXZhdGUubmV3U3R5bGUgKXtcbiAgICAgIHByZXZLZXkgPSAnJzsgLy8gc2luY2Ugd2UgbmVlZCB0byBhcHBseSBhbGwgc3R5bGUgaWYgYSBmcmVzaCBzdHlsZXNoZWV0XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBjeHQga2V5XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY29udGV4dCA9IHNlbGZbaV07XG4gICAgICB2YXIgY29udGV4dFNlbGVjdG9yTWF0Y2hlcyA9IGNvbnRleHQuc2VsZWN0b3IgJiYgY29udGV4dC5zZWxlY3Rvci5tYXRjaGVzKCBlbGUgKTsgLy8gTkI6IGNvbnRleHQuc2VsZWN0b3IgbWF5IGJlIG51bGwgZm9yICdjb3JlJ1xuXG4gICAgICBpZiggY29udGV4dFNlbGVjdG9yTWF0Y2hlcyApe1xuICAgICAgICBjeHRLZXkgKz0gJ3QnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3h0S2V5ICs9ICdmJztcbiAgICAgIH1cbiAgICB9IC8vIGZvciBjb250ZXh0XG5cbiAgICBkaWZmUHJvcHMgPSBzZWxmLmdldFByb3BlcnRpZXNEaWZmKCBwcmV2S2V5LCBjeHRLZXkgKTtcblxuICAgIGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSA9IGN4dEtleTtcblxuICAgIHJldHVybiB7XG4gICAgICBrZXk6IGN4dEtleSxcbiAgICAgIGRpZmZQcm9wTmFtZXM6IGRpZmZQcm9wc1xuICAgIH07XG4gIH07XG5cbiAgLy8gZ2V0cyBhIGNvbXB1dGVkIGVsZSBzdHlsZSBvYmplY3QgYmFzZWQgb24gbWF0Y2hlZCBjb250ZXh0c1xuICAkJC5zdHlmbi5nZXRDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiggY3h0TWV0YSApe1xuICAgIHZhciBjeHRLZXkgPSBjeHRNZXRhLmtleTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyA9IHRoaXMuX3ByaXZhdGUuY29udGV4dFN0eWxlcyB8fCB7fTtcblxuICAgIC8vIGlmIGFscmVhZHkgY29tcHV0ZWQgc3R5bGUsIHJldHVybmVkIGNhY2hlZCBjb3B5XG4gICAgaWYoIGN4dFN0eWxlc1tjeHRLZXldICl7IHJldHVybiBjeHRTdHlsZXNbY3h0S2V5XTsgfVxuXG4gICAgdmFyIHN0eWxlID0ge1xuICAgICAgX3ByaXZhdGU6IHtcbiAgICAgICAga2V5OiBjeHRLZXlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICAgIHZhciBoYXNDeHQgPSBjeHRLZXlbaV0gPT09ICd0JztcblxuICAgICAgaWYoICFoYXNDeHQgKXsgY29udGludWU7IH1cblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjeHQucHJvcGVydGllcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgcHJvcCA9IGN4dC5wcm9wZXJ0aWVzW2pdO1xuICAgICAgICB2YXIgc3R5UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3A7XG5cbiAgICAgICAgc3R5UHJvcC5jb250ZXh0ID0gY3h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGN4dFN0eWxlc1tjeHRLZXldID0gc3R5bGU7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gICQkLnN0eWZuLmFwcGx5Q29udGV4dFN0eWxlID0gZnVuY3Rpb24oIGN4dE1ldGEsIGN4dFN0eWxlLCBlbGUgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRpZmZQcm9wcyA9IGN4dE1ldGEuZGlmZlByb3BOYW1lcztcbiAgICB2YXIgcmV0RGlmZlByb3BzID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRpZmZQcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGRpZmZQcm9wTmFtZSA9IGRpZmZQcm9wc1tpXTtcbiAgICAgIHZhciBjeHRQcm9wID0gY3h0U3R5bGVbIGRpZmZQcm9wTmFtZSBdO1xuICAgICAgdmFyIGVsZVByb3AgPSBlbGUuX3ByaXZhdGUuc3R5bGVbIGRpZmZQcm9wTmFtZSBdO1xuXG4gICAgICAvLyBzYXZlIGN5Y2xlcyB3aGVuIHRoZSBjb250ZXh0IHByb3AgZG9lc24ndCBuZWVkIHRvIGJlIGFwcGxpZWRcbiAgICAgIGlmKCAhY3h0UHJvcCB8fCBlbGVQcm9wID09PSBjeHRQcm9wICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIHZhciByZXREaWZmUHJvcCA9IHJldERpZmZQcm9wc1sgZGlmZlByb3BOYW1lIF0gPSB7XG4gICAgICAgIHByZXY6IGVsZVByb3BcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuYXBwbHlQYXJzZWRQcm9wZXJ0eSggZWxlLCBjeHRQcm9wICk7XG5cbiAgICAgIHJldERpZmZQcm9wLm5leHQgPSBlbGUuX3ByaXZhdGUuc3R5bGVbIGRpZmZQcm9wTmFtZSBdO1xuXG4gICAgICBpZiggcmV0RGlmZlByb3AubmV4dCAmJiByZXREaWZmUHJvcC5uZXh0LmJ5cGFzcyApe1xuICAgICAgICByZXREaWZmUHJvcC5uZXh0ID0gcmV0RGlmZlByb3AubmV4dC5ieXBhc3NlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGlmZlByb3BzOiByZXREaWZmUHJvcHNcbiAgICB9O1xuICB9O1xuXG4gICQkLnN0eWZuLnVwZGF0ZVN0eWxlSGludHMgPSBmdW5jdGlvbihlbGUpe1xuICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG5cbiAgICAvLyBzZXQgd2hldGhlciBoYXMgcGllIG9yIG5vdDsgZm9yIGdyZWF0ZXIgZWZmaWNpZW5jeVxuICAgIHZhciBoYXNQaWUgPSBmYWxzZTtcbiAgICBpZiggX3AuZ3JvdXAgPT09ICdub2RlcycgJiYgc2VsZi5fcHJpdmF0ZS5oYXNQaWUgKXtcbiAgICAgIGZvciggdmFyIGkgPSAxOyBpIDw9ICQkLnN0eWxlLnBpZUJhY2tncm91bmROOyBpKysgKXsgLy8gMS4uTlxuICAgICAgICB2YXIgc2l6ZSA9IF9wLnN0eWxlWydwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtc2l6ZSddLnZhbHVlO1xuXG4gICAgICAgIGlmKCBzaXplID4gMCApe1xuICAgICAgICAgIGhhc1BpZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcC5oYXNQaWUgPSBoYXNQaWU7XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gc3R5bGVbJ3RleHQtdHJhbnNmb3JtJ10uc3RyVmFsdWU7XG4gICAgdmFyIGNvbnRlbnQgPSBzdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuICAgIHZhciBmU3R5bGUgPSBzdHlsZVsnZm9udC1zdHlsZSddLnN0clZhbHVlO1xuICAgIHZhciBzaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddLnB4VmFsdWUgKyAncHgnO1xuICAgIHZhciBmYW1pbHkgPSBzdHlsZVsnZm9udC1mYW1pbHknXS5zdHJWYWx1ZTtcbiAgICAvLyB2YXIgdmFyaWFudCA9IHN0eWxlWydmb250LXZhcmlhbnQnXS5zdHJWYWx1ZTtcbiAgICB2YXIgd2VpZ2h0ID0gc3R5bGVbJ2ZvbnQtd2VpZ2h0J10uc3RyVmFsdWU7XG4gICAgdmFyIHZhbGlnbiA9IHN0eWxlWyd0ZXh0LXZhbGlnbiddLnN0clZhbHVlO1xuICAgIHZhciBoYWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgb1dpZHRoID0gc3R5bGVbJ3RleHQtb3V0bGluZS13aWR0aCddLnB4VmFsdWU7XG4gICAgX3AubGFiZWxLZXkgPSBmU3R5bGUgKyckJysgc2l6ZSArJyQnKyBmYW1pbHkgKyckJysgd2VpZ2h0ICsnJCcrIGNvbnRlbnQgKyckJysgdHJhbnNmb3JtICsnJCcrIHZhbGlnbiArJyQnKyBoYWxpZ24gKyckJysgb1dpZHRoO1xuICAgIF9wLmZvbnRLZXkgPSBmU3R5bGUgKyckJysgd2VpZ2h0ICsnJCcrIHNpemUgKyckJysgZmFtaWx5O1xuXG4gICAgdmFyIHdpZHRoID0gc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZTtcbiAgICB2YXIgaGVpZ2h0ID0gc3R5bGVbJ2hlaWdodCddLnB4VmFsdWU7XG4gICAgdmFyIGJvcmRlclcgPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcbiAgICBfcC5ib3VuZGluZ0JveEtleSA9IHdpZHRoICsnJCcrIGhlaWdodCArJyQnKyBib3JkZXJXO1xuXG4gICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgICAgdmFyIGNwc3MgPSBzdHlsZVsnY29udHJvbC1wb2ludC1zdGVwLXNpemUnXS5weFZhbHVlO1xuICAgICAgdmFyIGNwZCA9IHN0eWxlWydjb250cm9sLXBvaW50LWRpc3RhbmNlJ10gPyBzdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZSddLnB4VmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgY3B3ID0gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0J10udmFsdWU7XG4gICAgICB2YXIgY3VydmUgPSBzdHlsZVsnY3VydmUtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgICAgIFxuICAgICAgX3AuYm91bmRpbmdCb3hLZXkgKz0gJyQnKyBjcHNzICsnJCcrIGNwZCArJyQnKyBjcHcgKyckJysgY3VydmU7XG4gICAgfVxuXG4gICAgX3Auc3R5bGVLZXkgPSBEYXRlLm5vdygpOyAvLyBwcm9iYWJseSBzYWZlIHRvIHVzZSBhcHBsaWVkIHRpbWUgYW5kIG11Y2ggZmFzdGVyXG4gICAgLy8gZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgLy8gICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgLy8gICB2YXIgZWxlUHJvcCA9IF9wLnN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAvLyAgIHZhciB2YWwgPSBlbGVQcm9wICYmIGVsZVByb3Auc3RyVmFsdWUgPyBlbGVQcm9wLnN0clZhbHVlIDogJ3VuZGVmaW5lZCc7XG5cbiAgICAvLyAgIF9wLnN0eWxlS2V5ICs9ICckJyArIHZhbDtcbiAgICAvLyB9XG4gIH07XG5cbiAgLy8gYXBwbHkgYSBwcm9wZXJ0eSB0byB0aGUgc3R5bGUgKGZvciBpbnRlcm5hbCB1c2UpXG4gIC8vIHJldHVybnMgd2hldGhlciBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAvL1xuICAvLyBub3csIHRoaXMgZnVuY3Rpb24gZmxhdHRlbnMgdGhlIHByb3BlcnR5LCBhbmQgaGVyZSdzIGhvdzpcbiAgLy9cbiAgLy8gZm9yIHBhcnNlZFByb3A6eyBieXBhc3M6IHRydWUsIGRlbGV0ZUJ5cGFzczogdHJ1ZSB9XG4gIC8vIG5vIHByb3BlcnR5IGlzIGdlbmVyYXRlZCwgaW5zdGVhZCB0aGUgYnlwYXNzIHByb3BlcnR5IGluIHRoZVxuICAvLyBlbGVtZW50J3Mgc3R5bGUgaXMgcmVwbGFjZWQgYnkgd2hhdCdzIHBvaW50ZWQgdG8gYnkgdGhlIGBieXBhc3NlZGBcbiAgLy8gZmllbGQgaW4gdGhlIGJ5cGFzcyBwcm9wZXJ0eSAoaS5lLiByZXN0b3JpbmcgdGhlIHByb3BlcnR5IHRoZVxuICAvLyBieXBhc3Mgd2FzIG92ZXJyaWRpbmcpXG4gIC8vXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgbWFwcGVkOiB0cnV0aHkgfVxuICAvLyB0aGUgZ2VuZXJhdGVkIGZsYXR0ZW5lZFByb3A6eyBtYXBwaW5nOiBwcm9wIH1cbiAgLy8gXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlIH1cbiAgLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgYnlwYXNzZWQ6IHBhcnNlZFByb3AgfSBcbiAgJCQuc3R5Zm4uYXBwbHlQYXJzZWRQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBlbGUsIHBhcnNlZFByb3AgKXtcbiAgICB2YXIgcHJvcCA9IHBhcnNlZFByb3A7XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBmaWVsZFZhbCwgZmxhdFByb3A7XG4gICAgdmFyIHR5cGUgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzWyBwcm9wLm5hbWUgXS50eXBlO1xuICAgIHZhciBwcm9wSXNCeXBhc3MgPSBwcm9wLmJ5cGFzcztcbiAgICB2YXIgb3JpZ1Byb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgdmFyIG9yaWdQcm9wSXNCeXBhc3MgPSBvcmlnUHJvcCAmJiBvcmlnUHJvcC5ieXBhc3M7XG5cbiAgICAvLyBjYW4ndCBhcHBseSBhdXRvIHRvIHdpZHRoIG9yIGhlaWdodCB1bmxlc3MgaXQncyBhIHBhcmVudCBub2RlXG4gICAgaWYoIChwYXJzZWRQcm9wLm5hbWUgPT09ICdoZWlnaHQnIHx8IHBhcnNlZFByb3AubmFtZSA9PT0gJ3dpZHRoJykgJiYgcGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2F1dG8nICYmIGVsZS5pc05vZGUoKSAmJiAhZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBieXBhc3NcbiAgICBpZiggcHJvcElzQnlwYXNzICYmIHByb3AuZGVsZXRlQnlwYXNzICl7IC8vIHRoZW4gdGhpcyBwcm9wZXJ0eSBpcyBqdXN0IGhlcmUgdG8gaW5kaWNhdGUgd2UgbmVlZCB0byBkZWxldGVcbiAgICAgIHZhciBjdXJyZW50UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgICAgLy8gY2FuIG9ubHkgZGVsZXRlIGlmIHRoZSBjdXJyZW50IHByb3AgaXMgYSBieXBhc3MgYW5kIGl0IHBvaW50cyB0byB0aGUgcHJvcGVydHkgaXQgd2FzIG92ZXJyaWRpbmdcbiAgICAgIGlmKCAhY3VycmVudFByb3AgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIHByb3BlcnR5IGlzIGFscmVhZHkgbm90IGRlZmluZWRcbiAgICAgIH0gZWxzZSBpZiggY3VycmVudFByb3AuYnlwYXNzICYmIGN1cnJlbnRQcm9wLmJ5cGFzc2VkICl7IC8vIHRoZW4gcmVwbGFjZSB0aGUgYnlwYXNzIHByb3BlcnR5IHdpdGggdGhlIG9yaWdpbmFsXG4gICAgICAgIFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBieXBhc3NlZCBwcm9wZXJ0eSB3YXMgYWxyZWFkeSBhcHBsaWVkIChhbmQgdGhlcmVmb3JlIHBhcnNlZCksIHdlIGNhbiBqdXN0IHJlcGxhY2UgaXQgKG5vIHJlYXBwbHlpbmcgbmVjZXNzYXJ5KVxuICAgICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBjdXJyZW50UHJvcC5ieXBhc3NlZDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgdW5zdWNjZXNzZnVsIGRlbGV0aW5nIHRoZSBieXBhc3NcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJpbnRNYXBwaW5nRXJyID0gZnVuY3Rpb24oKXtcbiAgICAgICQkLnV0aWwuZXJyb3IoJ0RvIG5vdCBhc3NpZ24gbWFwcGluZ3MgdG8gZWxlbWVudHMgd2l0aG91dCBjb3JyZXNwb25kaW5nIGRhdGEgKGUuZy4gZWxlIGAnKyBlbGUuaWQoKSArJ2AgZm9yIHByb3BlcnR5IGAnKyBwcm9wLm5hbWUgKydgIHdpdGggZGF0YSBmaWVsZCBgJysgcHJvcC5maWVsZCArJ2ApOyB0cnkgYSBgWycrIHByb3AuZmllbGQgKyddYCBzZWxlY3RvciB0byBsaW1pdCBzY29wZSB0byBlbGVtZW50cyB3aXRoIGAnKyBwcm9wLmZpZWxkICsnYCBkZWZpbmVkJyk7XG4gICAgfTtcblxuICAgIC8vIHB1dCB0aGUgcHJvcGVydHkgaW4gdGhlIHN0eWxlIG9iamVjdHNcbiAgICBzd2l0Y2goIHByb3AubWFwcGVkICl7IC8vIGZsYXR0ZW4gdGhlIHByb3BlcnR5IGlmIG1hcHBlZFxuICAgIGNhc2UgJCQuc3R5bGUudHlwZXMubWFwRGF0YTpcbiAgICBjYXNlICQkLnN0eWxlLnR5cGVzLm1hcExheW91dERhdGE6XG4gICAgICBcbiAgICAgIHZhciBpc0xheW91dCA9IHByb3AubWFwcGVkID09PSAkJC5zdHlsZS50eXBlcy5tYXBMYXlvdXREYXRhO1xuXG4gICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgZmllbGRWYWwgPSBpc0xheW91dCA/IGVsZS5fcHJpdmF0ZS5sYXlvdXREYXRhIDogZWxlLl9wcml2YXRlLmRhdGE7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGggJiYgZmllbGRWYWw7IGkrKyApe1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbIGZpZWxkIF07XG4gICAgICB9XG5cbiAgICAgIHZhciBwZXJjZW50O1xuICAgICAgaWYoICEkJC5pcy5udW1iZXIoZmllbGRWYWwpICl7IC8vIHRoZW4ga2VlcCB0aGUgbWFwcGluZyBidXQgYXNzdW1lIDAlIGZvciBub3dcbiAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJjZW50ID0gKGZpZWxkVmFsIC0gcHJvcC5maWVsZE1pbikgLyAocHJvcC5maWVsZE1heCAtIHByb3AuZmllbGRNaW4pO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gYm91bmQgcGVyY2VudCB2YWx1ZVxuICAgICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgfSBlbHNlIGlmKCBwZXJjZW50ID4gMSApe1xuICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGUuY29sb3IgKXtcbiAgICAgICAgdmFyIHIxID0gcHJvcC52YWx1ZU1pblswXTtcbiAgICAgICAgdmFyIHIyID0gcHJvcC52YWx1ZU1heFswXTtcbiAgICAgICAgdmFyIGcxID0gcHJvcC52YWx1ZU1pblsxXTtcbiAgICAgICAgdmFyIGcyID0gcHJvcC52YWx1ZU1heFsxXTtcbiAgICAgICAgdmFyIGIxID0gcHJvcC52YWx1ZU1pblsyXTtcbiAgICAgICAgdmFyIGIyID0gcHJvcC52YWx1ZU1heFsyXTtcbiAgICAgICAgdmFyIGExID0gcHJvcC52YWx1ZU1pblszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNaW5bM107XG4gICAgICAgIHZhciBhMiA9IHByb3AudmFsdWVNYXhbM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWF4WzNdO1xuXG4gICAgICAgIHZhciBjbHIgPSBbXG4gICAgICAgICAgTWF0aC5yb3VuZCggcjEgKyAocjIgLSByMSkqcGVyY2VudCApLFxuICAgICAgICAgIE1hdGgucm91bmQoIGcxICsgKGcyIC0gZzEpKnBlcmNlbnQgKSxcbiAgICAgICAgICBNYXRoLnJvdW5kKCBiMSArIChiMiAtIGIxKSpwZXJjZW50ICksXG4gICAgICAgICAgTWF0aC5yb3VuZCggYTEgKyAoYTIgLSBhMSkqcGVyY2VudCApXG4gICAgICAgIF07XG5cbiAgICAgICAgZmxhdFByb3AgPSB7IC8vIGNvbG91cnMgYXJlIHNpbXBsZSwgc28ganVzdCBjcmVhdGUgdGhlIGZsYXQgcHJvcGVydHkgaW5zdGVhZCBvZiBleHBlbnNpdmUgc3RyaW5nIHBhcnNpbmdcbiAgICAgICAgICBieXBhc3M6IHByb3AuYnlwYXNzLCAvLyB3ZSdyZSBhIGJ5cGFzcyBpZiB0aGUgbWFwcGluZyBwcm9wZXJ0eSBpcyBhIGJ5cGFzc1xuICAgICAgICAgIG5hbWU6IHByb3AubmFtZSxcbiAgICAgICAgICB2YWx1ZTogY2xyLFxuICAgICAgICAgIHN0clZhbHVlOiAncmdiKCcgKyBjbHJbMF0gKyAnLCAnICsgY2xyWzFdICsgJywgJyArIGNsclsyXSArICcpJ1xuICAgICAgICB9O1xuICAgICAgXG4gICAgICB9IGVsc2UgaWYoIHR5cGUubnVtYmVyICl7XG4gICAgICAgIHZhciBjYWxjVmFsdWUgPSBwcm9wLnZhbHVlTWluICsgKHByb3AudmFsdWVNYXggLSBwcm9wLnZhbHVlTWluKSAqIHBlcmNlbnQ7XG4gICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBjYWxjVmFsdWUsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gY2FuIG9ubHkgbWFwIHRvIGNvbG91cnMgYW5kIG51bWJlcnNcbiAgICAgIH1cblxuICAgICAgaWYoICFmbGF0UHJvcCApeyAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBvcmlnUHJvcC5zdHJWYWx1ZSwgcHJvcC5ieXBhc3MsIHRydWUgKTtcbiAgICAgIH0gXG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgcHJpbnRNYXBwaW5nRXJyKCk7IH1cbiAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgLy8gZGlyZWN0IG1hcHBpbmcgIFxuICAgIGNhc2UgJCQuc3R5bGUudHlwZXMuZGF0YTogXG4gICAgY2FzZSAkJC5zdHlsZS50eXBlcy5sYXlvdXREYXRhOiBcblxuICAgICAgdmFyIGlzTGF5b3V0ID0gcHJvcC5tYXBwZWQgPT09ICQkLnN0eWxlLnR5cGVzLmxheW91dERhdGE7XG5cbiAgICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICAgIHZhciBmaWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KFwiLlwiKTtcbiAgICAgIHZhciBmaWVsZFZhbCA9IGlzTGF5b3V0ID8gZWxlLl9wcml2YXRlLmxheW91dERhdGEgOiBlbGUuX3ByaXZhdGUuZGF0YTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrICl7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgZmllbGRWYWwgPSBmaWVsZFZhbFsgZmllbGQgXTtcbiAgICAgIH1cblxuICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIGZpZWxkVmFsLCBwcm9wLmJ5cGFzcywgdHJ1ZSApO1xuXG4gICAgICBpZiggIWZsYXRQcm9wICl7IC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIHVzZSB0aGUgb3JpZ1Byb3Agc28gd2Ugc3RpbGwga2VlcCB0aGUgbWFwcGluZyBpdHNlbGZcbiAgICAgICAgdmFyIGZsYXRQcm9wVmFsID0gb3JpZ1Byb3AgPyBvcmlnUHJvcC5zdHJWYWx1ZSA6ICcnO1xuXG4gICAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmbGF0UHJvcFZhbCwgcHJvcC5ieXBhc3MsIHRydWUgKTtcbiAgICAgIH1cblxuICAgICAgaWYoICFmbGF0UHJvcCApeyBwcmludE1hcHBpbmdFcnIoKTsgfVxuICAgICAgZmxhdFByb3AubWFwcGluZyA9IHByb3A7IC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIG1hcHBpbmdcbiAgICAgIHByb3AgPSBmbGF0UHJvcDsgLy8gdGhlIGZsYXR0ZW5lZCAobWFwcGVkKSBwcm9wZXJ0eSBpcyB0aGUgb25lIHdlIHdhbnRcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICBicmVhazsgLy8ganVzdCBzZXQgdGhlIHByb3BlcnR5XG5cbiAgICBkZWZhdWx0OiBcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90IGEgdmFsaWQgbWFwcGluZ1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eSwgdGhlbiBsaW5rIHRoZSByZXN1bHRhbnQgcHJvcGVydHkgdG8gdGhlIG9yaWdpbmFsIG9uZVxuICAgIGlmKCBwcm9wSXNCeXBhc3MgKXtcbiAgICAgIGlmKCBvcmlnUHJvcElzQnlwYXNzICl7IC8vIHRoZW4gdGhpcyBieXBhc3Mgb3ZlcnJpZGVzIHRoZSBleGlzdGluZyBvbmVcbiAgICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wLmJ5cGFzc2VkOyAvLyBzdGVhbCBieXBhc3NlZCBwcm9wIGZyb20gb2xkIGJ5cGFzc1xuICAgICAgfSBlbHNlIHsgLy8gdGhlbiBsaW5rIHRoZSBvcmlnIHByb3AgdG8gdGhlIG5ldyBieXBhc3NcbiAgICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wO1xuICAgICAgfVxuXG4gICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wOyAvLyBhbmQgc2V0XG4gICAgXG4gICAgfSBlbHNlIHsgLy8gcHJvcCBpcyBub3QgYnlwYXNzXG4gICAgICBpZiggb3JpZ1Byb3BJc0J5cGFzcyApeyAvLyB0aGVuIGtlZXAgdGhlIG9yaWcgcHJvcCAoc2luY2UgaXQncyBhIGJ5cGFzcykgYW5kIGxpbmsgdG8gdGhlIG5ldyBwcm9wXG4gICAgICAgIG9yaWdQcm9wLmJ5cGFzc2VkID0gcHJvcDtcbiAgICAgIH0gZWxzZSB7IC8vIHRoZW4ganVzdCByZXBsYWNlIHRoZSBvbGQgcHJvcCB3aXRoIHRoZSBuZXcgb25lXG4gICAgICAgIHN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3A7IFxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIHVwZGF0ZXMgdGhlIHZpc3VhbCBzdHlsZSBmb3IgYWxsIGVsZW1lbnRzICh1c2VmdWwgZm9yIG1hbnVhbCBzdHlsZSBtb2RpZmljYXRpb24gYWZ0ZXIgaW5pdClcbiAgJCQuc3R5Zm4udXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlbGVzID0gY3kuZWxlbWVudHMoKTtcblxuICAgIGVsZXMudXBkYXRlU3R5bGUoKTtcbiAgfTtcblxuICAvLyBqdXN0IHVwZGF0ZSB0aGUgZnVuY3Rpb25hbCBwcm9wZXJ0aWVzIChpLmUuIG1hcHBpbmdzKSBpbiB0aGUgZWxlbWVudHMnXG4gIC8vIHN0eWxlcyAobGVzcyBleHBlbnNpdmUgdGhhbiByZWNhbGN1bGF0aW9uKVxuICAkJC5zdHlmbi51cGRhdGVNYXBwZXJzID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGVhY2ggZWxlXG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoIHByb3BcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2pdO1xuICAgICAgICB2YXIgcHJvcEluU3R5bGUgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG5cbiAgICAgICAgaWYoIHByb3BJblN0eWxlICYmIHByb3BJblN0eWxlLm1hcHBpbmcgKXtcbiAgICAgICAgICB2YXIgbWFwcGluZyA9IHByb3BJblN0eWxlLm1hcHBpbmc7XG4gICAgICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIG1hcHBpbmcgKTsgLy8gcmVhcHBseSB0aGUgbWFwcGluZyBwcm9wZXJ0eVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlU3R5bGVIaW50cyggZWxlICk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGRpZmZQcm9wcyA6IHsgbmFtZSA9PiB7IHByZXYsIG5leHQgfSB9XG4gICQkLnN0eWZuLnVwZGF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICB2YXIgcHJvcHMgPSBzdHlsZVsndHJhbnNpdGlvbi1wcm9wZXJ0eSddLnZhbHVlO1xuICAgIHZhciBkdXJhdGlvbiA9IHN0eWxlWyd0cmFuc2l0aW9uLWR1cmF0aW9uJ10ubXNWYWx1ZTtcbiAgICB2YXIgZGVsYXkgPSBzdHlsZVsndHJhbnNpdGlvbi1kZWxheSddLm1zVmFsdWU7XG4gICAgdmFyIGNzcyA9IHt9O1xuXG4gICAgaWYoIHByb3BzLmxlbmd0aCA+IDAgJiYgZHVyYXRpb24gPiAwICl7XG5cbiAgICAgIC8vIGJ1aWxkIHVwIHRoZSBzdHlsZSB0byBhbmltYXRlIHRvd2FyZHNcbiAgICAgIHZhciBhbnlQcmV2ID0gZmFsc2U7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHZhciBzdHlQcm9wID0gc3R5bGVbIHByb3AgXTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wIF07XG5cbiAgICAgICAgaWYoICFkaWZmUHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBwcmV2UHJvcCA9IGRpZmZQcm9wLnByZXY7XG4gICAgICAgIHZhciBmcm9tUHJvcCA9IHByZXZQcm9wO1xuICAgICAgICB2YXIgdG9Qcm9wID0gZGlmZlByb3AubmV4dCAhPSBudWxsID8gZGlmZlByb3AubmV4dCA6IHN0eVByb3A7XG4gICAgICAgIHZhciBkaWZmID0gZmFsc2U7XG5cbiAgICAgICAgaWYoICFmcm9tUHJvcCApeyBjb250aW51ZTsgfSBcblxuICAgICAgICAvLyBjb25zaWRlciBweCB2YWx1ZXNcbiAgICAgICAgaWYoICQkLmlzLm51bWJlciggZnJvbVByb3AucHhWYWx1ZSApICYmICQkLmlzLm51bWJlciggdG9Qcm9wLnB4VmFsdWUgKSApe1xuICAgICAgICAgIGRpZmYgPSBmcm9tUHJvcC5weFZhbHVlICE9PSB0b1Byb3AucHhWYWx1ZTtcblxuICAgICAgICAvLyBjb25zaWRlciBudW1lcmljYWwgdmFsdWVzXG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKCBmcm9tUHJvcC52YWx1ZSApICYmICQkLmlzLm51bWJlciggdG9Qcm9wLnZhbHVlICkgKXtcbiAgICAgICAgICBkaWZmID0gZnJvbVByb3AudmFsdWUgIT09IHRvUHJvcC52YWx1ZTtcblxuICAgICAgICAvLyBjb25zaWRlciBjb2xvdXIgdmFsdWVzXG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMuYXJyYXkoIGZyb21Qcm9wLnZhbHVlICkgJiYgJCQuaXMuYXJyYXkoIHRvUHJvcC52YWx1ZSApICl7XG4gICAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF1cbiAgICAgICAgICAgIHx8IGZyb21Qcm9wLnZhbHVlWzFdICE9PSB0b1Byb3AudmFsdWVbMV1cbiAgICAgICAgICAgIHx8IGZyb21Qcm9wLnZhbHVlWzJdICE9PSB0b1Byb3AudmFsdWVbMl1cbiAgICAgICAgICA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgdmFsdWUgaXMgZ29vZCBmb3IgYW4gYW5pbWF0aW9uIG9ubHkgaWYgaXQncyBkaWZmZXJlbnRcbiAgICAgICAgaWYoIGRpZmYgKXtcbiAgICAgICAgICBjc3NbIHByb3AgXSA9IHRvUHJvcC5zdHJWYWx1ZTsgLy8gdG8gdmFsXG4gICAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyhlbGUsIHByb3AsIGZyb21Qcm9wLnN0clZhbHVlKTsgLy8gZnJvbSB2YWxcbiAgICAgICAgICBhbnlQcmV2ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gLy8gZW5kIGlmIHByb3BzIGFsbG93IGFuaVxuXG4gICAgICAvLyBjYW4ndCB0cmFuc2l0aW9uIGlmIHRoZXJlJ3Mgbm90aGluZyBwcmV2aW91cyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICAgIGlmKCAhYW55UHJldiApeyByZXR1cm47IH1cbiAgICAgIFxuICAgICAgZWxlLl9wcml2YXRlLnRyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG4gICAgICBlbGUuc3RvcCgpO1xuXG4gICAgICBpZiggZGVsYXkgPiAwICl7XG4gICAgICAgIGVsZS5kZWxheSggZGVsYXkgKTtcbiAgICAgIH1cblxuICAgICAgZWxlLmFuaW1hdGUoe1xuICAgICAgICBjc3M6IGNzc1xuICAgICAgfSwge1xuICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIHF1ZXVlOiBmYWxzZSxcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCl7IFxuICAgICAgICAgIGlmKCAhaXNCeXBhc3MgKXtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGUuX3ByaXZhdGUudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiggZWxlLl9wcml2YXRlLnRyYW5zaXRpb25pbmcgKXtcbiAgICAgIGVsZS5zdG9wKCk7XG5cbiAgICAgIHRoaXMucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcblxuICAgICAgZWxlLl9wcml2YXRlLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH07IFxuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGJ5cGFzc2VzIGFyZSBhcHBsaWVkIHRvIGFuIGV4aXN0aW5nIHN0eWxlIG9uIGFuIGVsZW1lbnQsIGFuZCBqdXN0IHRhY2tlZCBvbiB0ZW1wb3JhcmlseVxuICAvLyByZXR1cm5zIHRydWUgaWZmIGFwcGxpY2F0aW9uIHdhcyBzdWNjZXNzZnVsIGZvciBhdCBsZWFzdCAxIHNwZWNpZmllZCBwcm9wZXJ0eVxuICAkJC5zdHlmbi5hcHBseUJ5cGFzcyA9IGZ1bmN0aW9uKCBlbGVzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuICAgIFxuICAgIC8vIHB1dCBhbGwgdGhlIHByb3BlcnRpZXMgKGNhbiBzcGVjaWZ5IG9uZSBvciBtYW55KSBpbiBhbiBhcnJheSBhZnRlciBwYXJzaW5nIHRoZW1cbiAgICBpZiggbmFtZSA9PT0gXCIqXCIgfHwgbmFtZSA9PT0gXCIqKlwiICl7IC8vIGFwcGx5IHRvIGFsbCBwcm9wZXJ0eSBuYW1lc1xuXG4gICAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG5cbiAgICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApeyAvLyB0aGVuIHBhcnNlIHRoZSBzaW5nbGUgcHJvcGVydHlcbiAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG5cbiAgICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG5hbWUpICl7IC8vIHRoZW4gcGFyc2UgZWFjaCBwcm9wZXJ0eVxuICAgICAgdmFyIHNwZWNpZmllZFByb3BzID0gbmFtZTtcbiAgICAgIHVwZGF0ZVRyYW5zaXRpb25zID0gdmFsdWU7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1sgbmFtZSBdO1xuXG4gICAgICAgIGlmKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIHRyeSBjYW1lbCBjYXNlIG5hbWUgdG9vXG4gICAgICAgICAgdmFsdWUgPSBzcGVjaWZpZWRQcm9wc1sgJCQudXRpbC5kYXNoMmNhbWVsKG5hbWUpIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIHBhcnNlZFByb3AgKXtcbiAgICAgICAgICAgIHByb3BzLnB1c2goIHBhcnNlZFByb3AgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBjYW4ndCBkbyBhbnl0aGluZyB3aXRob3V0IHdlbGwgZGVmaW5lZCBwcm9wZXJ0aWVzXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gd2UndmUgZmFpbGVkIGlmIHRoZXJlIGFyZSBubyB2YWxpZCBwcm9wZXJ0aWVzXG4gICAgaWYoIHByb3BzLmxlbmd0aCA9PT0gMCApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIG5vdywgYXBwbHkgdGhlIGJ5cGFzcyBwcm9wZXJ0aWVzIG9uIHRoZSBlbGVtZW50c1xuICAgIHZhciByZXQgPSBmYWxzZTsgLy8gcmV0dXJuIHRydWUgaWYgYXQgbGVhc3Qgb25lIHN1Y2Nlc2Z1bCBieXBhc3MgYXBwbGllZFxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgZWFjaCBlbGVcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIGRpZmZQcm9wcyA9IHt9O1xuICAgICAgdmFyIGRpZmZQcm9wO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoIHByb3BcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgICB2YXIgcHJldlByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICAgICAgZGlmZlByb3AgPSBkaWZmUHJvcHNbIHByb3AubmFtZSBdID0geyBwcmV2OiBwcmV2UHJvcCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIHByb3AgKSB8fCByZXQ7XG5cbiAgICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgICAgZGlmZlByb3AubmV4dCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgfVxuXG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzICk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWxlc1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICAvLyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWZpYyBjYXNlcyBsaWtlIGFuaW1hdGlvblxuICAkJC5zdHlmbi5vdmVycmlkZUJ5cGFzcyA9IGZ1bmN0aW9uKCBlbGVzLCBuYW1lLCB2YWx1ZSApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgcHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsgJCQudXRpbC5jYW1lbDJkYXNoKG5hbWUpIF07XG5cbiAgICAgIGlmKCAhcHJvcC5ieXBhc3MgKXsgLy8gbmVlZCBhIGJ5cGFzcyBpZiBvbmUgZG9lc24ndCBleGlzdFxuICAgICAgICB0aGlzLmFwcGx5QnlwYXNzKCBlbGUsIG5hbWUsIHZhbHVlICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnZhbHVlID0gdmFsdWU7XG4gICAgICBwcm9wLnB4VmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH07XG5cbiAgJCQuc3R5Zm4ucmVtb3ZlQWxsQnlwYXNzZXMgPSBmdW5jdGlvbiggZWxlcywgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcblxuICAgICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBwYXJzZWRQcm9wKTtcblxuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZXNcbiAgfTtcblxuICAkJC5zdHlmbi5yZW1vdmVCeXBhc3NlcyA9IGZ1bmN0aW9uKCBlbGVzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICB2YXIgaXNCeXBhc3MgPSB0cnVlO1xuXG4gICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlbGVzLmxlbmd0aDsgaisrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tqXTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbmFtZSA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbIG5hbWUgXTtcbiAgICAgICAgdmFyIHZhbHVlID0gJyc7IC8vIGVtcHR5ID0+IHJlbW92ZSBieXBhc3NcbiAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgdmFyIHByZXZQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgICB2YXIgZGlmZlByb3AgPSBkaWZmUHJvcHNbIHByb3AubmFtZSBdID0geyBwcmV2OiBwcmV2UHJvcCB9O1xuXG4gICAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eShlbGUsIHBhcnNlZFByb3ApO1xuXG4gICAgICAgIGRpZmZQcm9wLm5leHQgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICB9IC8vIGZvciBwcm9wc1xuXG4gICAgICBpZiggdXBkYXRlVHJhbnNpdGlvbnMgKXtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2l0aW9ucyggZWxlLCBkaWZmUHJvcHMsIGlzQnlwYXNzICk7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgZWxlc1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkLCB3aW5kb3cpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gZ2V0cyB3aGF0IGFuIGVtIHNpemUgY29ycmVzcG9uZHMgdG8gaW4gcGl4ZWxzIHJlbGF0aXZlIHRvIGEgZG9tIGVsZW1lbnRcbiAgJCQuc3R5Zm4uZ2V0RW1TaXplSW5QaXhlbHMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcblxuICAgIGlmKCB3aW5kb3cgJiYgZG9tRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApe1xuICAgICAgdmFyIHB4QXNTdHIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKTtcbiAgICAgIHZhciBweCA9IHBhcnNlRmxvYXQoIHB4QXNTdHIgKTtcbiAgICAgIHJldHVybiBweDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDE7IC8vIGluIGNhc2Ugd2UncmUgcnVubmluZyBvdXRzaWRlIG9mIHRoZSBicm93c2VyXG4gICAgfVxuICB9O1xuXG4gIC8vIGdldHMgY3NzIHByb3BlcnR5IGZyb20gdGhlIGNvcmUgY29udGFpbmVyXG4gICQkLnN0eWZuLmNvbnRhaW5lckNzcyA9IGZ1bmN0aW9uKCBwcm9wTmFtZSApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjeS5jb250YWluZXIoKTtcblxuICAgIGlmKCB3aW5kb3cgJiYgZG9tRWxlbWVudCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApe1xuICAgICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoIHByb3BOYW1lICk7XG4gICAgfVxuICB9O1xuXG4gICQkLnN0eWZuLmNvbnRhaW5lclByb3BlcnR5ID0gZnVuY3Rpb24oIHByb3BOYW1lICl7XG4gICAgdmFyIHByb3BTdHIgPSB0aGlzLmNvbnRhaW5lckNzcyggcHJvcE5hbWUgKTtcbiAgICB2YXIgcHJvcCA9IHRoaXMucGFyc2UoIHByb3BOYW1lLCBwcm9wU3RyICk7XG4gICAgcmV0dXJuIHByb3A7XG4gIH07XG5cbiAgJCQuc3R5Zm4uY29udGFpbmVyUHJvcGVydHlBc1N0cmluZyA9IGZ1bmN0aW9uKCBwcm9wTmFtZSApe1xuICAgIHZhciBwcm9wID0gdGhpcy5jb250YWluZXJQcm9wZXJ0eSggcHJvcE5hbWUgKTtcblxuICAgIGlmKCBwcm9wICl7XG4gICAgICByZXR1cm4gcHJvcC5zdHJWYWx1ZTtcbiAgICB9XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUsIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBnZXRzIHRoZSByZW5kZXJlZCBzdHlsZSBmb3IgYW4gZWxlbWVudFxuICAkJC5zdHlmbi5nZXRSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciByc3R5bGUgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIHN0eWxlUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICAgICAgdmFyIHZhbCA9IHN0eWxlUHJvcC51bml0bGVzcyA/IHN0eWxlUHJvcC5zdHJWYWx1ZSA6IChzdHlsZVByb3AucHhWYWx1ZSAqIHpvb20pICsgJ3B4JztcbiAgICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gdmFsO1xuICAgICAgICAgIHJzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvLyBnZXRzIHRoZSByYXcgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbiAgJCQuc3R5Zm4uZ2V0UmF3U3R5bGUgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgdmFyIGVsZSA9IGVsZVswXTsgLy8gaW5zdXJlIGl0J3MgYW4gZWxlbWVudFxuXG4gICAgaWYoIGVsZSApe1xuICAgICAgdmFyIHJzdHlsZSA9IHt9O1xuICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgc3R5bGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBzdHlsZVByb3AgKXtcbiAgICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gc3R5bGVQcm9wLnN0clZhbHVlO1xuICAgICAgICAgIHJzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnN0eWxlO1xuICAgIH1cbiAgfTtcblxuICAvLyBnZXRzIHRoZSB2YWx1ZSBzdHlsZSBmb3IgYW4gZWxlbWVudCAodXNlZnVsIGZvciB0aGluZ3MgbGlrZSBhbmltYXRpb25zKVxuICAkJC5zdHlmbi5nZXRWYWx1ZVN0eWxlID0gZnVuY3Rpb24oIGVsZSwgb3B0cyApe1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgdmFyIHJzdHlsZSA9IG9wdHMuYXJyYXkgPyBbXSA6IHt9OyBcbiAgICB2YXIgc3R5bGU7XG5cbiAgICBpZiggJCQuaXMuZWxlbWVudChlbGUpICl7XG4gICAgICBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTsgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlID0gZWxlOyAvLyBqdXN0IHBhc3NlZCB0aGUgc3R5bGUgaXRzZWxmXG4gICAgfVxuXG4gICAgaWYoIHN0eWxlICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgc3R5bGVQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdIHx8IHN0eWxlWyAkJC51dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdO1xuXG4gICAgICAgIGlmKCBzdHlsZVByb3AgIT09IHVuZGVmaW5lZCAmJiAhJCQuaXMucGxhaW5PYmplY3QoIHN0eWxlUHJvcCApICl7IC8vIHRoZW4gbWFrZSBhIHByb3Agb2YgaXRcbiAgICAgICAgICBzdHlsZVByb3AgPSB0aGlzLnBhcnNlKHByb3AubmFtZSwgc3R5bGVQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBzdHlsZVByb3AgKXtcbiAgICAgICAgICBpZiggb3B0cy5hcnJheSApe1xuICAgICAgICAgICAgcnN0eWxlLnB1c2goIHN0eWxlUHJvcCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByc3R5bGVbIHByb3AubmFtZSBdID0gc3R5bGVQcm9wO1xuICAgICAgICAgICAgcnN0eWxlWyAkJC51dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdID0gc3R5bGVQcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3R5bGU7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuc3R5bGUuYXBwbHlGcm9tSnNvbiA9IGZ1bmN0aW9uKCBzdHlsZSwganNvbiApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNvbnRleHQgPSBqc29uW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICAgIHZhciBwcm9wcyA9IGNvbnRleHQuY3NzO1xuXG4gICAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICAgIGZvciggdmFyIG5hbWUgaW4gcHJvcHMgKXtcbiAgICAgICAgdmFyIHZhbHVlID0gcHJvcHNbbmFtZV07XG5cbiAgICAgICAgc3R5bGUuY3NzKCBuYW1lLCB2YWx1ZSApOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAvLyBzdGF0aWMgZnVuY3Rpb25cbiAgJCQuc3R5bGUuZnJvbUpzb24gPSBmdW5jdGlvbiggY3ksIGpzb24gKXtcbiAgICB2YXIgc3R5bGUgPSBuZXcgJCQuU3R5bGUoY3kpO1xuXG4gICAgJCQuc3R5bGUuYXBwbHlGcm9tSnNvbiggc3R5bGUsIGpzb24gKTtcblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAvLyBhY2Nlc3NpYmxlIGN5LnN0eWxlKCkgZnVuY3Rpb25cbiAgJCQuc3R5Zm4uZnJvbUpzb24gPSBmdW5jdGlvbigganNvbiApe1xuICAgIHZhciBzdHlsZSA9IHRoaXM7XG5cbiAgICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuXG4gICAgJCQuc3R5bGUuYXBwbHlGcm9tSnNvbiggc3R5bGUsIGpzb24gKTtcblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAvLyBnZXQganNvbiBmcm9tIGN5LnN0eWxlKCkgYXBpXG4gICQkLnN0eWZuLmpzb24gPSBmdW5jdGlvbigpe1xuICAgIHZhciBqc29uID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gdGhpcy5kZWZhdWx0TGVuZ3RoOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGN4dCA9IHRoaXNbaV07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjeHQuc2VsZWN0b3I7XG4gICAgICB2YXIgcHJvcHMgPSBjeHQucHJvcGVydGllcztcbiAgICAgIHZhciBjc3MgPSB7fTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2pdO1xuICAgICAgICBjc3NbIHByb3AubmFtZSBdID0gcHJvcC5zdHJWYWx1ZTtcbiAgICAgIH1cblxuICAgICAganNvbi5wdXNoKHtcbiAgICAgICAgc2VsZWN0b3I6ICFzZWxlY3RvciA/ICdjb3JlJyA6IHNlbGVjdG9yLnRvU3RyaW5nKCksXG4gICAgICAgIGNzczogY3NzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ganNvbjtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5zdHlsZS5hcHBseUZyb21TdHJpbmcgPSBmdW5jdGlvbiggc3R5bGUsIHN0cmluZyApe1xuICAgIHZhciByZW1haW5pbmcgPSAnJyArIHN0cmluZztcbiAgICB2YXIgc2VsQW5kQmxvY2tTdHI7XG4gICAgdmFyIGJsb2NrUmVtO1xuICAgIHZhciBwcm9wQW5kVmFsU3RyO1xuXG4gICAgLy8gcmVtb3ZlIGNvbW1lbnRzIGZyb20gdGhlIHN0eWxlIHN0cmluZ1xuICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5yZXBsYWNlKC9bL11bKl0oXFxzfC4pKz9bKl1bL10vZywgJycpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCl7XG4gICAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBzZWxlY3RvciBhbmQgYmxvY2sgZnJvbSB0aGUgcmVtYWluaW5nIHRleHQgdG8gcGFyc2VcbiAgICAgIGlmKCByZW1haW5pbmcubGVuZ3RoID4gc2VsQW5kQmxvY2tTdHIubGVuZ3RoICl7XG4gICAgICAgIHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHIoIHNlbEFuZEJsb2NrU3RyLmxlbmd0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKXtcbiAgICAgIC8vIHJlbW92ZSB0aGUgcGFyc2VkIHByb3BlcnR5IGFuZCB2YWx1ZSBmcm9tIHRoZSByZW1haW5pbmcgYmxvY2sgdGV4dCB0byBwYXJzZVxuICAgICAgaWYoIGJsb2NrUmVtLmxlbmd0aCA+IHByb3BBbmRWYWxTdHIubGVuZ3RoICl7XG4gICAgICAgIGJsb2NrUmVtID0gYmxvY2tSZW0uc3Vic3RyKCBwcm9wQW5kVmFsU3RyLmxlbmd0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmxvY2tSZW0gPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSh0cnVlKXtcbiAgICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSByZW1haW5pbmcubWF0Y2goL15cXHMqJC8pO1xuICAgICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgICB2YXIgc2VsQW5kQmxvY2sgPSByZW1haW5pbmcubWF0Y2goL15cXHMqKCg/Oi58XFxzKSs/KVxccypcXHsoKD86LnxcXHMpKz8pXFx9Lyk7XG5cbiAgICAgIGlmKCAhc2VsQW5kQmxvY2sgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignSGFsdGluZyBzdHlsZXNoZWV0IHBhcnNpbmc6IFN0cmluZyBzdHlsZXNoZWV0IGNvbnRhaW5zIG1vcmUgdG8gcGFyc2UgYnV0IG5vIHNlbGVjdG9yIGFuZCBibG9jayBmb3VuZCBpbjogJyArIHJlbWFpbmluZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzZWxBbmRCbG9ja1N0ciA9IHNlbEFuZEJsb2NrWzBdO1xuXG4gICAgICAvLyBwYXJzZSB0aGUgc2VsZWN0b3JcbiAgICAgIHZhciBzZWxlY3RvclN0ciA9IHNlbEFuZEJsb2NrWzFdO1xuICAgICAgdmFyIHNlbGVjdG9yID0gbmV3ICQkLlNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuICAgICAgaWYoIHNlbGVjdG9yLl9wcml2YXRlLmludmFsaWQgJiYgc2VsZWN0b3JTdHIgIT09ICdjb3JlJyApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpO1xuXG4gICAgICAgIC8vIHNraXAgdGhpcyBzZWxlY3RvciBhbmQgYmxvY2tcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGNvbnRpbnVlOyBcbiAgICAgIH1cblxuICAgICAgLy8gcGFyc2UgdGhlIGJsb2NrIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICAgICAgdmFyIGJsb2NrU3RyID0gc2VsQW5kQmxvY2tbMl07XG4gICAgICB2YXIgaW52YWxpZEJsb2NrID0gZmFsc2U7XG4gICAgICBibG9ja1JlbSA9IGJsb2NrU3RyO1xuICAgICAgdmFyIHByb3BzID0gW107XG5cbiAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqJC8pO1xuICAgICAgICBpZiggbm90aGluZ0xlZnRUb1BhcnNlICl7IGJyZWFrOyB9XG5cbiAgICAgICAgdmFyIHByb3BBbmRWYWwgPSBibG9ja1JlbS5tYXRjaCgvXlxccyooLis/KVxccyo6XFxzKiguKz8pXFxzKjsvKTtcblxuICAgICAgICBpZiggIXByb3BBbmRWYWwgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIGZvcm1hdHRpbmcgb2Ygc3R5bGUgcHJvcGVydHkgYW5kIHZhbHVlIGRlZmluaXRpb25zIGZvdW5kIGluOicgKyBibG9ja1N0cik7XG4gICAgICAgICAgaW52YWxpZEJsb2NrID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BBbmRWYWxTdHIgPSBwcm9wQW5kVmFsWzBdO1xuICAgICAgICB2YXIgcHJvcFN0ciA9IHByb3BBbmRWYWxbMV07XG4gICAgICAgIHZhciB2YWxTdHIgPSBwcm9wQW5kVmFsWzJdO1xuXG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1sgcHJvcFN0ciBdO1xuICAgICAgICBpZiggIXByb3AgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBuYW1lIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgICAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG4gICAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gc3R5bGUucGFyc2UoIHByb3BTdHIsIHZhbFN0ciApO1xuXG4gICAgICAgIGlmKCAhcGFyc2VkUHJvcCApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IGRlZmluaXRpb24gaW46ICcgKyBwcm9wQW5kVmFsU3RyKTtcblxuICAgICAgICAgIC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcbiAgICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogcHJvcFN0cixcbiAgICAgICAgICB2YWw6IHZhbFN0clxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgIH1cblxuICAgICAgaWYoIGludmFsaWRCbG9jayApe1xuICAgICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHB1dCB0aGUgcGFyc2VkIGJsb2NrIGluIHRoZSBzdHlsZVxuICAgICAgc3R5bGUuc2VsZWN0b3IoIHNlbGVjdG9yU3RyICk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICAgIHN0eWxlLmNzcyggcHJvcC5uYW1lLCBwcm9wLnZhbCApO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVTZWxBbmRCbG9ja0Zyb21SZW1haW5pbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgJCQuc3R5bGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKCBjeSwgc3RyaW5nICl7XG4gICAgdmFyIHN0eWxlID0gbmV3ICQkLlN0eWxlKGN5KTtcbiAgICBcbiAgICAkJC5zdHlsZS5hcHBseUZyb21TdHJpbmcoIHN0eWxlLCBzdHJpbmcgKTtcblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAkJC5zdHlmbi5mcm9tU3RyaW5nID0gZnVuY3Rpb24oIHN0cmluZyApe1xuICAgIHZhciBzdHlsZSA9IHRoaXM7XG5cbiAgICBzdHlsZS5yZXNldFRvRGVmYXVsdCgpO1xuXG4gICAgJCQuc3R5bGUuYXBwbHlGcm9tU3RyaW5nKCBzdHlsZSwgc3RyaW5nICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBhIGR1bW15IHN0eWxlc2hlZXQgb2JqZWN0IHRoYXQgZG9lc24ndCBuZWVkIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlXG4gIC8vICh1c2VmdWwgZm9yIGluaXQpXG4gICQkLnN0eWxlc2hlZXQgPSAkJC5TdHlsZXNoZWV0ID0gZnVuY3Rpb24oKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuU3R5bGVzaGVldCkgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuU3R5bGVzaGVldCgpO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICAvLyBqdXN0IHN0b3JlIHRoZSBzZWxlY3RvciB0byBiZSBwYXJzZWQgbGF0ZXJcbiAgJCQuU3R5bGVzaGVldC5wcm90b3R5cGUuc2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoKys7XG5cbiAgICB0aGlzW2ldID0ge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgcHJvcGVydGllczogW11cbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8ganVzdCBzdG9yZSB0aGUgcHJvcGVydHkgdG8gYmUgcGFyc2VkIGxhdGVyXG4gICQkLlN0eWxlc2hlZXQucHJvdG90eXBlLmNzcyA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApe1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3QobmFtZSkgKXtcbiAgICAgIHZhciBtYXAgPSBuYW1lO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2pdO1xuICAgICAgICB2YXIgbWFwVmFsID0gbWFwWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggbWFwVmFsID09PSB1bmRlZmluZWQgKXsgLy8gYWxzbyB0cnkgY2FtZWwgY2FzZSBuYW1lXG4gICAgICAgICAgbWFwVmFsID0gbWFwWyAkJC51dGlsLmRhc2gyY2FtZWwocHJvcC5uYW1lKSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG1hcFZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbWFwVmFsO1xuXG4gICAgICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gZ2VuZXJhdGUgYSByZWFsIHN0eWxlIG9iamVjdCBmcm9tIHRoZSBkdW1teSBzdHlsZXNoZWV0XG4gICQkLlN0eWxlc2hlZXQucHJvdG90eXBlLmdlbmVyYXRlU3R5bGUgPSBmdW5jdGlvbiggY3kgKXtcbiAgICB2YXIgc3R5bGUgPSBuZXcgJCQuU3R5bGUoY3kpO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXNbaV07XG4gICAgICB2YXIgc2VsZWN0b3IgPSBjb250ZXh0LnNlbGVjdG9yO1xuICAgICAgdmFyIHByb3BzID0gY29udGV4dC5wcm9wZXJ0aWVzO1xuXG4gICAgICBzdHlsZS5zZWxlY3RvcihzZWxlY3Rvcik7IC8vIGFwcGx5IHNlbGVjdG9yXG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcblxuICAgICAgICBzdHlsZS5jc3MoIHByb3AubmFtZSwgcHJvcC52YWx1ZSApOyAvLyBhcHBseSBwcm9wZXJ0eVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBpc1RvdWNoID0gJCQuaXMudG91Y2goKTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gIH07XG4gIFxuICB2YXIgb3JpZ0RlZmF1bHRzID0gJCQudXRpbC5jb3B5KCBkZWZhdWx0cyApO1xuXG4gICQkLmRlZmF1bHRzID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgICBkZWZhdWx0cyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBvcmlnRGVmYXVsdHMsIG9wdHMpO1xuICB9O1xuXG4gICQkLmZuLmNvcmUgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcbiAgICAgICQkLkNvcmUucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG4gIFxuICAkJC5Db3JlID0gZnVuY3Rpb24oIG9wdHMgKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuQ29yZSkgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29yZShvcHRzKTtcbiAgICB9XG4gICAgdmFyIGN5ID0gdGhpcztcblxuICAgIG9wdHMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdHMpO1xuXG4gICAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyO1xuICAgIHZhciByZWcgPSBjb250YWluZXIgPyBjb250YWluZXIuX2N5cmVnIDogbnVsbDsgLy8gZS5nLiBhbHJlYWR5IHJlZ2lzdGVyZWQgc29tZSBpbmZvIChlLmcuIHJlYWRpZXMpIHZpYSBqcXVlcnlcbiAgICByZWcgPSByZWcgfHwge307XG5cbiAgICBpZiggcmVnICYmIHJlZy5jeSApeyBcbiAgICAgIGlmKCBjb250YWluZXIgKXtcbiAgICAgICAgd2hpbGUoIGNvbnRhaW5lci5maXJzdENoaWxkICl7IC8vIGNsZWFuIHRoZSBjb250YWluZXJcbiAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lci5maXJzdENoaWxkICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVnLmN5Lm5vdGlmeSh7IHR5cGU6ICdkZXN0cm95JyB9KTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgICAgcmVnID0ge307IC8vIG9sZCBpbnN0YW5jZSA9PiByZXBsYWNlIHJlZyBjb21wbGV0ZWx5XG4gICAgfVxuXG4gICAgdmFyIHJlYWRpZXMgPSByZWcucmVhZGllcyA9IHJlZy5yZWFkaWVzIHx8IFtdO1xuICAgIFxuICAgIGlmKCBjb250YWluZXIgKXsgY29udGFpbmVyLl9jeXJlZyA9IHJlZzsgfSAvLyBtYWtlIHN1cmUgY29udGFpbmVyIGFzc29jJ2QgcmVnIHBvaW50cyB0byB0aGlzIGN5XG4gICAgcmVnLmN5ID0gY3k7XG5cbiAgICB2YXIgaGVhZCA9IHdpbmRvdyAhPT0gdW5kZWZpbmVkICYmIGNvbnRhaW5lciAhPT0gdW5kZWZpbmVkICYmICFvcHRzLmhlYWRsZXNzO1xuICAgIHZhciBvcHRpb25zID0gb3B0cztcbiAgICBvcHRpb25zLmxheW91dCA9ICQkLnV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnZ3JpZCcgOiAnbnVsbCcgfSwgb3B0aW9ucy5sYXlvdXQgKTtcbiAgICBvcHRpb25zLnJlbmRlcmVyID0gJCQudXRpbC5leHRlbmQoIHsgbmFtZTogaGVhZCA/ICdjYW52YXMnIDogJ251bGwnIH0sIG9wdGlvbnMucmVuZGVyZXIgKTtcbiAgICBcbiAgICB2YXIgZGVmVmFsID0gZnVuY3Rpb24oIGRlZiwgdmFsLCBhbHRWYWwgKXtcbiAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSBlbHNlIGlmKCBhbHRWYWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gYWx0VmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGNvbnRhaW5lcjogb3B0aW9ucy5jb250YWluZXIsIC8vIGh0bWwgZG9tIGVsZSBjb250YWluZXJcbiAgICAgIHJlYWR5OiBmYWxzZSwgLy8gd2hldGhlciByZWFkeSBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgIGluaXRyZW5kZXI6IGZhbHNlLCAvLyBoYXMgaW5pdHJlbmRlciBoYXMgYmVlbiB0cmlnZ2VyZWRcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsIC8vIGNhY2hlZCBvcHRpb25zXG4gICAgICBlbGVtZW50czogW10sIC8vIGFycmF5IG9mIGVsZW1lbnRzXG4gICAgICBpZDJpbmRleDoge30sIC8vIGVsZW1lbnQgaWQgPT4gaW5kZXggaW4gZWxlbWVudHMgYXJyYXlcbiAgICAgIGxpc3RlbmVyczogW10sIC8vIGxpc3Qgb2YgbGlzdGVuZXJzXG4gICAgICBhbmlFbGVzOiAkJC5Db2xsZWN0aW9uKHRoaXMpLCAvLyBlbGVtZW50cyBiZWluZyBhbmltYXRlZFxuICAgICAgc2NyYXRjaDoge30sIC8vIHNjcmF0Y2ggb2JqZWN0IGZvciBjb3JlXG4gICAgICBsYXlvdXQ6IG51bGwsXG4gICAgICByZW5kZXJlcjogbnVsbCxcbiAgICAgIG5vdGlmaWNhdGlvbnNFbmFibGVkOiB0cnVlLCAvLyB3aGV0aGVyIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgdG8gdGhlIHJlbmRlcmVyXG4gICAgICBtaW5ab29tOiAxZS01MCxcbiAgICAgIG1heFpvb206IDFlNTAsXG4gICAgICB6b29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMuem9vbWluZ0VuYWJsZWQpLFxuICAgICAgdXNlclpvb21pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy51c2VyWm9vbWluZ0VuYWJsZWQpLFxuICAgICAgcGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnBhbm5pbmdFbmFibGVkKSxcbiAgICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclBhbm5pbmdFbmFibGVkKSxcbiAgICAgIGJveFNlbGVjdGlvbkVuYWJsZWQ6IGRlZlZhbChmYWxzZSwgb3B0aW9ucy5ib3hTZWxlY3Rpb25FbmFibGVkKSxcbiAgICAgIGF1dG9sb2NrOiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b2xvY2ssIG9wdGlvbnMuYXV0b2xvY2tOb2RlcyksXG4gICAgICBhdXRvdW5ncmFiaWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeSwgb3B0aW9ucy5hdXRvdW5ncmFiaWZ5Tm9kZXMpLFxuICAgICAgYXV0b3Vuc2VsZWN0aWZ5OiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYXV0b3Vuc2VsZWN0aWZ5KSxcbiAgICAgIHN0eWxlRW5hYmxlZDogb3B0aW9ucy5zdHlsZUVuYWJsZWQgPT09IHVuZGVmaW5lZCA/IGhlYWQgOiBvcHRpb25zLnN0eWxlRW5hYmxlZCxcbiAgICAgIHpvb206ICQkLmlzLm51bWJlcihvcHRpb25zLnpvb20pID8gb3B0aW9ucy56b29tIDogMSxcbiAgICAgIHBhbjoge1xuICAgICAgICB4OiAkJC5pcy5wbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgJCQuaXMubnVtYmVyKG9wdGlvbnMucGFuLngpID8gb3B0aW9ucy5wYW4ueCA6IDAsXG4gICAgICAgIHk6ICQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMucGFuKSAmJiAkJC5pcy5udW1iZXIob3B0aW9ucy5wYW4ueSkgPyBvcHRpb25zLnBhbi55IDogMFxuICAgICAgfSxcbiAgICAgIGFuaW1hdGlvbjogeyAvLyBvYmplY3QgZm9yIGN1cnJlbnRseS1ydW5uaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgY3VycmVudDogW10sXG4gICAgICAgIHF1ZXVlOiBbXVxuICAgICAgfSxcbiAgICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZhbHNlLFxuICAgICAgZGVmZXJyZWRFeGVjUXVldWU6IFtdXG4gICAgfTtcblxuICAgIC8vIHNldCBzZWxlY3Rpb24gdHlwZVxuICAgIHZhciBzZWxUeXBlID0gb3B0aW9ucy5zZWxlY3Rpb25UeXBlO1xuICAgIGlmKCBzZWxUeXBlID09PSB1bmRlZmluZWQgfHwgKHNlbFR5cGUgIT09ICdhZGRpdGl2ZScgJiYgc2VsVHlwZSAhPT0gJ3NpbmdsZScpICl7XG4gICAgICAvLyB0aGVuIHNldCBkZWZhdWx0XG5cbiAgICAgIGlmKCBpc1RvdWNoICl7XG4gICAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSAnYWRkaXRpdmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9ICdzaW5nbGUnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfcC5zZWxlY3Rpb25UeXBlID0gc2VsVHlwZTtcbiAgICB9XG5cbiAgICAvLyBpbml0IHpvb20gYm91bmRzXG4gICAgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLm1pblpvb20pICYmICQkLmlzLm51bWJlcihvcHRpb25zLm1heFpvb20pICYmIG9wdGlvbnMubWluWm9vbSA8IG9wdGlvbnMubWF4Wm9vbSApe1xuICAgICAgX3AubWluWm9vbSA9IG9wdGlvbnMubWluWm9vbTtcbiAgICAgIF9wLm1heFpvb20gPSBvcHRpb25zLm1heFpvb207XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5taW5ab29tKSAmJiBvcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgICAgX3AubWluWm9vbSA9IG9wdGlvbnMubWluWm9vbTtcbiAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLm1heFpvb20pICYmIG9wdGlvbnMubWluWm9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBfcC5tYXhab29tID0gb3B0aW9ucy5tYXhab29tO1xuICAgIH1cblxuICAgIC8vIGluaXQgc3R5bGVcbiAgICBpZiggX3Auc3R5bGVFbmFibGVkICl7XG4gICAgICB0aGlzLnNldFN0eWxlKCBvcHRpb25zLnN0eWxlICk7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIHRoZSByZW5kZXJlclxuICAgIGN5LmluaXRSZW5kZXJlciggJCQudXRpbC5leHRlbmQoe1xuICAgICAgaGlkZUVkZ2VzT25WaWV3cG9ydDogb3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0LFxuICAgICAgaGlkZUxhYmVsc09uVmlld3BvcnQ6IG9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQsXG4gICAgICB0ZXh0dXJlT25WaWV3cG9ydDogb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydCxcbiAgICAgIHdoZWVsU2Vuc2l0aXZpdHk6ICQkLmlzLm51bWJlcihvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkpICYmIG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSA+IDAgPyBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgOiAxLFxuICAgICAgbW90aW9uQmx1cjogb3B0aW9ucy5tb3Rpb25CbHVyLFxuICAgICAgcGl4ZWxSYXRpbzogJCQuaXMubnVtYmVyKG9wdGlvbnMucGl4ZWxSYXRpbykgJiYgb3B0aW9ucy5waXhlbFJhdGlvID4gMCA/IG9wdGlvbnMucGl4ZWxSYXRpbyA6IChvcHRpb25zLnBpeGVsUmF0aW8gPT09ICdhdXRvJyA/IHVuZGVmaW5lZCA6IDEpLFxuICAgICAgdGFwVGhyZXNob2xkOiBkZWZWYWwoICQkLmlzLnRvdWNoKCkgPyA4IDogNCwgJCQuaXMudG91Y2goKSA/IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQgOiBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQgKVxuICAgIH0sIG9wdGlvbnMucmVuZGVyZXIpICk7XG5cbiAgICAvLyB0cmlnZ2VyIHRoZSBwYXNzZWQgZnVuY3Rpb24gZm9yIHRoZSBgaW5pdHJlbmRlcmAgZXZlbnRcbiAgICBpZiggb3B0aW9ucy5pbml0cmVuZGVyICl7XG4gICAgICBjeS5vbignaW5pdHJlbmRlcicsIG9wdGlvbnMuaW5pdHJlbmRlcik7XG4gICAgICBjeS5vbignaW5pdHJlbmRlcicsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGN5Ll9wcml2YXRlLmluaXRyZW5kZXIgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbCBsb2FkXG4gICAgY3kubG9hZChvcHRpb25zLmVsZW1lbnRzLCBmdW5jdGlvbigpeyAvLyBvbnJlYWR5XG4gICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgIGN5Ll9wcml2YXRlLnJlYWR5ID0gdHJ1ZTtcblxuICAgICAgLy8gaWYgYSByZWFkeSBjYWxsYmFjayBpcyBzcGVjaWZpZWQgYXMgYW4gb3B0aW9uLCB0aGUgYmluZCBpdFxuICAgICAgaWYoICQkLmlzLmZuKCBvcHRpb25zLnJlYWR5ICkgKXtcbiAgICAgICAgY3kub24oJ3JlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHJlYWRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGZuID0gcmVhZGllc1tpXTtcbiAgICAgICAgY3kub24oJ3JlYWR5JywgZm4pO1xuICAgICAgfVxuICAgICAgaWYoIHJlZyApeyByZWcucmVhZGllcyA9IFtdOyB9IC8vIGNsZWFyIGIvYyB3ZSd2ZSBib3VuZCB0aGVtIGFsbCBhbmQgZG9uJ3Qgd2FudCB0byBrZWVwIGl0IGFyb3VuZCBpbiBjYXNlIGEgbmV3IGNvcmUgdXNlcyB0aGUgc2FtZSBkaXYgZXRjXG4gICAgICBcbiAgICAgIGN5LnRyaWdnZXIoJ3JlYWR5Jyk7XG4gICAgfSwgb3B0aW9ucy5kb25lKTtcbiAgfTtcblxuICAkJC5jb3JlZm4gPSAkJC5Db3JlLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcbiAgXG5cbiAgJCQuZm4uY29yZSh7XG4gICAgaXNSZWFkeTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlYWR5O1xuICAgIH0sXG5cbiAgICByZWFkeTogZnVuY3Rpb24oIGZuICl7XG4gICAgICBpZiggdGhpcy5pc1JlYWR5KCkgKXtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZWFkeScsIFtdLCBmbik7IC8vIGp1c3QgY2FsbHMgZm4gYXMgdGhvdWdoIHRyaWdnZXJlZCB2aWEgcmVhZHkgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub24oJ3JlYWR5JywgZm4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0cmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaW5pdHJlbmRlcjtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMubm90aWZ5KHsgdHlwZTogJ2Rlc3Ryb3knIH0pOyAvLyBkZXN0cm95IHRoZSByZW5kZXJlclxuXG4gICAgICB2YXIgZG9tRWxlID0gdGhpcy5jb250YWluZXIoKTtcbiAgICAgIHZhciBwYXJFbGUgPSBkb21FbGUucGFyZW50Tm9kZTtcbiAgICAgIGlmKCBwYXJFbGUgKXtcbiAgICAgICAgcGFyRWxlLnJlbW92ZUNoaWxkKCBkb21FbGUgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldEVsZW1lbnRCeUlkOiBmdW5jdGlvbiggaWQgKXtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX3ByaXZhdGUuaWQyaW5kZXhbIGlkIF07XG4gICAgICBpZiggaW5kZXggIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50c1sgaW5kZXggXTtcbiAgICAgIH1cblxuICAgICAgLy8gd29yc3QgY2FzZSwgcmV0dXJuIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcyApO1xuICAgIH0sXG5cbiAgICBzZWxlY3Rpb25UeXBlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc2VsZWN0aW9uVHlwZTtcbiAgICB9LFxuXG4gICAgaGFzQ29tcG91bmROb2RlczogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gICAgfSxcblxuICAgIHN0eWxlRW5hYmxlZDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgICB9LFxuXG4gICAgYWRkVG9Qb29sOiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICAgIHZhciBpZDJpbmRleCA9IHRoaXMuX3ByaXZhdGUuaWQyaW5kZXg7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluZGV4ID0gaWQyaW5kZXhbIGlkIF07XG4gICAgICAgIHZhciBhbHJlYWR5SW5Qb29sID0gaW5kZXggIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiggIWFscmVhZHlJblBvb2wgKXtcbiAgICAgICAgICBpbmRleCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICBpZDJpbmRleFsgaWQgXSA9IGluZGV4O1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5pbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICByZW1vdmVGcm9tUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgICB2YXIgaWQyaW5kZXggPSB0aGlzLl9wcml2YXRlLmlkMmluZGV4O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbmRleCA9IGlkMmluZGV4WyBpZCBdO1xuICAgICAgICB2YXIgaW5Qb29sID0gaW5kZXggIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiggaW5Qb29sICl7XG4gICAgICAgICAgdGhpcy5fcHJpdmF0ZS5pZDJpbmRleFsgaWQgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBlbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBpbmRleCBvZiBhbGwgZWxlbWVudHMgcGFzdCB0aGlzIGluZGV4XG4gICAgICAgICAgZm9yKCB2YXIgaiA9IGluZGV4OyBqIDwgZWxlbWVudHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciBqaWQgPSBlbGVtZW50c1tqXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICAgICAgaWQyaW5kZXhbIGppZCBdLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcbiAgICB9LFxuXG4gICAgb3B0aW9uczogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiAkJC51dGlsLmNvcHkoIHRoaXMuX3ByaXZhdGUub3B0aW9ucyApO1xuICAgIH0sXG4gICAgXG4gICAganNvbjogZnVuY3Rpb24ocGFyYW1zKXtcbiAgICAgIHZhciBqc29uID0ge307XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgXG4gICAgICBqc29uLmVsZW1lbnRzID0ge307XG4gICAgICBjeS5lbGVtZW50cygpLmVhY2goZnVuY3Rpb24oaSwgZWxlKXtcbiAgICAgICAgdmFyIGdyb3VwID0gZWxlLmdyb3VwKCk7XG4gICAgICAgIFxuICAgICAgICBpZiggIWpzb24uZWxlbWVudHNbZ3JvdXBdICl7XG4gICAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAganNvbi5lbGVtZW50c1tncm91cF0ucHVzaCggZWxlLmpzb24oKSApO1xuICAgICAgfSk7XG5cbiAgICAgIGlmKCB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZCApe1xuICAgICAgICBqc29uLnN0eWxlID0gY3kuc3R5bGUoKS5qc29uKCk7XG4gICAgICB9XG5cbiAgICAgIGpzb24uem9vbWluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclpvb21pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAganNvbi56b29tID0gY3kuX3ByaXZhdGUuem9vbTtcbiAgICAgIGpzb24ubWluWm9vbSA9IGN5Ll9wcml2YXRlLm1pblpvb207XG4gICAgICBqc29uLm1heFpvb20gPSBjeS5fcHJpdmF0ZS5tYXhab29tO1xuICAgICAganNvbi5wYW5uaW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi51c2VyUGFubmluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnBhbiA9IGN5Ll9wcml2YXRlLnBhbjtcbiAgICAgIGpzb24uYm94U2VsZWN0aW9uRW5hYmxlZCA9IGN5Ll9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICBqc29uLmxheW91dCA9IGN5Ll9wcml2YXRlLm9wdGlvbnMubGF5b3V0O1xuICAgICAganNvbi5yZW5kZXJlciA9IGN5Ll9wcml2YXRlLm9wdGlvbnMucmVuZGVyZXI7XG4gICAgICBqc29uLmhpZGVFZGdlc09uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgICBqc29uLmhpZGVMYWJlbHNPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy5oaWRlTGFiZWxzT25WaWV3cG9ydDtcbiAgICAgIGpzb24udGV4dHVyZU9uVmlld3BvcnQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLnRleHR1cmVPblZpZXdwb3J0O1xuICAgICAganNvbi53aGVlbFNlbnNpdGl2aXR5ID0gY3kuX3ByaXZhdGUub3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgICAganNvbi5tb3Rpb25CbHVyID0gY3kuX3ByaXZhdGUub3B0aW9ucy5tb3Rpb25CbHVyO1xuICAgICAgXG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuXG4gICAgLy8gZGVmZXIgZXhlY3V0aW9uIHVudGlsIG5vdCBidXN5IGFuZCBndWFyYW50ZWUgcmVsYXRpdmUgZXhlY3V0aW9uIG9yZGVyIG9mIGRlZmVycmVkIGZ1bmN0aW9uc1xuICAgIGRlZmVyOiBmdW5jdGlvbiggZm4gKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICB2YXIgX3AgPSBjeS5fcHJpdmF0ZTtcbiAgICAgIHZhciBxID0gX3AuZGVmZXJyZWRFeGVjUXVldWU7XG5cbiAgICAgIHEucHVzaCggZm4gKTtcblxuICAgICAgaWYoICFfcC5kZWZlcnJlZFRpbWVvdXQgKXtcbiAgICAgICAgX3AuZGVmZXJyZWRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHdoaWxlKCBxLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgICggcS5zaGlmdCgpICkoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcC5kZWZlcnJlZFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gIH0pOyAgXG4gIFxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbihmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIHJlYWR5KGYpIHtcbiAgICB2YXIgZm4gPSAoIGRvY3VtZW50ICYmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpICkgID8gZiA6IHJlYWR5O1xuXG4gICAgc2V0VGltZW91dChmbiwgOSwgZik7XG4gIH1cblxuICAkJC5mbi5jb3JlKHtcbiAgICBhZGQ6IGZ1bmN0aW9uKG9wdHMpe1xuICAgICAgXG4gICAgICB2YXIgZWxlbWVudHM7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgXG4gICAgICAvLyBhZGQgdGhlIGVsZW1lbnRzXG4gICAgICBpZiggJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihvcHRzKSApe1xuICAgICAgICB2YXIgZWxlcyA9IG9wdHM7XG5cbiAgICAgICAgaWYoIGVsZXMuX3ByaXZhdGUuY3kgPT09IGN5ICl7IC8vIHNhbWUgaW5zdGFuY2UgPT4ganVzdCByZXN0b3JlXG4gICAgICAgICAgZWxlbWVudHMgPSBlbGVzLnJlc3RvcmUoKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIGNvcHkgZnJvbSBqc29uXG4gICAgICAgICAgdmFyIGpzb25zID0gW107XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgICAganNvbnMucHVzaCggZWxlLmpzb24oKSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnRzID0gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBqc29ucyApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHNwZWNpZnkgYW4gYXJyYXkgb2Ygb3B0aW9uc1xuICAgICAgZWxzZSBpZiggJCQuaXMuYXJyYXkob3B0cykgKXtcbiAgICAgICAgdmFyIGpzb25zID0gb3B0cztcblxuICAgICAgICBlbGVtZW50cyA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBqc29ucyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHNwZWNpZnkgdmlhIG9wdHMubm9kZXMgYW5kIG9wdHMuZWRnZXNcbiAgICAgIGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG9wdHMpICYmICgkJC5pcy5hcnJheShvcHRzLm5vZGVzKSB8fCAkJC5pcy5hcnJheShvcHRzLmVkZ2VzKSkgKXtcbiAgICAgICAgdmFyIGVsZXNCeUdyb3VwID0gb3B0cztcbiAgICAgICAgdmFyIGpzb25zID0gW107XG5cbiAgICAgICAgdmFyIGdycyA9IFsnbm9kZXMnLCAnZWRnZXMnXTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGlsID0gZ3JzLmxlbmd0aDsgaSA8IGlsOyBpKysgKXtcbiAgICAgICAgICB2YXIgZ3JvdXAgPSBncnNbaV07XG4gICAgICAgICAgdmFyIGVsZXNBcnJheSA9IGVsZXNCeUdyb3VwW2dyb3VwXTtcblxuICAgICAgICAgIGlmKCAkJC5pcy5hcnJheShlbGVzQXJyYXkpICl7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGogPSAwLCBqbCA9IGVsZXNBcnJheS5sZW5ndGg7IGogPCBqbDsgaisrICl7XG4gICAgICAgICAgICAgIHZhciBqc29uID0gZWxlc0FycmF5W2pdO1xuICAgICAgICAgICAgICBqc29uLmdyb3VwID0gZ3JvdXA7XG5cbiAgICAgICAgICAgICAganNvbnMucHVzaCgganNvbiApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gXG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50cyA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBqc29ucyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHNwZWNpZnkgb3B0aW9ucyBmb3Igb25lIGVsZW1lbnRcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIganNvbiA9IG9wdHM7XG4gICAgICAgIGVsZW1lbnRzID0gKG5ldyAkJC5FbGVtZW50KCBjeSwganNvbiApKS5jb2xsZWN0aW9uKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIFxuICAgIHJlbW92ZTogZnVuY3Rpb24oY29sbGVjdGlvbil7XG4gICAgICBpZiggJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihjb2xsZWN0aW9uKSApe1xuICAgICAgICBjb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKGNvbGxlY3Rpb24pICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IGNvbGxlY3Rpb247XG4gICAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLiQoIHNlbGVjdG9yICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uLnJlbW92ZSgpO1xuICAgIH0sXG4gICAgXG4gICAgbG9hZDogZnVuY3Rpb24oZWxlbWVudHMsIG9ubG9hZCwgb25kb25lKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG4gICAgICBcbiAgICAgIC8vIHJlbW92ZSBvbGQgZWxlbWVudHNcbiAgICAgIHZhciBvbGRFbGVzID0gY3kuZWxlbWVudHMoKTtcbiAgICAgIGlmKCBvbGRFbGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgb2xkRWxlcy5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgY3kubm90aWZpY2F0aW9ucyhmYWxzZSk7XG4gICAgICBcbiAgICAgIGlmKCBlbGVtZW50cyAhPSBudWxsICl7XG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChlbGVtZW50cykgfHwgJCQuaXMuYXJyYXkoZWxlbWVudHMpICl7XG4gICAgICAgICAgY3kuYWRkKCBlbGVtZW50cyApO1xuICAgICAgICB9IFxuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBjYWxsYmFjaygpeyAgICAgICAgXG4gICAgICAgIGN5Lm9uZSgnbGF5b3V0cmVhZHknLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICBjeS5ub3RpZmljYXRpb25zKHRydWUpO1xuICAgICAgICAgIGN5LnRyaWdnZXIoZSk7IC8vIHdlIG1pc3NlZCB0aGlzIGV2ZW50IGJ5IHR1cm5pbmcgbm90aWZpY2F0aW9ucyBvZmYsIHNvIHBhc3MgaXQgb25cblxuICAgICAgICAgIGN5Lm5vdGlmeSh7XG4gICAgICAgICAgICB0eXBlOiAnbG9hZCcsXG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBjeS5lbGVtZW50cygpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjeS5vbmUoJ2xvYWQnLCBvbmxvYWQpO1xuICAgICAgICAgIGN5LnRyaWdnZXIoJ2xvYWQnKTtcbiAgICAgICAgfSkub25lKCdsYXlvdXRzdG9wJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICBjeS5vbmUoJ2RvbmUnLCBvbmRvbmUpO1xuICAgICAgICAgIGN5LnRyaWdnZXIoJ2RvbmUnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgbGF5b3V0T3B0cyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dCk7XG4gICAgICAgIGxheW91dE9wdHMuZWxlcyA9IGN5LiQoKTtcblxuICAgICAgICBjeS5sYXlvdXQoIGxheW91dE9wdHMgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiggd2luZG93ICl7XG4gICAgICAgIHJlYWR5KCBjYWxsYmFjayApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG4gICAgXG4gICAgLy8gcHVsbCBpbiBhbmltYXRpb24gZnVuY3Rpb25zXG4gICAgYW5pbWF0ZWQ6ICQkLmRlZmluZS5hbmltYXRlZCgpLFxuICAgIGNsZWFyUXVldWU6ICQkLmRlZmluZS5jbGVhclF1ZXVlKCksXG4gICAgZGVsYXk6ICQkLmRlZmluZS5kZWxheSgpLFxuICAgIGFuaW1hdGU6ICQkLmRlZmluZS5hbmltYXRlKCksXG4gICAgc3RvcDogJCQuZGVmaW5lLnN0b3AoKSxcblxuICAgIGFkZFRvQW5pbWF0aW9uUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuICAgICAgXG4gICAgICBjeS5fcHJpdmF0ZS5hbmlFbGVzLm1lcmdlKCBlbGVzICk7XG4gICAgfSxcblxuICAgIHN0YXJ0QW5pbWF0aW9uTG9vcDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzIHdoZW4gbm8gc3R5bGUgdXNlZFxuXG4gICAgICAvLyBkb24ndCBleGVjdXRlIHRoZSBhbmltYXRpb24gbG9vcCBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHNcbiAgICAgIGlmKCAhd2luZG93ICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gZ2xvYmFsQW5pbWF0aW9uU3RlcCgpe1xuICAgICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbihub3cpe1xuICAgICAgICAgIGhhbmRsZUVsZW1lbnRzKG5vdyk7XG4gICAgICAgICAgZ2xvYmFsQW5pbWF0aW9uU3RlcCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZ2xvYmFsQW5pbWF0aW9uU3RlcCgpOyAvLyBmaXJzdCBjYWxsXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnRzKG5vdyl7XG4gICAgICAgIG5vdyA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHZhciBlbGVzID0gY3kuX3ByaXZhdGUuYW5pRWxlcztcbiAgICAgICAgdmFyIGRvbmVFbGVzID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRWxlbWVudCggZWxlLCBpc0NvcmUgKXtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudDtcbiAgICAgICAgICB2YXIgcXVldWUgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlO1xuICAgICAgICAgIHZhciByYW5BbmlzID0gZmFsc2U7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gaWYgbm90aGluZyBjdXJyZW50bHkgYW5pbWF0aW5nLCBnZXQgc29tZXRoaW5nIGZyb20gdGhlIHF1ZXVlXG4gICAgICAgICAgaWYoIGN1cnJlbnQubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHF1ZXVlLmxlbmd0aCA+IDAgPyBxdWV1ZS5zaGlmdCgpIDogbnVsbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIG5leHQgKXtcbiAgICAgICAgICAgICAgbmV4dC5jYWxsVGltZSA9IG5vdzsgLy8gd2FzIHF1ZXVlZCwgc28gdXBkYXRlIGNhbGwgdGltZVxuICAgICAgICAgICAgICBjdXJyZW50LnB1c2goIG5leHQgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gc3RlcCBhbmQgcmVtb3ZlIGlmIGRvbmVcbiAgICAgICAgICB2YXIgY29tcGxldGVzID0gW107XG4gICAgICAgICAgZm9yKHZhciBpID0gY3VycmVudC5sZW5ndGggLSAxOyBpID49IDA7IGktLSl7XG4gICAgICAgICAgICB2YXIgYW5pID0gY3VycmVudFtpXTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgaWYgbmVlZCBiZVxuICAgICAgICAgICAgaWYoICFhbmkuc3RhcnRlZCApeyBzdGFydEFuaW1hdGlvbiggZWxlLCBhbmkgKTsgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdGVwKCBlbGUsIGFuaSwgbm93LCBpc0NvcmUgKTtcblxuICAgICAgICAgICAgaWYoIGFuaS5kb25lICl7XG4gICAgICAgICAgICAgIGNvbXBsZXRlcy5wdXNoKCBhbmkgKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW50W2ldXG4gICAgICAgICAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByYW5BbmlzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY2FsbCBjb21wbGV0ZSBjYWxsYmFja3NcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBsZXRlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGFuaSA9IGNvbXBsZXRlc1tpXTtcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZSA9IGFuaS5wYXJhbXMuY29tcGxldGU7XG5cbiAgICAgICAgICAgIGlmKCAkJC5pcy5mbihjb21wbGV0ZSkgKXtcbiAgICAgICAgICAgICAgY29tcGxldGUuYXBwbHkoIGVsZSwgWyBub3cgXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhaXNDb3JlICYmIGN1cnJlbnQubGVuZ3RoID09PSAwICYmIHF1ZXVlLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgZG9uZUVsZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJhbkFuaXM7XG4gICAgICAgIH0gLy8gaGFuZGxlRWxlbWVudHNcblxuICAgICAgICAvLyBoYW5kbGUgYWxsIGVsZXNcbiAgICAgICAgZm9yKCB2YXIgZSA9IDA7IGUgPCBlbGVzLmxlbmd0aDsgZSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbZV07XG4gICAgICAgICAgXG4gICAgICAgICAgaGFuZGxlRWxlbWVudCggZWxlICk7XG4gICAgICAgIH0gLy8gZWFjaCBlbGVtZW50XG5cbiAgICAgICAgdmFyIHJhbkNvcmVBbmkgPSBoYW5kbGVFbGVtZW50KCBjeSwgdHJ1ZSApO1xuICAgICAgICBcbiAgICAgICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgICAgIGlmKCBlbGVzLmxlbmd0aCA+IDAgfHwgcmFuQ29yZUFuaSApe1xuICAgICAgICAgIHZhciB0b05vdGlmeTtcblxuICAgICAgICAgIGlmKCBlbGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIHZhciB1cGRhdGVkRWxlcyA9IGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRvTm90aWZ5ID0gdXBkYXRlZEVsZXMubGVuZ3RoID4gMCA/IGVsZXMuYWRkKCB1cGRhdGVkRWxlcyApIDogZWxlcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjeS5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogJ2RyYXcnLFxuICAgICAgICAgICAgY29sbGVjdGlvbjogdG9Ob3RpZnlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBlbGVtZW50cyBmcm9tIGxpc3Qgb2YgY3VycmVudGx5IGFuaW1hdGluZyBpZiBpdHMgcXVldWVzIGFyZSBlbXB0eVxuICAgICAgICBlbGVzLnVubWVyZ2UoIGRvbmVFbGVzICk7XG5cbiAgICAgIH0gLy8gaGFuZGxlRWxlbWVudHNcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oIHNlbGYsIGFuaSApe1xuICAgICAgICB2YXIgaXNDb3JlID0gJCQuaXMuY29yZSggc2VsZiApO1xuICAgICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgICAgdmFyIGVsZSA9IHNlbGY7XG4gICAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuXG4gICAgICAgIGlmKCBpc0VsZXMgKXtcbiAgICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgICB5OiBwb3MueVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHN0YXJ0U3R5bGUgPSBzdHlsZS5nZXRWYWx1ZVN0eWxlKCBlbGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBpc0NvcmUgKXtcbiAgICAgICAgICB2YXIgcGFuID0gY3kuX3ByaXZhdGUucGFuO1xuICAgICAgICAgIHZhciBzdGFydFBhbiA9IHtcbiAgICAgICAgICAgIHg6IHBhbi54LFxuICAgICAgICAgICAgeTogcGFuLnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHN0YXJ0Wm9vbSA9IGN5Ll9wcml2YXRlLnpvb207XG4gICAgICAgIH1cblxuICAgICAgICBhbmkuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGFuaS5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBhbmkuc3RhcnRQb3NpdGlvbiA9IHN0YXJ0UG9zaXRpb247XG4gICAgICAgIGFuaS5zdGFydFN0eWxlID0gc3RhcnRTdHlsZTtcbiAgICAgICAgYW5pLnN0YXJ0UGFuID0gc3RhcnRQYW47XG4gICAgICAgIGFuaS5zdGFydFpvb20gPSBzdGFydFpvb207XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHN0ZXAoIHNlbGYsIGFuaW1hdGlvbiwgbm93LCBpc0NvcmUgKXtcbiAgICAgICAgdmFyIHN0eWxlID0gY3kuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gYW5pbWF0aW9uLnByb3BlcnRpZXM7XG4gICAgICAgIHZhciBwYXJhbXMgPSBhbmltYXRpb24ucGFyYW1zO1xuICAgICAgICB2YXIgc3RhcnRUaW1lID0gYW5pbWF0aW9uLnN0YXJ0VGltZTtcbiAgICAgICAgdmFyIHBlcmNlbnQ7XG4gICAgICAgIHZhciBpc0VsZXMgPSAhaXNDb3JlO1xuICAgICAgICBcbiAgICAgICAgaWYoIGFuaW1hdGlvbi5kdXJhdGlvbiA9PT0gMCApe1xuICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlcmNlbnQgPSBNYXRoLm1pbigxLCAobm93IC0gc3RhcnRUaW1lKS9hbmltYXRpb24uZHVyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIHByb3BlcnRpZXMuZGVsYXkgPT0gbnVsbCApeyAvLyB0aGVuIHVwZGF0ZVxuXG4gICAgICAgICAgdmFyIHN0YXJ0UG9zID0gYW5pbWF0aW9uLnN0YXJ0UG9zaXRpb247XG4gICAgICAgICAgdmFyIGVuZFBvcyA9IHByb3BlcnRpZXMucG9zaXRpb247XG4gICAgICAgICAgdmFyIHBvcyA9IHNlbGYuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgaWYoIGVuZFBvcyAmJiBpc0VsZXMgKXtcbiAgICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQb3MueCwgZW5kUG9zLnggKSApe1xuICAgICAgICAgICAgICBwb3MueCA9IGVhc2UoIHN0YXJ0UG9zLngsIGVuZFBvcy54LCBwZXJjZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRQb3MueSwgZW5kUG9zLnkgKSApe1xuICAgICAgICAgICAgICBwb3MueSA9IGVhc2UoIHN0YXJ0UG9zLnksIGVuZFBvcy55LCBwZXJjZW50ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0UGFuID0gYW5pbWF0aW9uLnN0YXJ0UGFuO1xuICAgICAgICAgIHZhciBlbmRQYW4gPSBwcm9wZXJ0aWVzLnBhbjtcbiAgICAgICAgICB2YXIgcGFuID0gc2VsZi5fcHJpdmF0ZS5wYW47XG4gICAgICAgICAgdmFyIGFuaW1hdGluZ1BhbiA9IGVuZFBhbiAhPSBudWxsICYmIGlzQ29yZTtcbiAgICAgICAgICBpZiggYW5pbWF0aW5nUGFuICl7XG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UGFuLngsIGVuZFBhbi54ICkgKXtcbiAgICAgICAgICAgICAgcGFuLnggPSBlYXNlKCBzdGFydFBhbi54LCBlbmRQYW4ueCwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UGFuLnksIGVuZFBhbi55ICkgKXtcbiAgICAgICAgICAgICAgcGFuLnkgPSBlYXNlKCBzdGFydFBhbi55LCBlbmRQYW4ueSwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3BhbicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydFpvb20gPSBhbmltYXRpb24uc3RhcnRab29tO1xuICAgICAgICAgIHZhciBlbmRab29tID0gcHJvcGVydGllcy56b29tO1xuICAgICAgICAgIHZhciBhbmltYXRpbmdab29tID0gZW5kWm9vbSAhPSBudWxsICYmIGlzQ29yZTtcbiAgICAgICAgICBpZiggYW5pbWF0aW5nWm9vbSApe1xuICAgICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFpvb20sIGVuZFpvb20gKSApe1xuICAgICAgICAgICAgICBzZWxmLl9wcml2YXRlLnpvb20gPSBlYXNlKCBzdGFydFpvb20sIGVuZFpvb20sIHBlcmNlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd6b29tJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiB8fCBhbmltYXRpbmdab29tICl7XG4gICAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3ZpZXdwb3J0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHByb3BlcnRpZXMuY3NzICYmIGlzRWxlcyApe1xuICAgICAgICAgICAgdmFyIHByb3BzID0gcHJvcGVydGllcy5jc3M7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXS5uYW1lO1xuICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgICAgICB2YXIgZW5kID0gcHJvcDtcblxuICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBhbmltYXRpb24uc3RhcnRTdHlsZVsgbmFtZSBdO1xuICAgICAgICAgICAgICB2YXIgZWFzZWRWYWwgPSBlYXNlKCBzdGFydCwgZW5kLCBwZXJjZW50ICk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBzdHlsZS5vdmVycmlkZUJ5cGFzcyggc2VsZiwgbmFtZSwgZWFzZWRWYWwgKTtcbiAgICAgICAgICAgIH0gLy8gZm9yIHByb3BzXG4gICAgICAgICAgfSAvLyBpZiBcblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggJCQuaXMuZm4ocGFyYW1zLnN0ZXApICl7XG4gICAgICAgICAgcGFyYW1zLnN0ZXAuYXBwbHkoIHNlbGYsIFsgbm93IF0gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIHBlcmNlbnQgPj0gMSApe1xuICAgICAgICAgIGFuaW1hdGlvbi5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHBlcmNlbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHZhbGlkKHN0YXJ0LCBlbmQpe1xuICAgICAgICBpZiggc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoICQkLmlzLm51bWJlcihzdGFydCkgJiYgJCQuaXMubnVtYmVyKGVuZCkgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmKCAoc3RhcnQpICYmIChlbmQpICl7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gZWFzZShzdGFydFByb3AsIGVuZFByb3AsIHBlcmNlbnQpe1xuICAgICAgICBpZiggcGVyY2VudCA8IDAgKXtcbiAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmKCBwZXJjZW50ID4gMSApe1xuICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgICAgICAgaWYoIHN0YXJ0UHJvcC5weFZhbHVlICE9IG51bGwgfHwgc3RhcnRQcm9wLnZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgICBzdGFydCA9IHN0YXJ0UHJvcC5weFZhbHVlICE9IG51bGwgPyBzdGFydFByb3AucHhWYWx1ZSA6IHN0YXJ0UHJvcC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydCA9IHN0YXJ0UHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBlbmRQcm9wLnB4VmFsdWUgIT0gbnVsbCB8fCBlbmRQcm9wLnZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgICBlbmQgPSBlbmRQcm9wLnB4VmFsdWUgIT0gbnVsbCA/IGVuZFByb3AucHhWYWx1ZSA6IGVuZFByb3AudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gZW5kUHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAkJC5pcy5udW1iZXIoc3RhcnQpICYmICQkLmlzLm51bWJlcihlbmQpICl7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG5cbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoc3RhcnRbMF0pICYmICQkLmlzLm51bWJlcihlbmRbMF0pICl7IC8vIHRoZW4gYXNzdW1lIGEgY29sb3VyXG4gICAgICAgICAgdmFyIGMxID0gc3RhcnQ7XG4gICAgICAgICAgdmFyIGMyID0gZW5kO1xuXG4gICAgICAgICAgdmFyIGNoID0gZnVuY3Rpb24oY2gxLCBjaDIpe1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBjaDIgLSBjaDE7XG4gICAgICAgICAgICB2YXIgbWluID0gY2gxO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoIHBlcmNlbnQgKiBkaWZmICsgbWluICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgciA9IGNoKCBjMVswXSwgYzJbMF0gKTtcbiAgICAgICAgICB2YXIgZyA9IGNoKCBjMVsxXSwgYzJbMV0gKTtcbiAgICAgICAgICB2YXIgYiA9IGNoKCBjMVsyXSwgYzJbMl0gKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuICAgIFxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuXG4gIFxuICAgIFxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIGRhdGE6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgICB9KSxcblxuICAgIHJlbW92ZURhdGE6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlXG4gICAgfSksXG5cbiAgICBzY3JhdGNoOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlU2NyYXRjaDogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIHRyaWdnZXJFdmVudDogZmFsc2VcbiAgICB9KVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uY29yZSh7XG4gICAgb246ICQkLmRlZmluZS5vbigpLCAvLyAub24oIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgZGF0YV0sIGhhbmRsZXIpXG4gICAgb25lOiAkJC5kZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICAgIG9uY2U6ICQkLmRlZmluZS5vbih7IHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHRydWUgfSksXG4gICAgb2ZmOiAkJC5kZWZpbmUub2ZmKCksIC8vIC5vZmYoIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgaGFuZGxlcl0gKVxuICAgIHRyaWdnZXI6ICQkLmRlZmluZS50cmlnZ2VyKCkgLy8gLnRyaWdnZXIoIGV2ZW50cyBbLCBleHRyYVBhcmFtc10gKVxuICB9KTtcblxuICAvLyBhbGlhc2VzIGZvciB0aG9zZSBmb2xrcyB3aG8gbGlrZSBvbGQgc3R1ZmY6XG4gICQkLmNvcmVmbi5iaW5kID0gJCQuY29yZWZuLm9uO1xuICAkJC5jb3JlZm4udW5iaW5kID0gJCQuY29yZWZuLm9mZjtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG4gICAgXG4gICAgcG5nOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICByZXR1cm4gcmVuZGVyZXIucG5nKCBvcHRpb25zICk7ICAgICAgXG4gICAgfVxuICAgIFxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG4gICAgXG4gICAgbGF5b3V0OiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcy5fcHJpdmF0ZS5wcmV2TGF5b3V0ID0gKCBwYXJhbXMgPT0gbnVsbCA/IHRoaXMuX3ByaXZhdGUucHJldkxheW91dCA6IHRoaXMuaW5pdExheW91dCggcGFyYW1zICkgKTtcblxuICAgICAgbGF5b3V0LnJ1bigpO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgbWFrZUxheW91dDogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdExheW91dCggcGFyYW1zICk7XG4gICAgfSxcbiAgICBcbiAgICBpbml0TGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgaWYoIG9wdGlvbnMgPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdMYXlvdXQgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIG9wdGlvbnMubmFtZSA9PSBudWxsICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0EgYG5hbWVgIG11c3QgYmUgc3BlY2lmaWVkIHRvIG1ha2UgYSBsYXlvdXQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICAgIHZhciBMYXlvdXRQcm90byA9ICQkLmV4dGVuc2lvbignbGF5b3V0JywgbmFtZSk7XG4gICAgICBcbiAgICAgIGlmKCBMYXlvdXRQcm90byA9PSBudWxsICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgYXBwbHkgbGF5b3V0OiBObyBzdWNoIGxheW91dCBgJyArIG5hbWUgKyAnYCBmb3VuZDsgZGlkIHlvdSBpbmNsdWRlIGl0cyBKUyBmaWxlPycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMuZWxlcyA9IG9wdGlvbnMuZWxlcyAhPSBudWxsID8gb3B0aW9ucy5lbGVzIDogdGhpcy4kKCk7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcoIG9wdGlvbnMuZWxlcyApICl7XG4gICAgICAgIG9wdGlvbnMuZWxlcyA9IHRoaXMuJCggb3B0aW9ucy5lbGVzICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBsYXlvdXQgPSBuZXcgTGF5b3V0UHJvdG8oICQkLnV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGN5OiB0aGlzXG4gICAgICB9KSApO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgbGF5b3V0IGhhcyBfcHJpdmF0ZSBmb3IgdXNlIHcvIHN0ZCBhcGlzIGxpa2UgLm9uKClcbiAgICAgIGlmKCAhJCQuaXMucGxhaW5PYmplY3QobGF5b3V0Ll9wcml2YXRlKSApe1xuICAgICAgICBsYXlvdXQuX3ByaXZhdGUgPSB7fTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0Ll9wcml2YXRlLmN5ID0gdGhpcztcbiAgICAgIGxheW91dC5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGxheW91dDtcbiAgICB9XG4gICAgXG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcbihmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIG5vdGlmeTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgaWYoIHRoaXMuX3ByaXZhdGUuYmF0Y2hpbmdOb3RpZnkgKXtcbiAgICAgICAgdmFyIGJFbGVzID0gdGhpcy5fcHJpdmF0ZS5iYXRjaE5vdGlmeUVsZXM7XG4gICAgICAgIHZhciBiVHlwZXMgPSB0aGlzLl9wcml2YXRlLmJhdGNoTm90aWZ5VHlwZXM7XG5cbiAgICAgICAgaWYoIHBhcmFtcy5jb2xsZWN0aW9uICl7IGZvciggdmFyIGkgPSAwOyBpIDwgcGFyYW1zLmNvbGxlY3Rpb24ubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gcGFyYW1zLmNvbGxlY3Rpb25baV07XG5cbiAgICAgICAgICBpZiggIWJFbGVzLmlkc1sgZWxlLl9wcml2YXRlLmlkIF0gKXtcbiAgICAgICAgICAgIGJFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XG5cbiAgICAgICAgaWYoICFiVHlwZXMuaWRzWyBwYXJhbXMudHlwZSBdICl7XG4gICAgICAgICAgYlR5cGVzLnB1c2goIHBhcmFtcy50eXBlICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47IC8vIG5vdGlmaWNhdGlvbnMgYXJlIGRpc2FibGVkIGR1cmluZyBiYXRjaGluZ1xuICAgICAgfVxuXG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUubm90aWZpY2F0aW9uc0VuYWJsZWQgKXsgcmV0dXJuOyB9IC8vIGV4aXQgb24gZGlzYWJsZWRcblxuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcigpO1xuICAgICAgXG4gICAgICByZW5kZXJlci5ub3RpZnkocGFyYW1zKTtcbiAgICB9LFxuICAgIFxuICAgIG5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgICB2YXIgcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICBcbiAgICAgIGlmKCBib29sID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHAubm90aWZpY2F0aW9uc0VuYWJsZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwLm5vdGlmaWNhdGlvbnNFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIG5vTm90aWZpY2F0aW9uczogZnVuY3Rpb24oIGNhbGxiYWNrICl7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgICB9LFxuXG4gICAgc3RhcnRCYXRjaDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIF9wLmJhdGNoaW5nU3R5bGUgPSBfcC5iYXRjaGluZ05vdGlmeSA9IHRydWU7XG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcyA9IFtdO1xuICAgICAgX3AuYmF0Y2hOb3RpZnlFbGVzID0gW107XG4gICAgICBfcC5iYXRjaE5vdGlmeVR5cGVzID0gW107XG5cbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzLmlkcyA9IHt9O1xuICAgICAgX3AuYmF0Y2hOb3RpZnlFbGVzLmlkcyA9IHt9O1xuICAgICAgX3AuYmF0Y2hOb3RpZnlUeXBlcy5pZHMgPSB7fTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGVuZEJhdGNoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgLy8gdXBkYXRlIHN0eWxlIGZvciBkaXJ0eSBlbGVzXG4gICAgICBfcC5iYXRjaGluZ1N0eWxlID0gZmFsc2U7XG4gICAgICBuZXcgJCQuQ29sbGVjdGlvbih0aGlzLCBfcC5iYXRjaFN0eWxlRWxlcykudXBkYXRlU3R5bGUoKTtcblxuICAgICAgLy8gbm90aWZ5IHRoZSByZW5kZXJlciBvZiBxdWV1ZWQgZWxlcyBhbmQgZXZlbnQgdHlwZXNcbiAgICAgIF9wLmJhdGNoaW5nTm90aWZ5ID0gZmFsc2U7XG4gICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6IF9wLmJhdGNoTm90aWZ5VHlwZXMsXG4gICAgICAgIGNvbGxlY3Rpb246IF9wLmJhdGNoTm90aWZ5RWxlc1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBiYXRjaDogZnVuY3Rpb24oIGNhbGxiYWNrICl7XG4gICAgICB0aGlzLnN0YXJ0QmF0Y2goKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB0aGlzLmVuZEJhdGNoKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBiYXRjaERhdGE6IGZ1bmN0aW9uKCBtYXAgKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAgIHJldHVybiB0aGlzLmJhdGNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIGZvciggdmFyIGlkIGluIG1hcCApe1xuICAgICAgICAgIHZhciBkYXRhID0gbWFwW2lkXTtcbiAgICAgICAgICB2YXIgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG4gICAgICAgICAgXG4gICAgICAgICAgZWxlLmRhdGEoIGRhdGEgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBcbiAgICByZW5kZXJUbzogZnVuY3Rpb24oIGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyApe1xuICAgICAgdmFyIHIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuXG4gICAgICByLnJlbmRlclRvKCBjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8gKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZW5kZXJlcjogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgIH0sXG5cbiAgICBmb3JjZVJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ2RyYXcnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogJ3Jlc2l6ZSdcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Jlc2l6ZScpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIFxuICAgIGluaXRSZW5kZXJlcjogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICAgIHZhciBSZW5kZXJlclByb3RvID0gJCQuZXh0ZW5zaW9uKCdyZW5kZXJlcicsIG9wdGlvbnMubmFtZSk7XG4gICAgICBpZiggUmVuZGVyZXJQcm90byA9PSBudWxsICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgaW5pdGlhbGlzZTogTm8gc3VjaCByZW5kZXJlciBgJXNgIGZvdW5kOyBkaWQgeW91IGluY2x1ZGUgaXRzIEpTIGZpbGU/Jywgb3B0aW9ucy5uYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLl9wcml2YXRlLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyUHJvdG8oXG4gICAgICAgICQkLnV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgY3k6IGN5LFxuICAgICAgICAgIHN0eWxlOiBjeS5fcHJpdmF0ZS5zdHlsZVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgICBcbiAgICB9XG4gICAgXG4gIH0pOyAgXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuXG4gICAgLy8gZ2V0IGEgY29sbGVjdGlvblxuICAgIC8vIC0gZW1wdHkgY29sbGVjdGlvbiBvbiBubyBhcmdzXG4gICAgLy8gLSBjb2xsZWN0aW9uIG9mIGVsZW1lbnRzIGluIHRoZSBncmFwaCBvbiBzZWxlY3RvciBhcmdcbiAgICAvLyAtIGd1YXJhbnRlZSBhIHJldHVybmVkIGNvbGxlY3Rpb24gd2hlbiBlbGVtZW50cyBvciBjb2xsZWN0aW9uIHNwZWNpZmllZFxuICAgIGNvbGxlY3Rpb246IGZ1bmN0aW9uKCBlbGVzICl7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcoIGVsZXMgKSApe1xuICAgICAgICByZXR1cm4gdGhpcy4kKCBlbGVzICk7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbiggZWxlcyApICl7XG4gICAgICAgIHJldHVybiBlbGVzLmNvbGxlY3Rpb24oKTtcblxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5hcnJheSggZWxlcyApICl7XG4gICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcywgZWxlcyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMgKTtcbiAgICB9LFxuICAgIFxuICAgIG5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuJChmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5pc05vZGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgICAgcmV0dXJuIG5vZGVzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICAgIH0gXG5cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9LFxuICAgIFxuICAgIGVkZ2VzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuJChmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgICAgcmV0dXJuIGVkZ2VzLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH0sXG4gICAgICBcbiAgICAvLyBzZWFyY2ggdGhlIGdyYXBoIGxpa2UgalF1ZXJ5XG4gICAgJDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLCB0aGlzLl9wcml2YXRlLmVsZW1lbnRzICk7XG5cbiAgICAgIGlmKCBzZWxlY3RvciApe1xuICAgICAgICByZXR1cm4gZWxlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVzO1xuICAgIH1cbiAgICBcbiAgfSk7ICBcblxuICAvLyBhbGlhc2VzXG4gICQkLmNvcmVmbi5lbGVtZW50cyA9ICQkLmNvcmVmbi5maWx0ZXIgPSAkJC5jb3JlZm4uJDsgIFxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIHN0eWxlOiBmdW5jdGlvbiggbmV3U3R5bGUgKXtcbiAgICAgIGlmKCBuZXdTdHlsZSApe1xuICAgICAgICB2YXIgcyA9IHRoaXMuc2V0U3R5bGUoIG5ld1N0eWxlICk7XG5cbiAgICAgICAgcy51cGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3R5bGU7XG4gICAgfSxcblxuICAgIHNldFN0eWxlOiBmdW5jdGlvbiggc3R5bGUgKXtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHlsZXNoZWV0KHN0eWxlKSApe1xuICAgICAgICBfcC5zdHlsZSA9IHN0eWxlLmdlbmVyYXRlU3R5bGUodGhpcyk7XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuYXJyYXkoc3R5bGUpICkge1xuICAgICAgICBfcC5zdHlsZSA9ICQkLnN0eWxlLmZyb21Kc29uKHRoaXMsIHN0eWxlKTtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcoc3R5bGUpICl7XG4gICAgICAgIF9wLnN0eWxlID0gJCQuc3R5bGUuZnJvbVN0cmluZyh0aGlzLCBzdHlsZSk7XG4gICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wLnN0eWxlID0gbmV3ICQkLlN0eWxlKCB0aGlzICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcC5zdHlsZTtcbiAgICB9XG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG5cbiAgICBhdXRvbG9jazogZnVuY3Rpb24oYm9vbCl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2sgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b2xvY2s7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBhdXRvdW5ncmFiaWZ5OiBmdW5jdGlvbihib29sKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5ID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG91bmdyYWJpZnk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBhdXRvdW5zZWxlY3RpZnk6IGZ1bmN0aW9uKGJvb2wpe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLmF1dG91bnNlbGVjdGlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBwYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHVzZXJQYW5uaW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyUGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuICAgIFxuICAgIHpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgdXNlclpvb21pbmdFbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBmdW5jdGlvbiggYm9vbCApe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYm94U2VsZWN0aW9uRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICBwYW46IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgICAgc3dpdGNoKCBhcmdzLmxlbmd0aCApe1xuICAgICAgY2FzZSAwOiAvLyAucGFuKClcbiAgICAgICAgcmV0dXJuIHBhbjtcblxuICAgICAgY2FzZSAxOiBcblxuICAgICAgICBpZiggJCQuaXMuc3RyaW5nKCBhcmdzWzBdICkgKXsgLy8gLnBhbigneCcpXG4gICAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgICByZXR1cm4gcGFuWyBkaW0gXTtcblxuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBhcmdzWzBdICkgKSB7IC8vIC5wYW4oeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoeCkgKXtcbiAgICAgICAgICAgIHBhbi54ID0geDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKHkpICl7XG4gICAgICAgICAgICBwYW4ueSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOiAvLyAucGFuKCd4JywgMTAwKVxuICAgICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgICAgaWYoIChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgJCQuaXMubnVtYmVyKHZhbCkgKXtcbiAgICAgICAgICBwYW5bZGltXSA9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhazsgLy8gaW52YWxpZFxuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICBwYW5CeTogZnVuY3Rpb24ocGFyYW1zKXtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgdmFyIGRpbSwgdmFsLCBkaW1zLCB4LCB5O1xuXG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgICAgIGNhc2UgMTogXG5cbiAgICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBhcmdzWzBdICkgKSB7IC8vIC5wYW5CeSh7IHg6IDAsIHk6IDEwMCB9KVxuICAgICAgICAgIGRpbXMgPSBhcmdzWzBdO1xuICAgICAgICAgIHggPSBkaW1zLng7XG4gICAgICAgICAgeSA9IGRpbXMueTtcblxuICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoeCkgKXtcbiAgICAgICAgICAgIHBhbi54ICs9IHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICQkLmlzLm51bWJlcih5KSApe1xuICAgICAgICAgICAgcGFuLnkgKz0geTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6IC8vIC5wYW5CeSgneCcsIDEwMClcbiAgICAgICAgZGltID0gYXJnc1swXTtcbiAgICAgICAgdmFsID0gYXJnc1sxXTtcblxuICAgICAgICBpZiggKGRpbSA9PT0gJ3gnIHx8IGRpbSA9PT0gJ3knKSAmJiAkJC5pcy5udW1iZXIodmFsKSApe1xuICAgICAgICAgIHBhbltkaW1dICs9IHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhazsgLy8gaW52YWxpZFxuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICBmaXQ6IGZ1bmN0aW9uKCBlbGVtZW50cywgcGFkZGluZyApe1xuICAgICAgdmFyIHZpZXdwb3J0U3RhdGUgPSB0aGlzLmdldEZpdFZpZXdwb3J0KCBlbGVtZW50cywgcGFkZGluZyApO1xuXG4gICAgICBpZiggdmlld3BvcnRTdGF0ZSApe1xuICAgICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgICBfcC56b29tID0gdmlld3BvcnRTdGF0ZS56b29tO1xuICAgICAgICBfcC5wYW4gPSB2aWV3cG9ydFN0YXRlLnBhbjtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB6b29tIHZpZXdwb3J0Jyk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgZ2V0Rml0Vmlld3BvcnQ6IGZ1bmN0aW9uKCBlbGVtZW50cywgcGFkZGluZyApe1xuICAgICAgaWYoICQkLmlzLm51bWJlcihlbGVtZW50cykgJiYgcGFkZGluZyA9PT0gdW5kZWZpbmVkICl7IC8vIGVsZW1lbnRzIGlzIG9wdGlvbmFsXG4gICAgICAgIHBhZGRpbmcgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiYjtcblxuICAgICAgaWYoICQkLmlzLnN0cmluZyhlbGVtZW50cykgKXtcbiAgICAgICAgdmFyIHNlbCA9IGVsZW1lbnRzO1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuJCggc2VsICk7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuYm91bmRpbmdCb3goZWxlbWVudHMpICl7IC8vIGFzc3VtZSBiYlxuICAgICAgICB2YXIgYmJlID0gZWxlbWVudHM7XG4gICAgICAgIGJiID0ge1xuICAgICAgICAgIHgxOiBiYmUueDEsXG4gICAgICAgICAgeTE6IGJiZS55MSxcbiAgICAgICAgICB4MjogYmJlLngyLFxuICAgICAgICAgIHkyOiBiYmUueTJcbiAgICAgICAgfTtcblxuICAgICAgICBiYi53ID0gYmIueDIgLSBiYi54MTtcbiAgICAgICAgYmIuaCA9IGJiLnkyIC0gYmIueTE7XG5cbiAgICAgIH0gZWxzZSBpZiggISQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZWxlbWVudHMpICl7XG4gICAgICAgIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cygpO1xuICAgICAgfVxuXG4gICAgICBiYiA9IGJiIHx8IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgICAgdmFyIHpvb207XG4gICAgICBwYWRkaW5nID0gJCQuaXMubnVtYmVyKHBhZGRpbmcpID8gcGFkZGluZyA6IDA7XG5cbiAgICAgIGlmKCAhaXNOYU4odykgJiYgIWlzTmFOKGgpICYmIHcgPiAwICYmIGggPiAwICYmICFpc05hTihiYi53KSAmJiAhaXNOYU4oYmIuaCkgJiYgIGJiLncgPiAwICYmIGJiLmggPiAwICl7XG4gICAgICAgIHpvb20gPSBNYXRoLm1pbiggKHcgLSAyKnBhZGRpbmcpL2JiLncsIChoIC0gMipwYWRkaW5nKS9iYi5oICk7XG5cbiAgICAgICAgLy8gY3JvcCB6b29tXG4gICAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuXG4gICAgICAgIHZhciBwYW4gPSB7IC8vIG5vdyBwYW4gdG8gbWlkZGxlXG4gICAgICAgICAgeDogKHcgLSB6b29tKiggYmIueDEgKyBiYi54MiApKS8yLFxuICAgICAgICAgIHk6IChoIC0gem9vbSooIGJiLnkxICsgYmIueTIgKSkvMlxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgem9vbTogem9vbSwgXG4gICAgICAgICAgcGFuOiBwYW5cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgXG4gICAgbWluWm9vbTogZnVuY3Rpb24oIHpvb20gKXtcbiAgICAgIGlmKCB6b29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWluWm9vbTtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKHpvb20pICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUubWluWm9vbSA9IHpvb207XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtYXhab29tOiBmdW5jdGlvbiggem9vbSApe1xuICAgICAgaWYoIHpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5tYXhab29tO1xuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoem9vbSkgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5tYXhab29tID0gem9vbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHpvb206IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBwb3M7IC8vIGluIHJlbmRlcmVkIHB4XG4gICAgICB2YXIgem9vbTtcblxuICAgICAgaWYoIHBhcmFtcyA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gZ2V0IHRoZSB6b29tXG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnpvb207XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKHBhcmFtcykgKXsgLy8gdGhlbiBzZXQgdGhlIHpvb21cbiAgICAgICAgem9vbSA9IHBhcmFtcztcblxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdChwYXJhbXMpICl7IC8vIHRoZW4gem9vbSBhYm91dCBhIHBvaW50XG4gICAgICAgIHpvb20gPSBwYXJhbXMubGV2ZWw7XG5cbiAgICAgICAgaWYoIHBhcmFtcy5wb3NpdGlvbiApe1xuICAgICAgICAgIHZhciBwID0gcGFyYW1zLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgICAgICB2YXIgeiA9IHRoaXMuX3ByaXZhdGUuem9vbTtcblxuICAgICAgICAgIHBvcyA9IHsgLy8gY29udmVydCB0byByZW5kZXJlZCBweFxuICAgICAgICAgICAgeDogcC54ICogeiArIHBhbi54LFxuICAgICAgICAgICAgeTogcC55ICogeiArIHBhbi55XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKCBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbiApe1xuICAgICAgICAgIHBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHBvcyAmJiAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBwYW5uaW5nIGRpc2FibGVkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyB6b29taW5nIGRpc2FibGVkXG4gICAgICB9XG5cbiAgICAgIGlmKCAhJCQuaXMubnVtYmVyKHpvb20pIHx8ICggcG9zICYmICghJCQuaXMubnVtYmVyKHBvcy54KSB8fCAhJCQuaXMubnVtYmVyKHBvcy55KSkgKSApe1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gY2FuJ3Qgem9vbSB3aXRoIGludmFsaWQgcGFyYW1zXG4gICAgICB9XG5cbiAgICAgIC8vIGNyb3Agem9vbVxuICAgICAgem9vbSA9IHpvb20gPiB0aGlzLl9wcml2YXRlLm1heFpvb20gPyB0aGlzLl9wcml2YXRlLm1heFpvb20gOiB6b29tO1xuICAgICAgem9vbSA9IHpvb20gPCB0aGlzLl9wcml2YXRlLm1pblpvb20gPyB0aGlzLl9wcml2YXRlLm1pblpvb20gOiB6b29tO1xuXG4gICAgICBpZiggcG9zICl7IC8vIHNldCB6b29tIGFib3V0IHBvc2l0aW9uXG4gICAgICAgIHZhciBwYW4xID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICAgIHZhciB6b29tMSA9IHRoaXMuX3ByaXZhdGUuem9vbTtcbiAgICAgICAgdmFyIHpvb20yID0gem9vbTtcbiAgICAgICAgXG4gICAgICAgIHZhciBwYW4yID0ge1xuICAgICAgICAgIHg6IC16b29tMi96b29tMSAqIChwb3MueCAtIHBhbjEueCkgKyBwb3MueCxcbiAgICAgICAgICB5OiAtem9vbTIvem9vbTEgKiAocG9zLnkgLSBwYW4xLnkpICsgcG9zLnlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9wcml2YXRlLnpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjI7XG5cbiAgICAgICAgdmFyIHBvc0NoYW5nZWQgPSBwYW4xLnggIT09IHBhbjIueCB8fCBwYW4xLnkgIT09IHBhbjIueTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCcgem9vbSAnICsgKHBvc0NoYW5nZWQgPyAnIHBhbiAnIDogJycpICsgJyB2aWV3cG9ydCAnICk7XG4gICAgICBcbiAgICAgIH0gZWxzZSB7IC8vIGp1c3Qgc2V0IHRoZSB6b29tXG4gICAgICAgIHRoaXMuX3ByaXZhdGUuem9vbSA9IHpvb207XG4gICAgICAgIHRoaXMudHJpZ2dlcignem9vbSB2aWV3cG9ydCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vdGlmeSh7IC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgdGhhdCB0aGUgdmlld3BvcnQgY2hhbmdlZFxuICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHZpZXdwb3J0OiBmdW5jdGlvbiggb3B0cyApeyBcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgem9vbURlZmQgPSB0cnVlO1xuICAgICAgdmFyIHBhbkRlZmQgPSB0cnVlO1xuICAgICAgdmFyIGV2ZW50cyA9IFtdOyAvLyB0byB0cmlnZ2VyXG4gICAgICB2YXIgem9vbUZhaWxlZCA9IGZhbHNlO1xuICAgICAgdmFyIHBhbkZhaWxlZCA9IGZhbHNlO1xuXG4gICAgICBpZiggIW9wdHMgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICAgIGlmKCAhJCQuaXMubnVtYmVyKG9wdHMuem9vbSkgKXsgem9vbURlZmQgPSBmYWxzZTsgfVxuICAgICAgaWYoICEkJC5pcy5wbGFpbk9iamVjdChvcHRzLnBhbikgKXsgcGFuRGVmZCA9IGZhbHNlOyB9XG4gICAgICBpZiggIXpvb21EZWZkICYmICFwYW5EZWZkICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIGlmKCB6b29tRGVmZCApe1xuICAgICAgICB2YXIgeiA9IG9wdHMuem9vbTtcblxuICAgICAgICBpZiggeiA8IF9wLm1pblpvb20gfHwgeiA+IF9wLm1heFpvb20gfHwgIV9wLnpvb21pbmdFbmFibGVkICl7XG4gICAgICAgICAgem9vbUZhaWxlZCA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfcC56b29tID0gejtcblxuICAgICAgICAgIGV2ZW50cy5wdXNoKCd6b29tJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHBhbkRlZmQgJiYgKCF6b29tRmFpbGVkIHx8ICFvcHRzLmNhbmNlbE9uRmFpbGVkWm9vbSkgJiYgX3AucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgdmFyIHAgPSBvcHRzLnBhbjtcblxuICAgICAgICBpZiggJCQuaXMubnVtYmVyKHAueCkgKXtcbiAgICAgICAgICBfcC5wYW4ueCA9IHAueDtcbiAgICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAkJC5pcy5udW1iZXIocC55KSApe1xuICAgICAgICAgIF9wLnBhbi55ID0gcC55O1xuICAgICAgICAgIHBhbkZhaWxlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFwYW5GYWlsZWQgKXtcbiAgICAgICAgICBldmVudHMucHVzaCgncGFuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGV2ZW50cy5sZW5ndGggPiAwICl7XG4gICAgICAgIGV2ZW50cy5wdXNoKCd2aWV3cG9ydCcpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoIGV2ZW50cy5qb2luKCcgJykgKTtcblxuICAgICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCBlbGVtZW50cyApe1xuICAgICAgdmFyIHBhbiA9IHRoaXMuZ2V0Q2VudGVyUGFuKCBlbGVtZW50cyApO1xuXG4gICAgICBpZiggcGFuICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUucGFuID0gcGFuO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgICB0eXBlOiAndmlld3BvcnQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgZ2V0Q2VudGVyUGFuOiBmdW5jdGlvbiggZWxlbWVudHMsIHpvb20gKXtcbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcoZWxlbWVudHMpICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IGVsZW1lbnRzO1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoIHNlbGVjdG9yICk7XG4gICAgICB9IGVsc2UgaWYoICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSApe1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGJiID0gZWxlbWVudHMuYm91bmRpbmdCb3goKTtcbiAgICAgIHZhciB3ID0gdGhpcy53aWR0aCgpO1xuICAgICAgdmFyIGggPSB0aGlzLmhlaWdodCgpO1xuICAgICAgem9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3ByaXZhdGUuem9vbSA6IHpvb207XG5cbiAgICAgIHZhciBwYW4gPSB7IC8vIG1pZGRsZVxuICAgICAgICB4OiAodyAtIHpvb20qKCBiYi54MSArIGJiLngyICkpLzIsXG4gICAgICAgIHk6IChoIC0gem9vbSooIGJiLnkxICsgYmIueTIgKSkvMlxuICAgICAgfTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHBhbjtcbiAgICB9LFxuICAgIFxuICAgIHJlc2V0OiBmdW5jdGlvbigpe1xuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkIHx8ICF0aGlzLl9wcml2YXRlLnpvb21pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZpZXdwb3J0KHtcbiAgICAgICAgcGFuOiB7IHg6IDAsIHk6IDAgfSxcbiAgICAgICAgem9vbTogMVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICB3aWR0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcblxuICAgICAgaWYoIGNvbnRhaW5lciApe1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTsgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgICB9LFxuXG4gICAgaGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX3ByaXZhdGUuY29udGFpbmVyO1xuXG4gICAgICBpZiggY29udGFpbmVyICl7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMTsgLy8gZmFsbGJhY2sgaWYgbm8gY29udGFpbmVyIChub3QgMCBiL2MgY2FuIGJlIHVzZWQgZm9yIGRpdmlkaW5nIGV0YylcbiAgICB9LFxuXG4gICAgZXh0ZW50OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIHBhbiA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgdmFyIHpvb20gPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgICB2YXIgcmIgPSB0aGlzLnJlbmRlcmVkRXh0ZW50KCk7XG5cbiAgICAgIHZhciBiID0ge1xuICAgICAgICB4MTogKCByYi54MSAtIHBhbi54ICkvem9vbSxcbiAgICAgICAgeDI6ICggcmIueDIgLSBwYW4ueCApL3pvb20sXG4gICAgICAgIHkxOiAoIHJiLnkxIC0gcGFuLnkgKS96b29tLFxuICAgICAgICB5MjogKCByYi55MiAtIHBhbi55ICkvem9vbSxcbiAgICAgIH07XG5cbiAgICAgIGIudyA9IGIueDIgLSBiLngxO1xuICAgICAgYi5oID0gYi55MiAtIGIueTE7XG5cbiAgICAgIHJldHVybiBiO1xuICAgIH0sXG5cbiAgICByZW5kZXJlZEV4dGVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogMCxcbiAgICAgICAgeTE6IDAsXG4gICAgICAgIHgyOiB3aWR0aCxcbiAgICAgICAgeTI6IGhlaWdodCxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGFsaWFzZXNcbiAgJCQuY29yZWZuLmNlbnRyZSA9ICQkLmNvcmVmbi5jZW50ZXI7XG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgJCQuY29yZWZuLmF1dG9sb2NrTm9kZXMgPSAkJC5jb3JlZm4uYXV0b2xvY2s7XG4gICQkLmNvcmVmbi5hdXRvdW5ncmFiaWZ5Tm9kZXMgPSAkJC5jb3JlZm4uYXV0b3VuZ3JhYmlmeTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gVXNlIHRoaXMgaW50ZXJmYWNlIHRvIGRlZmluZSBmdW5jdGlvbnMgZm9yIGNvbGxlY3Rpb25zL2VsZW1lbnRzLlxuICAvLyBUaGlzIGludGVyZmFjZSBpcyBnb29kLCBiZWNhdXNlIGl0IGZvcmNlcyB5b3UgdG8gdGhpbmsgaW4gdGVybXNcbiAgLy8gb2YgdGhlIGNvbGxlY3Rpb25zIGNhc2UgKG1vcmUgdGhhbiAxIGVsZW1lbnQpLCBzbyB3ZSBkb24ndCBuZWVkXG4gIC8vIG5vdGlmaWNhdGlvbiBibG9ja2luZyBub25zZW5zZSBldmVyeXdoZXJlLlxuICAvL1xuICAvLyBPdGhlciBjb2xsZWN0aW9uLSouanMgZmlsZXMgZGVwZW5kIG9uIHRoaXMgYmVpbmcgZGVmaW5lZCBmaXJzdC5cbiAgLy8gSXQncyBhIHRyYWRlIG9mZjogSXQgc2ltcGxpZmllcyB0aGUgY29kZSBmb3IgQ29sbGVjdGlvbiBhbmQgXG4gIC8vIEVsZW1lbnQgaW50ZWdyYXRpb24gc28gbXVjaCB0aGF0IGl0J3Mgd29ydGggaXQgdG8gY3JlYXRlIHRoZVxuICAvLyBKUyBkZXBlbmRlbmN5LlxuICAvL1xuICAvLyBIYXZpbmcgdGhpcyBpbnRlZ3JhdGlvbiBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIGNhbGwgYW55XG4gIC8vIGNvbGxlY3Rpb24gZnVuY3Rpb24gb24gYW4gZWxlbWVudCBhbmQgdmljZSB2ZXJzYS5cblxuICAvLyBlLmcuICQkLmZuLmNvbGxlY3Rpb24oeyBzb21lRnVuYzogZnVuY3Rpb24oKXsgLyogLi4uICovIH0gfSlcbiAgJCQuZm4uY29sbGVjdGlvbiA9ICQkLmZuLmVsZXMgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcblxuICAgICAgJCQuQ29sbGVjdGlvbi5wcm90b3R5cGVbIG5hbWUgXSA9IGZuO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIGZhY3RvcnkgZm9yIGdlbmVyYXRpbmcgZWRnZSBpZHMgd2hlbiBubyBpZCBpcyBzcGVjaWZpZWQgZm9yIGEgbmV3IGVsZW1lbnRcbiAgdmFyIGlkRmFjdG9yeSA9IHtcbiAgICBwcmVmaXg6IHtcbiAgICAgIG5vZGVzOiAnbicsXG4gICAgICBlZGdlczogJ2UnXG4gICAgfSxcbiAgICBpZDoge1xuICAgICAgbm9kZXM6IDAsXG4gICAgICBlZGdlczogMFxuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKGN5LCBlbGVtZW50LCB0cnlUaGlzSWQpe1xuICAgICAgdmFyIGpzb24gPSAkJC5pcy5lbGVtZW50KCBlbGVtZW50ICkgPyBlbGVtZW50Ll9wcml2YXRlIDogZWxlbWVudDtcbiAgICAgIHZhciBncm91cCA9IGpzb24uZ3JvdXA7XG4gICAgICB2YXIgaWQgPSB0cnlUaGlzSWQgIT0gbnVsbCA/IHRyeVRoaXNJZCA6IHRoaXMucHJlZml4W2dyb3VwXSArIHRoaXMuaWRbZ3JvdXBdO1xuICAgICAgXG4gICAgICBpZiggY3kuZ2V0RWxlbWVudEJ5SWQoaWQpLmVtcHR5KCkgKXtcbiAgICAgICAgdGhpcy5pZFtncm91cF0rKzsgLy8gd2UndmUgdXNlZCB0aGUgY3VycmVudCBpZCwgc28gbW92ZSBpdCB1cFxuICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIGtlZXAgdHJ5aW5nIHN1Y2Nlc3NpdmUgdW51c2VkIGlkc1xuICAgICAgICB3aGlsZSggIWN5LmdldEVsZW1lbnRCeUlkKGlkKS5lbXB0eSgpICl7XG4gICAgICAgICAgaWQgPSB0aGlzLnByZWZpeFtncm91cF0gKyAoICsrdGhpcy5pZFtncm91cF0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRWxlbWVudFxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAvLyByZXByZXNlbnRzIGEgbm9kZSBvciBhbiBlZGdlXG4gICQkLkVsZW1lbnQgPSBmdW5jdGlvbihjeSwgcGFyYW1zLCByZXN0b3JlKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuRWxlbWVudCkgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuRWxlbWVudChjeSwgcGFyYW1zLCByZXN0b3JlKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmVzdG9yZSA9IChyZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSA/IHRydWUgOiBmYWxzZSk7XG4gICAgXG4gICAgaWYoIGN5ID09PSB1bmRlZmluZWQgfHwgcGFyYW1zID09PSB1bmRlZmluZWQgfHwgISQkLmlzLmNvcmUoY3kpICl7XG4gICAgICAkJC51dGlsLmVycm9yKCdBbiBlbGVtZW50IG11c3QgaGF2ZSBhIGNvcmUgcmVmZXJlbmNlIGFuZCBwYXJhbWV0ZXJzIHNldCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyB2YWxpZGF0ZSBncm91cFxuICAgIGlmKCBwYXJhbXMuZ3JvdXAgIT09ICdub2RlcycgJiYgcGFyYW1zLmdyb3VwICE9PSAnZWRnZXMnICl7XG4gICAgICAkJC51dGlsLmVycm9yKCdBbiBlbGVtZW50IG11c3QgYmUgb2YgdHlwZSBgbm9kZXNgIG9yIGBlZGdlc2A7IHlvdSBzcGVjaWZpZWQgYCcgKyBwYXJhbXMuZ3JvdXAgKyAnYCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBtYWtlIHRoZSBlbGVtZW50IGFycmF5LWxpa2UsIGp1c3QgbGlrZSBhIGNvbGxlY3Rpb25cbiAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgdGhpc1swXSA9IHRoaXM7XG4gICAgXG4gICAgLy8gTk9URTogd2hlbiBzb21ldGhpbmcgaXMgYWRkZWQgaGVyZSwgYWRkIGFsc28gdG8gZWxlLmpzb24oKVxuICAgIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjeTogY3ksXG4gICAgICBzaW5nbGU6IHRydWUsIC8vIGluZGljYXRlcyB0aGlzIGlzIGFuIGVsZW1lbnRcbiAgICAgIGRhdGE6IHBhcmFtcy5kYXRhIHx8IHt9LCAvLyBkYXRhIG9iamVjdFxuICAgICAgbGF5b3V0RGF0YToge30sIC8vIHBsYWNlIGZvciBsYXlvdXRzIHRvIHB1dCBjYWxjdWxhdGVkIHN0YXRzIGV0YyBmb3IgbWFwcGVyc1xuICAgICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbiB8fCB7fSwgLy8gKHgsIHkpIHBvc2l0aW9uIHBhaXJcbiAgICAgIGF1dG9XaWR0aDogdW5kZWZpbmVkLCAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIG5vZGVzIGNhbGN1bGF0ZWQgYnkgdGhlIHJlbmRlcmVyIHdoZW4gc2V0IHRvIHNwZWNpYWwgJ2F1dG8nIHZhbHVlXG4gICAgICBhdXRvSGVpZ2h0OiB1bmRlZmluZWQsIFxuICAgICAgbGlzdGVuZXJzOiBbXSwgLy8gYXJyYXkgb2YgYm91bmQgbGlzdGVuZXJzXG4gICAgICBncm91cDogcGFyYW1zLmdyb3VwLCAvLyBzdHJpbmc7ICdub2Rlcycgb3IgJ2VkZ2VzJ1xuICAgICAgc3R5bGU6IHt9LCAvLyBwcm9wZXJ0aWVzIGFzIHNldCBieSB0aGUgc3R5bGVcbiAgICAgIHJzdHlsZToge30sIC8vIHByb3BlcnRpZXMgZm9yIHN0eWxlIHNlbnQgZnJvbSB0aGUgcmVuZGVyZXIgdG8gdGhlIGNvcmVcbiAgICAgIHN0eWxlQ3h0czogW10sIC8vIGFwcGxpZWQgc3R5bGUgY29udGV4dHMgZnJvbSB0aGUgc3R5bGVyXG4gICAgICByZW1vdmVkOiB0cnVlLCAvLyB3aGV0aGVyIGl0J3MgaW5zaWRlIHRoZSB2aXM7IHRydWUgaWYgcmVtb3ZlZCAoc2V0IHRydWUgaGVyZSBzaW5jZSB3ZSBjYWxsIHJlc3RvcmUpXG4gICAgICBzZWxlY3RlZDogcGFyYW1zLnNlbGVjdGVkID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0ZWRcbiAgICAgIHNlbGVjdGFibGU6IHBhcmFtcy5zZWxlY3RhYmxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogKCBwYXJhbXMuc2VsZWN0YWJsZSA/IHRydWUgOiBmYWxzZSApLCAvLyB3aGV0aGVyIGl0J3Mgc2VsZWN0YWJsZVxuICAgICAgbG9ja2VkOiBwYXJhbXMubG9ja2VkID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGxvY2tlZCAoY2Fubm90IGJlIG1vdmVkKVxuICAgICAgZ3JhYmJlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgZ3JhYmJlZCBieSB0aGUgbW91c2U7IHJlbmRlcmVyIHNldHMgdGhpcyBwcml2YXRlbHlcbiAgICAgIGdyYWJiYWJsZTogcGFyYW1zLmdyYWJiYWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICggcGFyYW1zLmdyYWJiYWJsZSA/IHRydWUgOiBmYWxzZSApLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGNhbiBiZSBncmFiYmVkXG4gICAgICBhY3RpdmU6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFjdGl2ZSBmcm9tIHVzZXIgaW50ZXJhY3Rpb25cbiAgICAgIGNsYXNzZXM6IHt9LCAvLyBtYXAgKCBjbGFzc05hbWUgPT4gdHJ1ZSApXG4gICAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgICBxdWV1ZTogW11cbiAgICAgIH0sXG4gICAgICByc2NyYXRjaDoge30sIC8vIG9iamVjdCBpbiB3aGljaCB0aGUgcmVuZGVyZXIgY2FuIHN0b3JlIGluZm9ybWF0aW9uXG4gICAgICBzY3JhdGNoOiB7fSwgLy8gc2NyYXRjaCBvYmplY3RzXG4gICAgICBlZGdlczogW10sIC8vIGFycmF5IG9mIGNvbm5lY3RlZCBlZGdlc1xuICAgICAgY2hpbGRyZW46IFtdIC8vIGFycmF5IG9mIGNoaWxkcmVuXG4gICAgfTtcbiAgICBcbiAgICAvLyByZW5kZXJlZFBvc2l0aW9uIG92ZXJyaWRlcyBpZiBzcGVjaWZpZWRcbiAgICBpZiggcGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gKXtcbiAgICAgIHZhciBycG9zID0gcGFyYW1zLnJlbmRlcmVkUG9zaXRpb247XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgdGhpcy5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgeDogKHJwb3MueCAtIHBhbi54KS96b29tLFxuICAgICAgICB5OiAocnBvcy55IC0gcGFuLnkpL3pvb21cbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGlmKCAkJC5pcy5zdHJpbmcocGFyYW1zLmNsYXNzZXMpICl7XG4gICAgICB2YXIgY2xhc3NlcyA9IHBhcmFtcy5jbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICBmb3IoIHZhciBpID0gMCwgbCA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgICAgICBpZiggIWNscyB8fCBjbHMgPT09ICcnICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgc2VsZi5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBwYXJhbXMuY3NzICl7XG4gICAgICBjeS5zdHlsZSgpLmFwcGx5QnlwYXNzKCB0aGlzLCBwYXJhbXMuY3NzICk7XG4gICAgfVxuICAgIFxuICAgIGlmKCByZXN0b3JlID09PSB1bmRlZmluZWQgfHwgcmVzdG9yZSApe1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIFxuICB9O1xuXG4gIFxuICAvLyBDb2xsZWN0aW9uXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIC8vIHJlcHJlc2VudHMgYSBzZXQgb2Ygbm9kZXMsIGVkZ2VzLCBvciBib3RoIHRvZ2V0aGVyXG4gICQkLkNvbGxlY3Rpb24gPSBmdW5jdGlvbihjeSwgZWxlbWVudHMsIG9wdGlvbnMpe1xuICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5Db2xsZWN0aW9uKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG4gICAgfVxuXG4gICAgaWYoIGN5ID09PSB1bmRlZmluZWQgfHwgISQkLmlzLmNvcmUoY3kpICl7XG4gICAgICAkJC51dGlsLmVycm9yKCdBIGNvbGxlY3Rpb24gbXVzdCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb3JlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciBpZHMgPSB7fTtcbiAgICB2YXIgaW5kZXhlcyA9IHt9O1xuICAgIHZhciBjcmVhdGVkRWxlbWVudHMgPSBmYWxzZTtcbiAgICBcbiAgICBpZiggIWVsZW1lbnRzICl7XG4gICAgICBlbGVtZW50cyA9IFtdO1xuICAgIH0gZWxzZSBpZiggZWxlbWVudHMubGVuZ3RoID4gMCAmJiAkJC5pcy5wbGFpbk9iamVjdCggZWxlbWVudHNbMF0gKSAmJiAhJCQuaXMuZWxlbWVudCggZWxlbWVudHNbMF0gKSApe1xuICAgICAgY3JlYXRlZEVsZW1lbnRzID0gdHJ1ZTtcblxuICAgICAgLy8gbWFrZSBlbGVtZW50cyBmcm9tIGpzb24gYW5kIHJlc3RvcmUgYWxsIGF0IG9uY2UgbGF0ZXJcbiAgICAgIHZhciBlbGVzID0gW107XG4gICAgICB2YXIgZWxlc0lkcyA9IHt9O1xuXG4gICAgICBmb3IoIHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICB2YXIganNvbiA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICAgIGlmKCBqc29uLmRhdGEgPT0gbnVsbCApe1xuICAgICAgICAgIGpzb24uZGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgZGF0YSA9IGpzb24uZGF0YTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgbmV3bHkgY3JlYXRlZCBlbGVtZW50cyBoYXZlIHZhbGlkIGlkc1xuICAgICAgICBpZiggZGF0YS5pZCA9PSBudWxsICl7XG4gICAgICAgICAgZGF0YS5pZCA9IGlkRmFjdG9yeS5nZW5lcmF0ZSggY3ksIGpzb24gKTtcbiAgICAgICAgfSBlbHNlIGlmKCBjeS5nZXRFbGVtZW50QnlJZCggZGF0YS5pZCApLmxlbmd0aCAhPT0gMCB8fCBlbGVzSWRzWyBkYXRhLmlkIF0gKXtcbiAgICAgICAgICBjb250aW51ZTsgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgcHJpb3IgaWQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGUgPSBuZXcgJCQuRWxlbWVudCggY3ksIGpzb24sIGZhbHNlICk7XG4gICAgICAgIGVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIGVsZXNJZHNbIGRhdGEuaWQgXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnRzID0gZWxlcztcbiAgICB9XG4gICAgXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiggIWVsZW1lbnQgKXsgIGNvbnRpbnVlOyB9XG4gICAgICBcbiAgICAgIHZhciBpZCA9IGVsZW1lbnQuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIFxuICAgICAgaWYoICFvcHRpb25zIHx8IChvcHRpb25zLnVuaXF1ZSAmJiAhaWRzWyBpZCBdICkgKXtcbiAgICAgICAgaWRzWyBpZCBdID0gZWxlbWVudDtcbiAgICAgICAgaW5kZXhlc1sgaWQgXSA9IHRoaXMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXNbIHRoaXMubGVuZ3RoIF0gPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY3k6IGN5LFxuICAgICAgaWRzOiBpZHMsXG4gICAgICBpbmRleGVzOiBpbmRleGVzXG4gICAgfTtcblxuICAgIC8vIHJlc3RvcmUgdGhlIGVsZW1lbnRzIGlmIHdlIGNyZWF0ZWQgdGhlbSBmcm9tIGpzb25cbiAgICBpZiggY3JlYXRlZEVsZW1lbnRzICl7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG4gIH07XG4gIFxuICBcbiAgLy8gRnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIC8vIGtlZXAgdGhlIHByb3RvdHlwZXMgaW4gc3luYyAoYW4gZWxlbWVudCBoYXMgdGhlIHNhbWUgZnVuY3Rpb25zIGFzIGEgY29sbGVjdGlvbilcbiAgLy8gYW5kIHVzZSAkJC5lbGVmbiBhbmQgJCQuZWxlc2ZuIGFzIHNob3J0aGFuZHMgdG8gdGhlIHByb3RvdHlwZXNcbiAgJCQuZWxlZm4gPSAkJC5lbGVzZm4gPSAkJC5FbGVtZW50LnByb3RvdHlwZSA9ICQkLkNvbGxlY3Rpb24ucHJvdG90eXBlO1xuXG4gICQkLmVsZXNmbi5jeSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuY3k7XG4gIH07XG4gIFxuICAkJC5lbGVzZm4uZWxlbWVudCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXNbMF07XG4gIH07XG4gIFxuICAkJC5lbGVzZm4uY29sbGVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoICQkLmlzLmNvbGxlY3Rpb24odGhpcykgKXtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7IC8vIGFuIGVsZW1lbnRcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgW3RoaXNdICk7XG4gICAgfVxuICB9O1xuXG4gICQkLmVsZXNmbi51bmlxdWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgdGhpcywgeyB1bmlxdWU6IHRydWUgfSApO1xuICB9O1xuXG4gICQkLmVsZXNmbi5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uKCBpZCApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgdmFyIGVsZSA9IHRoaXMuX3ByaXZhdGUuaWRzWyBpZCBdO1xuXG4gICAgcmV0dXJuIGVsZSA/IGVsZSA6ICQkLkNvbGxlY3Rpb24oY3kpOyAvLyBnZXQgZWxlIG9yIGVtcHR5IGNvbGxlY3Rpb25cbiAgfTtcblxuICAkJC5lbGVzZm4uanNvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXMuZWxlbWVudCgpO1xuICAgIGlmKCBlbGUgPT0gbnVsbCApeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICB2YXIgcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICBcbiAgICB2YXIganNvbiA9ICQkLnV0aWwuY29weSh7XG4gICAgICBkYXRhOiBwLmRhdGEsXG4gICAgICBwb3NpdGlvbjogcC5wb3NpdGlvbixcbiAgICAgIGdyb3VwOiBwLmdyb3VwLFxuICAgICAgYnlwYXNzOiBwLmJ5cGFzcyxcbiAgICAgIHJlbW92ZWQ6IHAucmVtb3ZlZCxcbiAgICAgIHNlbGVjdGVkOiBwLnNlbGVjdGVkLFxuICAgICAgc2VsZWN0YWJsZTogcC5zZWxlY3RhYmxlLFxuICAgICAgbG9ja2VkOiBwLmxvY2tlZCxcbiAgICAgIGdyYWJiZWQ6IHAuZ3JhYmJlZCxcbiAgICAgIGdyYWJiYWJsZTogcC5ncmFiYmFibGUsXG4gICAgICBjbGFzc2VzOiAnJ1xuICAgIH0pO1xuICAgIFxuICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgZm9yKCB2YXIgY2xzIGluIHAuY2xhc3NlcyApe1xuICAgICAgaWYoIHAuY2xhc3Nlc1tjbHNdICl7XG4gICAgICAgIGNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgICAganNvbi5jbGFzc2VzICs9IGNscyArICggaSA8IGNsYXNzZXMubGVuZ3RoIC0gMSA/ICcgJyA6ICcnICk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBqc29uO1xuICB9O1xuXG4gICQkLmVsZXNmbi5qc29ucyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGpzb25zID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuXG4gICAgICBqc29ucy5wdXNoKCBqc29uICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb25zO1xuICB9O1xuXG4gICQkLmVsZXNmbi5jbG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgIHZhciBlbGVzQXJyID0gW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgdmFyIGpzb24gPSBlbGUuanNvbigpO1xuICAgICAgdmFyIGNsb25lID0gbmV3ICQkLkVsZW1lbnQoY3ksIGpzb24sIGZhbHNlKTsgLy8gTkIgbm8gcmVzdG9yZVxuXG4gICAgICBlbGVzQXJyLnB1c2goIGNsb25lICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlc0FyciApO1xuICB9O1xuXG4gICQkLmVsZXNmbi5yZXN0b3JlID0gZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXN0b3JlZCA9IFtdO1xuICAgIHZhciBjeSA9IHNlbGYuY3koKTtcbiAgICBcbiAgICBpZiggbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCApe1xuICAgICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhcnJheXMgb2Ygbm9kZXMgYW5kIGVkZ2VzLCBzaW5jZSB3ZSBuZWVkIHRvXG4gICAgLy8gcmVzdG9yZSB0aGUgbm9kZXMgZmlyc3RcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSBbXSwgZWRnZXMgPSBbXTtcbiAgICB2YXIgbnVtTm9kZXMgPSAwO1xuICAgIHZhciBudW1FZGdlcyA9IDA7XG4gICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG4gICAgICBcbiAgICAgIC8vIGtlZXAgbm9kZXMgZmlyc3QgaW4gdGhlIGFycmF5IGFuZCBlZGdlcyBhZnRlclxuICAgICAgaWYoIGVsZS5pc05vZGUoKSApeyAvLyBwdXQgdG8gZnJvbnQgb2YgYXJyYXkgaWYgbm9kZVxuICAgICAgICBub2Rlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgbnVtTm9kZXMrKztcbiAgICAgIH0gZWxzZSB7IC8vIHB1dCB0byBlbmQgb2YgYXJyYXkgaWYgZWRnZVxuICAgICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgbnVtRWRnZXMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtZW50cyA9IG5vZGVzLmNvbmNhdCggZWRnZXMgKTtcblxuICAgIC8vIG5vdywgcmVzdG9yZSBlYWNoIGVsZW1lbnRcbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZW1lbnRzW2ldO1xuXG4gICAgICBpZiggIWVsZS5yZW1vdmVkKCkgKXtcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIF9wcml2YXRlID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIGRhdGEgPSBfcHJpdmF0ZS5kYXRhO1xuICAgICAgXG4gICAgICAvLyBzZXQgaWQgYW5kIHZhbGlkYXRlXG4gICAgICBpZiggZGF0YS5pZCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGRhdGEuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoIGN5LCBlbGUgKTtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuZW1wdHlTdHJpbmcoZGF0YS5pZCkgfHwgISQkLmlzLnN0cmluZyhkYXRhLmlkKSApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBlbGVtZW50IHdpdGggaW52YWxpZCBzdHJpbmcgSUQgYCcgKyBkYXRhLmlkICsgJ2AnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIGl0IGhhcyBlbXB0eSBzdHJpbmcgYXMgaWQgb3Igbm9uLXN0cmluZyBpZFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiggY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuaWQgKS5sZW5ndGggIT09IDAgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgc2Vjb25kIGVsZW1lbnQgd2l0aCBJRCBgJyArIGRhdGEuaWQgKyAnYCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgb25lIGFscmVhZHkgaGFzIHRoYXQgaWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9IGRhdGEuaWQ7IC8vIGlkIGlzIGZpbmFsaXNlZCwgbm93IGxldCdzIGtlZXAgYSByZWZcbiAgICAgIFxuICAgICAgaWYoIGVsZS5pc0VkZ2UoKSApeyAvLyBleHRyYSBjaGVja3MgZm9yIGVkZ2VzXG4gICAgICAgIFxuICAgICAgICB2YXIgZWRnZSA9IGVsZTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFsnc291cmNlJywgJ3RhcmdldCddO1xuICAgICAgICB2YXIgZmllbGRzTGVuZ3RoID0gZmllbGRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGJhZFNvdXJjZU9yVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBmaWVsZHNMZW5ndGg7IGorKyl7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2pdO1xuICAgICAgICAgIHZhciB2YWwgPSBkYXRhW2ZpZWxkXTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggdmFsID09IG51bGwgfHwgdmFsID09PSAnJyApe1xuICAgICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGlmIHNvdXJjZSBvciB0YXJnZXQgaXMgbm90IGRlZmluZWQgcHJvcGVybHlcbiAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggdW5zcGVjaWZpZWQgJyArIGZpZWxkKTtcbiAgICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYoIGN5LmdldEVsZW1lbnRCeUlkKHZhbCkuZW1wdHkoKSApeyBcbiAgICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlZGdlIGlmIG9uZSBvZiBpdHMgbm9kZXMgZG9lc24ndCBleGlzdFxuICAgICAgICAgICAgJCQudXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCBub25leGlzdGFudCAnICsgZmllbGQgKyAnIGAnICsgdmFsICsgJ2AnKTtcbiAgICAgICAgICAgIGJhZFNvdXJjZU9yVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggYmFkU291cmNlT3JUYXJnZXQgKXsgY29udGludWU7IH0gLy8gY2FuJ3QgY3JlYXRlIHRoaXNcbiAgICAgICAgXG4gICAgICAgIHZhciBzcmMgPSBjeS5nZXRFbGVtZW50QnlJZCggZGF0YS5zb3VyY2UgKTtcbiAgICAgICAgdmFyIHRndCA9IGN5LmdldEVsZW1lbnRCeUlkKCBkYXRhLnRhcmdldCApO1xuXG4gICAgICAgIHNyYy5fcHJpdmF0ZS5lZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgIHRndC5fcHJpdmF0ZS5lZGdlcy5wdXNoKCBlZGdlICk7XG5cbiAgICAgICAgZWRnZS5fcHJpdmF0ZS5zb3VyY2UgPSBzcmM7XG4gICAgICAgIGVkZ2UuX3ByaXZhdGUudGFyZ2V0ID0gdGd0O1xuXG4gICAgICB9IC8vIGlmIGlzIGVkZ2VcbiAgICAgICBcbiAgICAgIC8vIGNyZWF0ZSBtb2NrIGlkcyBtYXAgZm9yIGVsZW1lbnQgc28gaXQgY2FuIGJlIHVzZWQgbGlrZSBjb2xsZWN0aW9uc1xuICAgICAgX3ByaXZhdGUuaWRzID0ge307XG4gICAgICBfcHJpdmF0ZS5pZHNbIGlkIF0gPSBlbGU7XG5cbiAgICAgIF9wcml2YXRlLnJlbW92ZWQgPSBmYWxzZTtcbiAgICAgIGN5LmFkZFRvUG9vbCggZWxlICk7XG4gICAgICBcbiAgICAgIHJlc3RvcmVkLnB1c2goIGVsZSApO1xuICAgIH0gLy8gZm9yIGVhY2ggZWxlbWVudFxuXG4gICAgLy8gZG8gY29tcG91bmQgbm9kZSBzYW5pdHkgY2hlY2tzXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrICl7IC8vIGVhY2ggbm9kZSBcbiAgICAgIHZhciBub2RlID0gZWxlbWVudHNbaV07XG4gICAgICB2YXIgZGF0YSA9IG5vZGUuX3ByaXZhdGUuZGF0YTtcblxuICAgICAgdmFyIHBhcmVudElkID0gbm9kZS5fcHJpdmF0ZS5kYXRhLnBhcmVudDtcbiAgICAgIHZhciBzcGVjaWZpZWRQYXJlbnQgPSBwYXJlbnRJZCAhPSBudWxsO1xuXG4gICAgICBpZiggc3BlY2lmaWVkUGFyZW50ICl7XG4gICAgICAgIHZhciBwYXJlbnQgPSBjeS5nZXRFbGVtZW50QnlJZCggcGFyZW50SWQgKTtcblxuICAgICAgICBpZiggcGFyZW50LmVtcHR5KCkgKXtcbiAgICAgICAgICAvLyBub24tZXhpc3RhbnQgcGFyZW50OyBqdXN0IHJlbW92ZSBpdFxuICAgICAgICAgIGRhdGEucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzZWxmQXNQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSBwYXJlbnQ7XG4gICAgICAgICAgd2hpbGUoICFhbmNlc3Rvci5lbXB0eSgpICl7XG4gICAgICAgICAgICBpZiggbm9kZS5zYW1lKGFuY2VzdG9yKSApe1xuICAgICAgICAgICAgICAvLyBtYXJrIHNlbGYgYXMgcGFyZW50IGFuZCByZW1vdmUgZnJvbSBkYXRhXG4gICAgICAgICAgICAgIHNlbGZBc1BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICAgIGRhdGEucGFyZW50ID0gdW5kZWZpbmVkOyAvLyByZW1vdmUgcGFyZW50IHJlZmVyZW5jZVxuXG4gICAgICAgICAgICAgIC8vIGV4aXQgb3Igd2UgbG9vcCBmb3JldmVyXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhc2VsZkFzUGFyZW50ICl7XG4gICAgICAgICAgICAvLyBjb25uZWN0IHdpdGggY2hpbGRyZW5cbiAgICAgICAgICAgIHBhcmVudFswXS5fcHJpdmF0ZS5jaGlsZHJlbi5wdXNoKCBub2RlICk7XG4gICAgICAgICAgICBub2RlLl9wcml2YXRlLnBhcmVudCA9IHBhcmVudFswXTtcblxuICAgICAgICAgICAgLy8gbGV0IHRoZSBjb3JlIGtub3cgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoXG4gICAgICAgICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZWxzZVxuICAgICAgfSAvLyBpZiBzcGVjaWZpZWQgcGFyZW50XG4gICAgfSAvLyBmb3IgZWFjaCBub2RlXG4gICAgXG4gICAgcmVzdG9yZWQgPSBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHJlc3RvcmVkICk7XG4gICAgaWYoIHJlc3RvcmVkLmxlbmd0aCA+IDAgKXtcblxuICAgICAgdmFyIHRvVXBkYXRlU3R5bGUgPSByZXN0b3JlZC5hZGQoIHJlc3RvcmVkLmNvbm5lY3RlZE5vZGVzKCkgKS5hZGQoIHJlc3RvcmVkLnBhcmVudCgpICk7XG4gICAgICB0b1VwZGF0ZVN0eWxlLnVwZGF0ZVN0eWxlKCBub3RpZnlSZW5kZXJlciApO1xuXG4gICAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgICAgcmVzdG9yZWQucnRyaWdnZXIoJ2FkZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdG9yZWQudHJpZ2dlcignYWRkJyk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBzZWxmOyAvLyBjaGFpbmFiaWxpdHlcbiAgfTtcbiAgXG4gICQkLmVsZXNmbi5yZW1vdmVkID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlICYmIGVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xuICB9O1xuXG4gICQkLmVsZXNmbi5pbnNpZGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUgJiYgIWVsZS5fcHJpdmF0ZS5yZW1vdmVkO1xuICB9O1xuXG4gICQkLmVsZXNmbi5yZW1vdmUgPSBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICB2YXIgZWxlc1RvUmVtb3ZlID0gW107XG4gICAgdmFyIGVsZXNUb1JlbW92ZUlkcyA9IHt9O1xuICAgIHZhciBjeSA9IHNlbGYuX3ByaXZhdGUuY3k7XG4gICAgXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgKXtcbiAgICAgIG5vdGlmeVJlbmRlcmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gYWRkIGNvbm5lY3RlZCBlZGdlc1xuICAgIGZ1bmN0aW9uIGFkZENvbm5lY3RlZEVkZ2VzKG5vZGUpe1xuICAgICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlczsgXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGFkZCggZWRnZXNbaV0gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG5cbiAgICAvLyBhZGQgZGVzY2VuZGFudCBub2Rlc1xuICAgIGZ1bmN0aW9uIGFkZENoaWxkcmVuKG5vZGUpe1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5fcHJpdmF0ZS5jaGlsZHJlbjtcbiAgICAgIFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKyApe1xuICAgICAgICBhZGQoIGNoaWxkcmVuW2ldICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKCBlbGUgKXtcbiAgICAgIHZhciBhbHJlYWR5QWRkZWQgPSAgZWxlc1RvUmVtb3ZlSWRzWyBlbGUuaWQoKSBdO1xuICAgICAgaWYoIGFscmVhZHlBZGRlZCApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVzVG9SZW1vdmVJZHNbIGVsZS5pZCgpIF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICAgIGVsZXNUb1JlbW92ZS5wdXNoKCBlbGUgKTsgLy8gbm9kZXMgYXJlIHJlbW92ZWQgbGFzdFxuXG4gICAgICAgIGFkZENvbm5lY3RlZEVkZ2VzKCBlbGUgKTtcbiAgICAgICAgYWRkQ2hpbGRyZW4oIGVsZSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlc1RvUmVtb3ZlLnVuc2hpZnQoIGVsZSApOyAvLyBlZGdlcyBhcmUgcmVtb3ZlZCBmaXJzdFxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2UgdGhlIGxpc3Qgb2YgZWxlbWVudHMgdG8gcmVtb3ZlXG4gICAgLy8gKG1heSBiZSByZW1vdmluZyBtb3JlIHRoYW4gc3BlY2lmaWVkIGR1ZSB0byBjb25uZWN0ZWQgZWRnZXMgZXRjKVxuXG4gICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBzZWxmLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICAgIGFkZCggZWxlICk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHJlbW92ZUVkZ2VSZWYobm9kZSwgZWRnZSl7XG4gICAgICB2YXIgY29ubmVjdGVkRWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgY29ubmVjdGVkRWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2pdO1xuICAgICAgICBcbiAgICAgICAgaWYoIGVkZ2UgPT09IGNvbm5lY3RlZEVkZ2UgKXtcbiAgICAgICAgICBjb25uZWN0ZWRFZGdlcy5zcGxpY2UoIGosIDEgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgZWxlKXtcbiAgICAgIGVsZSA9IGVsZVswXTtcbiAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5fcHJpdmF0ZS5jaGlsZHJlbjtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKyApe1xuICAgICAgICBpZiggY2hpbGRyZW5bal1bMF0gPT09IGVsZVswXSApe1xuICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShqLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1RvUmVtb3ZlW2ldO1xuXG4gICAgICAvLyBtYXJrIGFzIHJlbW92ZWRcbiAgICAgIGVsZS5fcHJpdmF0ZS5yZW1vdmVkID0gdHJ1ZTtcblxuICAgICAgLy8gcmVtb3ZlIGZyb20gY29yZSBwb29sXG4gICAgICBjeS5yZW1vdmVGcm9tUG9vbCggZWxlICk7XG5cbiAgICAgIC8vIGFkZCB0byBsaXN0IG9mIHJlbW92ZWQgZWxlbWVudHNcbiAgICAgIHJlbW92ZWQucHVzaCggZWxlICk7XG5cbiAgICAgIGlmKCBlbGUuaXNFZGdlKCkgKXsgLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gdGhpcyBlZGdlIGluIGl0cyBjb25uZWN0ZWQgbm9kZXNcbiAgICAgICAgdmFyIHNyYyA9IGVsZS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIHRndCA9IGVsZS50YXJnZXQoKVswXTtcblxuICAgICAgICByZW1vdmVFZGdlUmVmKCBzcmMsIGVsZSApO1xuICAgICAgICByZW1vdmVFZGdlUmVmKCB0Z3QsIGVsZSApO1xuXG4gICAgICB9IGVsc2UgeyAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHBhcmVudCBcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsZS5wYXJlbnQoKTtcblxuICAgICAgICBpZiggcGFyZW50Lmxlbmd0aCAhPT0gMCApe1xuICAgICAgICAgIHJlbW92ZUNoaWxkUmVmKHBhcmVudCwgZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGggb3Igbm90XG4gICAgdmFyIGVsZXNTdGlsbEluc2lkZSA9IGN5Ll9wcml2YXRlLmVsZW1lbnRzO1xuICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSBmYWxzZTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNTdGlsbEluc2lkZS5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNTdGlsbEluc2lkZVtpXTtcblxuICAgICAgaWYoIGVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVtb3ZlZEVsZW1lbnRzID0gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSwgcmVtb3ZlZCApO1xuICAgIGlmKCByZW1vdmVkRWxlbWVudHMuc2l6ZSgpID4gMCApe1xuICAgICAgLy8gbXVzdCBtYW51YWxseSBub3RpZnkgc2luY2UgdHJpZ2dlciB3b24ndCBkbyB0aGlzIGF1dG9tYXRpY2FsbHkgb25jZSByZW1vdmVkXG4gICAgICBcbiAgICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgICB0aGlzLmN5KCkubm90aWZ5KHtcbiAgICAgICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICAgICAgICBjb2xsZWN0aW9uOiByZW1vdmVkRWxlbWVudHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJlbW92ZWRFbGVtZW50cy50cmlnZ2VyKCdyZW1vdmUnKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgZW1wdHkgcmVtYWluaW5nIHBhcmVudCBub2Rlc1xuICAgIHZhciBjaGVja2VkUGFyZW50SWQgPSB7fTtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNUb1JlbW92ZVtpXTtcbiAgICAgIHZhciBpc05vZGUgPSBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2Rlcyc7XG4gICAgICB2YXIgcGFyZW50SWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQ7XG5cbiAgICAgIGlmKCBpc05vZGUgJiYgcGFyZW50SWQgIT09IHVuZGVmaW5lZCAmJiAhY2hlY2tlZFBhcmVudElkWyBwYXJlbnRJZCBdICl7XG4gICAgICAgIGNoZWNrZWRQYXJlbnRJZFsgcGFyZW50SWQgXSA9IHRydWU7XG4gICAgICAgIHZhciBwYXJlbnQgPSBjeS5nZXRFbGVtZW50QnlJZCggcGFyZW50SWQgKTtcblxuICAgICAgICBpZiggcGFyZW50ICYmIHBhcmVudC5sZW5ndGggIT09IDAgJiYgIXBhcmVudC5fcHJpdmF0ZS5yZW1vdmVkICYmIHBhcmVudC5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgIHBhcmVudC51cGRhdGVTdHlsZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgJCQuZWxlc2ZuLm1vdmUgPSBmdW5jdGlvbiggc3RydWN0ICl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgIGlmKCBzdHJ1Y3Quc291cmNlICE9PSB1bmRlZmluZWQgfHwgc3RydWN0LnRhcmdldCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB2YXIgc3JjSWQgPSBzdHJ1Y3Quc291cmNlO1xuICAgICAgdmFyIHRndElkID0gc3RydWN0LnRhcmdldDtcbiAgICAgIHZhciBzcmNFeGlzdHMgPSBjeS5nZXRFbGVtZW50QnlJZCggc3JjSWQgKS5sZW5ndGggPiAwO1xuICAgICAgdmFyIHRndEV4aXN0cyA9IGN5LmdldEVsZW1lbnRCeUlkKCB0Z3RJZCApLmxlbmd0aCA+IDA7XG5cbiAgICAgIGlmKCBzcmNFeGlzdHMgfHwgdGd0RXhpc3RzICl7XG4gICAgICAgIHZhciBqc29ucyA9IHRoaXMuanNvbnMoKTtcblxuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuXG4gICAgICAgICAgaWYoIGpzb24uZ3JvdXAgPT09ICdlZGdlcycgKXtcbiAgICAgICAgICAgIGlmKCBzcmNFeGlzdHMgKXsganNvbi5kYXRhLnNvdXJjZSA9IHNyY0lkOyB9XG4gICAgICAgICAgICBpZiggdGd0RXhpc3RzICl7IGpzb24uZGF0YS50YXJnZXQgPSB0Z3RJZDsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjeS5hZGQoIGpzb25zICk7XG4gICAgICB9XG4gXG4gICAgfSBlbHNlIGlmKCBzdHJ1Y3QucGFyZW50ICE9PSB1bmRlZmluZWQgKXsgLy8gbW92ZSBub2RlIHRvIG5ldyBwYXJlbnRcbiAgICAgIHZhciBwYXJlbnRJZCA9IHN0cnVjdC5wYXJlbnQ7XG4gICAgICB2YXIgcGFyZW50RXhpc3RzID0gcGFyZW50SWQgPT09IG51bGwgfHwgY3kuZ2V0RWxlbWVudEJ5SWQoIHBhcmVudElkICkubGVuZ3RoID4gMDtcbiAgICBcbiAgICAgIGlmKCBwYXJlbnRFeGlzdHMgKXtcbiAgICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuICAgICAgICB2YXIgZGVzY3MgPSB0aGlzLmRlc2NlbmRhbnRzKCk7XG4gICAgICAgIHZhciBkZXNjc0V0YyA9IGRlc2NzLm1lcmdlKCBkZXNjcy5hZGQodGhpcykuY29ubmVjdGVkRWRnZXMoKSApO1xuXG4gICAgICAgIHRoaXMucmVtb3ZlKCk7IC8vIE5COiBhbHNvIHJlbW92ZXMgZGVzY2VuZGFudHMgYW5kIHRoZWlyIGNvbm5lY3RlZCBlZGdlc1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG5cbiAgICAgICAgICBpZigganNvbi5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICAgICAganNvbi5kYXRhLnBhcmVudCA9IHBhcmVudElkID09PSBudWxsID8gdW5kZWZpbmVkIDogcGFyZW50SWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjeS5hZGQoIGpzb25zICkubWVyZ2UoIGRlc2NzRXRjLnJlc3RvcmUoKSApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBpZiBub3RoaW5nIGRvbmVcbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBzZWFyY2gsIHNwYW5uaW5nIHRyZWVzLCBldGNcbiAgJCQuZm4uZWxlcyh7XG5cbiAgICAvLyBzdGQgZnVuY3Rpb25hbCBlbGUgZmlyc3QgY2FsbGJhY2sgc3R5bGVcbiAgICBzdGRCcmVhZHRoRmlyc3RTZWFyY2g6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICBvcHRpb25zID0gJCQudXRpbC5leHRlbmQoIHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHN0ZDogdHJ1ZVxuICAgICAgfSApO1xuXG4gICAgICByZXR1cm4gdGhpcy5icmVhZHRoRmlyc3RTZWFyY2goIG9wdGlvbnMgKTtcbiAgICB9LFxuXG4gICAgLy8gZG8gYSBicmVhZHRoIGZpcnN0IHNlYXJjaCBmcm9tIHRoZSBub2RlcyBpbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGZyb20gcHNldWRvY29kZSBvbiB3aWtpcGVkaWFcbiAgICBicmVhZHRoRmlyc3RTZWFyY2g6IGZ1bmN0aW9uKCByb290cywgZm4sIGRpcmVjdGVkICl7XG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIHZhciBzdGQ7XG4gICAgICB2YXIgdGhpc0FyZztcbiAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChyb290cykgJiYgISQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24ocm9vdHMpICl7XG4gICAgICAgIG9wdGlvbnMgPSByb290cztcbiAgICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzO1xuICAgICAgICBmbiA9IG9wdGlvbnMudmlzaXQ7XG4gICAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgICAgc3RkID0gb3B0aW9ucy5zdGQ7XG4gICAgICAgIHRoaXNBcmcgPSBvcHRpb25zLnRoaXNBcmc7XG4gICAgICB9XG5cbiAgICAgIGRpcmVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhJCQuaXMuZm4oZm4pID8gZm4gOiBkaXJlY3RlZDtcbiAgICAgIGZuID0gJCQuaXMuZm4oZm4pID8gZm4gOiBmdW5jdGlvbigpe307XG4gICAgICBcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgdiA9ICQkLmlzLnN0cmluZyhyb290cykgPyB0aGlzLmZpbHRlcihyb290cykgOiByb290cztcbiAgICAgIHZhciBRID0gW107XG4gICAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBbXTtcbiAgICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgICB2YXIgViA9IHt9O1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIGZvdW5kO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuXG4gICAgICAvLyBlbnF1ZXVlIHZcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKyApe1xuICAgICAgICBpZiggdltpXS5pc05vZGUoKSApe1xuICAgICAgICAgIFEudW5zaGlmdCggdltpXSApO1xuICAgICAgICAgIFZbIHZbaV0uaWQoKSBdID0gdHJ1ZTsgXG5cbiAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB2W2ldICk7XG4gICAgICAgICAgaWQyZGVwdGhbIHZbaV0uaWQoKSBdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSggUS5sZW5ndGggIT09IDAgKXtcbiAgICAgICAgdmFyIHYgPSBRLnNoaWZ0KCk7XG4gICAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoWyB2LmlkKCkgXTtcbiAgICAgICAgdmFyIHByZXZFZGdlID0gY29ubmVjdGVkQnlbIHYuaWQoKSBdO1xuICAgICAgICB2YXIgcHJldk5vZGUgPSBwcmV2RWRnZSA9PSBudWxsID8gdW5kZWZpbmVkIDogcHJldkVkZ2UuY29ubmVjdGVkTm9kZXMoKS5ub3QoIHYgKVswXTtcbiAgICAgICAgdmFyIHJldDtcblxuICAgICAgICBpZiggc3RkICl7XG4gICAgICAgICAgcmV0ID0gZm4uY2FsbCh0aGlzQXJnLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGZuLmNhbGwodiwgaisrLCBkZXB0aCwgdiwgcHJldkVkZ2UsIHByZXZOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXQgPT09IHRydWUgKXtcbiAgICAgICAgICBmb3VuZCA9IHY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApe1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZ3RWRnZXMgPSB2LmNvbm5lY3RlZEVkZ2VzKGRpcmVjdGVkID8gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YSgnc291cmNlJykgPT09IHYuaWQoKTsgfSA6IHVuZGVmaW5lZCkuaW50ZXJzZWN0KCBlZGdlcyApO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07XG4gICAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmlkKCkgIT09IHYuaWQoKTsgfSkuaW50ZXJzZWN0KCBub2RlcyApO1xuXG4gICAgICAgICAgaWYoIHcubGVuZ3RoICE9PSAwICYmICFWWyB3LmlkKCkgXSApe1xuICAgICAgICAgICAgdyA9IHdbMF07XG5cbiAgICAgICAgICAgIFEucHVzaCggdyApO1xuICAgICAgICAgICAgVlsgdy5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZDJkZXB0aFsgdy5pZCgpIF0gPSBpZDJkZXB0aFsgdi5pZCgpIF0gKyAxO1xuXG4gICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB3ICk7XG4gICAgICAgICAgICBjb25uZWN0ZWRCeVsgdy5pZCgpIF0gPSBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IGNvbm5lY3RlZE5vZGVzW2ldO1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEJ5WyBub2RlLmlkKCkgXTtcblxuICAgICAgICBpZiggZWRnZSApe1xuICAgICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaCggZWRnZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBub2RlICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgY29ubmVjdGVkRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgICBmb3VuZDogbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBmb3VuZCwgeyB1bmlxdWU6IHRydWUgfSApXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBzdGQgZnVuY3Rpb25hbCBlbGUgZmlyc3QgY2FsbGJhY2sgc3R5bGVcbiAgICBzdGREZXB0aEZpcnN0U2VhcmNoOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgb3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKCB7fSwgb3B0aW9ucywge1xuICAgICAgICBzdGQ6IHRydWVcbiAgICAgIH0gKTtcblxuICAgICAgcmV0dXJuIHRoaXMuZGVwdGhGaXJzdFNlYXJjaCggb3B0aW9ucyApO1xuICAgIH0sXG5cbiAgICAvLyBkbyBhIGRlcHRoIGZpcnN0IHNlYXJjaCBvbiB0aGUgbm9kZXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBmcm9tIHBzZXVkb2NvZGUgb24gd2lraXBlZGlhIChpdGVyYXRpdmUgaW1wbClcbiAgICBkZXB0aEZpcnN0U2VhcmNoOiBmdW5jdGlvbiggcm9vdHMsIGZuLCBkaXJlY3RlZCApe1xuICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICB2YXIgc3RkO1xuICAgICAgdmFyIHRoaXNBcmc7XG4gICAgICBpZiggJCQuaXMucGxhaW5PYmplY3Qocm9vdHMpICYmICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSApe1xuICAgICAgICBvcHRpb25zID0gcm9vdHM7XG4gICAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgICAgICAgZm4gPSBvcHRpb25zLnZpc2l0O1xuICAgICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICAgIHN0ZCA9IG9wdGlvbnMuc3RkO1xuICAgICAgICB0aGlzQXJnID0gb3B0aW9ucy50aGlzQXJnO1xuICAgICAgfVxuICAgICAgXG4gICAgICBkaXJlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgISQkLmlzLmZuKGZuKSA/IGZuIDogZGlyZWN0ZWQ7XG4gICAgICBmbiA9ICQkLmlzLmZuKGZuKSA/IGZuIDogZnVuY3Rpb24oKXt9O1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciB2ID0gJCQuaXMuc3RyaW5nKHJvb3RzKSA/IHRoaXMuZmlsdGVyKHJvb3RzKSA6IHJvb3RzO1xuICAgICAgdmFyIFMgPSBbXTtcbiAgICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgICAgdmFyIGNvbm5lY3RlZEJ5ID0ge307XG4gICAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICAgIHZhciBkaXNjb3ZlcmVkID0ge307XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICB2YXIgZm91bmQ7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIC8vIHB1c2ggdlxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCB2W2ldLmlzTm9kZSgpICl7XG4gICAgICAgICAgUy5wdXNoKCB2W2ldICk7XG5cbiAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB2W2ldICk7XG4gICAgICAgICAgaWQyZGVwdGhbIHZbaV0uaWQoKSBdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSggUy5sZW5ndGggIT09IDAgKXtcbiAgICAgICAgdmFyIHYgPSBTLnBvcCgpO1xuXG4gICAgICAgIGlmKCAhZGlzY292ZXJlZFsgdi5pZCgpIF0gKXtcbiAgICAgICAgICBkaXNjb3ZlcmVkWyB2LmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgdi5pZCgpIF07XG4gICAgICAgICAgdmFyIHByZXZFZGdlID0gY29ubmVjdGVkQnlbIHYuaWQoKSBdO1xuICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IHByZXZFZGdlID09IG51bGwgPyB1bmRlZmluZWQgOiBwcmV2RWRnZS5jb25uZWN0ZWROb2RlcygpLm5vdCggdiApWzBdO1xuICAgICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgICBpZiggc3RkICl7XG4gICAgICAgICAgICByZXQgPSBmbi5jYWxsKHRoaXNBcmcsIHYsIHByZXZFZGdlLCBwcmV2Tm9kZSwgaisrLCBkZXB0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IGZuLmNhbGwodiwgaisrLCBkZXB0aCwgdiwgcHJldkVkZ2UsIHByZXZOb2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggcmV0ID09PSB0cnVlICl7XG4gICAgICAgICAgICBmb3VuZCA9IHY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApe1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZ3RWRnZXMgPSB2LmNvbm5lY3RlZEVkZ2VzKGRpcmVjdGVkID8gZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YSgnc291cmNlJykgPT09IHYuaWQoKTsgfSA6IHVuZGVmaW5lZCkuaW50ZXJzZWN0KCBlZGdlcyApO1xuICAgICAgICAgIFxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW2ldO1xuICAgICAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmlkKCkgIT09IHYuaWQoKTsgfSkuaW50ZXJzZWN0KCBub2RlcyApO1xuXG4gICAgICAgICAgICBpZiggdy5sZW5ndGggIT09IDAgJiYgIWRpc2NvdmVyZWRbIHcuaWQoKSBdICl7XG4gICAgICAgICAgICAgIHcgPSB3WzBdO1xuXG4gICAgICAgICAgICAgIFMucHVzaCggdyApO1xuXG4gICAgICAgICAgICAgIGlkMmRlcHRoWyB3LmlkKCkgXSA9IGlkMmRlcHRoWyB2LmlkKCkgXSArIDE7XG5cbiAgICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdyApO1xuICAgICAgICAgICAgICBjb25uZWN0ZWRCeVsgdy5pZCgpIF0gPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29ubmVjdGVkRWxlcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gY29ubmVjdGVkTm9kZXNbaV07XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbIG5vZGUuaWQoKSBdO1xuXG4gICAgICAgIGlmKCBlZGdlICl7XG4gICAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBjb25uZWN0ZWRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICksXG4gICAgICAgIGZvdW5kOiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGZvdW5kLCB7IHVuaXF1ZTogdHJ1ZSB9IClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIGtydXNrYWwncyBhbGdvcml0aG0gKGZpbmRzIG1pbiBzcGFubmluZyB0cmVlLCBhc3N1bWluZyB1bmRpcmVjdGVkIGdyYXBoKVxuICAgIC8vIGltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIGtydXNrYWw6IGZ1bmN0aW9uKCB3ZWlnaHRGbiApe1xuICAgICAgd2VpZ2h0Rm4gPSAkJC5pcy5mbih3ZWlnaHRGbikgPyB3ZWlnaHRGbiA6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9OyAvLyBpZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG5cbiAgICAgIGZ1bmN0aW9uIGZpbmRTZXQoZWxlKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlcyA9IGZvcmVzdFtpXTtcblxuICAgICAgICAgIGlmKCBlbGVzLmFueVNhbWUoZWxlKSApe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZWxlczogZWxlcyxcbiAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBBID0gbmV3ICQkLkNvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgW10pO1xuICAgICAgdmFyIGZvcmVzdCA9IFtdO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGZvcmVzdC5wdXNoKCBub2Rlc1tpXS5jb2xsZWN0aW9uKCkgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgICAgdmFyIFMgPSBlZGdlcy50b0FycmF5KCkuc29ydChmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgdmFyIHdlaWdodEEgPSB3ZWlnaHRGbi5jYWxsKGEsIGEpO1xuICAgICAgICB2YXIgd2VpZ2h0QiA9IHdlaWdodEZuLmNhbGwoYiwgYik7XG5cbiAgICAgICAgcmV0dXJuIHdlaWdodEEgLSB3ZWlnaHRCO1xuICAgICAgfSk7XG5cbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBTLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBTW2ldO1xuICAgICAgICB2YXIgdSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICAgIHZhciB2ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgICAgICAgdmFyIHNldFUgPSBmaW5kU2V0KHUpO1xuICAgICAgICB2YXIgc2V0ViA9IGZpbmRTZXQodik7XG5cbiAgICAgICAgaWYoIHNldFUuaW5kZXggIT09IHNldFYuaW5kZXggKXtcbiAgICAgICAgICBBID0gQS5hZGQoIGVkZ2UgKTtcblxuICAgICAgICAgIC8vIGNvbWJpbmUgZm9yZXN0cyBmb3IgdSBhbmQgdlxuICAgICAgICAgIGZvcmVzdFsgc2V0VS5pbmRleCBdID0gc2V0VS5lbGVzLmFkZCggc2V0Vi5lbGVzICk7XG4gICAgICAgICAgZm9yZXN0LnNwbGljZSggc2V0Vi5pbmRleCwgMSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2Rlcy5hZGQoIEEgKTtcblxuICAgIH0sXG5cbiAgICBkaWprc3RyYTogZnVuY3Rpb24oIHJvb3QsIHdlaWdodEZuLCBkaXJlY3RlZCApe1xuICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICBpZiggJCQuaXMucGxhaW5PYmplY3Qocm9vdCkgJiYgISQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24ocm9vdCkgKXtcbiAgICAgICAgb3B0aW9ucyA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSBvcHRpb25zLnJvb3Q7XG4gICAgICAgIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIGRpcmVjdGVkID0gISQkLmlzLmZuKHdlaWdodEZuKSA/IHdlaWdodEZuIDogZGlyZWN0ZWQ7XG4gICAgICB3ZWlnaHRGbiA9ICQkLmlzLmZuKHdlaWdodEZuKSA/IHdlaWdodEZuIDogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH07IC8vIGlmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcblxuICAgICAgdmFyIHNvdXJjZSA9ICQkLmlzLnN0cmluZyhyb290KSA/IHRoaXMuZmlsdGVyKHJvb3QpLmVxKDApIDogcm9vdC5lcSgwKTtcbiAgICAgIHZhciBkaXN0ID0ge307XG4gICAgICB2YXIgcHJldiA9IHt9O1xuICAgICAgdmFyIGtub3duRGlzdCA9IHt9O1xuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuZmlsdGVyKGZ1bmN0aW9uKCl7IHJldHVybiAhdGhpcy5pc0xvb3AoKTsgfSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgUSA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGRpc3RbIG5vZGVzW2ldLmlkKCkgXSA9IG5vZGVzW2ldLnNhbWUoIHNvdXJjZSApID8gMCA6IEluZmluaXR5O1xuICAgICAgICBRLnB1c2goIG5vZGVzW2ldICk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZUZuID0gZnVuY3Rpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gZGlzdFsgbm9kZS5pZCgpIF07XG4gICAgICB9O1xuICAgICAgXG4gICAgICBRID0gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIFEpO1xuICAgIFxuICAgICAgdmFyIGhlYXAgPSAkJC5NaW5oZWFwKGN5LCBRLCB2YWx1ZUZuKTtcbiAgICBcbiAgICAgIHZhciBkaXN0QmV0d2VlbiA9IGZ1bmN0aW9uKHUsIHYpe1xuICAgICAgICB2YXIgdXZzID0gKCBkaXJlY3RlZCA/IHUuZWRnZXNUbyh2KSA6IHUuZWRnZXNXaXRoKHYpICkuaW50ZXJzZWN0KGVkZ2VzKTtcbiAgICAgICAgdmFyIHNtYWxsZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIHNtYWxsZXN0RWRnZTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHV2cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gdXZzW2ldO1xuICAgICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseSggZWRnZSwgW2VkZ2VdICk7XG5cbiAgICAgICAgICBpZiggd2VpZ2h0IDwgc21hbGxlc3REaXN0YW5jZSB8fCAhc21hbGxlc3RFZGdlICl7XG4gICAgICAgICAgICBzbWFsbGVzdERpc3RhbmNlID0gd2VpZ2h0O1xuICAgICAgICAgICAgc21hbGxlc3RFZGdlID0gZWRnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVkZ2U6IHNtYWxsZXN0RWRnZSxcbiAgICAgICAgICBkaXN0OiBzbWFsbGVzdERpc3RhbmNlXG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICB3aGlsZShoZWFwLnNpemUoKSA+IDApe1xuICAgICAgICB2YXIgc21hbGxlc3RFbCA9IGhlYXAucG9wKCksXG4gICAgICAgIHNtYWxsZXRzRGlzdCA9IHNtYWxsZXN0RWwudmFsdWUsXG4gICAgICAgIHVpZCA9IHNtYWxsZXN0RWwuaWQsXG4gICAgICAgIHUgPSBjeS5nZXRFbGVtZW50QnlJZCh1aWQpO1xuICAgIFxuICAgICAgICBrbm93bkRpc3RbdWlkXSA9IHNtYWxsZXRzRGlzdDtcbiAgICAgIFxuICAgICAgICBpZiggc21hbGxldHNEaXN0ID09PSBNYXRoLkluZmluaXRlICl7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdS5uZWlnaGJvcmhvb2QoKS5pbnRlcnNlY3Qobm9kZXMpO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciB2ID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICAgIHZhciB2aWQgPSB2LmlkKCk7XG4gICAgICAgICAgdmFyIHZEaXN0ID0gZGlzdEJldHdlZW4odSwgdik7XG5cbiAgICAgICAgICB2YXIgYWx0ID0gc21hbGxldHNEaXN0ICsgdkRpc3QuZGlzdDtcblxuICAgICAgICAgIGlmKCBhbHQgPCBoZWFwLmdldFZhbHVlQnlJZCh2aWQpICl7XG4gICAgICAgICAgICBoZWFwLmVkaXQodmlkLCBhbHQpO1xuICAgICAgICAgICAgcHJldlsgdmlkIF0gPSB7XG4gICAgICAgICAgICAgIG5vZGU6IHUsXG4gICAgICAgICAgICAgIGVkZ2U6IHZEaXN0LmVkZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZvciBcbiAgICAgIH0gLy8gd2hpbGVcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzdGFuY2VUbzogZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgdmFyIHRhcmdldCA9ICQkLmlzLnN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKS5lcSgwKSA6IG5vZGUuZXEoMCk7XG5cbiAgICAgICAgICByZXR1cm4ga25vd25EaXN0WyB0YXJnZXQuaWQoKSBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhdGhUbzogZnVuY3Rpb24obm9kZSl7XG4gICAgICAgICAgdmFyIHRhcmdldCA9ICQkLmlzLnN0cmluZyhub2RlKSA/IG5vZGVzLmZpbHRlcihub2RlKS5lcSgwKSA6IG5vZGUuZXEoMCk7XG4gICAgICAgICAgdmFyIFMgPSBbXTtcbiAgICAgICAgICB2YXIgdSA9IHRhcmdldDtcblxuICAgICAgICAgIGlmKCB0YXJnZXQubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgUy51bnNoaWZ0KCB0YXJnZXQgKTtcblxuICAgICAgICAgICAgd2hpbGUoIHByZXZbIHUuaWQoKSBdICl7XG4gICAgICAgICAgICAgIHZhciBwID0gcHJldlsgdS5pZCgpIF07XG5cbiAgICAgICAgICAgICAgUy51bnNoaWZ0KCBwLmVkZ2UgKTtcbiAgICAgICAgICAgICAgUy51bnNoaWZ0KCBwLm5vZGUgKTtcblxuICAgICAgICAgICAgICB1ID0gcC5ub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIFMgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9ICBcbiAgfSk7XG5cbiAgLy8gbmljZSwgc2hvcnQgbWF0aGVtYXRoaWNhbCBhbGlhc1xuICAkJC5lbGVzZm4uYmZzID0gJCQuZWxlc2ZuLmJyZWFkdGhGaXJzdFNlYXJjaDtcbiAgJCQuZWxlc2ZuLmRmcyA9ICQkLmVsZXNmbi5kZXB0aEZpcnN0U2VhcmNoO1xuICAkJC5lbGVzZm4uc3RkQmZzID0gJCQuZWxlc2ZuLnN0ZEJyZWFkdGhGaXJzdFNlYXJjaDtcbiAgJCQuZWxlc2ZuLnN0ZERmcyA9ICQkLmVsZXNmbi5zdGREZXB0aEZpcnN0U2VhcmNoO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpIHsgXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBZGRpdGlvbmFsIGdyYXBoIGFuYWx5c2lzIGFsZ29yaXRobXNcbiAgJCQuZm4uZWxlcyh7XG5cbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcblxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHJvb3QgLy8gc3RhcnRpbmcgbm9kZSAoZWl0aGVyIGVsZW1lbnQgb3Igc2VsZWN0b3Igc3RyaW5nKVxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGhldXJpc3RpYzogZnVuY3Rpb24oIG5vZGUgKXt9IC8vIHNwZWNpZmllcyBoZXVyaXN0aWMgdmFsdWUgZm9yIGBub2RlYC9gdGhpc2BcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyAgIGdvYWwgLy8gdGFyZ2V0IG5vZGUgKGVpdGhlciBlbGVtZW50IG9yIHNlbGVjdG9yIHN0cmluZykuIE1hbmRhdG9yeS5cblxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIGZvdW5kIDogdHJ1ZS9mYWxzZSAvLyB3aGV0aGVyIGEgcGF0aCBmcm9tIHJvb3QgdG8gZ29hbCBoYXMgYmVlbiBmb3VuZFxuICAgIC8vICAgZGlzdGFuY2UgLy8gRGlzdGFuY2UgZm9yIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gcm9vdCB0byBnb2FsXG4gICAgLy8gICBwYXRoIC8vIEFycmF5IG9mIGlkcyBvZiBub2RlcyBpbiBzaG9ydGVzdCBwYXRoXG4gICAgYVN0YXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gUmVjb25zdHJ1Y3RzIHRoZSBwYXRoIGZyb20gU3RhcnQgdG8gRW5kLCBhY3VtdWxhdGluZyB0aGUgcmVzdWx0IGluIHBhdGhBY3VtXG4gICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgY2FtZUZyb21NYXAsIHBhdGhBY3VtKSB7XG4gICAgICAgIC8vIEJhc2UgY2FzZVxuICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKSB7XG4gICAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoZW5kKSApO1xuICAgICAgICAgIHJldHVybiBwYXRoQWN1bTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGVuZCBpbiBjYW1lRnJvbU1hcCkge1xuICAgICAgICAgIC8vIFdlIGtub3cgd2hpY2ggbm9kZSBpcyBiZWZvcmUgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gY2FtZUZyb21NYXBbZW5kXTtcbiAgICAgICAgICB2YXIgcHJldmlvdXNFZGdlID0gY2FtZUZyb21FZGdlW2VuZF07XG5cbiAgICAgICAgICBwYXRoQWN1bS5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChlbmQpICk7XG4gICAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocHJldmlvdXNFZGdlKSApO1xuXG5cbiAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RQYXRoKHN0YXJ0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMsIFxuICAgICAgICAgICAgICAgICAgICAgICBjYW1lRnJvbU1hcCwgXG4gICAgICAgICAgICAgICAgICAgICAgIHBhdGhBY3VtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcmVhY2ggaGVyZSFcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgICAgICAgXG4gICAgICB9O1xuXG4gICAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiBvcGVuU2V0IHdoaWNoIGhhcyBtaW5pbXVtIGZTY29yZVxuICAgICAgdmFyIGZpbmRNaW4gPSBmdW5jdGlvbihvcGVuU2V0LCBmU2NvcmUpIHtcbiAgICAgICAgaWYgKG9wZW5TZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGJlIHRoZSBjYXNlXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluUG9zID0gMDtcbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGZTY29yZVtvcGVuU2V0WzBdXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvcGVuU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHMgPSBmU2NvcmVbb3BlblNldFtpXV07XG4gICAgICAgICAgaWYgKHMgPCB0ZW1wU2NvcmUpIHtcbiAgICAgICAgICAgIHRlbXBTY29yZSA9IHM7XG4gICAgICAgICAgICBtaW5Qb3MgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluUG9zO1xuICAgICAgfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxvZ0RlYnVnKFwiU3RhcnRpbmcgYVN0YXIuLi5cIik7IFxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5yb290ICE9IG51bGwpIHsgICAgICAgIFxuICAgICAgICB2YXIgc291cmNlID0gJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkgPyBcbiAgICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgICB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdIDogXG4gICAgICAgICAgb3B0aW9ucy5yb290WzBdO1xuICAgICAgICBsb2dEZWJ1ZyhcIlNvdXJjZSBub2RlOiAlc1wiLCBzb3VyY2UuaWQoKSk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gZ29hbCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zLmdvYWwgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIHRhcmdldCA9ICQkLmlzLnN0cmluZyhvcHRpb25zLmdvYWwpID8gXG4gICAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjZ29hbElEXG4gICAgICAgICAgdGhpcy5maWx0ZXIob3B0aW9ucy5nb2FsKVswXSA6IFxuICAgICAgICAgIG9wdGlvbnMuZ29hbFswXTtcbiAgICAgICAgbG9nRGVidWcoXCJUYXJnZXQgbm9kZTogJXNcIiwgdGFyZ2V0LmlkKCkpOyBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEhldXJpc3RpYyBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5oZXVyaXN0aWMgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLmhldXJpc3RpYykpIHsgICAgICAgXG4gICAgICAgIHZhciBoZXVyaXN0aWMgPSBvcHRpb25zLmhldXJpc3RpYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoZXVyaXN0aWMgPSBmdW5jdGlvbigpeyByZXR1cm4gMDsgfTsgLy8gdXNlIGNvbnN0YW50IGlmIHVuc3BlY2lmaWVkXG4gICAgICAgIC8vICQkLnV0aWwuZXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAoaGV1cmlzdGljKSEgQWJvcnRpbmcuXCIpO1xuICAgICAgICAvLyByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHsgICAgICAgXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvc2VkU2V0ID0gW107XG4gICAgICB2YXIgb3BlblNldCA9IFtzb3VyY2UuaWQoKV07XG4gICAgICB2YXIgY2FtZUZyb20gPSB7fTtcbiAgICAgIHZhciBjYW1lRnJvbUVkZ2UgPSB7fTtcbiAgICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICAgIHZhciBmU2NvcmUgPSB7fTtcblxuICAgICAgZ1Njb3JlW3NvdXJjZS5pZCgpXSA9IDA7XG4gICAgICBmU2NvcmVbc291cmNlLmlkKCldID0gaGV1cmlzdGljKHNvdXJjZSk7XG4gICAgICBcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5ub3QoJzpsb29wJyk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIC8vIENvdW50ZXJcbiAgICAgIHZhciBzdGVwcyA9IDA7XG5cbiAgICAgIC8vIE1haW4gbG9vcCBcbiAgICAgIHdoaWxlIChvcGVuU2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG1pblBvcyA9IGZpbmRNaW4ob3BlblNldCwgZlNjb3JlKTtcbiAgICAgICAgdmFyIGNNaW4gPSB0aGlzLmZpbHRlcihcIiNcIiArIG9wZW5TZXRbbWluUG9zXSlbMF07XG4gICAgICAgIHN0ZXBzKys7XG5cbiAgICAgICAgbG9nRGVidWcoXCJcXG5TdGVwOiAlc1wiLCBzdGVwcyk7XG4gICAgICAgIGxvZ0RlYnVnKFwiUHJvY2Vzc2luZyBub2RlOiAlcywgZlNjb3JlID0gJXNcIiwgY01pbi5pZCgpLCBmU2NvcmVbY01pbi5pZCgpXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBvdXIgZ29hbCwgdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgICBpZiAoY01pbi5pZCgpID09IHRhcmdldC5pZCgpKSB7XG4gICAgICAgICAgbG9nRGVidWcoXCJGb3VuZCBnb2FsIG5vZGUhXCIpO1xuICAgICAgICAgIHZhciByUGF0aCA9IHJlY29uc3RydWN0UGF0aChzb3VyY2UuaWQoKSwgdGFyZ2V0LmlkKCksIGNhbWVGcm9tLCBbXSk7XG4gICAgICAgICAgclBhdGgucmV2ZXJzZSgpO1xuICAgICAgICAgIGxvZ0RlYnVnKFwiUGF0aDogJXNcIiwgclBhdGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3VuZCA6IHRydWUsXG4gICAgICAgICAgICBkaXN0YW5jZSA6IGdTY29yZVtjTWluLmlkKCldLFxuICAgICAgICAgICAgcGF0aCA6IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCByUGF0aCksXG4gICAgICAgICAgICBzdGVwcyA6IHN0ZXBzXG4gICAgICAgICAgfTsgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBjTWluIHRvIHByb2Nlc3NlZCBub2Rlc1xuICAgICAgICBjbG9zZWRTZXQucHVzaChjTWluLmlkKCkpO1xuICAgICAgICAvLyBSZW1vdmUgY01pbiBmcm9tIGJvdW5kYXJ5IG5vZGVzXG4gICAgICAgIG9wZW5TZXQuc3BsaWNlKG1pblBvcywgMSk7XG4gICAgICAgIGxvZ0RlYnVnKFwiQWRkZWQgbm9kZSB0byBjbG9zZWRTZXQsIHJlbW92ZWQgZnJvbSBvcGVuU2V0LlwiKTtcbiAgICAgICAgbG9nRGVidWcoXCJQcm9jZXNzaW5nIG5laWdoYm9ycy4uLlwiKTtcblxuICAgICAgICAvLyBVcGRhdGUgc2NvcmVzIGZvciBuZWlnaGJvcnMgb2YgY01pblxuICAgICAgICAvLyBUYWtlIGludG8gYWNjb3VudCBpZiBncmFwaCBpcyBkaXJlY3RlZCBvciBub3RcbiAgICAgICAgdmFyIHZ3RWRnZXMgPSBjTWluLmNvbm5lY3RlZEVkZ2VzKGRpcmVjdGVkID8gJ1tzb3VyY2UgPSBcIicgKyBjTWluLmlkKCkgKyAnXCJdJyBcbiAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkuaW50ZXJzZWN0KGVkZ2VzKTsgICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW2ldO1xuICAgICAgICAgIHZhciB3ID0gZS5jb25uZWN0ZWROb2RlcygnW2lkICE9IFwiJyArIGNNaW4uaWQoKSArICdcIl0nKS5pbnRlcnNlY3Qobm9kZXMpO1xuXG4gICAgICAgICAgbG9nRGVidWcoXCIgICBwcm9jZXNzaW5nIG5laWdoYm9yOiAlc1wiLCB3LmlkKCkpO1xuICAgICAgICAgIC8vIGlmIG5vZGUgaXMgaW4gY2xvc2VkU2V0LCBpZ25vcmUgaXRcbiAgICAgICAgICBpZiAoY2xvc2VkU2V0LmluZGV4T2Yody5pZCgpKSAhPSAtMSkge1xuICAgICAgICAgICAgbG9nRGVidWcoXCIgICBhbHJlYWR5IGluIGNsb3NlZFNldCwgaWdub3JpbmcgaXQuXCIpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIE5ldyB0ZW50YXRpdmUgc2NvcmUgZm9yIG5vZGUgd1xuICAgICAgICAgIHZhciB0ZW1wU2NvcmUgPSBnU2NvcmVbY01pbi5pZCgpXSArIHdlaWdodEZuLmFwcGx5KGUsIFtlXSk7XG4gICAgICAgICAgbG9nRGVidWcoXCIgICB0ZW50YXRpdmUgZ1Njb3JlOiAlZFwiLCB0ZW1wU2NvcmUpO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIGdTY29yZSBmb3Igbm9kZSB3IGlmOlxuICAgICAgICAgIC8vICAgdyBub3QgcHJlc2VudCBpbiBvcGVuU2V0XG4gICAgICAgICAgLy8gT1JcbiAgICAgICAgICAvLyAgIHRlbnRhdGl2ZSBnU2NvcmUgaXMgbGVzcyB0aGFuIHByZXZpb3VzIHZhbHVlXG5cbiAgICAgICAgICAvLyB3IG5vdCBpbiBvcGVuU2V0XG4gICAgICAgICAgaWYgKG9wZW5TZXQuaW5kZXhPZih3LmlkKCkpID09IC0xKSB7XG4gICAgICAgICAgICBnU2NvcmVbdy5pZCgpXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICAgIGZTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgICAgb3BlblNldC5wdXNoKHcuaWQoKSk7IC8vIEFkZCBub2RlIHRvIG9wZW5TZXRcbiAgICAgICAgICAgIGNhbWVGcm9tW3cuaWQoKV0gPSBjTWluLmlkKCk7XG4gICAgICAgICAgICBjYW1lRnJvbUVkZ2Vbdy5pZCgpXSA9IGUuaWQoKTtcbiAgICAgICAgICAgIGxvZ0RlYnVnKFwiICAgbm90IGluIG9wZW5TZXQsIGFkZGluZyBpdC4gXCIpO1xuICAgICAgICAgICAgbG9nRGVidWcoXCIgICBmU2NvcmUoJXMpID0gJXNcIiwgdy5pZCgpLCB0ZW1wU2NvcmUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHcgYWxyZWFkeSBpbiBvcGVuU2V0LCBidXQgd2l0aCBncmVhdGVyIGdTY29yZVxuICAgICAgICAgIGlmICh0ZW1wU2NvcmUgPCBnU2NvcmVbdy5pZCgpXSkge1xuICAgICAgICAgICAgZ1Njb3JlW3cuaWQoKV0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgICBmU2NvcmVbdy5pZCgpXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyh3KTtcbiAgICAgICAgICAgIGNhbWVGcm9tW3cuaWQoKV0gPSBjTWluLmlkKCk7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhcIiAgIGJldHRlciBzY29yZSwgcmVwbGFjaW5nIGdTY29yZS4gXCIpO1xuICAgICAgICAgICAgbG9nRGVidWcoXCIgICBmU2NvcmUoJXMpID0gJXNcIiwgdy5pZCgpLCB0ZW1wU2NvcmUpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IC8vIEVuZCBvZiBuZWlnaGJvcnMgdXBkYXRlXG5cbiAgICAgIH0gLy8gRW5kIG9mIG1haW4gbG9vcFxuXG4gICAgICAvLyBJZiB3ZSd2ZSByZWFjaGVkIGhlcmUsIHRoZW4gd2UndmUgbm90IHJlYWNoZWQgb3VyIGdvYWxcbiAgICAgIGxvZ0RlYnVnKFwiUmVhY2hlZCBlbmQgb2YgY29tcHV0YXRpb24gd2l0aG91dCBmaW5kaW5nIG91ciBnb2FsXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm91bmQgOiBmYWxzZSxcbiAgICAgICAgZGlzdGFuY2UgOiB1bmRlZmluZWQsXG4gICAgICAgIHBhdGggOiB1bmRlZmluZWQsXG4gICAgICAgIHN0ZXBzIDogc3RlcHNcbiAgICAgIH07XG4gICAgfSwgLy8gYVN0YXIoKVxuXG5cbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICB3ZWlnaHQ6IGZ1bmN0aW9uKCBlZGdlICl7fSAvLyBzcGVjaWZpZXMgd2VpZ2h0IHRvIHVzZSBmb3IgYGVkZ2VgL2B0aGlzYC4gSWYgbm90IHByZXNlbnQsIGl0IHdpbGwgYmUgYXN1bWVkIGEgd2VpZ2h0IG9mIDEgZm9yIGFsbCBlZGdlc1xuICAgIC8vICAgZGlyZWN0ZWQgLy8gZGVmYXVsdCBmYWxzZVxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIHBhdGhUbyA6IGZ1bmN0aW9uKGZyb21JZCwgdG9JZCkgLy8gUmV0dXJucyB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIG5vZGUgd2l0aCBJRCBcImZyb21JRFwiIHRvIG5vZGUgd2l0aCBJRCBcInRvSWRcIiwgYXMgYW4gYXJyYXkgb2Ygbm9kZSBJRHNcbiAgICAvLyAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKGZyb21JZCwgdG9JZCkgLy8gUmV0dXJucyB0aGUgZGlzdGFuY2Ugb2YgdGhlIHNob3J0ZXN0IHBhdGggZnJvbSBub2RlIHdpdGggSUQgXCJmcm9tSURcIiB0byBub2RlIHdpdGggSUQgXCJ0b0lkXCJcbiAgICBmbG95ZFdhcnNoYWxsOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbG9nRGVidWcoXCJTdGFydGluZyBmbG95ZFdhcnNoYWxsLi4uXCIpOyBcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkgeyAgICAgICBcbiAgICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKGUpIHtyZXR1cm4gMTt9O1xuICAgICAgfVxuXG4gICAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsKSB7ICAgICAgIFxuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5ub3QoJzpsb29wJyk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICAgIH0gICAgIFxuXG4gICAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuICAgICAgdmFyIGRpc3QgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICB2YXIgbmV3Um93ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgICAgbmV3Um93W2pdID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3Um93W2pdID0gSW5maW5pdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpc3QucHVzaChuZXdSb3cpO1xuICAgICAgfSAgICAgICAgICAgXG5cbiAgICAgIC8vIEluaXRpYWxpemUgbWF0cml4IHVzZWQgZm9yIHBhdGggcmVjb25zdHJ1Y3Rpb25cbiAgICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG4gICAgICB2YXIgbmV4dCA9IFtdO1xuICAgICAgdmFyIGVkZ2VOZXh0ID0gW107XG5cbiAgICAgIHZhciBpbml0TWF0cml4ID0gZnVuY3Rpb24obmV4dCl7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIHZhciBuZXdSb3cgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICAgICAgbmV3Um93W2pdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0LnB1c2gobmV3Um93KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaW5pdE1hdHJpeChuZXh0KTtcbiAgICAgIGluaXRNYXRyaXgoZWRnZU5leHQpO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGVkZ2VzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aCA7IGkrKykgeyAgICAgXG4gICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS50YXJnZXQoKS5pZCgpXTsgICAgXG4gICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseShlZGdlc1tpXSwgW2VkZ2VzW2ldXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG4gICAgICAgIGlmIChkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPiB3ZWlnaHQpIHtcbiAgICAgICAgICBkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB3ZWlnaHQ7XG4gICAgICAgICAgbmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgZWRnZU5leHRbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IGVkZ2VzW2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHByb2Nlc3MgJ3JldmVyc2VkJyBlZGdlc1xuICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aCA7IGkrKykgeyAgICAgXG4gICAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0udGFyZ2V0KCkuaWQoKV07ICAgIFxuICAgICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseShlZGdlc1tpXSwgW2VkZ2VzW2ldXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcm9jZXNzIGFub3RoZXIgZWRnZSBiZXR3ZWVuIHNhbWUgMiBub2Rlc1xuICAgICAgICAgIGlmIChkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPiB3ZWlnaHQpIHtcbiAgICAgICAgICAgIGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IHdlaWdodDtcbiAgICAgICAgICAgIG5leHRbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IHRhcmdldEluZGV4O1xuICAgICAgICAgICAgZWRnZU5leHRbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IGVkZ2VzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNYWluIGxvb3BcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbnVtTm9kZXM7IGsrKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHsgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChkaXN0W2ldW2tdICsgZGlzdFtrXVtqXSA8IGRpc3RbaV1bal0pIHtcbiAgICAgICAgICAgICAgZGlzdFtpXVtqXSA9IGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdO1xuICAgICAgICAgICAgICBuZXh0W2ldW2pdID0gbmV4dFtpXVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgcmVzdWx0IG9iamVjdCAgICAgICBcbiAgICAgIHZhciBwb3NpdGlvbjJpZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHBvc2l0aW9uMmlkLnB1c2gobm9kZXNbaV0uaWQoKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIGRpc3RhbmNlOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcoZnJvbSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBmcm9tSWQgPSAoY3kuZmlsdGVyKGZyb20pWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIGZyb21JZCA9IGZyb20uaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkaXN0W2lkMnBvc2l0aW9uW2Zyb21JZF1dW2lkMnBvc2l0aW9uW3RvSWRdXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXRoOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICAgIHZhciByZWNvbnN0cnVjdFBhdGhBdXggPSBmdW5jdGlvbihmcm9tLCB0bywgbmV4dCwgcG9zaXRpb24yaWQsIGVkZ2VOZXh0KSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN5LmdldEVsZW1lbnRCeUlkKCBwb3NpdGlvbjJpZFtmcm9tXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRbZnJvbV1bdG9dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhdGggPSBbIGN5LmdldEVsZW1lbnRCeUlkKHBvc2l0aW9uMmlkW2Zyb21dKSBdO1xuICAgICAgICAgICAgdmFyIHByZXYgPSBmcm9tO1xuICAgICAgICAgICAgd2hpbGUgKGZyb20gIT09IHRvKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBmcm9tO1xuICAgICAgICAgICAgICBmcm9tID0gbmV4dFtmcm9tXVt0b107XG5cbiAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlTmV4dFtwcmV2XVtmcm9tXTtcbiAgICAgICAgICAgICAgcGF0aC5wdXNoKCBlZGdlICk7XG5cbiAgICAgICAgICAgICAgcGF0aC5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChwb3NpdGlvbjJpZFtmcm9tXSkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKGZyb20pKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgZnJvbUlkID0gKGN5LmZpbHRlcihmcm9tKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBmcm9tSWQgPSBmcm9tLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIodG8pWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIHBhdGhBcnIgPSByZWNvbnN0cnVjdFBhdGhBdXgoaWQycG9zaXRpb25bZnJvbUlkXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvblt0b0lkXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24yaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlTmV4dCk7XG5cbiAgICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBwYXRoQXJyICk7XG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVzO1xuXG4gICAgfSwgLy8gZmxveWRXYXJzaGFsbFxuXG5cbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICByb290OiBzdGFydGluZyBub2RlIChlaXRoZXIgZWxlbWVudCBvciBzZWxlY3RvciBzdHJpbmcpXG4gICAgLy8gICB3ZWlnaHQ6IGZ1bmN0aW9uKCBlZGdlICl7fSAvLyBzcGVjaWZpZXMgd2VpZ2h0IHRvIHVzZSBmb3IgYGVkZ2VgL2B0aGlzYC4gSWYgbm90IHByZXNlbnQsIGl0IHdpbGwgYmUgYXN1bWVkIGEgd2VpZ2h0IG9mIDEgZm9yIGFsbCBlZGdlc1xuICAgIC8vICAgZGlyZWN0ZWQgLy8gZGVmYXVsdCBmYWxzZVxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIHBhdGhUbyA6IGZ1bmN0aW9uKHRvSWQpIC8vIFJldHVybnMgdGhlIHNob3J0ZXN0IHBhdGggZnJvbSByb290IG5vZGUgdG8gbm9kZSB3aXRoIElEIFwidG9JZFwiLCBhcyBhbiBhcnJheSBvZiBub2RlIElEc1xuICAgIC8vICAgZGlzdGFuY2VUbzogZnVuY3Rpb24odG9JZCkgLy8gUmV0dXJucyB0aGUgZGlzdGFuY2Ugb2YgdGhlIHNob3J0ZXN0IHBhdGggZnJvbSByb290IG5vZGUgdG8gbm9kZSB3aXRoIElEIFwidG9JZFwiXG4gICAgLy8gICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiB0cnVlL2ZhbHNlIChpZiB0cnVlLCBwYXRoVG8gYW5kIGRpc3RhbmNlVG8gd2lsbCBiZSB1bmRlZmluZWQpXG4gICAgYmVsbG1hbkZvcmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIGJlbGxtYW5Gb3JkLi4uXCIpOyBcblxuICAgICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkgeyAgICAgICBcbiAgICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKGUpIHtyZXR1cm4gMTt9O1xuICAgICAgfVxuXG4gICAgICAvLyBkaXJlY3RlZCAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3RlZCAhPSBudWxsKSB7ICAgICAgIFxuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgICBpZiAob3B0aW9ucy5yb290ICE9IG51bGwpIHsgICAgICAgXG4gICAgICAgIGlmICgkJC5pcy5zdHJpbmcob3B0aW9ucy5yb290KSkge1xuICAgICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI3Jvb3RJRFxuICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICAgIH1cbiAgICAgICAgbG9nRGVidWcoXCJTb3VyY2Ugbm9kZTogJXNcIiwgc291cmNlLmlkKCkpOyBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoXCJvcHRpb25zLnJvb3QgcmVxdWlyZWRcIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkubm90KCc6bG9vcCcpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgICB9ICAgICBcblxuICAgICAgLy8gSW5pdGlhbGl6YXRpb25zXG4gICAgICB2YXIgY29zdCA9IFtdO1xuICAgICAgdmFyIHByZWRlY2Vzc29yID0gW107XG4gICAgICB2YXIgcHJlZEVkZ2UgPSBbXTtcbiAgICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGlmIChub2Rlc1tpXS5pZCgpID09PSBzb3VyY2UuaWQoKSkge1xuICAgICAgICAgIGNvc3RbaV0gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvc3RbaV0gPSBJbmZpbml0eTtcbiAgICAgICAgfSBcbiAgICAgICAgcHJlZGVjZXNzb3JbaV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEVkZ2VzIHJlbGF4YXRpb24gICAgICBcbiAgICAgIHZhciBmbGFnID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGVkZ2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0uc291cmNlKCkuaWQoKV07XG4gICAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0udGFyZ2V0KCkuaWQoKV07ICAgIFxuICAgICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseShlZGdlc1tlXSwgW2VkZ2VzW2VdXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIHRlbXAgPSBjb3N0W3NvdXJjZUluZGV4XSArIHdlaWdodDtcbiAgICAgICAgICBpZiAodGVtcCA8IGNvc3RbdGFyZ2V0SW5kZXhdKSB7XG4gICAgICAgICAgICBjb3N0W3RhcmdldEluZGV4XSA9IHRlbXA7XG4gICAgICAgICAgICBwcmVkZWNlc3Nvclt0YXJnZXRJbmRleF0gPSBzb3VyY2VJbmRleDtcbiAgICAgICAgICAgIHByZWRFZGdlW3RhcmdldEluZGV4XSA9IGVkZ2VzW2VdO1xuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgd2UgbmVlZCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgJ3JldmVyc2UnIGVkZ2VcbiAgICAgICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGNvc3RbdGFyZ2V0SW5kZXhdICsgd2VpZ2h0O1xuICAgICAgICAgICAgaWYgKHRlbXAgPCBjb3N0W3NvdXJjZUluZGV4XSkge1xuICAgICAgICAgICAgICBjb3N0W3NvdXJjZUluZGV4XSA9IHRlbXA7XG4gICAgICAgICAgICAgIHByZWRlY2Vzc29yW3NvdXJjZUluZGV4XSA9IHRhcmdldEluZGV4O1xuICAgICAgICAgICAgICBwcmVkRWRnZVtzb3VyY2VJbmRleF0gPSBlZGdlc1tlXTtcbiAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gICAgICBcbiAgICAgICAgICAgIFxuICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIG5lZ2F0aXZlIHdlaWdodCBjeWNsZXNcbiAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnRhcmdldCgpLmlkKCldOyAgICBcbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZXNbZV0sIFtlZGdlc1tlXV0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChjb3N0W3NvdXJjZUluZGV4XSArIHdlaWdodCA8IGNvc3RbdGFyZ2V0SW5kZXhdKSB7XG4gICAgICAgICAgICAkJC51dGlsLmVycm9yKFwiRXJyb3I6IGdyYXBoIGNvbnRhaW5zIGEgbmVnYXRpdmUgd2VpZ3RoIGN5Y2xlIVwiKTsgXG4gICAgICAgICAgICByZXR1cm4geyBwYXRoVG86IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgZGlzdGFuY2VUbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiB0cnVlfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gICAgIFxuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZCByZXN1bHQgb2JqZWN0ICAgICAgIFxuICAgICAgdmFyIHBvc2l0aW9uMmlkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgcG9zaXRpb24yaWQucHVzaChub2Rlc1tpXS5pZCgpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICB2YXIgcmVzID0geyAgICAgICBcbiAgICAgICAgZGlzdGFuY2VUbyA6IGZ1bmN0aW9uKHRvKSB7XG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIodG8pWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29zdFtpZDJwb3NpdGlvblt0b0lkXV07XG4gICAgICAgIH0sIFxuXG4gICAgICAgIHBhdGhUbyA6IGZ1bmN0aW9uKHRvKSB7XG5cbiAgICAgICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoQXV4ID0gZnVuY3Rpb24ocHJlZGVjZXNzb3IsIGZyb21Qb3MsIHRvUG9zLCBwb3NpdGlvbjJpZCwgYWN1bVBhdGgsIHByZWRFZGdlKSB7XG4gICAgICAgICAgICBmb3IoOzspe1xuICAgICAgICAgICAgICAvLyBBZGQgdG9JZCB0byBwYXRoXG4gICAgICAgICAgICAgIGFjdW1QYXRoLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKHBvc2l0aW9uMmlkW3RvUG9zXSkgKTtcbiAgICAgICAgICAgICAgYWN1bVBhdGgucHVzaCggcHJlZEVkZ2VbdG9Qb3NdICk7XG5cbiAgICAgICAgICAgICAgaWYgKGZyb21Qb3MgPT09IHRvUG9zKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVhY2hlZCBzdGFydGluZyBub2RlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdW1QYXRoO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gSWYgbm8gcGF0aCBleGlzdHMsIGRpc2NhcnQgYWN1bXVsYXRlZCBwYXRoIGFuZCByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgICAgICAgIHZhciBwcmVkUG9zID0gcHJlZGVjZXNzb3JbdG9Qb3NdO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHByZWRQb3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdG9Qb3MgPSBwcmVkUG9zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcodG8pKSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwYXRoID0gW107XG5cbiAgICAgICAgICAvLyBUaGlzIHJldHVybnMgYSByZXZlcnNlZCBwYXRoIFxuICAgICAgICAgIHZhciByZXMgPSAgcmVjb25zdHJ1Y3RQYXRoQXV4KHByZWRlY2Vzc29yLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkMnBvc2l0aW9uW3NvdXJjZS5pZCgpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkMnBvc2l0aW9uW3RvSWRdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uMmlkLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVkRWRnZSk7XG5cbiAgICAgICAgICAvLyBHZXQgaXQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgYW5kIHJldHVybiBpdFxuICAgICAgICAgIGlmIChyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzLnJldmVyc2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIHJlcyk7ICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSwgXG5cbiAgICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogZmFsc2VcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXM7XG5cbiAgICB9LCAvLyBiZWxsbWFuRm9yZFxuXG5cbiAgICAvLyBDb21wdXRlcyB0aGUgbWluaW11bSBjdXQgb2YgYW4gdW5kaXJlY3RlZCBncmFwaFxuICAgIC8vIFJldHVybnMgdGhlIGNvcnJlY3QgYW5zd2VyIHdpdGggaGlnaCBwcm9iYWJpbGl0eVxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyBcbiAgICAvLyByZXRPYmogPT4gcmV0dXJuZWQgb2JqZWN0IGJ5IGZ1bmN0aW9uXG4gICAgLy8gICBjdXQgOiBsaXN0IG9mIElEcyBvZiBlZGdlcyBpbiB0aGUgY3V0LFxuICAgIC8vICAgcGFydGl0aW9uMTogbGlzdCBvZiBJRHMgb2Ygbm9kZXMgaW4gb25lIHBhcnRpdGlvblxuICAgIC8vICAgcGFydGl0aW9uMjogbGlzdCBvZiBJRHMgb2Ygbm9kZXMgaW4gdGhlIG90aGVyIHBhcnRpdGlvblxuICAgIGthcmdlclN0ZWluOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIFxuICAgICAgdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEZ1bmN0aW9uIHdoaWNoIGNvbGFwc2VzIDIgKG1ldGEpIG5vZGVzIGludG8gb25lXG4gICAgICAvLyBVcGRhdGVzIHRoZSByZW1haW5pbmcgZWRnZSBsaXN0c1xuICAgICAgLy8gUmVjZWl2ZXMgYXMgYSBwYXJhbWF0ZXIgdGhlIGVkZ2Ugd2hpY2ggY2F1c2VzIHRoZSBjb2xsYXBzZVxuICAgICAgdmFyIGNvbGFwc2UgPSBmdW5jdGlvbihlZGdlSW5kZXgsIG5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKSB7XG4gICAgICAgIHZhciBlZGdlSW5mbyA9IHJlbWFpbmluZ0VkZ2VzW2VkZ2VJbmRleF07XG4gICAgICAgIHZhciBzb3VyY2VJbiA9IGVkZ2VJbmZvWzFdO1xuICAgICAgICB2YXIgdGFyZ2V0SW4gPSBlZGdlSW5mb1syXTtcbiAgICAgICAgdmFyIHBhcnRpdGlvbjEgPSBub2RlTWFwW3NvdXJjZUluXTtcbiAgICAgICAgdmFyIHBhcnRpdGlvbjIgPSBub2RlTWFwW3RhcmdldEluXTtcblxuICAgICAgICAvLyBEZWxldGUgYWxsIGVkZ2VzIGJldHdlZW4gcGFydGl0aW9uMSBhbmQgcGFydGl0aW9uMlxuICAgICAgICB2YXIgbmV3RWRnZXMgPSByZW1haW5pbmdFZGdlcy5maWx0ZXIoZnVuY3Rpb24oZWRnZSkge1xuICAgICAgICAgIGlmIChub2RlTWFwW2VkZ2VbMV1dID09PSBwYXJ0aXRpb24xICYmIG5vZGVNYXBbZWRnZVsyXV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGVNYXBbZWRnZVsxXV0gPT09IHBhcnRpdGlvbjIgJiYgbm9kZU1hcFtlZGdlWzJdXSA9PT0gcGFydGl0aW9uMSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBbGwgZWRnZXMgcG9pbnRpbmcgdG8gcGFydGl0aW9uMiBzaG91bGQgbm93IHBvaW50IHRvIHBhcnRpdGlvbjFcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gbmV3RWRnZXNbaV07XG4gICAgICAgICAgaWYgKGVkZ2VbMV0gPT09IHBhcnRpdGlvbjIpIHsgLy8gQ2hlY2sgc291cmNlXG4gICAgICAgICAgICBuZXdFZGdlc1tpXSA9IGVkZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICBuZXdFZGdlc1tpXVsxXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgICAgfSBlbHNlIGlmIChlZGdlWzJdID09PSBwYXJ0aXRpb24yKSB7IC8vIENoZWNrIHRhcmdldFxuICAgICAgICAgICAgbmV3RWRnZXNbaV0gPSBlZGdlLnNsaWNlKDApO1xuICAgICAgICAgICAgbmV3RWRnZXNbaV1bMl0gPSBwYXJ0aXRpb24xO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgXG4gICAgICAgIC8vIE1vdmUgYWxsIG5vZGVzIGZyb20gcGFydGl0aW9uMiB0byBwYXJ0aXRpb24xXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZU1hcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChub2RlTWFwW2ldID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAgICAgICBub2RlTWFwW2ldID0gcGFydGl0aW9uMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBuZXdFZGdlcztcbiAgICAgIH07XG5cblxuICAgICAgLy8gQ29udHJhY3RzIGEgZ3JhcGggdW50aWwgd2UgcmVhY2ggYSBjZXJ0YWluIG51bWJlciBvZiBtZXRhIG5vZGVzXG4gICAgICB2YXIgY29udHJhY3RVbnRpbCA9IGZ1bmN0aW9uKG1ldGFOb2RlTWFwLCBcbiAgICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0VkZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgc2l6ZSwgXG4gICAgICAgICAgICAgICAgICAgICBzaXplTGltaXQpIHtcbiAgICAgICAgLy8gU3RvcCBjb25kaXRpb25cbiAgICAgICAgaWYgKHNpemUgPD0gc2l6ZUxpbWl0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlbWFpbmluZ0VkZ2VzO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaG9vc2UgYW4gZWRnZSByYW5kb21seVxuICAgICAgICB2YXIgZWRnZUluZGV4ID0gTWF0aC5mbG9vcigoTWF0aC5yYW5kb20oKSAqIHJlbWFpbmluZ0VkZ2VzLmxlbmd0aCkpO1xuXG4gICAgICAgIC8vIENvbGFwc2UgZ3JhcGggYmFzZWQgb24gZWRnZVxuICAgICAgICB2YXIgbmV3RWRnZXMgPSBjb2xhcHNlKGVkZ2VJbmRleCwgbWV0YU5vZGVNYXAsIHJlbWFpbmluZ0VkZ2VzKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBcbiAgICAgICAgICAgICAgICAgICBuZXdFZGdlcywgXG4gICAgICAgICAgICAgICAgICAgc2l6ZSAtIDEsIFxuICAgICAgICAgICAgICAgICAgIHNpemVMaW1pdCk7ICAgICAgICBcbiAgICAgIH07XG5cblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbG9nRGVidWcoXCJTdGFydGluZyBrYXJnZXJTdGVpbi4uLlwiKTsgXG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkubm90KCc6bG9vcCcpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuICAgICAgdmFyIG51bUl0ZXIgPSBNYXRoLmNlaWwoTWF0aC5wb3coTWF0aC5sb2cobnVtTm9kZXMpIC8gTWF0aC5MTjIsIDIpKTtcbiAgICAgIHZhciBzdG9wU2l6ZSA9IE1hdGguZmxvb3IobnVtTm9kZXMgLyBNYXRoLnNxcnQoMikpO1xuXG4gICAgICBpZiAobnVtTm9kZXMgPCAyKSB7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoXCJBdCBsZWFzdCAyIG5vZGVzIGFyZSByZXF1aXJlZCBmb3IgS2FyZ2VyU3RlaW5nIGFsZ29yaXRobSFcIik7IFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbnVtZXJpY2FsIGlkZW50aWZpZXJzIGZvciBlYWNoIG5vZGVcbiAgICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAgIC8vIGZvciByZXZlcnNlIG1hcHBpbmcsIHNpbXBseSB1c2Ugbm9kZXMgYXJyYXlcbiAgICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93IHN0b3JlIGVkZ2UgZGVzdGluYXRpb24gYXMgaW5kZXhlc1xuICAgICAgLy8gRm9ybWF0IGZvciBlYWNoIGVkZ2UgKGVkZ2UgaW5kZXgsIHNvdXJjZSBub2RlIGluZGV4LCB0YXJnZXQgbm9kZSBpbmRleClcbiAgICAgIHZhciBlZGdlSW5kZXhlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKSB7XG4gICAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICAgIGVkZ2VJbmRleGVzLnB1c2goW2ksIGlkMnBvc2l0aW9uW2Uuc291cmNlKCkuaWQoKV0sIGlkMnBvc2l0aW9uW2UudGFyZ2V0KCkuaWQoKV1dKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2Ugd2lsbCBzdG9yZSB0aGUgYmVzdCBjdXQgZm91bmQgaGVyZVxuICAgICAgdmFyIG1pbkN1dFNpemUgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5DdXQ7ICAgICBcblxuICAgICAgLy8gSW5pdGlhbCBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICB2YXIgb3JpZ2luYWxNZXRhTm9kZSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIG9yaWdpbmFsTWV0YU5vZGUucHVzaChpKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFpbiBsb29wXG4gICAgICBmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8PSBudW1JdGVyOyBpdGVyKyspIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBtZXRhIG5vZGUgcGFydGl0aW9uXG4gICAgICAgIHZhciBtZXRhTm9kZU1hcCA9IG9yaWdpbmFsTWV0YU5vZGUuc2xpY2UoMCk7XG5cbiAgICAgICAgLy8gQ29udHJhY3QgdW50aWwgc3RvcCBwb2ludCAoc3RvcFNpemUgbm9kZXMpXG4gICAgICAgIHZhciBlZGdlc1N0YXRlID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZUluZGV4ZXMsIG51bU5vZGVzLCBzdG9wU2l6ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBjb2xhcHNlZCBub2RlcyBzdGF0ZVxuICAgICAgICB2YXIgbWV0YU5vZGVNYXAyID0gbWV0YU5vZGVNYXAuc2xpY2UoMCk7XG5cbiAgICAgICAgLy8gUnVuIDIgaXRlcmF0aW9ucyBzdGFydGluZyBpbiB0aGUgc3RvcCBzdGF0ZVxuICAgICAgICB2YXIgcmVzMSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyKTtcbiAgICAgICAgdmFyIHJlczIgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwMiwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuXG4gICAgICAgIC8vIElzIGFueSBvZiB0aGUgMiByZXN1bHRzIHRoZSBiZXN0IGN1dCBzbyBmYXI/XG4gICAgICAgIGlmIChyZXMxLmxlbmd0aCA8PSByZXMyLmxlbmd0aCAmJiByZXMxLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgICBtaW5DdXRTaXplID0gcmVzMS5sZW5ndGg7XG4gICAgICAgICAgbWluQ3V0ID0gW3JlczEsIG1ldGFOb2RlTWFwXTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXMyLmxlbmd0aCA8PSByZXMxLmxlbmd0aCAmJiByZXMyLmxlbmd0aCA8IG1pbkN1dFNpemUpIHtcbiAgICAgICAgICBtaW5DdXRTaXplID0gcmVzMi5sZW5ndGg7XG4gICAgICAgICAgbWluQ3V0ID0gW3JlczIsIG1ldGFOb2RlTWFwMl07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZW5kIG9mIG1haW4gbG9vcFxuXG4gICAgICBcbiAgICAgIC8vIENvbnN0cnVjdCByZXN1bHRcbiAgICAgIHZhciByZXNFZGdlcyA9IChtaW5DdXRbMF0pLm1hcChmdW5jdGlvbihlKXsgcmV0dXJuIGVkZ2VzW2VbMF1dOyB9KTtcbiAgICAgIHZhciBwYXJ0aXRpb24xID0gW107XG4gICAgICB2YXIgcGFydGl0aW9uMiA9IFtdO1xuXG4gICAgICAvLyB0cmF2ZXJzZSBtZXRhTm9kZU1hcCBmb3IgYmVzdCBjdXRcbiAgICAgIHZhciB3aXRuZXNzTm9kZVBhcnRpdGlvbiA9IG1pbkN1dFsxXVswXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWluQ3V0WzFdLmxlbmd0aDsgaSsrKSB7IFxuICAgICAgICB2YXIgcGFydGl0aW9uSWQgPSBtaW5DdXRbMV1baV07IFxuICAgICAgICBpZiAocGFydGl0aW9uSWQgPT09IHdpdG5lc3NOb2RlUGFydGl0aW9uKSB7XG4gICAgICAgICAgcGFydGl0aW9uMS5wdXNoKG5vZGVzW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0aXRpb24yLnB1c2gobm9kZXNbaV0pO1xuICAgICAgICB9ICAgICAgIFxuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBjdXQ6IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCByZXNFZGdlcyksXG4gICAgICAgIHBhcnRpdGlvbjE6IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBwYXJ0aXRpb24xKSxcbiAgICAgICAgcGFydGl0aW9uMjogbmV3ICQkLkNvbGxlY3Rpb24oY3ksIHBhcnRpdGlvbjIpXG4gICAgICB9O1xuICAgICAgXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cblxuICAgIC8vIFxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIGRhbXBpbmdGYWN0b3I6IG9wdGlvbmFsXG4gICAgLy8gICBwcmVjaXNpb246IG9wdGlvbmFsXG4gICAgLy8gICBpdGVyYXRpb25zIDogb3B0aW9uYWxcbiAgICAvLyByZXRPYmogPT4gcmV0dXJuZWQgb2JqZWN0IGJ5IGZ1bmN0aW9uXG4gICAgLy8gIHJhbmsgOiBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHBhZ2VSYW5rIG9mIGEgZ2l2ZW4gbm9kZSAob2JqZWN0IG9yIHNlbGVjdG9yIHN0cmluZylcbiAgICBwYWdlUmFuazogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBcbiAgICAgIHZhciBub3JtYWxpemVWZWN0b3IgPSBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHZlY3Rvci5sZW5ndGg7XG5cbiAgICAgICAgLy8gRmlyc3QsIGdldCBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gICAgICAgIHZhciB0b3RhbCA9IDA7IFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdG90YWwgKz0gdmVjdG9yW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm93LCBkaXZpZGUgZWFjaCBieSB0aGUgc3VtIG9mIGFsbCBlbGVtZW50c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmVjdG9yW2ldID0gdmVjdG9yW2ldIC8gdG90YWw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIFxuICAgICAgICBvcHRpb25zLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbG9nRGVidWcoXCJTdGFydGluZyBwYWdlUmFuay4uLlwiKTsgXG5cbiAgICAgIC8vIGRhbXBpbmdGYWN0b3IgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBcbiAgICAgICAgb3B0aW9ucy5kYW1waW5nZmFjdG9yICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRhbXBpbmdGYWN0b3IgPSBvcHRpb25zLmRhbXBpbmdGYWN0b3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGFtcGluZ0ZhY3RvciA9IDAuODsgLy8gRGVmYXVsdCBkYW1waW5nIGZhY3RvclxuICAgICAgfVxuXG4gICAgICAvLyBkZXNpcmVkIHByZWNpc2lvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIFxuICAgICAgICBvcHRpb25zLnByZWNpc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHZhciBlcHNpbG9uID0gb3B0aW9ucy5wcmVjaXNpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXBzaWxvbiA9IDAuMDAwMDAxOyAvLyBEZWZhdWx0IHByZWNpc2lvblxuICAgICAgfVxuXG4gICAgICAvLyBNYXggbnVtYmVyIG9mIGl0ZXJhdGlvbnMgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBcbiAgICAgICAgb3B0aW9ucy5pdGVyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG51bUl0ZXIgPSBvcHRpb25zLml0ZXJhdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbnVtSXRlciA9IDIwMDsgLy8gRGVmYXVsdCBudW1iZXIgb2YgaXRlcmF0aW9uc1xuICAgICAgfVxuXG4gICAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBcbiAgICAgICAgb3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiBcbiAgICAgICAgJCQuaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7ICAgICAgIFxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oZSkge3JldHVybiAxO307IFxuICAgICAgfVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLm5vdCgnOmxvb3AnKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcblxuICAgICAgLy8gQ3JlYXRlIG51bWVyaWNhbCBpZGVudGlmaWVycyBmb3IgZWFjaCBub2RlXG4gICAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgICB9XG5cbiAgICAgIC8vIENvbnN0cnVjdCB0cmFuc3Bvc2VkIGFkamFjZW5jeSBtYXRyaXhcbiAgICAgIC8vIEZpcnN0IGxldHMgaGF2ZSBhIHplcm9lZCBtYXRyaXggb2YgdGhlIHJpZ2h0IHNpemVcbiAgICAgIC8vIFdlJ2xsIGFsc28ga2VlcCB0cmFjayBvZiB0aGUgc3VtIG9mIGVhY2ggY29sdW1uXG4gICAgICB2YXIgbWF0cml4ID0gW107XG4gICAgICB2YXIgY29sdW1uU3VtID0gW107XG4gICAgICB2YXIgYWRkaXRpb25hbFByb2IgPSAoMSAtIGRhbXBpbmdGYWN0b3IpIC8gbnVtTm9kZXM7XG5cbiAgICAgIC8vIENyZWF0ZSBudWxsIG1hdHJpY1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7IFxuICAgICAgICB2YXIgbmV3Um93ID0gW107XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICAgIG5ld1Jvdy5wdXNoKDAuMCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0cml4LnB1c2gobmV3Um93KTtcbiAgICAgICAgY29sdW1uU3VtLnB1c2goMC4wKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm93LCBwcm9jZXNzIGVkZ2VzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgdmFyIHMgPSBpZDJwb3NpdGlvbltlZGdlLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICB2YXIgdCA9IGlkMnBvc2l0aW9uW2VkZ2UudGFyZ2V0KCkuaWQoKV07XG4gICAgICAgIHZhciB3ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZSwgW2VkZ2VdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBtYXRyaXhcbiAgICAgICAgbWF0cml4W3RdW3NdICs9IHc7XG5cbiAgICAgICAgLy8gVXBkYXRlIGNvbHVtbiBzdW1cbiAgICAgICAgY29sdW1uU3VtW3NdICs9IHc7IFxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgYWRkaXRpb25hbCBwcm9iYWJpbGl0eSBiYXNlZCBvbiBkYW1waW5nIGZhY3RvclxuICAgICAgLy8gQWxzbywgdGFrZSBpbnRvIGFjY291bnQgY29sdW1ucyB0aGF0IGhhdmUgc3VtID0gMFxuICAgICAgdmFyIHAgPSAxLjAgLyBudW1Ob2RlcyArIGFkZGl0aW9uYWxQcm9iOyAvLyBTaG9ydGhhbmRcbiAgICAgIC8vIFRyYXZlcnNlIG1hdHJpeCwgY29sdW1uIGJ5IGNvbHVtblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7IFxuICAgICAgICBpZiAoY29sdW1uU3VtW2pdID09PSAwKSB7XG4gICAgICAgICAgLy8gTm8gJ2xpbmtzJyBvdXQgZnJvbSBub2RlIGp0aCwgYXNzdW1lIGVxdWFsIHByb2JhYmlsaXR5IGZvciBlYWNoIHBvc3NpYmxlIG5vZGVcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IHA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vZGUganRoIGhhcyBvdXRnb2luZyBsaW5rLCBjb21wdXRlIG5vcm1hbGl6ZWQgcHJvYmFiaWxpdGllc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gbWF0cml4W2ldW2pdIC8gY29sdW1uU3VtW2pdICsgYWRkaXRpb25hbFByb2I7XG4gICAgICAgICAgfSAgICAgICAgIFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXB1dGUgZG9taW5hbnQgZWlnZW52ZWN0b3IgdXNpbmcgcG93ZXIgbWV0aG9kXG4gICAgICB2YXIgZWlnZW52ZWN0b3IgPSBbXTtcbiAgICAgIHZhciBudWxsVmVjdG9yID0gW107XG4gICAgICB2YXIgcHJldmlvdXM7XG5cbiAgICAgIC8vIFN0YXJ0IHdpdGggYSB2ZWN0b3Igb2YgYWxsIDEnc1xuICAgICAgLy8gQWxzbywgaW5pdGlhbGl6ZSBhIG51bGwgdmVjdG9yIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBzaG9ydGhhbmRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBlaWdlbnZlY3Rvci5wdXNoKDEuMCk7XG4gICAgICAgIG51bGxWZWN0b3IucHVzaCgwLjApO1xuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICBmb3IgKHZhciBpdGVyID0gMDsgaXRlciA8IG51bUl0ZXI7IGl0ZXIrKykge1xuICAgICAgICAvLyBOZXcgYXJyYXkgd2l0aCBhbGwgMCdzXG4gICAgICAgIHZhciB0ZW1wID0gbnVsbFZlY3Rvci5zbGljZSgwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE11bHRpcGx5IG1hdHJpeCB3aXRoIHByZXZpb3VzIHJlc3VsdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHsgICAgICAgIFxuICAgICAgICAgICAgdGVtcFtpXSArPSBtYXRyaXhbaV1bal0gKiBlaWdlbnZlY3RvcltqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub3JtYWxpemVWZWN0b3IodGVtcCk7XG4gICAgICAgIHByZXZpb3VzID0gZWlnZW52ZWN0b3I7XG4gICAgICAgIGVpZ2VudmVjdG9yID0gdGVtcDtcblxuICAgICAgICB2YXIgZGlmZiA9IDA7XG4gICAgICAgIC8vIENvbXB1dGUgZGlmZmVyZW5jZSAoc3F1YXJlZCBtb2R1bGUpIG9mIGJvdGggdmVjdG9yc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICBkaWZmICs9IE1hdGgucG93KHByZXZpb3VzW2ldIC0gZWlnZW52ZWN0b3JbaV0sIDIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBkaWZmZXJlbmNlIGlzIGxlc3MgdGhhbiB0aGUgZGVzaXJlZCB0aHJlc2hvbGQsIHN0b3AgaXRlcmF0aW5nXG4gICAgICAgIGlmIChkaWZmIDwgZXBzaWxvbikge1xuICAgICAgICAgIGxvZ0RlYnVnKFwiU3RvcGVkIGF0IGl0ZXJhdGlvbiAlc1wiLCBpdGVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICBsb2dEZWJ1ZyhcIlJlc3VsdDpcXG5cIiArIGVpZ2VudmVjdG9yKTtcblxuICAgICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgcmFuayA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGVJZCA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlzIGEgbm9kZSBvYmplY3RcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSBub2RlLmlkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlaWdlbnZlY3RvcltpZDJwb3NpdGlvbltub2RlSWRdXTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuXG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gLy8gcGFnZVJhbmtcblxuICB9KTsgLy8gJCQuZm4uZWxlc1xuXG5cbn0pIChjeXRvc2NhcGUpO1xuOyhmdW5jdGlvbiggJCQgKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIGFuaW1hdGVkOiAkJC5kZWZpbmUuYW5pbWF0ZWQoKSxcbiAgICBjbGVhclF1ZXVlOiAkJC5kZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICAgIGRlbGF5OiAkJC5kZWZpbmUuZGVsYXkoKSxcbiAgICBhbmltYXRlOiAkJC5kZWZpbmUuYW5pbWF0ZSgpLFxuICAgIHN0b3A6ICQkLmRlZmluZS5zdG9wKClcbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApOyAgXG5cbjsoZnVuY3Rpb24oICQkICl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmVsZXMoe1xuICAgIGNsYXNzZXM6IGZ1bmN0aW9uKG9wdHMpe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgICAgIHZhciBmbjtcblxuICAgICAgaWYoICQkLmlzLmZuKG9wdHMpICl7XG4gICAgICAgIGZuID0gb3B0cztcblxuICAgICAgfSBlbHNlIGlmKCAhJCQuaXMucGxhaW5PYmplY3Qob3B0cykgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIG5lZWRzIG9wdHMgb3IgZm5cbiAgICAgIH0gXG5cbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciBlbGVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgb3B0cyA9IGZuID8gZm4uYXBwbHkoZWxlLCBbaSwgZWxlXSkgOiBvcHRzO1xuXG4gICAgICAgIC8vIGFkZCBjbGFzc2VzXG4gICAgICAgIGlmKCBvcHRzLmFkZCApeyBmb3IoIHZhciBqID0gMDsgaiA8IG9wdHMuYWRkLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGNscyA9IG9wdHMuYWRkW2pdO1xuICAgICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc107XG5cbiAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcblxuICAgICAgICAgIGlmKCAhaGFzQ2xhc3MgJiYgIWVsZUNoYW5nZWQgKXtcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaCggZWxlICk7XG4gICAgICAgICAgICBlbGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfVxuXG4gICAgICAgIC8vIHJlbW92ZSBjbGFzc2VzXG4gICAgICAgIGlmKCBvcHRzLnJlbW92ZSApeyBmb3IoIHZhciBqID0gMDsgaiA8IG9wdHMucmVtb3ZlLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGNscyA9IG9wdHMucmVtb3ZlW2pdO1xuICAgICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc107XG5cbiAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiggaGFzQ2xhc3MgJiYgIWVsZUNoYW5nZWQgKXtcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaCggZWxlICk7XG4gICAgICAgICAgICBlbGVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfVxuXG4gICAgICAgIC8vIHRvZ2dsZSBjbGFzc2VzXG4gICAgICAgIGlmKCBvcHRzLnRvZ2dsZSApeyBmb3IoIHZhciBqID0gMDsgaiA8IG9wdHMudG9nZ2xlLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGNscyA9IG9wdHMudG9nZ2xlW2pdO1xuICAgICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc107XG5cbiAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gIWhhc0NsYXNzO1xuXG4gICAgICAgICAgaWYoICFlbGVDaGFuZ2VkICl7XG4gICAgICAgICAgICBjaGFuZ2VkLnB1c2goIGVsZSApO1xuICAgICAgICAgICAgZWxlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1cbiAgICAgIH1cblxuICAgICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgICBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCBjaGFuZ2VkIClcbiAgICAgICAgICAudXBkYXRlU3R5bGUoKVxuICAgICAgICAgIC50cmlnZ2VyKCdjbGFzcycpXG4gICAgICAgIDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZENsYXNzOiBmdW5jdGlvbihjbGFzc2VzKXtcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2hhbmdlZCA9IFtdO1xuICAgICAgXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbaV07XG4gICAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhjbHMpICl7IGNvbnRpbnVlOyB9XG4gICAgICAgIFxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gc2VsZltqXTtcbiAgICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdO1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSB0cnVlO1xuXG4gICAgICAgICAgaWYoICFoYXNDbGFzcyApeyAvLyBpZiBkaWRuJ3QgYWxyZWFkeSBoYXZlLCBhZGQgdG8gbGlzdCBvZiBjaGFuZ2VkXG4gICAgICAgICAgICBjaGFuZ2VkLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICAgIGlmKCBjaGFuZ2VkLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgbmV3ICQkLkNvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgY2hhbmdlZClcbiAgICAgICAgICAudXBkYXRlU3R5bGUoKVxuICAgICAgICAgIC50cmlnZ2VyKCdjbGFzcycpXG4gICAgICAgIDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihjbGFzc05hbWUpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICByZXR1cm4gKCBlbGUgIT0gbnVsbCAmJiBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbGFzc05hbWVdICkgPyB0cnVlIDogZmFsc2U7XG4gICAgfSxcblxuICAgIHRvZ2dsZUNsYXNzOiBmdW5jdGlvbihjbGFzc2VzU3RyLCB0b2dnbGUpe1xuICAgICAgdmFyIGNsYXNzZXMgPSBjbGFzc2VzU3RyLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2hhbmdlZCA9IFtdOyAvLyBlbGVzIHdobyBoYWQgY2xhc3NlcyBjaGFuZ2VkXG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwLCBpbCA9IHNlbGYubGVuZ3RoOyBpIDwgaWw7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gc2VsZltpXTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tqXTtcblxuICAgICAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhjbHMpICl7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGhhc0NsYXNzID0gZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXTtcbiAgICAgICAgICB2YXIgc2hvdWxkQWRkID0gdG9nZ2xlIHx8ICh0b2dnbGUgPT09IHVuZGVmaW5lZCAmJiAhaGFzQ2xhc3MpO1xuXG4gICAgICAgICAgaWYoIHNob3VsZEFkZCApe1xuICAgICAgICAgICAgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKCAhaGFzQ2xhc3MgKXsgY2hhbmdlZC5wdXNoKGVsZSk7IH1cbiAgICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHJlbW92ZVxuICAgICAgICAgICAgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiggaGFzQ2xhc3MgKXsgY2hhbmdlZC5wdXNoKGVsZSk7IH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSAvLyBmb3IgaiBjbGFzc2VzXG4gICAgICB9IC8vIGZvciBpIGVsZXNcbiAgICAgIFxuICAgICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgICBpZiggY2hhbmdlZC5sZW5ndGggPiAwICl7XG4gICAgICAgIG5ldyAkJC5Db2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIGNoYW5nZWQpXG4gICAgICAgICAgLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgICAudHJpZ2dlcignY2xhc3MnKVxuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24oY2xhc3Nlcyl7XG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNoYW5nZWQgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2pdO1xuICAgICAgICAgIGlmKCAhY2xzIHx8IGNscyA9PT0gJycgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc107XG4gICAgICAgICAgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGlmKCBoYXNDbGFzcyApeyAvLyB0aGVuIHdlIGNoYW5nZWQgaXRzIHNldCBvZiBjbGFzc2VzXG4gICAgICAgICAgICBjaGFuZ2VkLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICAgIGlmKCBjaGFuZ2VkLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgbmV3ICQkLkNvbGxlY3Rpb24oc2VsZi5fcHJpdmF0ZS5jeSwgY2hhbmdlZCkudXBkYXRlU3R5bGUoKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi50cmlnZ2VyKCdjbGFzcycpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIGZsYXNoQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzZXMsIGR1cmF0aW9uKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYoIGR1cmF0aW9uID09IG51bGwgKXtcbiAgICAgICAgZHVyYXRpb24gPSAyNTA7XG4gICAgICB9IGVsc2UgaWYoIGR1cmF0aW9uID09PSAwICl7XG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBub3RoaW5nIHRvIGRvIHJlYWxseVxuICAgICAgfVxuXG4gICAgICBzZWxmLmFkZENsYXNzKCBjbGFzc2VzICk7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYucmVtb3ZlQ2xhc3MoIGNsYXNzZXMgKTtcbiAgICAgIH0sIGR1cmF0aW9uKTtcblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgYWxsQXJlOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihzZWxlY3RvcikubGVuZ3RoID09PSB0aGlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgaXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHNlbGVjdG9yKS5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICBzb21lOiBmdW5jdGlvbiggZm4sIHRoaXNBcmcgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcmV0ID0gZm4uYXBwbHkoIHRoaXNBcmcsIFsgdGhpc1tpXSwgaSwgdGhpcyBdICk7XG5cbiAgICAgICAgaWYoIHJldCApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZXZlcnk6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciByZXQgPSBmbi5hcHBseSggdGhpc0FyZywgWyB0aGlzW2ldLCBpLCB0aGlzIF0gKTtcblxuICAgICAgICBpZiggIXJldCApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgc2FtZTogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgICAvLyBjaGVhcCBleHRyYSBjaGVja1xuICAgICAgaWYoIHRoaXMubGVuZ3RoICE9PSBjb2xsZWN0aW9uLmxlbmd0aCApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA9PT0gdGhpcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGFueVNhbWU6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgYWxsQXJlTmVpZ2hib3JzOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCgpLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA9PT0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ29tcG91bmQgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIHBhcmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCApO1xuXG4gICAgICAgIGlmKCBwYXJlbnQuc2l6ZSgpID4gMCApe1xuICAgICAgICAgIHBhcmVudHMucHVzaCggcGFyZW50ICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcGFyZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgcGFyZW50czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gICAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG4gICAgICB3aGlsZSggZWxlcy5ub25lbXB0eSgpICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHBhcmVudHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCksIHBhcmVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGNvbW1vbkFuY2VzdG9yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgYW5jZXN0b3JzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBwYXJlbnRzID0gZWxlLnBhcmVudHMoKTtcbiAgICAgICAgXG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuXG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5pbnRlcnNlY3QoIHBhcmVudHMgKTsgLy8gY3VycmVudCBsaXN0IG11c3QgYmUgY29tbW9uIHdpdGggY3VycmVudCBlbGUgcGFyZW50cyBzZXRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuY2VzdG9ycy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIG9ycGhhbnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUucGFyZW50KCkuZW1wdHkoKTtcbiAgICAgIH0pLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgbm9ub3JwaGFuczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5ub25lbXB0eSgpO1xuICAgICAgfSkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdCggZWxlLl9wcml2YXRlLmNoaWxkcmVuICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCBjaGlsZHJlbiwgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgc2libGluZ3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QoIHRoaXMgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGlzUGFyZW50OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggIT09IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzQ2hpbGQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEucGFyZW50ICE9PSB1bmRlZmluZWQgJiYgZWxlLnBhcmVudCgpLmxlbmd0aCAhPT0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGFkZCggZWxlcyApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuXG4gICAgICAgICAgaWYoIGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkgKXtcbiAgICAgICAgICAgIGFkZCggZWxlLmNoaWxkcmVuKCkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWRkKCB0aGlzLmNoaWxkcmVuKCkgKTtcblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCksIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWxpYXNlc1xuICAkJC5lbGVzZm4uYW5jZXN0b3JzID0gJCQuZWxlc2ZuLnBhcmVudHM7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBib3JkZXJXaWR0aE11bHRpcGxpZXIgPSAyICogMC41O1xuICB2YXIgYm9yZGVyV2lkdGhBZGp1c3RtZW50ID0gMDtcblxuICAkJC5mbi5lbGVzKHtcblxuICAgIGRhdGE6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAgICdpZCc6IHRydWUsXG4gICAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlRGF0YTogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgICBpbW11dGFibGVLZXlzOiB7XG4gICAgICAgICdpZCc6IHRydWUsXG4gICAgICAgICdzb3VyY2UnOiB0cnVlLFxuICAgICAgICAndGFyZ2V0JzogdHJ1ZSxcbiAgICAgICAgJ3BhcmVudCc6IHRydWVcbiAgICAgIH0sXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgc2NyYXRjaDogJCQuZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgICB9KSxcblxuICAgIHJlbW92ZVNjcmF0Y2g6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gICAgfSksXG5cbiAgICByc2NyYXRjaDogJCQuZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gICAgfSksXG5cbiAgICByZW1vdmVSc2NyYXRjaDogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdyc2NyYXRjaCcsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gICAgfSksXG5cbiAgICBpZDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcG9zaXRpb246ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAncG9zaXRpb24nLFxuICAgICAgYmluZGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgICAgYWxsb3dCaW5kaW5nOiB0cnVlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAncnRyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICAgICAgb25TZXQ6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICAgIHZhciB1cGRhdGVkRWxlcyA9IGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgdXBkYXRlZEVsZXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICB9LFxuICAgICAgY2FuU2V0OiBmdW5jdGlvbiggZWxlICl7XG4gICAgICAgIHJldHVybiAhZWxlLmxvY2tlZCgpO1xuICAgICAgfVxuICAgIH0pLFxuXG4gICAgLy8gcG9zaXRpb24gYnV0IG5vIG5vdGlmaWNhdGlvbiB0byByZW5kZXJlclxuICAgIHNpbGVudFBvc2l0aW9uOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3Bvc2l0aW9uJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICB2YWxpZEtleXM6IFsneCcsICd5J10sXG4gICAgICBvblNldDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgICAgZWxlcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgfSxcbiAgICAgIGNhblNldDogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIHBvc2l0aW9uczogZnVuY3Rpb24oIHBvcywgc2lsZW50ICl7XG4gICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QocG9zKSApe1xuICAgICAgICB0aGlzLnBvc2l0aW9uKHBvcyk7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5mbihwb3MpICl7XG4gICAgICAgIHZhciBmbiA9IHBvcztcbiAgICAgICAgXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgdmFyIHBvcyA9IGZuLmFwcGx5KGVsZSwgW2ksIGVsZV0pO1xuXG4gICAgICAgICAgaWYoIHBvcyAmJiAhZWxlLmxvY2tlZCgpICl7XG4gICAgICAgICAgICB2YXIgZWxlUG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgICAgZWxlUG9zLnggPSBwb3MueDtcbiAgICAgICAgICAgIGVsZVBvcy55ID0gcG9zLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVwZGF0ZWRFbGVzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICB2YXIgdG9UcmlnZ2VyID0gdXBkYXRlZEVsZXMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkRWxlcyApIDogdGhpcztcblxuICAgICAgICBpZiggc2lsZW50ICl7XG4gICAgICAgICAgdG9UcmlnZ2VyLnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9UcmlnZ2VyLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBzaWxlbnRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MgKXtcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyggcG9zLCB0cnVlICk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUNvbXBvdW5kQm91bmRzOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkgKXsgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTsgfSAvLyBzYXZlIGN5Y2xlcyBmb3Igbm9uIGNvbXBvdW5kIGdyYXBocyBvciB3aGVuIHN0eWxlIGRpc2FibGVkXG5cbiAgICAgIHZhciB1cGRhdGVkID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSggcGFyZW50ICl7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbigpO1xuICAgICAgICB2YXIgc3R5bGUgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgIHZhciBiYiA9IGNoaWxkcmVuLmJvdW5kaW5nQm94KHsgaW5jbHVkZUxhYmVsczogZmFsc2UsIGluY2x1ZGVFZGdlczogZmFsc2UgfSk7XG4gICAgICAgIHZhciBwYWRkaW5nID0ge1xuICAgICAgICAgIHRvcDogc3R5bGVbJ3BhZGRpbmctdG9wJ10ucHhWYWx1ZSxcbiAgICAgICAgICBib3R0b206IHN0eWxlWydwYWRkaW5nLWJvdHRvbSddLnB4VmFsdWUsXG4gICAgICAgICAgbGVmdDogc3R5bGVbJ3BhZGRpbmctbGVmdCddLnB4VmFsdWUsXG4gICAgICAgICAgcmlnaHQ6IHN0eWxlWydwYWRkaW5nLXJpZ2h0J10ucHhWYWx1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9zID0gcGFyZW50Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgZGlkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIHN0eWxlWyd3aWR0aCddLnZhbHVlID09PSAnYXV0bycgKXtcbiAgICAgICAgICBwYXJlbnQuX3ByaXZhdGUuYXV0b1dpZHRoID0gYmIudyArIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgcG9zLnggPSAoYmIueDEgKyBiYi54MiAtIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQpLzI7XG4gICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBzdHlsZVsnaGVpZ2h0J10udmFsdWUgPT09ICdhdXRvJyApe1xuICAgICAgICAgIHBhcmVudC5fcHJpdmF0ZS5hdXRvSGVpZ2h0ID0gYmIuaCArIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gICAgICAgICAgcG9zLnkgPSAoYmIueTEgKyBiYi55MiAtIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b20pLzI7XG4gICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBkaWRVcGRhdGUgKXtcbiAgICAgICAgICB1cGRhdGVkLnB1c2goIHBhcmVudCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdvIHVwLCBsZXZlbCBieSBsZXZlbFxuICAgICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgd2hpbGUoIGVsZXMubm9uZW1wdHkoKSApe1xuXG4gICAgICAgIC8vIHVwZGF0ZSBlYWNoIHBhcmVudCBub2RlIGluIHRoaXMgbGV2ZWxcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICB1cGRhdGUoIGVsZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmV4dCBsZXZlbFxuICAgICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIGNoYW5nZWRcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHVwZGF0ZWQgKTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0L3NldCB0aGUgcmVuZGVyZWQgKGkuZS4gb24gc2NyZWVuKSBwb3NpdG9uIG9mIHRoZSBlbGVtZW50XG4gICAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24oIGRpbSwgdmFsICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHJwb3MgPSAkJC5pcy5wbGFpbk9iamVjdCggZGltICkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmICQkLmlzLnN0cmluZyhkaW0pICk7XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLmlzTm9kZSgpICl7IC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgICAgaWYoIHNldHRpbmcgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uW2RpbV0gPSAoIHZhbCAtIHBhbltkaW1dICkvem9vbTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggcnBvcyAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogKCBycG9zLnggLSBwYW4ueCApIC96b29tLFxuICAgICAgICAgICAgICAgIHk6ICggcnBvcy55IC0gcGFuLnkgKSAvem9vbVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7IC8vIGdldHRpbmdcbiAgICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIHJwb3MgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmKCBkaW0gPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgICByZXR1cm4gcnBvc1sgZGltIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoICFzZXR0aW5nICl7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGdldC9zZXQgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAgICBwYXJlbnRQb3NpdGlvbjogZnVuY3Rpb24oIGRpbSwgdmFsICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciBwcG9zID0gJCQuaXMucGxhaW5PYmplY3QoIGRpbSApID8gZGltIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHNldHRpbmcgPSBwcG9zICE9PSB1bmRlZmluZWQgfHwgKCB2YWwgIT09IHVuZGVmaW5lZCAmJiAkJC5pcy5zdHJpbmcoZGltKSApO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLmlzTm9kZSgpICl7IC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgICAgaWYoIHNldHRpbmcgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHZhciByZWxhdGl2ZVRvUGFyZW50ID0gaGFzUGFyZW50O1xuXG4gICAgICAgICAgICBpZiggaGFzUGFyZW50ICl7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQuX3ByaXZhdGUucG9zaXRpb24gOiB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICAgICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvbltkaW1dID0gdmFsICsgb3JpZ2luW2RpbV07XG4gICAgICAgICAgICB9IGVsc2UgaWYoIHBwb3MgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHBwb3MueCArIG9yaWdpbi54LFxuICAgICAgICAgICAgICAgIHk6IHBwb3MueSArIG9yaWdpbi55LFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gZ2V0dGluZ1xuICAgICAgICAgIHZhciBwb3MgPSBlbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kTm9kZXMgPyBlbGUucGFyZW50KCkgOiBudWxsO1xuICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG5cbiAgICAgICAgICBpZiggaGFzUGFyZW50ICl7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG9yaWdpbiA9IHJlbGF0aXZlVG9QYXJlbnQgPyBwYXJlbnQuX3ByaXZhdGUucG9zaXRpb24gOiB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICAgIHBwb3MgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCAtIG9yaWdpbi54LFxuICAgICAgICAgICAgeTogcG9zLnkgLSBvcmlnaW4ueVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiggZGltID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gcHBvcztcbiAgICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgICAgcmV0dXJuIHBwb3NbIGRpbSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKCAhc2V0dGluZyApe1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICAvLyBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgYSBudW1lcmljYWwgdmFsdWUgZm9yIHRoZSB3aWR0aCBvZiB0aGUgbm9kZS9lZGdlXG4gICAgd2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IGVsZS5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICAgIHZhciB3ID0gZWxlLl9wcml2YXRlLnN0eWxlLndpZHRoO1xuICAgICAgICAgIHJldHVybiB3LnN0clZhbHVlID09PSAnYXV0bycgPyBlbGUuX3ByaXZhdGUuYXV0b1dpZHRoIDogdy5weFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG91dGVyV2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IGVsZS5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgICAgICB2YXIgd2lkdGggPSBzdHlsZS53aWR0aC5zdHJWYWx1ZSA9PT0gJ2F1dG8nID8gZWxlLl9wcml2YXRlLmF1dG9XaWR0aCA6IHN0eWxlLndpZHRoLnB4VmFsdWU7XG4gICAgICAgICAgdmFyIGJvcmRlciA9IHN0eWxlWydib3JkZXItd2lkdGgnXSA/IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlICogYm9yZGVyV2lkdGhNdWx0aXBsaWVyICsgYm9yZGVyV2lkdGhBZGp1c3RtZW50IDogMDtcblxuICAgICAgICAgIHJldHVybiB3aWR0aCArIGJvcmRlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJlZFdpZHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdmFyIHdpZHRoID0gZWxlLndpZHRoKCk7XG4gICAgICAgIHJldHVybiB3aWR0aCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcmVkT3V0ZXJXaWR0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHZhciBvd2lkdGggPSBlbGUub3V0ZXJXaWR0aCgpO1xuICAgICAgICByZXR1cm4gb3dpZHRoICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IGEgbnVtZXJpY2FsIHZhbHVlIGZvciB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlXG4gICAgaGVpZ2h0OiBmdW5jdGlvbigpeyBcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgICAgaWYoIGVsZSAmJiBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICAgIHZhciBoID0gZWxlLl9wcml2YXRlLnN0eWxlLmhlaWdodDtcbiAgICAgICAgICByZXR1cm4gaC5zdHJWYWx1ZSA9PT0gJ2F1dG8nID8gZWxlLl9wcml2YXRlLmF1dG9IZWlnaHQgOiBoLnB4VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb3V0ZXJIZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IGVsZS5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodC5zdHJWYWx1ZSA9PT0gJ2F1dG8nID8gZWxlLl9wcml2YXRlLmF1dG9IZWlnaHQgOiBzdHlsZS5oZWlnaHQucHhWYWx1ZTtcbiAgICAgICAgICB2YXIgYm9yZGVyID0gc3R5bGVbJ2JvcmRlci13aWR0aCddID8gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWUgKiBib3JkZXJXaWR0aE11bHRpcGxpZXIgKyBib3JkZXJXaWR0aEFkanVzdG1lbnQgOiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlaWdodCArIGJvcmRlcjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyZWRIZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSAmJiBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgdmFyIGhlaWdodCA9IGVsZS5oZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIGhlaWdodCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcmVkT3V0ZXJIZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSAmJiBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgdmFyIG9oZWlnaHQgPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgcmV0dXJuIG9oZWlnaHQgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJlZEJvdW5kaW5nQm94OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGJiID0gdGhpcy5ib3VuZGluZ0JveCggb3B0aW9ucyApO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG5cbiAgICAgIHZhciB4MSA9IGJiLngxICogem9vbSArIHBhbi54O1xuICAgICAgdmFyIHgyID0gYmIueDIgKiB6b29tICsgcGFuLng7XG4gICAgICB2YXIgeTEgPSBiYi55MSAqIHpvb20gKyBwYW4ueTtcbiAgICAgIHZhciB5MiA9IGJiLnkyICogem9vbSArIHBhbi55O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHc6IHgyIC0geDEsXG4gICAgICAgIGg6IHkyIC0geTFcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIGdldCB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBlbGVtZW50cyAoaW4gcmF3IG1vZGVsIHBvc2l0aW9uKVxuICAgIGJvdW5kaW5nQm94OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGN5ID0gZWxlcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBjeV9wID0gY3kuX3ByaXZhdGU7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3lfcC5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB2YXIgaW5jbHVkZU5vZGVzID0gb3B0aW9ucy5pbmNsdWRlTm9kZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVOb2RlcztcbiAgICAgIHZhciBpbmNsdWRlRWRnZXMgPSBvcHRpb25zLmluY2x1ZGVFZGdlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuaW5jbHVkZUVkZ2VzO1xuICAgICAgdmFyIGluY2x1ZGVMYWJlbHMgPSBvcHRpb25zLmluY2x1ZGVMYWJlbHMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVMYWJlbHM7XG5cbiAgICAgIC8vIHJlY2FsY3VsYXRlIHByb2plY3Rpb25zIGV0Y1xuICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICBjeV9wLnJlbmRlcmVyLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSggdGhpcyApO1xuICAgICAgfVxuXG4gICAgICB2YXIgeDEgPSBJbmZpbml0eTtcbiAgICAgIHZhciB4MiA9IC1JbmZpbml0eTtcbiAgICAgIHZhciB5MSA9IEluZmluaXR5O1xuICAgICAgdmFyIHkyID0gLUluZmluaXR5O1xuXG4gICAgICAvLyBmaW5kIGJvdW5kcyBvZiBlbGVtZW50c1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBkaXNwbGF5ID0gc3R5bGVFbmFibGVkID8gX3Auc3R5bGVbJ2Rpc3BsYXknXS52YWx1ZSA6ICdlbGVtZW50JztcbiAgICAgICAgdmFyIGlzTm9kZSA9IF9wLmdyb3VwID09PSAnbm9kZXMnO1xuICAgICAgICB2YXIgZXgxLCBleDIsIGV5MSwgZXkyLCB4LCB5O1xuICAgICAgICB2YXIgaW5jbHVkZWRFbGUgPSBmYWxzZTtcblxuICAgICAgICBpZiggZGlzcGxheSA9PT0gJ25vbmUnICl7IGNvbnRpbnVlOyB9IC8vIHRoZW4gZWxlIGRvZXNuJ3QgdGFrZSB1cCBzcGFjZSAgICAgIFxuXG4gICAgICAgIGlmKCBpc05vZGUgJiYgaW5jbHVkZU5vZGVzICl7XG4gICAgICAgICAgaW5jbHVkZWRFbGUgPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHBvcyA9IF9wLnBvc2l0aW9uO1xuICAgICAgICAgIHggPSBwb3MueDtcbiAgICAgICAgICB5ID0gcG9zLnk7XG4gICAgICAgICAgdmFyIHcgPSBlbGUub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgIHZhciBoYWxmVyA9IHcvMjtcbiAgICAgICAgICB2YXIgaCA9IGVsZS5vdXRlckhlaWdodCgpO1xuICAgICAgICAgIHZhciBoYWxmSCA9IGgvMjtcblxuICAgICAgICAgIC8vIGhhbmRsZSBub2RlIGRpbWVuc2lvbnNcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICBleDEgPSB4IC0gaGFsZlc7XG4gICAgICAgICAgZXgyID0geCArIGhhbGZXO1xuICAgICAgICAgIGV5MSA9IHkgLSBoYWxmSDtcbiAgICAgICAgICBleTIgPSB5ICsgaGFsZkg7XG5cbiAgICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICAgIHkxID0gZXkxIDwgeTEgPyBleTEgOiB5MTtcbiAgICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7XG5cbiAgICAgICAgfSBlbHNlIGlmKCBlbGUuaXNFZGdlKCkgJiYgaW5jbHVkZUVkZ2VzICl7IFxuICAgICAgICAgIGluY2x1ZGVkRWxlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBuMXBvcyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2UuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgdmFyIG4ycG9zID0gZWxlLl9wcml2YXRlLnRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICAgIC8vIGhhbmRsZSBlZGdlIGRpbWVuc2lvbnMgKHJvdWdoIGJveCBlc3RpbWF0ZSlcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZSB8fCB7fTtcblxuICAgICAgICAgIGV4MSA9IG4xcG9zLng7XG4gICAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgICBleTEgPSBuMXBvcy55O1xuICAgICAgICAgIGV5MiA9IG4ycG9zLnk7XG5cbiAgICAgICAgICBpZiggZXgxID4gZXgyICl7XG4gICAgICAgICAgICB2YXIgdGVtcCA9IGV4MTtcbiAgICAgICAgICAgIGV4MSA9IGV4MjtcbiAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGV5MSA+IGV5MiApe1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBleTE7XG4gICAgICAgICAgICBleTEgPSBleTI7XG4gICAgICAgICAgICBleTIgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxID0gZXgxIDwgeDEgPyBleDEgOiB4MTtcbiAgICAgICAgICB4MiA9IGV4MiA+IHgyID8gZXgyIDogeDI7XG4gICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgIHkyID0gZXkyID4geTIgPyBleTIgOiB5MjtcblxuICAgICAgICAgIC8vIGhhbmRsZSBwb2ludHMgYWxvbmcgZWRnZSAoc2FuaXR5IGNoZWNrKVxuICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuICAgICAgICAgICAgdmFyIGJwdHMgPSByc3R5bGUuYmV6aWVyUHRzIHx8IFtdO1xuXG4gICAgICAgICAgICB2YXIgdyA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlO1xuICAgICAgICAgICAgdmFyIHdIYWxmID0gdy8yO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGJwdHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgdmFyIGJwdCA9IGJwdHNbal07XG5cbiAgICAgICAgICAgICAgZXgxID0gYnB0LnggLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXgyID0gYnB0LnggKyB3SGFsZjtcbiAgICAgICAgICAgICAgZXkxID0gYnB0LnkgLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXkyID0gYnB0LnkgKyB3SGFsZjtcblxuICAgICAgICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgICAgICAgIHgyID0gZXgyID4geDIgPyBleDIgOiB4MjtcbiAgICAgICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gLy8gZWRnZXNcblxuICAgICAgICAvLyBoYW5kbGUgbGFiZWwgZGltZW5zaW9uc1xuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcblxuICAgICAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgICAgICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcbiAgICAgICAgICB2YXIgbGFiZWwgPSBzdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuICAgICAgICAgIHZhciBmb250U2l6ZSA9IHN0eWxlWydmb250LXNpemUnXTtcbiAgICAgICAgICB2YXIgaGFsaWduID0gc3R5bGVbJ3RleHQtaGFsaWduJ107XG4gICAgICAgICAgdmFyIHZhbGlnbiA9IHN0eWxlWyd0ZXh0LXZhbGlnbiddO1xuICAgICAgICAgIHZhciBsYWJlbFdpZHRoID0gcnN0eWxlLmxhYmVsV2lkdGg7XG4gICAgICAgICAgdmFyIGxhYmVsSGVpZ2h0ID0gcnN0eWxlLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIHZhciBsYWJlbFggPSByc3R5bGUubGFiZWxYO1xuICAgICAgICAgIHZhciBsYWJlbFkgPSByc3R5bGUubGFiZWxZO1xuXG4gICAgICAgICAgaWYoIGluY2x1ZGVkRWxlICYmIGluY2x1ZGVMYWJlbHMgJiYgbGFiZWwgJiYgZm9udFNpemUgJiYgbGFiZWxIZWlnaHQgIT0gbnVsbCAmJiBsYWJlbFdpZHRoICE9IG51bGwgJiYgbGFiZWxYICE9IG51bGwgJiYgbGFiZWxZICE9IG51bGwgJiYgaGFsaWduICYmIHZhbGlnbiApe1xuICAgICAgICAgICAgdmFyIGxoID0gbGFiZWxIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbHcgPSBsYWJlbFdpZHRoO1xuICAgICAgICAgICAgdmFyIGx4MSwgbHgyLCBseTEsIGx5MjtcblxuICAgICAgICAgICAgaWYoIGVsZS5pc0VkZ2UoKSApe1xuICAgICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdy8yO1xuICAgICAgICAgICAgICBseDIgPSBsYWJlbFggKyBsdy8yO1xuICAgICAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaC8yO1xuICAgICAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaC8yO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3dpdGNoKCBoYWxpZ24udmFsdWUgKXtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3O1xuICAgICAgICAgICAgICAgICAgbHgyID0gbGFiZWxYO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHcvMjtcbiAgICAgICAgICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3LzI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICAgIGx4MSA9IGxhYmVsWDtcbiAgICAgICAgICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzd2l0Y2goIHZhbGlnbi52YWx1ZSApe1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaDtcbiAgICAgICAgICAgICAgICAgIGx5MiA9IGxhYmVsWTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoLzI7XG4gICAgICAgICAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaC8yO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgbHkxID0gbGFiZWxZO1xuICAgICAgICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB4MSA9IGx4MSA8IHgxID8gbHgxIDogeDE7XG4gICAgICAgICAgICB4MiA9IGx4MiA+IHgyID8gbHgyIDogeDI7XG4gICAgICAgICAgICB5MSA9IGx5MSA8IHkxID8gbHkxIDogeTE7XG4gICAgICAgICAgICB5MiA9IGx5MiA+IHkyID8gbHkyIDogeTI7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIHN0eWxlIGVuYWJsZWRcbiAgICAgIH0gLy8gZm9yXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHkyOiB5MixcbiAgICAgICAgdzogeDIgLSB4MSxcbiAgICAgICAgaDogeTIgLSB5MVxuICAgICAgfTtcbiAgICB9XG4gIH0pOyBcblxuICAvLyBpbiBjYXNlIHNvbWUgdXNlcnMgd2FudCB0byBiZSBleHBsaWNpdFxuICAkJC5lbGVzZm4ubW9kZWxQb3NpdGlvbiA9ICQkLmVsZXNmbi5wb3NpdGlvbjtcbiAgJCQuZWxlc2ZuLm1vZGVsUG9zaXRpb25zID0gJCQuZWxlc2ZuLnBvc2l0aW9ucztcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oICQkICl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIFJlZ3VsYXIgZGVncmVlIGZ1bmN0aW9ucyAod29ya3Mgb24gc2luZ2xlIGVsZW1lbnQpXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIGZ1bmN0aW9uIGRlZmluZURlZ3JlZUZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiggaW5jbHVkZUxvb3BzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgaW5jbHVkZUxvb3BzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIHNlbGYubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgICBpZiggc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkgKXtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IDA7XG4gICAgICAgIHZhciBub2RlID0gc2VsZlswXTtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tpXTtcblxuICAgICAgICAgIGlmKCAhaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkgKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayggbm9kZSwgZWRnZSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZGVncmVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgXG4gICQkLmZuLmVsZXMoe1xuICAgIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24obm9kZSwgZWRnZSl7XG4gICAgICBpZiggZWRnZS5zb3VyY2UoKS5zYW1lKCBlZGdlLnRhcmdldCgpICkgKXtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIGluZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbihub2RlLCBlZGdlKXtcbiAgICAgIGlmKCBlZGdlLnRhcmdldCgpLnNhbWUobm9kZSkgKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIG91dGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24obm9kZSwgZWRnZSl7XG4gICAgICBpZiggZWRnZS5zb3VyY2UoKS5zYW1lKG5vZGUpICl7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSlcbiAgfSk7XG4gIFxuICBcbiAgLy8gQ29sbGVjdGlvbiBkZWdyZWUgc3RhdHNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oZGVncmVlRm4sIGNhbGxiYWNrKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgICAgdmFyIHJldDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBkZWdyZWUgPSBlbGVbZGVncmVlRm5dKCBpbmNsdWRlTG9vcHMgKTtcbiAgICAgICAgaWYoIGRlZ3JlZSAhPT0gdW5kZWZpbmVkICYmIChyZXQgPT09IHVuZGVmaW5lZCB8fCBjYWxsYmFjayhkZWdyZWUsIHJldCkpICl7XG4gICAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfVxuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgbWluRGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtaW4pe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgICB9KSxcblxuICAgIG1heERlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWF4KXtcbiAgICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gICAgfSksXG5cbiAgICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtaW4pe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgICB9KSxcblxuICAgIG1heEluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1heCl7XG4gICAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICAgIH0pLFxuXG4gICAgbWluT3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtaW4pe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgICB9KSxcblxuICAgIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWF4KXtcbiAgICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gICAgfSlcbiAgfSk7XG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICB0b3RhbERlZ3JlZTogZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB0b3RhbCArPSBub2Rlc1tpXS5kZWdyZWUoIGluY2x1ZGVMb29wcyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbiAgXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gRnVuY3Rpb25zIGZvciBiaW5kaW5nICYgdHJpZ2dlcmluZyBldmVudHNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgb246ICQkLmRlZmluZS5vbigpLCAvLyAub24oIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgZGF0YV0sIGhhbmRsZXIpXG4gICAgb25lOiAkJC5kZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICAgIG9uY2U6ICQkLmRlZmluZS5vbih7IHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHRydWUgfSksXG4gICAgb2ZmOiAkJC5kZWZpbmUub2ZmKCksIC8vIC5vZmYoIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgaGFuZGxlcl0gKVxuICAgIHRyaWdnZXI6ICQkLmRlZmluZS50cmlnZ2VyKCksIC8vIC50cmlnZ2VyKCBldmVudHMgWywgZXh0cmFQYXJhbXNdIClcblxuICAgIHJ0cmlnZ2VyOiBmdW5jdGlvbihldmVudCwgZXh0cmFQYXJhbXMpeyAvLyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgIGlmKCB0aGlzLmxlbmd0aCA9PT0gMCApeyByZXR1cm47IH0gLy8gZW1wdHkgY29sbGVjdGlvbnMgZG9uJ3QgbmVlZCB0byBub3RpZnkgYW55dGhpbmdcblxuICAgICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgICB0aGlzLmN5KCkubm90aWZ5KHtcbiAgICAgICAgdHlwZTogZXZlbnQsXG4gICAgICAgIGNvbGxlY3Rpb246IHRoaXNcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLnRyaWdnZXIoZXZlbnQsIGV4dHJhUGFyYW1zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWxpYXNlcyBmb3IgdGhvc2UgZm9sa3Mgd2hvIGxpa2Ugb2xkIHN0dWZmOlxuICAkJC5lbGVzZm4uYmluZCA9ICQkLmVsZXNmbi5vbjtcbiAgJCQuZWxlc2ZuLnVuYmluZCA9ICQkLmVsZXNmbi5vZmY7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIG5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihpLCBlbGVtZW50KXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaXNOb2RlKCk7XG4gICAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICBlZGdlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmlzRWRnZSgpO1xuICAgICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgZmlsdGVyOiBmdW5jdGlvbiggZmlsdGVyICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgXG4gICAgICBpZiggJCQuaXMuZm4oZmlsdGVyKSApe1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAgIGlmKCBmaWx0ZXIuYXBwbHkoZWxlLCBbaSwgZWxlXSkgKXtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpO1xuICAgICAgXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhmaWx0ZXIpIHx8ICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZmlsdGVyKSApe1xuICAgICAgICByZXR1cm4gbmV3ICQkLlNlbGVjdG9yKGZpbHRlcikuZmlsdGVyKHRoaXMpO1xuICAgICAgXG4gICAgICB9IGVsc2UgaWYoIGZpbHRlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5ICk7IC8vIGlmIG5vdCBoYW5kbGVkIGJ5IGFib3ZlLCBnaXZlICdlbSBhbiBlbXB0eSBjb2xsZWN0aW9uXG4gICAgfSxcblxuICAgIG5vdDogZnVuY3Rpb24oIHRvUmVtb3ZlICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBpZiggIXRvUmVtb3ZlICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIFxuICAgICAgICBpZiggJCQuaXMuc3RyaW5nKCB0b1JlbW92ZSApICl7XG4gICAgICAgICAgdG9SZW1vdmUgPSB0aGlzLmZpbHRlciggdG9SZW1vdmUgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICAgIFxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbaV07XG5cbiAgICAgICAgICB2YXIgcmVtb3ZlID0gdG9SZW1vdmUuX3ByaXZhdGUuaWRzWyBlbGVtZW50LmlkKCkgXTtcbiAgICAgICAgICBpZiggIXJlbW92ZSApe1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlbWVudCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlbWVudHMgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKCBvdGhlciApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIFxuICAgICAgLy8gaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWQsIHRoZW4gZmlsdGVyIGJ5IGl0IGluc3RlYWRcbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3RoZXIpICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IG90aGVyO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICAgIHZhciBjb2wxU21hbGxlciA9IHRoaXMubGVuZ3RoIDwgb3RoZXIubGVuZ3RoO1xuICAgICAgLy8gdmFyIGlkczEgPSBjb2wxU21hbGxlciA/IGNvbDEuX3ByaXZhdGUuaWRzIDogY29sMi5fcHJpdmF0ZS5pZHM7XG4gICAgICB2YXIgaWRzMiA9IGNvbDFTbWFsbGVyID8gY29sMi5fcHJpdmF0ZS5pZHMgOiBjb2wxLl9wcml2YXRlLmlkcztcbiAgICAgIHZhciBjb2wgPSBjb2wxU21hbGxlciA/IGNvbDEgOiBjb2wyO1xuICAgICAgXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgaWQgPSBjb2xbaV0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGVsZSA9IGlkczJbIGlkIF07XG5cbiAgICAgICAgaWYoIGVsZSApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzICk7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oIHRvQWRkICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5OyAgICBcbiAgICAgIFxuICAgICAgaWYoICF0b0FkZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoICQkLmlzLnN0cmluZyh0b0FkZCkgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICAgIHRvQWRkID0gY3kuZWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goIHRoaXNbaV0gKTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKyApe1xuXG4gICAgICAgIHZhciBhZGQgPSAhdGhpcy5fcHJpdmF0ZS5pZHNbIHRvQWRkW2ldLmlkKCkgXTtcbiAgICAgICAgaWYoIGFkZCApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIHRvQWRkW2ldICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIGluIHBsYWNlIG1lcmdlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICAgIG1lcmdlOiBmdW5jdGlvbiggdG9BZGQgKXtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgY3kgPSBfcC5jeTsgICAgXG4gICAgICBcbiAgICAgIGlmKCAhdG9BZGQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcodG9BZGQpICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgICB0b0FkZCA9IGN5LmVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdG9BZGRFbGUgPSB0b0FkZFtpXTtcbiAgICAgICAgdmFyIGlkID0gdG9BZGRFbGUuaWQoKTtcbiAgICAgICAgdmFyIGFkZCA9ICFfcC5pZHNbIGlkIF07XG5cbiAgICAgICAgaWYoIGFkZCApe1xuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG5cbiAgICAgICAgICB0aGlzWyBpbmRleCBdID0gdG9BZGRFbGU7XG4gICAgICAgICAgX3AuaWRzWyBpZCBdID0gdG9BZGRFbGU7XG4gICAgICAgICAgX3AuaW5kZXhlc1sgaWQgXSA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICAvLyByZW1vdmUgc2luZ2xlIGVsZSBpbiBwbGFjZSBpbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgICB1bm1lcmdlT25lOiBmdW5jdGlvbiggZWxlICl7XG4gICAgICBlbGUgPSBlbGVbMF07XG5cbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBpID0gX3AuaW5kZXhlc1sgaWQgXTtcblxuICAgICAgaWYoIGkgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gbm8gbmVlZCB0byByZW1vdmVcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGVsZVxuICAgICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIF9wLmlkc1sgaWQgXSA9IHVuZGVmaW5lZDtcbiAgICAgIF9wLmluZGV4ZXNbIGlkIF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciB1bm1lcmdlZExhc3RFbGUgPSBpID09PSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIHJlcGxhY2UgZW1wdHkgc3BvdCB3aXRoIGxhc3QgZWxlIGluIGNvbGxlY3Rpb25cbiAgICAgIGlmKCB0aGlzLmxlbmd0aCA+IDEgJiYgIXVubWVyZ2VkTGFzdEVsZSApe1xuICAgICAgICB2YXIgbGFzdEVsZUkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBsYXN0RWxlID0gdGhpc1sgbGFzdEVsZUkgXTtcblxuICAgICAgICB0aGlzWyBsYXN0RWxlSSBdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzW2ldID0gbGFzdEVsZTtcbiAgICAgICAgX3AuaW5kZXhlc1sgbGFzdEVsZS5pZCgpIF0gPSBpO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgY29sbGVjdGlvbiBpcyBub3cgMSBlbGUgc21hbGxlclxuICAgICAgdGhpcy5sZW5ndGgtLTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIHJlbW92ZSBlbGVzIGluIHBsYWNlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICAgIHVubWVyZ2U6IGZ1bmN0aW9uKCB0b1JlbW92ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTsgICAgXG4gICAgICBcbiAgICAgIGlmKCAhdG9SZW1vdmUgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcodG9SZW1vdmUpICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRvUmVtb3ZlO1xuICAgICAgICB0b1JlbW92ZSA9IGN5LmVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgICAgICB0aGlzLnVubWVyZ2VPbmUoIHRvUmVtb3ZlW2ldICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBtYXA6IGZ1bmN0aW9uKCBtYXBGbiwgdGhpc0FyZyApe1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciByZXQgPSBtYXBGbi5hcHBseSggdGhpc0FyZywgW2VsZSwgaSwgZWxlc10gKTtcblxuICAgICAgICBhcnIucHVzaCggcmV0ICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfSxcblxuICAgIHN0ZEZpbHRlcjogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgICB2YXIgZmlsdGVyRWxlcyA9IFtdO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IGZuLmFwcGx5KCB0aGlzQXJnLCBbZWxlLCBpLCBlbGVzXSApO1xuXG4gICAgICAgIGlmKCBpbmNsdWRlICl7XG4gICAgICAgICAgZmlsdGVyRWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBmaWx0ZXJFbGVzICk7XG4gICAgfSxcblxuICAgIG1heDogZnVuY3Rpb24oIHZhbEZuLCB0aGlzQXJnICl7XG4gICAgICB2YXIgbWF4ID0gLUluZmluaXR5O1xuICAgICAgdmFyIG1heEVsZTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgdmFsID0gdmFsRm4uYXBwbHkoIHRoaXNBcmcsIFsgZWxlLCBpLCBlbGVzIF0gKTtcblxuICAgICAgICBpZiggdmFsID4gbWF4ICl7XG4gICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICAgIG1heEVsZSA9IGVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbWF4LFxuICAgICAgICBlbGU6IG1heEVsZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgbWluOiBmdW5jdGlvbiggdmFsRm4sIHRoaXNBcmcgKXtcbiAgICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5FbGU7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IHZhbEZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgZWxlcyBdICk7XG5cbiAgICAgICAgaWYoIHZhbCA8IG1pbiApe1xuICAgICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgICBtaW5FbGUgPSBlbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG1pbixcbiAgICAgICAgZWxlOiBtaW5FbGVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIGlzTm9kZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdub2Rlcyc7XG4gICAgfSxcblxuICAgIGlzRWRnZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdlZGdlcyc7XG4gICAgfSxcblxuICAgIGlzTG9vcDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKCkuaWQoKSA9PT0gdGhpcy50YXJnZXQoKS5pZCgpO1xuICAgIH0sXG5cbiAgICBpc1NpbXBsZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKCkuaWQoKSAhPT0gdGhpcy50YXJnZXQoKS5pZCgpO1xuICAgIH0sXG5cbiAgICBncm91cDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JvdXA7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIEZ1bmN0aW9ucyBmb3IgaXRlcmF0aW5nIG92ZXIgY29sbGVjdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgZWFjaDogZnVuY3Rpb24oZm4pe1xuICAgICAgaWYoICQkLmlzLmZuKGZuKSApe1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIHJldCA9IGZuLmFwcGx5KCBlbGUsIFsgaSwgZWxlIF0gKTtcblxuICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7IGJyZWFrOyB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGZuLCB0aGlzQXJnKXtcbiAgICAgIGlmKCAkJC5pcy5mbihmbikgKXtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIHJldCA9IGZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgdGhpcyBdICk7XG5cbiAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyBicmVhazsgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgIFxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBhcnJheS5wdXNoKCB0aGlzW2ldICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuXG4gICAgc2xpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpe1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICB2YXIgdGhpc1NpemUgPSB0aGlzLmxlbmd0aDtcbiAgICAgIFxuICAgICAgaWYoIGVuZCA9PSBudWxsICl7XG4gICAgICAgIGVuZCA9IHRoaXNTaXplO1xuICAgICAgfVxuXG4gICAgICBpZiggc3RhcnQgPT0gbnVsbCApe1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBzdGFydCA8IDAgKXtcbiAgICAgICAgc3RhcnQgPSB0aGlzU2l6ZSArIHN0YXJ0O1xuICAgICAgfVxuXG4gICAgICBpZiggZW5kIDwgMCApe1xuICAgICAgICBlbmQgPSB0aGlzU2l6ZSArIGVuZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yKHZhciBpID0gc3RhcnQ7IGkgPj0gMCAmJiBpIDwgZW5kICYmIGkgPCB0aGlzU2l6ZTsgaSsrKXtcbiAgICAgICAgYXJyYXkucHVzaCggdGhpc1tpXSApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24odGhpcy5jeSgpLCBhcnJheSk7XG4gICAgfSxcblxuICAgIHNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGVxOiBmdW5jdGlvbihpKXtcbiAgICAgIHJldHVybiB0aGlzW2ldIHx8IG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCkgKTtcbiAgICB9LFxuXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpc1swXSB8fCBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpICk7XG4gICAgfSxcblxuICAgIGxhc3Q6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpc1sgdGhpcy5sZW5ndGggLSAxIF0gfHwgbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSApO1xuICAgIH0sXG5cbiAgICBlbXB0eTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcbiAgICB9LFxuXG4gICAgbm9uZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gIXRoaXMuZW1wdHkoKTtcbiAgICB9LFxuXG4gICAgc29ydDogZnVuY3Rpb24oIHNvcnRGbiApe1xuICAgICAgaWYoICEkJC5pcy5mbiggc29ydEZuICkgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTsgICAgICBcbiAgICAgIHZhciBzb3J0ZWQgPSB0aGlzLnRvQXJyYXkoKS5zb3J0KCBzb3J0Rm4gKTtcblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBzb3J0ZWQpO1xuICAgIH0sXG5cbiAgICBzb3J0QnlaSW5kZXg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5zb3J0KCAkJC5Db2xsZWN0aW9uLnpJbmRleFNvcnQgKTtcbiAgICB9LFxuXG4gICAgekRlcHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICBpZiggIWVsZSApeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5cbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBncm91cCA9IF9wLmdyb3VwO1xuXG4gICAgICBpZiggZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgcmV0dXJuIF9wLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKS5zaXplKCkgOiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyYyA9IF9wLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgICAgdmFyIHNyY0RlcHRoID0gc3JjLl9wcml2YXRlLmRhdGEucGFyZW50ID8gc3JjLnBhcmVudHMoKS5zaXplKCkgOiAwO1xuICAgICAgICB2YXIgdGd0RGVwdGggPSB0Z3QuX3ByaXZhdGUuZGF0YS5wYXJlbnQgPyB0Z3QucGFyZW50cygpLnNpemUoKSA6IDA7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KCBzcmNEZXB0aCAtIDEsIHRndERlcHRoIC0gMSwgMCApICsgMC41OyAvLyBkZXB0aCBvZiBkZWVwZXN0IHBhcmVudCBhbmQganVzdCBhIGJpdCBhYm92ZVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgJCQuQ29sbGVjdGlvbi56SW5kZXhTb3J0ID0gZnVuY3Rpb24oYSwgYil7XG4gICAgdmFyIGN5ID0gYS5jeSgpO1xuICAgIHZhciBhX3AgPSBhLl9wcml2YXRlO1xuICAgIHZhciBiX3AgPSBiLl9wcml2YXRlO1xuICAgIHZhciB6RGlmZiA9IGFfcC5zdHlsZVsnei1pbmRleCddLnZhbHVlIC0gYl9wLnN0eWxlWyd6LWluZGV4J10udmFsdWU7XG4gICAgdmFyIGRlcHRoQSA9IDA7XG4gICAgdmFyIGRlcHRoQiA9IDA7XG4gICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGFJc05vZGUgPSBhX3AuZ3JvdXAgPT09ICdub2Rlcyc7XG4gICAgdmFyIGFJc0VkZ2UgPSBhX3AuZ3JvdXAgPT09ICdlZGdlcyc7XG4gICAgdmFyIGJJc05vZGUgPSBiX3AuZ3JvdXAgPT09ICdub2Rlcyc7XG4gICAgdmFyIGJJc0VkZ2UgPSBiX3AuZ3JvdXAgPT09ICdlZGdlcyc7XG5cbiAgICAvLyBubyBuZWVkIHRvIGNhbGN1bGF0ZSBlbGVtZW50IGRlcHRoIGlmIHRoZXJlIGlzIG5vIGNvbXBvdW5kIG5vZGVcbiAgICBpZiggaGFzQ29tcG91bmROb2RlcyApe1xuICAgICAgZGVwdGhBID0gYS56RGVwdGgoKTtcbiAgICAgIGRlcHRoQiA9IGIuekRlcHRoKCk7XG4gICAgfVxuXG4gICAgdmFyIGRlcHRoRGlmZiA9IGRlcHRoQSAtIGRlcHRoQjtcbiAgICB2YXIgc2FtZURlcHRoID0gZGVwdGhEaWZmID09PSAwO1xuXG4gICAgaWYoIHNhbWVEZXB0aCApe1xuICAgICAgXG4gICAgICBpZiggYUlzTm9kZSAmJiBiSXNFZGdlICl7XG4gICAgICAgIHJldHVybiAxOyAvLyAnYScgaXMgYSBub2RlLCBpdCBzaG91bGQgYmUgZHJhd24gbGF0ZXIgICAgICAgXG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiggYUlzRWRnZSAmJiBiSXNOb2RlICl7XG4gICAgICAgIHJldHVybiAtMTsgLy8gJ2EnIGlzIGFuIGVkZ2UsIGl0IHNob3VsZCBiZSBkcmF3biBmaXJzdFxuXG4gICAgICB9IGVsc2UgeyAvLyBib3RoIG5vZGVzIG9yIGJvdGggZWRnZXNcbiAgICAgICAgaWYoIHpEaWZmID09PSAwICl7IC8vIHNhbWUgei1pbmRleCA9PiBjb21wYXJlIGluZGljZXMgaW4gdGhlIGNvcmUgKG9yZGVyIGFkZGVkIHRvIGdyYXBoIHcvIGxhc3Qgb24gdG9wKVxuICAgICAgICAgIHJldHVybiBhX3AuaW5kZXggLSBiX3AuaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHpEaWZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgXG4gICAgLy8gZWxlbWVudHMgb24gZGlmZmVyZW50IGxldmVsXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZXB0aERpZmY7IC8vIGRlZXBlciBlbGVtZW50IHNob3VsZCBiZSBkcmF3biBsYXRlclxuICAgIH1cblxuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIEZ1bmN0aW9ucyBmb3IgbGF5b3V0cyBvbiBub2Rlc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAkJC5mbi5lbGVzKHtcblxuICAgIC8vIHVzaW5nIHN0YW5kYXJkIGxheW91dCBvcHRpb25zLCBhcHBseSBwb3NpdGlvbiBmdW5jdGlvbiAody8gb3Igdy9vIGFuaW1hdGlvbilcbiAgICBsYXlvdXRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBsYXlvdXQsIG9wdGlvbnMsIGZuICl7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIGxhc3ROb2RlID0gaSA9PT0gbm9kZXMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgIHZhciBuZXdQb3MgPSBmbi5jYWxsKCBub2RlLCBpLCBub2RlICk7XG4gICAgICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgICAgIGlmKCAhJCQuaXMubnVtYmVyKHBvcy54KSB8fCAhJCQuaXMubnVtYmVyKHBvcy55KSApe1xuICAgICAgICAgICAgbm9kZS5zaWxlbnRQb3NpdGlvbih7IHg6IDAsIHk6IDAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZS5hbmltYXRlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBuZXdQb3NcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbixcbiAgICAgICAgICAgIHN0ZXA6ICFsYXN0Tm9kZSA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGxldGU6ICFsYXN0Tm9kZSA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLnpvb20gIT0gbnVsbCApe1xuICAgICAgICAgICAgICAgIGN5Lnpvb20oIG9wdGlvbnMuem9vbSApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYoIG9wdGlvbnMucGFuICl7XG4gICAgICAgICAgICAgICAgY3kucGFuKCBvcHRpb25zLnBhbiApO1xuICAgICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVzLnBvc2l0aW9ucyggZm4gKTtcblxuICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuem9vbSAhPSBudWxsICl7XG4gICAgICAgICAgY3kuem9vbSggb3B0aW9ucy56b29tICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0aW9ucy5wYW4gKXtcbiAgICAgICAgICBjeS5wYW4oIG9wdGlvbnMucGFuICk7XG4gICAgICAgIH0gXG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgICAgXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBsYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIGN5LmxheW91dCggJCQudXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgZWxlczogdGhpc1xuICAgICAgfSkgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG5cbiAgICAgIHJldHVybiBjeS5tYWtlTGF5b3V0KCAkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBlbGVzOiB0aGlzXG4gICAgICB9KSApO1xuICAgIH1cblxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uZWxlcyh7XG5cbiAgICAvLyBmdWxseSB1cGRhdGVzIChyZWNhbGN1bGF0ZXMpIHRoZSBzdHlsZSBmb3IgdGhlIGVsZW1lbnRzXG4gICAgdXBkYXRlU3R5bGU6IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBpZiggY3kuX3ByaXZhdGUuYmF0Y2hpbmdTdHlsZSApe1xuICAgICAgICB2YXIgYkVsZXMgPSBjeS5fcHJpdmF0ZS5iYXRjaFN0eWxlRWxlcztcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAgIGlmKCAhYkVsZXMuaWRzWyBlbGUuX3ByaXZhdGUuaWQgXSApe1xuICAgICAgICAgICAgYkVsZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nIGFuZCBleGl0IGVhcmx5IHdoZW4gYmF0Y2hpbmdcbiAgICAgIH1cblxuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIG5vdGlmeVJlbmRlcmVyID0gbm90aWZ5UmVuZGVyZXIgfHwgbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgc3R5bGUuYXBwbHkoIHRoaXMgKTtcblxuICAgICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcblxuICAgICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCdzdHlsZScpOyAvLyBsZXQgcmVuZGVyZXIga25vdyB3ZSBjaGFuZ2VkIHN0eWxlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b05vdGlmeS50cmlnZ2VyKCdzdHlsZScpOyAvLyBqdXN0IGZpcmUgdGhlIGV2ZW50XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgLy8ganVzdCB1cGRhdGUgdGhlIG1hcHBlcnMgaW4gdGhlIGVsZW1lbnRzJyBzdHlsZXM7IGNoZWFwZXIgdGhhbiBlbGVzLnVwZGF0ZVN0eWxlKClcbiAgICB1cGRhdGVNYXBwZXJzOiBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHN0eWxlLnVwZGF0ZU1hcHBlcnMoIHRoaXMgKTtcblxuICAgICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcblxuICAgICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCdzdHlsZScpOyAvLyBsZXQgcmVuZGVyZXIga25vdyB3ZSBjaGFuZ2VkIHN0eWxlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b05vdGlmeS50cmlnZ2VyKCdzdHlsZScpOyAvLyBqdXN0IGZpcmUgdGhlIGV2ZW50XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgLy8gZ2V0IHRoZSBzcGVjaWZpZWQgY3NzIHByb3BlcnR5IGFzIGEgcmVuZGVyZWQgdmFsdWUgKGkuZS4gb24tc2NyZWVuIHZhbHVlKVxuICAgIC8vIG9yIGdldCB0aGUgd2hvbGUgcmVuZGVyZWQgc3R5bGUgaWYgbm8gcHJvcGVydHkgc3BlY2lmaWVkIChOQiBkb2Vzbid0IGFsbG93IHNldHRpbmcpXG4gICAgcmVuZGVyZWRDc3M6IGZ1bmN0aW9uKCBwcm9wZXJ0eSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgcmVuc3R5bGUgPSBlbGUuY3koKS5zdHlsZSgpLmdldFJlbmRlcmVkU3R5bGUoIGVsZSApO1xuXG4gICAgICAgIGlmKCBwcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgcmV0dXJuIHJlbnN0eWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZW5zdHlsZVsgcHJvcGVydHkgXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyByZWFkIHRoZSBjYWxjdWxhdGVkIGNzcyBzdHlsZSBvZiB0aGUgZWxlbWVudCBvciBvdmVycmlkZSB0aGUgc3R5bGUgKHZpYSBhIGJ5cGFzcylcbiAgICBjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcblxuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KG5hbWUpICl7IC8vIHRoZW4gZXh0ZW5kIHRoZSBieXBhc3NcbiAgICAgICAgdmFyIHByb3BzID0gbmFtZTtcbiAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3MoIHRoaXMsIHByb3BzLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuXG4gICAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKG5hbWUpICl7XG4gIFxuICAgICAgICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIGdldCB0aGUgcHJvcGVydHkgZnJvbSB0aGUgc3R5bGVcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGVbIG5hbWUgXS5zdHJWYWx1ZTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiBzZXQgdGhlIGJ5cGFzcyB3aXRoIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKCB0aGlzLCBuYW1lLCB2YWx1ZSwgdXBkYXRlVHJhbnNpdGlvbnMgKTtcblxuICAgICAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuICAgICAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiggbmFtZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICByZXR1cm4gc3R5bGUuZ2V0UmF3U3R5bGUoIGVsZSApO1xuICAgICAgICB9IGVsc2UgeyAvLyBlbXB0eSBjb2xsZWN0aW9uID0+IGNhbid0IGdldCBhbnkgdmFsdWVcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHJlbW92ZUNzczogZnVuY3Rpb24oIG5hbWVzICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBpZiggbmFtZXMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICAgIHN0eWxlLnJlbW92ZUFsbEJ5cGFzc2VzKCBlbGUsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWVzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICAgIHN0eWxlLnJlbW92ZUJ5cGFzc2VzKCBlbGUsIG5hbWVzLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG4gICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHNob3c6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLmNzcygnZGlzcGxheScsICdlbGVtZW50Jyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgaGlkZTogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICB2aXNpYmxlOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgICBpZihcbiAgICAgICAgICBzdHlsZVsndmlzaWJpbGl0eSddLnZhbHVlICE9PSAndmlzaWJsZSdcbiAgICAgICAgICB8fCBzdHlsZVsnZGlzcGxheSddLnZhbHVlICE9PSAnZWxlbWVudCdcbiAgICAgICAgKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgICAgIHZhciBwYXJlbnRzID0gZWxlLl9wcml2YXRlLmRhdGEucGFyZW50ID8gZWxlLnBhcmVudHMoKSA6IG51bGw7XG5cbiAgICAgICAgICBpZiggcGFyZW50cyApe1xuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgICB2YXIgcFN0eWxlID0gcGFyZW50Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgICAgICAgICB2YXIgcFZpcyA9IHBTdHlsZVsndmlzaWJpbGl0eSddLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgcERpcyA9IHBTdHlsZVsnZGlzcGxheSddLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmKCBwVmlzICE9PSAndmlzaWJsZScgfHwgcERpcyAhPT0gJ2VsZW1lbnQnICl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICAgICAgdmFyIHRndCA9IGVsZS5fcHJpdmF0ZS50YXJnZXQ7XG5cbiAgICAgICAgICByZXR1cm4gc3JjLnZpc2libGUoKSAmJiB0Z3QudmlzaWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGlkZGVuOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuICFlbGUudmlzaWJsZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlZmZlY3RpdmVPcGFjaXR5OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gMTsgfVxuXG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgICAgdmFyIHBhcmVudE9wYWNpdHkgPSBfcC5zdHlsZS5vcGFjaXR5LnZhbHVlO1xuXG4gICAgICAgIGlmKCAhaGFzQ29tcG91bmROb2RlcyApeyByZXR1cm4gcGFyZW50T3BhY2l0eTsgfVxuXG4gICAgICAgIHZhciBwYXJlbnRzID0gIV9wLmRhdGEucGFyZW50ID8gbnVsbCA6IGVsZS5wYXJlbnRzKCk7XG4gICAgICAgIFxuICAgICAgICBpZiggcGFyZW50cyApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IHBhcmVudC5fcHJpdmF0ZS5zdHlsZS5vcGFjaXR5LnZhbHVlO1xuXG4gICAgICAgICAgICBwYXJlbnRPcGFjaXR5ID0gb3BhY2l0eSAqIHBhcmVudE9wYWNpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcmVudE9wYWNpdHk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHRyYW5zcGFyZW50OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGVsZS5jeSgpLmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnN0eWxlLm9wYWNpdHkudmFsdWUgPT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5lZmZlY3RpdmVPcGFjaXR5KCkgPT09IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaXNGdWxsQXV0b1BhcmVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHZhciBhdXRvVyA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS52YWx1ZSA9PT0gJ2F1dG8nO1xuICAgICAgICB2YXIgYXV0b0ggPSBlbGUuX3ByaXZhdGUuc3R5bGVbJ2hlaWdodCddLnZhbHVlID09PSAnYXV0byc7XG5cbiAgICAgICAgcmV0dXJuIGVsZS5pc1BhcmVudCgpICYmIGF1dG9XICYmIGF1dG9IO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuXG4gICQkLmVsZXNmbi5zdHlsZSA9ICQkLmVsZXNmbi5jc3M7XG4gICQkLmVsZXNmbi5yZW5kZXJlZFN0eWxlID0gJCQuZWxlc2ZuLnJlbmRlcmVkQ3NzO1xuICAkJC5lbGVzZm4ucmVtb3ZlU3R5bGUgPSAkJC5lbGVzZm4ucmVtb3ZlQ3NzO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyBDb2xsZWN0aW9uIGZ1bmN0aW9ucyB0aGF0IHRvZ2dsZSBhIGJvb2xlYW4gdmFsdWVcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgXG4gIGZ1bmN0aW9uIGRlZmluZVN3aXRjaEZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIFxuICAgICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggZGF0YSwgaGFuZGxlciApXG4gICAgICBpZiggYXJncy5sZW5ndGggPT09IDIgKXtcbiAgICAgICAgdmFyIGRhdGEgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMV07XG4gICAgICAgIHRoaXMuYmluZCggcGFyYW1zLmV2ZW50LCBkYXRhLCBoYW5kbGVyICk7XG4gICAgICB9IFxuICAgICAgXG4gICAgICAvLyBlLmcuIGN5Lm5vZGVzKCkuc2VsZWN0KCBoYW5kbGVyIClcbiAgICAgIGVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAxICl7XG4gICAgICAgIHZhciBoYW5kbGVyID0gYXJnc1swXTtcbiAgICAgICAgdGhpcy5iaW5kKCBwYXJhbXMuZXZlbnQsIGhhbmRsZXIgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCgpXG4gICAgICBlbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICB2YXIgYWJsZSA9ICFwYXJhbXMuYWJsZUZpZWxkIHx8IGVsZS5fcHJpdmF0ZVtwYXJhbXMuYWJsZUZpZWxkXTtcblxuICAgICAgICAgIGlmKCBwYXJhbXMub3ZlcnJpZGVBYmxlICl7XG4gICAgICAgICAgICB2YXIgb3ZlcnJpZGVBYmxlID0gcGFyYW1zLm92ZXJyaWRlQWJsZShlbGUpO1xuXG4gICAgICAgICAgICBpZiggb3ZlcnJpZGVBYmxlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgICAgYWJsZSA9IG92ZXJyaWRlQWJsZTtcblxuICAgICAgICAgICAgICBpZiggIW92ZXJyaWRlQWJsZSApeyByZXR1cm4gdGhpczsgfSAvLyB0byBzYXZlIGN5Y2xlcyBhc3N1bWUgbm90IGFibGUgZm9yIGFsbCBvbiBvdmVycmlkZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhYmxlICl7XG4gICAgICAgICAgICBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSA9IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZSgpOyAvLyBjaGFuZ2Ugb2Ygc3RhdGUgPT4gcG9zc2libGUgY2hhbmdlIG9mIHN0eWxlXG4gICAgICAgIHRoaXMudHJpZ2dlciggcGFyYW1zLmV2ZW50ICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGRlZmluZVN3aXRjaFNldCggcGFyYW1zICl7XG4gICAgJCQuZWxlc2ZuWyBwYXJhbXMuZmllbGQgXSA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBpZiggcGFyYW1zLm92ZXJyaWRlRmllbGQgKXtcbiAgICAgICAgICB2YXIgdmFsID0gcGFyYW1zLm92ZXJyaWRlRmllbGQoZWxlKTtcblxuICAgICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlWyBwYXJhbXMuZmllbGQgXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgICQkLmVsZXNmblsgcGFyYW1zLm9uIF0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgICBldmVudDogcGFyYW1zLm9uLFxuICAgICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICAgIHZhbHVlOiB0cnVlXG4gICAgfSk7XG5cbiAgICAkJC5lbGVzZm5bIHBhcmFtcy5vZmYgXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKHtcbiAgICAgIGV2ZW50OiBwYXJhbXMub2ZmLFxuICAgICAgZmllbGQ6IHBhcmFtcy5maWVsZCxcbiAgICAgIGFibGVGaWVsZDogcGFyYW1zLmFibGVGaWVsZCxcbiAgICAgIG92ZXJyaWRlQWJsZTogcGFyYW1zLm92ZXJyaWRlQWJsZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIFxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnbG9ja2VkJyxcbiAgICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbihlbGUpe1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG9sb2NrKCkgPyB0cnVlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdsb2NrJyxcbiAgICBvZmY6ICd1bmxvY2snXG4gIH0pO1xuICBcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ2dyYWJiYWJsZScsXG4gICAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oZWxlKXtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5ncmFiaWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnZ3JhYmlmeScsXG4gICAgb2ZmOiAndW5ncmFiaWZ5J1xuICB9KTtcbiAgXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdzZWxlY3RlZCcsXG4gICAgYWJsZUZpZWxkOiAnc2VsZWN0YWJsZScsXG4gICAgb3ZlcnJpZGVBYmxlOiBmdW5jdGlvbihlbGUpe1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ3NlbGVjdCcsXG4gICAgb2ZmOiAndW5zZWxlY3QnXG4gIH0pO1xuICBcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ3NlbGVjdGFibGUnLFxuICAgIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uKGVsZSl7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnc2VsZWN0aWZ5JyxcbiAgICBvZmY6ICd1bnNlbGVjdGlmeSdcbiAgfSk7XG4gIFxuICAkJC5lbGVzZm4uZ3JhYmJlZCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncmFiYmVkO1xuICAgIH1cbiAgfTtcblxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnYWN0aXZlJyxcbiAgICBvbjogJ2FjdGl2YXRlJyxcbiAgICBvZmY6ICd1bmFjdGl2YXRlJ1xuICB9KTtcblxuICAkJC5lbGVzZm4uaW5hY3RpdmUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgICB9XG4gIH07XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERBRyBmdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAkJC5mbi5lbGVzKHtcbiAgICAvLyBnZXQgdGhlIHJvb3Qgbm9kZXMgaW4gdGhlIERBR1xuICAgIHJvb3RzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciByb290cyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFzRWRnZXNQb2ludGluZ0luID0gZWxlLmNvbm5lY3RlZEVkZ2VzKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgndGFyZ2V0JykgPT09IGVsZS5pZCgpICYmIHRoaXMuZGF0YSgnc291cmNlJykgIT09IGVsZS5pZCgpO1xuICAgICAgICB9KS5sZW5ndGggPiAwO1xuXG4gICAgICAgIGlmKCAhaGFzRWRnZXNQb2ludGluZ0luICl7XG4gICAgICAgICAgcm9vdHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCByb290cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IHRoZSBsZWFmIG5vZGVzIGluIHRoZSBEQUdcbiAgICBsZWF2ZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGxlYXZlcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFzRWRnZXNQb2ludGluZ091dCA9IGVsZS5jb25uZWN0ZWRFZGdlcyhmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ3NvdXJjZScpID09PSBlbGUuaWQoKSAmJiB0aGlzLmRhdGEoJ3RhcmdldCcpICE9PSBlbGUuaWQoKTtcbiAgICAgICAgfSkubGVuZ3RoID4gMDtcblxuICAgICAgICBpZiggIWhhc0VkZ2VzUG9pbnRpbmdPdXQgKXtcbiAgICAgICAgICBsZWF2ZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBsZWF2ZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIC8vIG5vcm1hbGx5IGNhbGxlZCBjaGlsZHJlbiBpbiBncmFwaCB0aGVvcnlcbiAgICAvLyB0aGVzZSBub2RlcyA9ZWRnZXM9PiBvdXRnb2luZyBub2Rlc1xuICAgIG91dGdvZXJzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBvRWxlcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciBlbGVJZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIGVkZ2VzID0gZWxlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgICB2YXIgc3JjSWQgPSBlZGdlLl9wcml2YXRlLmRhdGEuc291cmNlO1xuICAgICAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS50YXJnZXQ7XG5cbiAgICAgICAgICBpZiggc3JjSWQgPT09IGVsZUlkICYmIHRndElkICE9PSBlbGVJZCApe1xuICAgICAgICAgICAgb0VsZXMucHVzaCggZWRnZSApO1xuICAgICAgICAgICAgb0VsZXMucHVzaCggZWRnZS50YXJnZXQoKVswXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIG9FbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICAvLyBha2EgREFHIGRlc2NlbmRhbnRzXG4gICAgc3VjY2Vzc29yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgc0VsZXMgPSBbXTtcbiAgICAgIHZhciBzRWxlc0lkcyA9IHt9O1xuXG4gICAgICBmb3IoOzspe1xuICAgICAgICB2YXIgb3V0Z29lcnMgPSBlbGVzLm91dGdvZXJzKCk7XG5cbiAgICAgICAgaWYoIG91dGdvZXJzLmxlbmd0aCA9PT0gMCApeyBicmVhazsgfSAvLyBkb25lIGlmIG5vIG91dGdvZXJzIGxlZnRcblxuICAgICAgICB2YXIgbmV3T3V0Z29lcnMgPSBmYWxzZTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvdXRnb2Vycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBvdXRnb2VyID0gb3V0Z29lcnNbaV07XG4gICAgICAgICAgdmFyIG91dGdvZXJJZCA9IG91dGdvZXIuaWQoKTtcblxuICAgICAgICAgIGlmKCAhc0VsZXNJZHNbIG91dGdvZXJJZCBdICl7XG4gICAgICAgICAgICBzRWxlc0lkc1sgb3V0Z29lcklkIF0gPSB0cnVlO1xuICAgICAgICAgICAgc0VsZXMucHVzaCggb3V0Z29lciApO1xuICAgICAgICAgICAgbmV3T3V0Z29lcnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhbmV3T3V0Z29lcnMgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiB0b3VjaGVkIGFsbCBvdXRnb2VycyBhbHJlYWR5XG5cbiAgICAgICAgZWxlcyA9IG91dGdvZXJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHNFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICAvLyBub3JtYWxseSBjYWxsZWQgcGFyZW50cyBpbiBncmFwaCB0aGVvcnlcbiAgICAvLyB0aGVzZSBub2RlcyA8PWVkZ2VzPSBpbmNvbWluZyBub2Rlc1xuICAgIGluY29tZXJzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBvRWxlcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciBlbGVJZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIGVkZ2VzID0gZWxlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgICB2YXIgc3JjSWQgPSBlZGdlLl9wcml2YXRlLmRhdGEuc291cmNlO1xuICAgICAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS50YXJnZXQ7XG5cbiAgICAgICAgICBpZiggdGd0SWQgPT09IGVsZUlkICYmIHNyY0lkICE9PSBlbGVJZCApe1xuICAgICAgICAgICAgb0VsZXMucHVzaCggZWRnZSApO1xuICAgICAgICAgICAgb0VsZXMucHVzaCggZWRnZS5zb3VyY2UoKVswXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIG9FbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICAvLyBha2EgREFHIGFuY2VzdG9yc1xuICAgIHByZWRlY2Vzc29yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgcEVsZXMgPSBbXTtcbiAgICAgIHZhciBwRWxlc0lkcyA9IHt9O1xuXG4gICAgICBmb3IoOzspe1xuICAgICAgICB2YXIgaW5jb21lcnMgPSBlbGVzLmluY29tZXJzKCk7XG5cbiAgICAgICAgaWYoIGluY29tZXJzLmxlbmd0aCA9PT0gMCApeyBicmVhazsgfSAvLyBkb25lIGlmIG5vIGluY29tZXJzIGxlZnRcblxuICAgICAgICB2YXIgbmV3SW5jb21lcnMgPSBmYWxzZTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBpbmNvbWVycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBpbmNvbWVyID0gaW5jb21lcnNbaV07XG4gICAgICAgICAgdmFyIGluY29tZXJJZCA9IGluY29tZXIuaWQoKTtcblxuICAgICAgICAgIGlmKCAhcEVsZXNJZHNbIGluY29tZXJJZCBdICl7XG4gICAgICAgICAgICBwRWxlc0lkc1sgaW5jb21lcklkIF0gPSB0cnVlO1xuICAgICAgICAgICAgcEVsZXMucHVzaCggaW5jb21lciApO1xuICAgICAgICAgICAgbmV3SW5jb21lcnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhbmV3SW5jb21lcnMgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiB0b3VjaGVkIGFsbCBpbmNvbWVycyBhbHJlYWR5XG5cbiAgICAgICAgZWxlcyA9IGluY29tZXJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHBFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cbiAgfSk7XG5cblxuICAvLyBOZWlnaGJvdXJob29kIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIG5laWdoYm9yaG9vZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7IC8vIGZvciBhbGwgbm9kZXNcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICAgIC8vIGZvciBlYWNoIGNvbm5lY3RlZCBlZGdlLCBhZGQgdGhlIGVkZ2UgYW5kIHRoZSBvdGhlciBub2RlXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2pdO1xuICAgICAgICAgIHZhciBvdGhlck5vZGUgPSBlZGdlLmNvbm5lY3RlZE5vZGVzKCkubm90KG5vZGUpO1xuXG4gICAgICAgICAgLy8gbmVlZCBjaGVjayBpbiBjYXNlIG9mIGxvb3BcbiAgICAgICAgICBpZiggb3RoZXJOb2RlLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goIG90aGVyTm9kZVswXSApOyAvLyBhZGQgbm9kZSAxIGhvcCBhd2F5XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGFkZCBjb25uZWN0ZWQgZWRnZVxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVkZ2VbMF0gKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiAoIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgY2xvc2VkTmVpZ2hib3Job29kOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5hZGQoIHRoaXMgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIG9wZW5OZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCggc2VsZWN0b3IgKTtcbiAgICB9XG4gIH0pOyAgXG5cblxuICAvLyBFZGdlIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vL1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIHNvdXJjZTogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBzcmM7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgc3JjID0gZWxlLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNyYyAmJiBzZWxlY3RvciA/IHNyYy5maWx0ZXIoIHNlbGVjdG9yICkgOiBzcmM7XG4gICAgfSxcblxuICAgIHRhcmdldDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciB0Z3Q7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRndCAmJiBzZWxlY3RvciA/IHRndC5maWx0ZXIoIHNlbGVjdG9yICkgOiB0Z3Q7XG4gICAgfSxcblxuICAgIHNvdXJjZXM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICAgIGF0dHI6ICdzb3VyY2UnXG4gICAgfSksXG5cbiAgICB0YXJnZXRzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgICBhdHRyOiAndGFyZ2V0J1xuICAgIH0pXG4gIH0pO1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lU291cmNlRnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHJldHVybiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBzcmMgPSBlbGUuX3ByaXZhdGVbIHBhcmFtcy5hdHRyIF07XG5cbiAgICAgICAgaWYoIHNyYyApe1xuICAgICAgICAgIHNvdXJjZXMucHVzaCggc3JjICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgc291cmNlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9O1xuICB9XG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgZWRnZXNXaXRoOiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbigpLFxuXG4gICAgZWRnZXNUbzogZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oe1xuICAgICAgdGhpc0lzOiAnc291cmNlJ1xuICAgIH0pXG4gIH0pO1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbihvdGhlck5vZGVzKXtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBwID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgICAvLyBnZXQgZWxlbWVudHMgaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWRcbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3RoZXJOb2RlcykgKXtcbiAgICAgICAgb3RoZXJOb2RlcyA9IGN5LiQoIG90aGVyTm9kZXMgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGVkZ2VzID0gb3RoZXJOb2Rlcy5jb25uZWN0ZWRFZGdlcygpO1xuICAgICAgdmFyIHRoaXNJZHMgPSB0aGlzLl9wcml2YXRlLmlkcztcbiAgICAgIFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgZm91bmRJZDtcbiAgICAgICAgdmFyIGVkZ2VEYXRhID0gZWRnZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICAgIGlmKCBwLnRoaXNJcyApe1xuICAgICAgICAgIHZhciBpZFRvRmluZCA9IGVkZ2VEYXRhWyBwLnRoaXNJcyBdO1xuICAgICAgICAgIGZvdW5kSWQgPSB0aGlzSWRzWyBpZFRvRmluZCBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvdW5kSWQgPSB0aGlzSWRzWyBlZGdlRGF0YS5zb3VyY2UgXSB8fCB0aGlzSWRzWyBlZGdlRGF0YS50YXJnZXQgXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIGZvdW5kSWQgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKTtcbiAgICB9O1xuICB9XG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBjb25uZWN0ZWRFZGdlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIFxuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gZWxlc1tpXTtcbiAgICAgICAgaWYoICFub2RlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIGVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTsgICAgICAgICAgXG4gICAgICAgICAgcmV0RWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcmV0RWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgY29ubmVjdGVkTm9kZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVsZXNbaV07XG4gICAgICAgIGlmKCAhZWRnZS5pc0VkZ2UoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHJldEVsZXMucHVzaCggZWRnZS5zb3VyY2UoKVswXSApO1xuICAgICAgICByZXRFbGVzLnB1c2goIGVkZ2UudGFyZ2V0KClbMF0gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcmV0RWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgcGFyYWxsZWxFZGdlczogZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKCksXG5cbiAgICBjb2RpcmVjdGVkRWRnZXM6IGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbih7XG4gICAgICBjb2RpcmVjdGVkOiB0cnVlXG4gICAgfSlcbiAgfSk7XG4gIFxuICBmdW5jdGlvbiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24ocGFyYW1zKXtcbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICBjb2RpcmVjdGVkOiBmYWxzZVxuICAgIH07XG4gICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICAgIHZhciBwID0gcGFyYW1zO1xuXG4gICAgICAvLyBsb29rIGF0IGFsbCB0aGUgZWRnZXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UxID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBzcmMxID0gZWRnZTEuc291cmNlKClbMF07XG4gICAgICAgIHZhciBzcmNpZDEgPSBzcmMxLmlkKCk7XG4gICAgICAgIHZhciB0Z3QxID0gZWRnZTEudGFyZ2V0KClbMF07XG4gICAgICAgIHZhciB0Z3RpZDEgPSB0Z3QxLmlkKCk7XG4gICAgICAgIHZhciBzcmNFZGdlczEgPSBzcmMxLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAgIC8vIGxvb2sgYXQgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzcmMgbm9kZSBvZiB0aGlzIGVkZ2VcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzcmNFZGdlczEubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWRnZTIgPSBzcmNFZGdlczFbal07XG4gICAgICAgICAgdmFyIGVkZ2UyZGF0YSA9IGVkZ2UyLl9wcml2YXRlLmRhdGE7XG4gICAgICAgICAgdmFyIHRndGlkMiA9IGVkZ2UyZGF0YS50YXJnZXQ7XG4gICAgICAgICAgdmFyIHNyY2lkMiA9IGVkZ2UyZGF0YS5zb3VyY2U7XG5cbiAgICAgICAgICB2YXIgY29kaXJlY3RlZCA9IHRndGlkMiA9PT0gdGd0aWQxICYmIHNyY2lkMiA9PT0gc3JjaWQxO1xuICAgICAgICAgIHZhciBvcHBkaXJlY3RlZCA9IHNyY2lkMSA9PT0gdGd0aWQyICYmIHRndGlkMSA9PT0gc3JjaWQyO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCAocC5jb2RpcmVjdGVkICYmIGNvZGlyZWN0ZWQpIHx8ICghcC5jb2RpcmVjdGVkICYmIChjb2RpcmVjdGVkIHx8IG9wcGRpcmVjdGVkKSkgKXtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVkZ2UyICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH07XG4gIFxuICB9XG5cbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uZWxlcyh7XG5cbiAgICBmaXQ6IGZ1bmN0aW9uKCl7fSxcbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCl7fVxuXG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24gKCQkKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIC8qICBNaW4gYW5kIE1heCBoZWFwIHByZWRlZmF1bHRzICovXG4gIFxuICAkJC5NaW5oZWFwID0gZnVuY3Rpb24gKGN5LCBlbGVzLCB2YWx1ZUZuKSB7XG4gICAgcmV0dXJuIG5ldyAkJC5IZWFwKGN5LCBlbGVzLCAkJC5IZWFwLm1pbkhlYXBDb21wYXJhdG9yLCB2YWx1ZUZuKTtcbiAgfTtcblxuICAkJC5NYXhoZWFwID0gZnVuY3Rpb24gKGN5LCBlbGVzLCB2YWx1ZUZuKSB7XG4gICAgcmV0dXJuIG5ldyAkJC5IZWFwKGN5LCBlbGVzLCAkJC5IZWFwLm1heEhlYXBDb21wYXJhdG9yLCB2YWx1ZUZuKTtcbiAgfTtcbiAgXG4gICQkLkhlYXAgPSBmdW5jdGlvbiAoY3ksIGVsZXMsIGNvbXBhcmF0b3IsIHZhbHVlRm4pIHtcbiAgICBpZiAodHlwZW9mIGNvbXBhcmF0b3IgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIGVsZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiB2YWx1ZUZuID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB2YWx1ZUZuID0gJCQuSGVhcC5pZEZuO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VIZWFwID0gW10sXG4gICAgICBwb2ludGVycyA9IHt9LFxuICAgICAgZWxlbWVudHMgPSBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgaWQsXG4gICAgICBoZWFwLFxuICAgICAgZWxlc0xlbjtcblxuICAgIGVsZXMgPSB0aGlzLmdldEFyZ3VtZW50QXNDb2xsZWN0aW9uKGVsZXMsIGN5KTtcbiAgICBlbGVzTGVuID0gZWxlcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZWxlc0xlbjsgaSArPSAxKSB7XG4gICAgICBzb3VyY2VIZWFwLnB1c2godmFsdWVGbi5jYWxsKGN5LCBlbGVzW2ldLCBpLCBlbGVzKSk7XG5cbiAgICAgIGlkID0gZWxlc1tpXS5pZCgpO1xuICAgICAgXG4gICAgICBpZiAocG9pbnRlcnMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgIHRocm93IFwiRVJST1I6IE11bHRpcGxlIGl0ZW1zIHdpdGggdGhlIHNhbWUgaWQgZm91bmQ6IFwiICsgaWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHBvaW50ZXJzW2lkXSA9IGk7XG4gICAgICBlbGVtZW50cy5wdXNoKGlkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY3k6IGN5LFxuICAgICAgaGVhcDogc291cmNlSGVhcCxcbiAgICAgIHBvaW50ZXJzOiBwb2ludGVycyxcbiAgICAgIGVsZW1lbnRzOiBlbGVtZW50cyxcbiAgICAgIGNvbXBhcmF0b3I6IGNvbXBhcmF0b3IsXG4gICAgICBleHRyYWN0b3I6IHZhbHVlRm4sXG4gICAgICBsZW5ndGg6IGVsZXNMZW5cbiAgICB9O1xuXG4gICAgZm9yIChpID0gTWF0aC5mbG9vcihlbGVzTGVuIC8gMik7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBoZWFwID0gdGhpcy5oZWFwaWZ5KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFwO1xuICB9O1xuXG4gIC8qIHN0YXRpYyBtZXRob2RzICovXG4gICQkLkhlYXAuaWRGbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuaWQoKTtcbiAgfTtcblxuICAkJC5IZWFwLm1pbkhlYXBDb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSA+PSBiO1xuICB9O1xuXG4gICQkLkhlYXAubWF4SGVhcENvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIDw9IGI7XG4gIH07XG5cbiAgJCQuZm4uaGVhcCA9IGZ1bmN0aW9uKCBmbk1hcCwgb3B0aW9ucyApe1xuICAgIGZvciggdmFyIG5hbWUgaW4gZm5NYXAgKXtcbiAgICAgIHZhciBmbiA9IGZuTWFwW25hbWVdO1xuICAgICAgJCQuSGVhcC5wcm90b3R5cGVbIG5hbWUgXSA9IGZuO1xuICAgIH1cbiAgfTtcblxuICAkJC5oZWFwZm4gPSAkJC5IZWFwLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxuICAvKiBvYmplY3QgbWV0aG9kcyAqL1xuICAkJC5oZWFwZm4uc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5sZW5ndGg7XG4gIH07XG5cbiAgJCQuaGVhcGZuLmdldEFyZ3VtZW50QXNDb2xsZWN0aW9uID0gZnVuY3Rpb24gKGVsZXMsIGN5KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBpZih0eXBlb2YgY3kgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB9XG5cbiAgICBpZiAoJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihlbGVzKSkge1xuICAgICAgcmVzdWx0ID0gZWxlcztcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0QXJyYXkgPSBbXSxcbiAgICAgICAgc291cmNlRWxlcyA9IFtdLmNvbmNhdC5hcHBseShbXSwgW2VsZXNdKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VFbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IHNvdXJjZUVsZXNbaV0sXG4gICAgICAgICAgZWxlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXG4gICAgICAgIGlmKGVsZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzdWx0QXJyYXkucHVzaChlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCByZXN1bHRBcnJheSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAkJC5oZWFwZm4uaXNIZWFwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcnJheSA9IHRoaXMuX3ByaXZhdGUuaGVhcCxcbiAgICAgIGFycmxlbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGksXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBsQ2hlY2ssXG4gICAgICByQ2hlY2ssXG4gICAgICBjb21wYXJhdG9yID0gdGhpcy5fcHJpdmF0ZS5jb21wYXJhdG9yO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGFycmxlbjsgaSArPSAxKSB7XG4gICAgICBsZWZ0ID0gMiAqIGkgKyAxO1xuICAgICAgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgIGxDaGVjayA9IGxlZnQgPCBhcnJsZW4gPyBjb21wYXJhdG9yKGFycmF5W2xlZnRdLCBhcnJheVtpXSkgOiB0cnVlO1xuICAgICAgckNoZWNrID0gcmlnaHQgPCBhcnJsZW4gPyBjb21wYXJhdG9yKGFycmF5W3JpZ2h0XSwgYXJyYXlbaV0pIDogdHJ1ZTtcblxuICAgICAgaWYgKCFsQ2hlY2sgfHwgIXJDaGVjaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgJCQuaGVhcGZuLmhlYXBTd2FwID0gZnVuY3Rpb24gKGksIGopIHtcbiAgICB2YXIgaGVhcCA9IHRoaXMuX3ByaXZhdGUuaGVhcCxcbiAgICAgIHBvaW50ZXJzID0gdGhpcy5fcHJpdmF0ZS5wb2ludGVycyxcbiAgICAgIGVsZW1lbnRzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cyxcbiAgICAgIHN3YXBWYWx1ZSA9IGhlYXBbaV0sXG4gICAgICBzd2FwRWxlbXMgPSBlbGVtZW50c1tpXSxcbiAgICAgIGlkSSA9IGVsZW1lbnRzW2ldLFxuICAgICAgaWRKID0gZWxlbWVudHNbal07XG5cbiAgICBoZWFwW2ldID0gaGVhcFtqXTtcbiAgICBlbGVtZW50c1tpXSA9IGVsZW1lbnRzW2pdO1xuXG4gICAgcG9pbnRlcnNbaWRJXSA9IGo7XG4gICAgcG9pbnRlcnNbaWRKXSA9IGk7XG5cbiAgICBoZWFwW2pdID0gc3dhcFZhbHVlO1xuICAgIGVsZW1lbnRzW2pdID0gc3dhcEVsZW1zO1xuICB9O1xuXG4gICQkLmhlYXBmbi5oZWFwaWZ5ID0gZnVuY3Rpb24gKGksIHJvb3RUb0xlYWYpIHtcbiAgICB2YXIgdHJlZUxlbiA9IDAsXG4gICAgICBjb25kSGVhcCA9IGZhbHNlLFxuICAgICAgYXJyYXksXG4gICAgICBjdXJyZW50LFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYmVzdCxcbiAgICAgIGNvbXBhcmF0b3IsXG4gICAgICBwYXJlbnQ7XG4gICAgXG4gICAgaWYgKHR5cGVvZiByb290VG9MZWFmID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByb290VG9MZWFmID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBhcnJheSA9IHRoaXMuX3ByaXZhdGUuaGVhcDtcbiAgICB0cmVlTGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIGNvbXBhcmF0b3IgPSB0aGlzLl9wcml2YXRlLmNvbXBhcmF0b3I7XG4gICAgY3VycmVudCA9IGk7XG5cbiAgICB3aGlsZSAoIWNvbmRIZWFwKSB7XG5cbiAgICAgIGlmIChyb290VG9MZWFmKSB7XG4gICAgICAgIGxlZnQgPSAyICogY3VycmVudCArIDE7XG4gICAgICAgIHJpZ2h0ID0gbGVmdCArIDE7XG4gICAgICAgIGJlc3QgPSBjdXJyZW50O1xuICAgICAgICBcbiAgICAgICAgaWYgKGxlZnQgPCB0cmVlTGVuICYmICFjb21wYXJhdG9yKGFycmF5W2xlZnRdLCBhcnJheVtiZXN0XSkpIHtcbiAgICAgICAgICBiZXN0ID0gbGVmdDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHJpZ2h0IDwgdHJlZUxlbiAmJiAhY29tcGFyYXRvcihhcnJheVtyaWdodF0sIGFycmF5W2Jlc3RdKSkge1xuICAgICAgICAgIGJlc3QgPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uZEhlYXAgPSBiZXN0ID09PSBjdXJyZW50O1xuICAgICAgICBcbiAgICAgICAgaWYgKCFjb25kSGVhcCkge1xuICAgICAgICAgIHRoaXMuaGVhcFN3YXAoYmVzdCwgY3VycmVudCk7XG4gICAgICAgICAgY3VycmVudCA9IGJlc3Q7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gTWF0aC5mbG9vcigoY3VycmVudCAtIDEpIC8gMik7XG4gICAgICAgIGJlc3QgPSBjdXJyZW50O1xuICAgICAgICBjb25kSGVhcCA9IHBhcmVudCA8IDAgfHwgY29tcGFyYXRvcihhcnJheVtiZXN0XSwgYXJyYXlbcGFyZW50XSk7XG5cbiAgICAgICAgaWYgKCFjb25kSGVhcCkge1xuICAgICAgICAgIHRoaXMuaGVhcFN3YXAoYmVzdCwgcGFyZW50KTtcbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IC8vIHdoaWxlXG4gIH07XG5cbiAgLyogY29sbGVjdGlvbk9yRWxlbWVudCAqL1xuICAkJC5oZWFwZm4uaW5zZXJ0ID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmdldEFyZ3VtZW50QXNDb2xsZWN0aW9uKGVsZXMpLFxuICAgICAgZWxzaXplID0gZWxlbWVudHMubGVuZ3RoLFxuICAgICAgZWxlbWVudCxcbiAgICAgIGVsaW5kZXgsXG4gICAgICBlbHZhbHVlLFxuICAgICAgZWxpZCxcbiAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZWxzaXplOyBpICs9IDEpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGVsaW5kZXggPSB0aGlzLl9wcml2YXRlLmhlYXAubGVuZ3RoO1xuICAgICAgZWx2YWx1ZSA9IHRoaXMuX3ByaXZhdGUuZXh0cmFjdG9yKGVsZW1lbnQpO1xuICAgICAgZWxpZCA9IGVsZW1lbnQuaWQoKTtcblxuICAgICAgaWYgKHRoaXMuX3ByaXZhdGUucG9pbnRlcnMuaGFzT3duUHJvcGVydHkoZWxpZCkpIHtcbiAgICAgICAgdGhyb3cgXCJFUlJPUjogTXVsdGlwbGUgaXRlbXMgd2l0aCB0aGUgc2FtZSBpZCBmb3VuZDogXCIgKyBlbGlkO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcml2YXRlLmhlYXAucHVzaChlbHZhbHVlKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMucHVzaChlbGlkKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxpZF0gPSBlbGluZGV4O1xuICAgICAgdGhpcy5oZWFwaWZ5KGVsaW5kZXgsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcml2YXRlLmxlbmd0aCA9IHRoaXMuX3ByaXZhdGUuaGVhcC5sZW5ndGg7XG4gIH07XG5cbiAgJCQuaGVhcGZuLmdldFZhbHVlQnlJZCA9IGZ1bmN0aW9uIChlbGVtZW50SWQpIHtcbiAgICBpZiAodGhpcy5fcHJpdmF0ZS5wb2ludGVycy5oYXNPd25Qcm9wZXJ0eShlbGVtZW50SWQpKSB7XG4gICAgICB2YXIgZWxlbWVudEluZGV4ID0gdGhpcy5fcHJpdmF0ZS5wb2ludGVyc1tlbGVtZW50SWRdO1xuXG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF07XG4gICAgfVxuICB9O1xuICBcbiAgJCQuaGVhcGZuLmNvbnRhaW5zID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmdldEFyZ3VtZW50QXNDb2xsZWN0aW9uKGVsZXMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGVsZW1lbnRJZCA9IGVsZW1lbnRzW2ldLmlkKCk7XG5cbiAgICAgIGlmKCF0aGlzLl9wcml2YXRlLnBvaW50ZXJzLmhhc093blByb3BlcnR5KGVsZW1lbnRJZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgJCQuaGVhcGZuLnRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcHJpdmF0ZS5sZW5ndGggPiAwKSB7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB0aGlzLl9wcml2YXRlLmhlYXBbMF0sXG4gICAgICAgIGlkOiB0aGlzLl9wcml2YXRlLmVsZW1lbnRzWzBdXG4gICAgICB9O1xuXG4gICAgfVxuICB9O1xuXG4gICQkLmhlYXBmbi5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGUubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHRvcCA9IHRoaXMudG9wKCksXG4gICAgICAgIGxhc3RJbmRleCA9IHRoaXMuX3ByaXZhdGUubGVuZ3RoIC0gMSxcbiAgICAgICAgcmVtb3ZlQ2FuZGlkYXRlLFxuICAgICAgICByZW1vdmVWYWx1ZSxcbiAgICAgICAgcmVtSWQ7XG5cbiAgICAgIHRoaXMuaGVhcFN3YXAoMCwgbGFzdEluZGV4KTtcblxuICAgICAgcmVtb3ZlQ2FuZGlkYXRlID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50c1tsYXN0SW5kZXhdO1xuICAgICAgcmVtb3ZlVmFsdWUgPSB0aGlzLl9wcml2YXRlLmhlYXBbbGFzdEluZGV4XTtcbiAgICAgIHJlbUlkID0gcmVtb3ZlQ2FuZGlkYXRlO1xuXG4gICAgICB0aGlzLl9wcml2YXRlLmhlYXAucG9wKCk7XG4gICAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnBvcCgpO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5sZW5ndGggPSB0aGlzLl9wcml2YXRlLmhlYXAubGVuZ3RoO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wb2ludGVyc1tyZW1JZF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuaGVhcGlmeSgwKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuICB9O1xuXG4gICQkLmhlYXBmbi5maW5kRGlyZWN0aW9uSGVhcGlmeSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBwYXJlbnQgPSBNYXRoLmZsb29yKChpbmRleCAtIDEpIC8gMiksXG4gICAgICBhcnJheSA9IHRoaXMuX3ByaXZhdGUuaGVhcCxcbiAgICAgIGNvbmRIZWFwID0gcGFyZW50IDwgMCB8fCB0aGlzLl9wcml2YXRlLmNvbXBhcmF0b3IoYXJyYXlbaW5kZXhdLCBhcnJheVtwYXJlbnRdKTtcblxuICAgIHRoaXMuaGVhcGlmeShpbmRleCwgY29uZEhlYXApO1xuICB9O1xuXG4gIC8qIGVkaXQgaXMgYSBuZXcgdmFsdWUgb3IgZnVuY3Rpb24gKi9cbiAgLy8gb25seSB2YWx1ZXMgaW4gaGVhcCBhcmUgdXBkYXRlZC4gZWxlbWVudHMgdGhlbXNlbHZlcyBhcmUgbm90IVxuICAkJC5oZWFwZm4uZWRpdCA9IGZ1bmN0aW9uIChlbGVzLCBlZGl0KSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgZWxlbWVudElkID0gZWxlbWVudHNbaV0uaWQoKSxcbiAgICAgICAgZWxlbWVudEluZGV4ID0gdGhpcy5fcHJpdmF0ZS5wb2ludGVyc1tlbGVtZW50SWRdLFxuICAgICAgICBlbGVtZW50VmFsdWUgPSB0aGlzLl9wcml2YXRlLmhlYXBbZWxlbWVudEluZGV4XTtcbiAgICAgIFxuICAgICAgaWYgKCQkLmlzLm51bWJlcihlZGl0KSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmhlYXBbZWxlbWVudEluZGV4XSA9IGVkaXQ7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmICgkJC5pcy5mbihlZGl0KSkge1xuICAgICAgICB0aGlzLl9wcml2YXRlLmhlYXBbZWxlbWVudEluZGV4XSA9IGVkaXQuY2FsbCh0aGlzLl9wcml2YXRlLmN5LCBlbGVtZW50VmFsdWUsIGVsZW1lbnRJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmluZERpcmVjdGlvbkhlYXBpZnkoZWxlbWVudEluZGV4KTtcbiAgICB9XG4gIH07XG5cbiAgJCQuaGVhcGZuLmRlbGV0ZSA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgZWxlbWVudElkID0gZWxlbWVudHNbaV0uaWQoKSxcbiAgICAgICAgZWxlbWVudEluZGV4ID0gdGhpcy5fcHJpdmF0ZS5wb2ludGVyc1tlbGVtZW50SWRdLFxuICAgICAgICBsYXN0SW5kZXggPSB0aGlzLl9wcml2YXRlLmxlbmd0aCAtIDEsXG4gICAgICAgIHJlbW92ZUNhbmRpZGF0ZSxcbiAgICAgICAgcmVtb3ZlVmFsdWUsXG4gICAgICAgIHJlbUlkO1xuXG4gICAgICBpZiAoZWxlbWVudEluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgdGhpcy5oZWFwU3dhcChlbGVtZW50SW5kZXgsIGxhc3RJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZUNhbmRpZGF0ZSA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHNbbGFzdEluZGV4XTtcbiAgICAgIHJlbW92ZVZhbHVlID0gdGhpcy5fcHJpdmF0ZS5oZWFwW2xhc3RJbmRleF07XG4gICAgICByZW1JZCA9IHJlbW92ZUNhbmRpZGF0ZTtcblxuICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwLnBvcCgpO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5wb3AoKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUubGVuZ3RoID0gdGhpcy5fcHJpdmF0ZS5oZWFwLmxlbmd0aDtcbiAgICAgIHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbcmVtSWRdID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLmZpbmREaXJlY3Rpb25IZWFwaWZ5KGVsZW1lbnRJbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbW92ZVZhbHVlO1xuICB9O1xuXG59KShjeXRvc2NhcGUpO1xuLypcbiAgVGhlIGNhbnZhcyByZW5kZXJlciB3YXMgd3JpdHRlbiBieSBZdWUgRG9uZy5cblxuICBNb2RpZmljYXRpb25zIHRyYWNrZWQgb24gR2l0aHViLlxuKi9cblxuKGZ1bmN0aW9uKCQkKSB7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBDYW52YXNSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgXG4gICAgQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyA9IDU7XG4gICAgQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWCA9IDA7XG4gICAgQ2FudmFzUmVuZGVyZXIuRFJBRyA9IDI7XG4gICAgQ2FudmFzUmVuZGVyZXIuTk9ERSA9IDQ7XG4gICAgQ2FudmFzUmVuZGVyZXIuVEVYVFVSRV9CVUZGRVIgPSAwO1xuICAgIENhbnZhc1JlbmRlcmVyLkJVRkZFUl9DT1VOVCA9IDI7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgICBcbiAgICAgIHNlbGVjdDogW3VuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgMF0sIC8vIENvb3JkaW5hdGVzIGZvciBzZWxlY3Rpb24gYm94LCBwbHVzIGVuYWJsZWQgZmxhZyBcbiAgICAgIHJlbmRlcmVyOiB0aGlzLCBjeTogb3B0aW9ucy5jeSwgY29udGFpbmVyOiBvcHRpb25zLmN5LmNvbnRhaW5lcigpLFxuICAgICAgXG4gICAgICBjYW52YXNlczogbmV3IEFycmF5KENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlMpLFxuICAgICAgY29udGV4dHM6IG5ldyBBcnJheShDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTKSxcbiAgICAgIGNhbnZhc05lZWRzUmVkcmF3OiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyksXG4gICAgICBcbiAgICAgIGJ1ZmZlckNhbnZhc2VzOiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQlVGRkVSX0NPVU5UKSxcbiAgICAgIGJ1ZmZlckNvbnRleHRzOiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUylcblxuICAgIH07XG4gICAgXG4gICAgLy8tLVBvaW50ZXItcmVsYXRlZCBkYXRhXG4gICAgdGhpcy5ob3ZlckRhdGEgPSB7ZG93bjogbnVsbCwgbGFzdDogbnVsbCwgXG4gICAgICAgIGRvd25UaW1lOiBudWxsLCB0cmlnZ2VyTW9kZTogbnVsbCwgXG4gICAgICAgIGRyYWdnaW5nOiBmYWxzZSwgXG4gICAgICAgIGluaXRpYWxQYW46IFtudWxsLCBudWxsXSwgY2FwdHVyZTogZmFsc2V9O1xuICAgIFxuICAgIHRoaXMudGltZW91dERhdGEgPSB7cGFuVGltZW91dDogbnVsbH07XG4gICAgXG4gICAgdGhpcy5kcmFnRGF0YSA9IHtwb3NzaWJsZURyYWdFbGVtZW50czogW119O1xuICAgIFxuICAgIHRoaXMudG91Y2hEYXRhID0ge3N0YXJ0OiBudWxsLCBjYXB0dXJlOiBmYWxzZSxcbiAgICAgICAgLy8gVGhlc2UgMyBmaWVsZHMgcmVsYXRlZCB0byB0YXAsIHRhcGhvbGQgZXZlbnRzXG4gICAgICAgIHN0YXJ0UG9zaXRpb246IFtudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsXSxcbiAgICAgICAgc2luZ2xlVG91Y2hTdGFydFRpbWU6IG51bGwsXG4gICAgICAgIHNpbmdsZVRvdWNoTW92ZWQ6IHRydWUsXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgbm93OiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sIFxuICAgICAgICBlYXJsaWVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0gfTtcbiAgICAvLy0tXG4gICAgXG4gICAgLy8tLVdoZWVsLXJlbGF0ZWQgZGF0YSBcbiAgICB0aGlzLnpvb21EYXRhID0ge2ZyZWVUb1pvb206IGZhbHNlLCBsYXN0UG9pbnRlclg6IG51bGx9O1xuICAgIC8vLS1cbiAgICBcbiAgICB0aGlzLnJlZHJhd3MgPSAwO1xuICAgIHRoaXMuc2hvd0ZwcyA9IG9wdGlvbnMuc2hvd0ZwcztcblxuICAgIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgICBcbiAgICB0aGlzLmRhdGEuY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGNvbnRhaW5lclN0eWxlID0gdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lci5zdHlsZTtcbiAgICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgY29udGFpbmVyU3R5bGUuekluZGV4ID0gJzAnO1xuICAgIGNvbnRhaW5lclN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICB0aGlzLmRhdGEuY29udGFpbmVyLmFwcGVuZENoaWxkKCB0aGlzLmRhdGEuY2FudmFzQ29udGFpbmVyICk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlM7IGkrKykge1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0aGlzLmRhdGEuY29udGV4dHNbaV0gPSB0aGlzLmRhdGEuY2FudmFzZXNbaV0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNlc1tpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0aGlzLmRhdGEuY2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIGkpO1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZyhDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTIC0gaSk7XG4gICAgICB0aGlzLmRhdGEuY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZGF0YS5jYW52YXNlc1tpXSk7XG4gICAgICBcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tpXSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmRhdGEudG9wQ2FudmFzID0gdGhpcy5kYXRhLmNhbnZhc2VzWzBdO1xuXG4gICAgdGhpcy5kYXRhLmNhbnZhc2VzW0NhbnZhc1JlbmRlcmVyLk5PREVdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDYW52YXNSZW5kZXJlci5OT0RFICsgJy1ub2RlJyk7XG4gICAgdGhpcy5kYXRhLmNhbnZhc2VzW0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YICsgJy1zZWxlY3Rib3gnKTtcbiAgICB0aGlzLmRhdGEuY2FudmFzZXNbQ2FudmFzUmVuZGVyZXIuRFJBR10uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2xheWVyJyArIENhbnZhc1JlbmRlcmVyLkRSQUcgKyAnLWRyYWcnKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDb250ZXh0c1tpXSA9IHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnYnVmZmVyJyArIGkpO1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnpJbmRleCA9IFN0cmluZygtaSAtIDEpO1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIC8vdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuaGlkZUVkZ2VzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydDtcbiAgICB0aGlzLmhpZGVMYWJlbHNPblZpZXdwb3J0ID0gb3B0aW9ucy5oaWRlTGFiZWxzT25WaWV3cG9ydDtcbiAgICB0aGlzLnRleHR1cmVPblZpZXdwb3J0ID0gb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICB0aGlzLndoZWVsU2Vuc2l0aXZpdHkgPSBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHk7XG4gICAgdGhpcy5tb3Rpb25CbHVyRW5hYmxlZCA9IG9wdGlvbnMubW90aW9uQmx1ciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMubW90aW9uQmx1cjsgLy8gb24gYnkgZGVmYXVsdFxuICAgIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyA9IG9wdGlvbnMucGl4ZWxSYXRpbztcbiAgICB0aGlzLm1vdGlvbkJsdXIgPSB0cnVlOyAvLyBmb3IgaW5pdGlhbCBraWNrIG9mZlxuICAgIHRoaXMudGFwVGhyZXNob2xkID0gb3B0aW9ucy50YXBUaHJlc2hvbGQ7XG4gICAgdGhpcy50YXBUaHJlc2hvbGQyID0gb3B0aW9ucy50YXBUaHJlc2hvbGQgKiBvcHRpb25zLnRhcFRocmVzaG9sZDtcbiAgICB0aGlzLnRhcGhvbGREdXJhdGlvbiA9IDUwMDtcblxuICAgIHRoaXMubG9hZCgpO1xuICB9XG5cbiAgQ2FudmFzUmVuZGVyZXIucGFuT3JCb3hTZWxlY3REZWxheSA9IDQwMDtcbiAgQ2FudmFzUmVuZGVyZXIuaXNUb3VjaCA9ICQkLmlzLnRvdWNoKCk7XG5cbiAgLy8gd2hldGhlciB0byB1c2UgUGF0aDJEIGNhY2hpbmcgZm9yIGRyYXdpbmdcbiAgdmFyIHBhdGhzSW1wbGQgPSB0eXBlb2YgUGF0aDJEICE9PSAndW5kZWZpbmVkJztcbiAgQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBwYXRoc0ltcGxkO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICB2YXIgdHlwZXM7XG5cbiAgICBpZiggJCQuaXMuYXJyYXkoIHBhcmFtcy50eXBlICkgKXtcbiAgICAgIHR5cGVzID0gcGFyYW1zLnR5cGU7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZXMgPSBbIHBhcmFtcy50eXBlIF07XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHR5cGUgPSB0eXBlc1tpXTtcblxuICAgICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlICdhZGQnOlxuICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICBjYXNlICdsb2FkJzpcbiAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVzQ2FjaGUoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUVkZ2VzQ2FjaGUoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2aWV3cG9ydCc6XG4gICAgICAgICAgdGhpcy5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdHlsZSc6XG4gICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiggdHlwZSA9PT0gJ2xvYWQnIHx8IHR5cGUgPT09ICdyZXNpemUnICl7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICAgIHRoaXMubWF0Y2hDYW52YXNTaXplKHRoaXMuZGF0YS5jb250YWluZXIpO1xuICAgICAgfVxuICAgIH0gLy8gZm9yXG4gICAgXG4gICAgdGhpcy5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuXG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJpbmRpbmdzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbaV07XG4gICAgICB2YXIgYiA9IGJpbmRpbmc7XG5cbiAgICAgIGIudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoYi5ldmVudCwgYi5oYW5kbGVyLCBiLnVzZUNhcHR1cmUpO1xuICAgIH1cblxuICAgIGlmKCB0aGlzLnJlbW92ZU9ic2VydmVyICl7XG4gICAgICB0aGlzLnJlbW92ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICBpZiggdGhpcy5sYWJlbENhbGNEaXYgKXtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5sYWJlbENhbGNEaXYpO1xuICAgIH1cbiAgfTtcblxuICBcblxuICAvLyBjb3B5IHRoZSBtYXRoIGZ1bmN0aW9ucyBpbnRvIHRoZSByZW5kZXJlciBwcm90b3R5cGVcbiAgLy8gdW5mb3J0dW5hdGVseSB0aGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgaW50ZXJzcGVyc2VkIHQvbyB0aGUgY29kZVxuICAvLyBhbmQgdGhpcyBtYWtlcyBzdXJlIHRoaW5ncyB3b3JrIGp1c3QgaW4gY2FzZSBhIHJlZiB3YXMgbWlzc2VkIGluIHJlZmFjdG9yaW5nXG4gIC8vIFRPRE8gcmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxuICBmb3IoIHZhciBmbk5hbWUgaW4gJCQubWF0aCApe1xuICAgIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZVsgZm5OYW1lIF0gPSAkJC5tYXRoWyBmbk5hbWUgXTtcbiAgfVxuICBcbiAgXG4gICQkKCdyZW5kZXJlcicsICdjYW52YXMnLCBDYW52YXNSZW5kZXJlcik7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIHJlbmRGdW5jID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuICB2YXIgYXJyb3dTaGFwZXMgPSBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlcyA9IHt9O1xuXG4gIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVIZWlnaHQgPSAwLjM7XG5cbiAgLy8gQ29udHJhY3QgZm9yIGFycm93IHNoYXBlczpcbiAgLy8gMCwgMCBpcyBhcnJvdyB0aXBcbiAgLy8gKDAsIDEpIGlzIGRpcmVjdGlvbiB0b3dhcmRzIG5vZGVcbiAgLy8gKDEsIDApIGlzIHJpZ2h0XG4gIC8vXG4gIC8vIGZ1bmN0aW9uYWwgYXBpOlxuICAvLyBjb2xsaWRlOiBjaGVjayB4LCB5IGluIHNoYXBlXG4gIC8vIHJvdWdoQ29sbGlkZTogY2FsbGVkIGJlZm9yZSBjb2xsaWRlLCBubyBmYWxzZSBuZWdhdGl2ZXNcbiAgLy8gZHJhdzogZHJhd1xuICAvLyBzcGFjaW5nOiBkaXN0KGFycm93VGlwLCBub2RlQm91bmRhcnkpXG4gIC8vIGdhcDogZGlzdChlZGdlVGlwLCBub2RlQm91bmRhcnkpLCBlZGdlVGlwIG1heSAhPSBhcnJvd1RpcFxuXG4gIHZhciBiYkNvbGxpZGUgPSBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpe1xuICAgIHZhciB4MSA9IGNlbnRlclggLSB3aWR0aC8yO1xuICAgIHZhciB4MiA9IGNlbnRlclggKyB3aWR0aC8yO1xuICAgIHZhciB5MSA9IGNlbnRlclkgLSBoZWlnaHQvMjtcbiAgICB2YXIgeTIgPSBjZW50ZXJZICsgaGVpZ2h0LzI7XG5cbiAgICByZXR1cm4gKHgxIDw9IHggJiYgeCA8PSB4MikgJiYgKHkxIDw9IHkgJiYgeSA8PSB5Mik7XG4gIH07XG5cbiAgdmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uKHgsIHksIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbil7XG4gICAgYW5nbGUgPSAtYW5nbGU7IC8vIGIvYyBvZiBub3RhdGlvbiB1c2VkIGluIGFycm93IGRyYXcgZm5cblxuICAgIHZhciB4Um90YXRlZCA9IHggKiBNYXRoLmNvcyhhbmdsZSkgLSB5ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciB5Um90YXRlZCA9IHggKiBNYXRoLnNpbihhbmdsZSkgKyB5ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIFxuICAgIHZhciB4U2NhbGVkID0geFJvdGF0ZWQgKiBzaXplO1xuICAgIHZhciB5U2NhbGVkID0geVJvdGF0ZWQgKiBzaXplO1xuXG4gICAgdmFyIHhUcmFuc2xhdGVkID0geFNjYWxlZCArIHRyYW5zbGF0aW9uLng7XG4gICAgdmFyIHlUcmFuc2xhdGVkID0geVNjYWxlZCArIHRyYW5zbGF0aW9uLnk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHhUcmFuc2xhdGVkLFxuICAgICAgeTogeVRyYW5zbGF0ZWRcbiAgICB9O1xuICB9O1xuXG4gIGFycm93U2hhcGVzWydhcnJvdyddID0ge1xuICAgIF9wb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4zLFxuICAgICAgMCwgMCxcbiAgICAgIDAuMTUsIC0wLjNcbiAgICBdLFxuICAgIFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydhcnJvdyddLl9wb2ludHM7XG4gICAgICBcbi8vICAgICAgY29uc29sZS5sb2coXCJjb2xsaWRlKCk6IFwiICsgZGlyZWN0aW9uKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snYXJyb3cnXS5fcG9pbnRzO1xuICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSAqIDI7XG4gICAgfVxuICB9O1xuXG4gIGFycm93U2hhcGVzWyd0cmlhbmdsZSddID0gYXJyb3dTaGFwZXNbJ2Fycm93J107XG4gIFxuICBhcnJvd1NoYXBlc1sndHJpYW5nbGUtYmFja2N1cnZlJ10gPSB7XG4gICAgX2N0cmxQdDogWyAwLCAtMC4xNSBdLFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlJ10uX3BvaW50cztcbiAgICAgIFxuLy8gICAgICBjb25zb2xlLmxvZyhcImNvbGxpZGUoKTogXCIgKyBkaXJlY3Rpb24pO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZSddLl9wb2ludHM7XG4gICAgICB2YXIgZmlyc3RQdDtcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBpZiggaSA9PT0gMCApe1xuICAgICAgICAgIGZpcnN0UHQgPSBwdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3RybFB0ID0gdGhpcy5fY3RybFB0O1xuICAgICAgdmFyIGN0cmxQdFRyYW5zID0gdHJhbnNmb3JtKCBjdHJsUHRbMF0sIGN0cmxQdFsxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyggY3RybFB0VHJhbnMueCwgY3RybFB0VHJhbnMueSwgZmlyc3RQdC54LCBmaXJzdFB0LnkgKTtcbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG4gIFxuXG4gIGFycm93U2hhcGVzWyd0cmlhbmdsZS10ZWUnXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zLFxuICAgICAgLTAuMTUsIC0wLjNcbiAgICBdLFxuXG4gICAgX3BvaW50c1RlZTogW1xuICAgICAgLTAuMTUsIC0wLjQsXG4gICAgICAtMC4xNSwgLTAuNSxcbiAgICAgIDAuMTUsIC0wLjUsXG4gICAgICAwLjE1LCAtMC40XG4gICAgXSxcbiAgICBcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciB0cmlQdHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUtdGVlJ10uX3BvaW50cztcbiAgICAgIHZhciB0ZWVQdHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUtdGVlJ10uX3BvaW50c1RlZTtcbiAgICAgIFxuICAgICAgdmFyIGluc2lkZSA9ICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRlZVB0cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSBcbiAgICAgICAgfHwgJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgdHJpUHRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuXG4gICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgdHJpUHRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLXRlZSddLl9wb2ludHM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaVB0cy5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHRyaVB0c1sgaSAqIDIgXSwgIHRyaVB0c1sgaSAqIDIgKyAxIF0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuICAgICAgICBcbiAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlZVB0cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZS10ZWUnXS5fcG9pbnRzVGVlO1xuICAgICAgdmFyIGZpcnN0VGVlUHQgPSB0cmFuc2Zvcm0oIHRlZVB0c1swXSwgdGVlUHRzWzFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKCBmaXJzdFRlZVB0LngsIGZpcnN0VGVlUHQueSApO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlZVB0cy5sZW5ndGggLyAyOyBpKyspe1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHRlZVB0c1sgaSAqIDIgXSwgIHRlZVB0c1sgaSAqIDIgKyAxIF0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuICAgICAgICBcbiAgICAgICAgY29udGV4dC5saW5lVG8oIHB0LngsIHB0LnkgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG5cbiAgYXJyb3dTaGFwZXNbJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAwLCAtMC4yNSxcbiAgICAgIC0wLjUsIC0wLjI1LFxuICAgICAgMC41LCAwLjI1XG4gICAgXSxcbiAgICBcbiAgICBsZWF2ZVBhdGhPcGVuOiB0cnVlLFxuICAgIG1hdGNoRWRnZVdpZHRoOiB0cnVlLFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzO1xuICAgICAgXG4vLyAgICAgIGNvbnNvbGUubG9nKFwiY29sbGlkZSgpOiBcIiArIGRpcmVjdGlvbik7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gdGhpcy5fcG9pbnRzO1xuICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcblxuICBhcnJvd1NoYXBlc1snbm9uZSddID0ge1xuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIFxuICBhcnJvd1NoYXBlc1snY2lyY2xlJ10gPSB7XG4gICAgX2Jhc2VSYWRpdXM6IDAuMTUsXG4gICAgXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICAvLyBUcmFuc2Zvcm0geCwgeSB0byBnZXQgbm9uLXJvdGF0ZWQgZWxsaXBzZVxuICAgICAgXG4gICAgICBpZiAod2lkdGggIT0gaGVpZ2h0KSB7ICAgICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IChoZWlnaHQgKyBwYWRkaW5nKSAvICh3aWR0aCArIHBhZGRpbmcpO1xuICAgICAgICB5IC89IGFzcGVjdFJhdGlvO1xuICAgICAgICBjZW50ZXJZIC89IGFzcGVjdFJhdGlvO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhjZW50ZXJYIC0geCwgMikgXG4gICAgICAgICAgKyBNYXRoLnBvdyhjZW50ZXJZIC0geSwgMikgPD0gTWF0aC5wb3coKHdpZHRoICsgcGFkZGluZylcbiAgICAgICAgICAgICogYXJyb3dTaGFwZXNbJ2NpcmNsZSddLl9iYXNlUmFkaXVzLCAyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKE1hdGgucG93KGNlbnRlclggLSB4LCAyKSBcbiAgICAgICAgICArIE1hdGgucG93KGNlbnRlclkgLSB5LCAyKSA8PSBNYXRoLnBvdygod2lkdGggKyBwYWRkaW5nKVxuICAgICAgICAgICAgKiBhcnJvd1NoYXBlc1snY2lyY2xlJ10uX2Jhc2VSYWRpdXMsIDIpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgY29udGV4dC5hcmModHJhbnNsYXRpb24ueCwgdHJhbnNsYXRpb24ueSwgYXJyb3dTaGFwZXNbJ2NpcmNsZSddLl9iYXNlUmFkaXVzICogc2l6ZSwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiByZW5kRnVuYy5nZXRBcnJvd1dpZHRoKGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSlcbiAgICAgICAgKiBhcnJvd1NoYXBlc1snY2lyY2xlJ10uX2Jhc2VSYWRpdXM7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcbiAgXG4gIGFycm93U2hhcGVzWydpbmhpYml0b3InXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAtMC4yNSwgMCxcbiAgICAgIC0wLjI1LCAtMC4xLFxuICAgICAgMC4yNSwgLTAuMSxcbiAgICAgIDAuMjUsIDBcbiAgICBdLFxuICAgIFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydpbmhpYml0b3InXS5fcG9pbnRzO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydpbmhpYml0b3InXS5fcG9pbnRzO1xuICAgICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCBwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9O1xuXG4gIGFycm93U2hhcGVzWyd0ZWUnXSA9IGFycm93U2hhcGVzWydpbmhpYml0b3InXTtcblxuICBhcnJvd1NoYXBlc1snc3F1YXJlJ10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgLTAuMTUsIDAuMDAsXG4gICAgICAwLjE1LCAwLjAwLFxuICAgICAgMC4xNSwgLTAuMyxcbiAgICAgIC0wLjE1LCAtMC4zXG4gICAgXSxcbiAgICBcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snc3F1YXJlJ10uX3BvaW50cztcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snc3F1YXJlJ10uX3BvaW50cztcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcblxuICBhcnJvd1NoYXBlc1snZGlhbW9uZCddID0ge1xuICAgIF9wb2ludHM6IFtcbiAgICAgIC0wLjE1LCAtMC4xNSxcbiAgICAgIDAsIC0wLjMsXG4gICAgICAwLjE1LCAtMC4xNSxcbiAgICAgIDAsIDBcbiAgICBdLFxuXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ2RpYW1vbmQnXS5fcG9pbnRzO1xuICAgICAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcblxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ2RpYW1vbmQnXS5fcG9pbnRzO1xuICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWU7XG4gICAgfVxuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q2FjaGVkTm9kZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTsgdmFyIGN5ID0gdGhpcy5kYXRhLmN5O1xuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRhdGEuY2FjaGUuY2FjaGVkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgZGF0YS5jYWNoZS5jYWNoZWROb2RlcyA9IGN5Lm5vZGVzKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYXRhLmNhY2hlLmNhY2hlZE5vZGVzO1xuICB9O1xuICBcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZU5vZGVzQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTsgdmFyIGN5ID0gdGhpcy5kYXRhLmN5O1xuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgZGF0YS5jYWNoZS5jYWNoZWROb2RlcyA9IGN5Lm5vZGVzKCk7XG4gIH07XG4gIFxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q2FjaGVkRWRnZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTsgdmFyIGN5ID0gdGhpcy5kYXRhLmN5O1xuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGRhdGEuY2FjaGUuY2FjaGVkRWRnZXMgPT0gbnVsbCkge1xuICAgICAgZGF0YS5jYWNoZS5jYWNoZWRFZGdlcyA9IGN5LmVkZ2VzKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkYXRhLmNhY2hlLmNhY2hlZEVkZ2VzO1xuICB9O1xuICBcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUVkZ2VzQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTsgdmFyIGN5ID0gdGhpcy5kYXRhLmN5O1xuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgZGF0YS5jYWNoZS5jYWNoZWRFZGdlcyA9IGN5LmVkZ2VzKCk7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG5cbiAgLy8gUHJvamVjdCBtb3VzZVxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucHJvamVjdEludG9WaWV3cG9ydCA9IGZ1bmN0aW9uKGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICB2YXIgb2Zmc2V0cyA9IHRoaXMuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICB2YXIgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcbiAgICBcbiAgICB2YXIgeCA9IGNsaWVudFggLSBvZmZzZXRMZWZ0OyBcbiAgICB2YXIgeSA9IGNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgXG4gICAgeCAtPSB0aGlzLmRhdGEuY3kucGFuKCkueDsgeSAtPSB0aGlzLmRhdGEuY3kucGFuKCkueTsgeCAvPSB0aGlzLmRhdGEuY3kuem9vbSgpOyB5IC89IHRoaXMuZGF0YS5jeS56b29tKCk7XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZmluZENvbnRhaW5lckNsaWVudENvb3JkcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmRhdGEuY29udGFpbmVyO1xuXG4gICAgdmFyIGJiID0gdGhpcy5jb250YWluZXJCQiA9IHRoaXMuY29udGFpbmVyQkIgfHwgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgcmV0dXJuIFtiYi5sZWZ0LCBiYi50b3AsIGJiLnJpZ2h0IC0gYmIubGVmdCwgYmIuYm90dG9tIC0gYmIudG9wXTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmNvbnRhaW5lckJCID0gbnVsbDtcbiAgfTtcblxuICAvLyBGaW5kIG5lYXJlc3QgZWxlbWVudFxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZmluZE5lYXJlc3RFbGVtZW50ID0gZnVuY3Rpb24oeCwgeSwgdmlzaWJsZUVsZW1lbnRzT25seSl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbGVzID0gdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgIHZhciBuZWFyID0gW107XG4gICAgdmFyIGlzVG91Y2ggPSBDYW52YXNSZW5kZXJlci5pc1RvdWNoO1xuICAgIHZhciB6b29tID0gdGhpcy5kYXRhLmN5Lnpvb20oKTtcbiAgICB2YXIgaGFzQ29tcG91bmRzID0gdGhpcy5kYXRhLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWRnZVRocmVzaG9sZCA9IChpc1RvdWNoID8gMjU2IDogMzIpIC8gem9vbTtcbiAgICB2YXIgbm9kZVRocmVzaG9sZCA9IChpc1RvdWNoID8gMTYgOiAwKSAvICB6b29tO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tOb2RlKG5vZGUpe1xuICAgICAgdmFyIHdpZHRoID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpO1xuICAgICAgdmFyIGh3ID0gd2lkdGgvMjtcbiAgICAgIHZhciBoaCA9IGhlaWdodC8yO1xuICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgIGlmKFxuICAgICAgICBwb3MueCAtIGh3IDw9IHggJiYgeCA8PSBwb3MueCArIGh3IC8vIGJiIGNoZWNrIHhcbiAgICAgICAgICAmJlxuICAgICAgICBwb3MueSAtIGhoIDw9IHkgJiYgeSA8PSBwb3MueSArIGhoIC8vIGJiIGNoZWNrIHlcbiAgICAgICl7XG4gICAgICAgIHZhciB2aXNpYmxlID0gIXZpc2libGVFbGVtZW50c09ubHkgfHwgKCBub2RlLnZpc2libGUoKSAmJiAhbm9kZS50cmFuc3BhcmVudCgpICk7XG5cbiAgICAgICAgLy8gZXhpdCBlYXJseSBpZiBpbnZpc2libGUgZWRnZSBhbmQgbXVzdCBiZSB2aXNpYmxlXG4gICAgICAgIGlmKCB2aXNpYmxlRWxlbWVudHNPbmx5ICYmICF2aXNpYmxlICl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYXBlID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1sgc2VsZi5nZXROb2RlU2hhcGUobm9kZSkgXTtcbiAgICAgICAgdmFyIGJvcmRlcldPID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZSAvIDI7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgc2hhcGUuY2hlY2tQb2ludCh4LCB5LCBib3JkZXJXTywgd2lkdGggKyBub2RlVGhyZXNob2xkLCBoZWlnaHQgKyBub2RlVGhyZXNob2xkLCBwb3MueCwgcG9zLnkpXG4gICAgICAgICl7XG4gICAgICAgICAgICBuZWFyLnB1c2goIG5vZGUgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tFZGdlKGVkZ2Upe1xuICAgICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgd2lkdGggPSBzdHlsZVsnd2lkdGgnXS5weFZhbHVlO1xuICAgICAgdmFyIHdpZHRoU3EgPSB3aWR0aCAqIHdpZHRoO1xuICAgICAgdmFyIHdpZHRoMiA9IHdpZHRoICogMjtcbiAgICAgIHZhciBzcmMgPSBlZGdlLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgIHZhciB0Z3QgPSBlZGdlLl9wcml2YXRlLnRhcmdldDtcbiAgICAgIHZhciBpbkVkZ2VCQiA9IGZhbHNlO1xuXG4gICAgICAvLyBleGl0IGVhcmx5IGlmIGludmlzaWJsZSBlZGdlIGFuZCBtdXN0IGJlIHZpc2libGVcbiAgICAgIHZhciBwYXNzZWRWaXNpYmlsaXR5Q2hlY2s7XG4gICAgICB2YXIgcGFzc2VzVmlzaWJpbGl0eUNoZWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHBhc3NlZFZpc2liaWxpdHlDaGVjayAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgcmV0dXJuIHBhc3NlZFZpc2liaWxpdHlDaGVjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhdmlzaWJsZUVsZW1lbnRzT25seSApe1xuICAgICAgICAgIHBhc3NlZFZpc2liaWxpdHlDaGVjayA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlzaWJsZSA9IGVkZ2UudmlzaWJsZSgpICYmICFlZGdlLnRyYW5zcGFyZW50KCk7XG4gICAgICAgIGlmKCB2aXNpYmxlICl7XG4gICAgICAgICAgcGFzc2VkVmlzaWJpbGl0eUNoZWNrID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhc3NlZFZpc2liaWxpdHlDaGVjayA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICBpZiAocnMuZWRnZVR5cGUgPT09ICdzZWxmJykge1xuICAgICAgICBpZihcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgKGluRWRnZUJCID0gJCQubWF0aC5pbkJlemllclZpY2luaXR5KHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJheCwgcnMuY3AyYXksIHJzLnNlbGZFZGdlTWlkWCwgcnMuc2VsZkVkZ2VNaWRZLCB3aWR0aFNxKSlcbiAgICAgICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgICAgICAoIHdpZHRoU3EgKyBlZGdlVGhyZXNob2xkID4gJCQubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMmF4LCBycy5jcDJheSwgcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFkpIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgKGluRWRnZUJCID0gJCQubWF0aC5pbkJlemllclZpY2luaXR5KHgsIHksIHJzLnNlbGZFZGdlTWlkWCwgcnMuc2VsZkVkZ2VNaWRZLCBycy5jcDJjeCwgcnMuY3AyY3ksIHJzLmVuZFgsIHJzLmVuZFksIHdpZHRoU3EpKVxuICAgICAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgICAgICggd2lkdGhTcSArIGVkZ2VUaHJlc2hvbGQgPiAkJC5tYXRoLnNxRGlzdGFuY2VUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWSwgcnMuY3AyY3gsIHJzLmNwMmN5LCBycy5lbmRYLCBycy5lbmRZKSApXG4gICAgICAgICAgICApXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJykge1xuICAgICAgICB2YXIgcmFkaXVzID0gc3R5bGVbJ2hheXN0YWNrLXJhZGl1cyddLnZhbHVlO1xuICAgICAgICB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cy8yOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgICAgIHZhciB0Z3RQb3MgPSB0Z3QuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciB0Z3RXID0gdGd0LndpZHRoKCk7XG4gICAgICAgIHZhciB0Z3RIID0gdGd0LmhlaWdodCgpO1xuICAgICAgICB2YXIgc3JjUG9zID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgc3JjVyA9IHNyYy53aWR0aCgpO1xuICAgICAgICB2YXIgc3JjSCA9IHNyYy5oZWlnaHQoKTtcblxuICAgICAgICB2YXIgc3RhcnRYID0gc3JjUG9zLnggKyBycy5zb3VyY2UueCAqIHNyY1cgKiBoYWxmUmFkaXVzO1xuICAgICAgICB2YXIgc3RhcnRZID0gc3JjUG9zLnkgKyBycy5zb3VyY2UueSAqIHNyY0ggKiBoYWxmUmFkaXVzO1xuICAgICAgICB2YXIgZW5kWCA9IHRndFBvcy54ICsgcnMudGFyZ2V0LnggKiB0Z3RXICogaGFsZlJhZGl1cztcbiAgICAgICAgdmFyIGVuZFkgPSB0Z3RQb3MueSArIHJzLnRhcmdldC55ICogdGd0SCAqIGhhbGZSYWRpdXM7XG5cbiAgICAgICAgaWYoIFxuICAgICAgICAgIChpbkVkZ2VCQiA9ICQkLm1hdGguaW5MaW5lVmljaW5pdHkoeCwgeSwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIHdpZHRoMikpXG4gICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgIHdpZHRoU3EgKyBlZGdlVGhyZXNob2xkID4gJCQubWF0aC5zcURpc3RhbmNlVG9GaW5pdGVMaW5lKCB4LCB5LCBzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSApXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgICBpZihcbiAgICAgICAgICAoaW5FZGdlQkIgPSAkJC5tYXRoLmluTGluZVZpY2luaXR5KHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5lbmRYLCBycy5lbmRZLCB3aWR0aDIpKVxuICAgICAgICAgICAgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiZcbiAgICAgICAgICB3aWR0aFNxICsgZWRnZVRocmVzaG9sZCA+ICQkLm1hdGguc3FEaXN0YW5jZVRvRmluaXRlTGluZSh4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWSlcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgXG4gICAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJykge1xuICAgICAgICBpZihcbiAgICAgICAgICAoaW5FZGdlQkIgPSAkJC5tYXRoLmluQmV6aWVyVmljaW5pdHkoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMngsIHJzLmNwMnksIHJzLmVuZFgsIHJzLmVuZFksIHdpZHRoU3EpKVxuICAgICAgICAgICAgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiZcbiAgICAgICAgICAod2lkdGhTcSArIGVkZ2VUaHJlc2hvbGQgPiAkJC5tYXRoLnNxRGlzdGFuY2VUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuY3AyeCwgcnMuY3AyeSwgcnMuZW5kWCwgcnMuZW5kWSkpXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIGluRWRnZUJCICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmIG5lYXIubGVuZ3RoID09PSAwIHx8IG5lYXJbbmVhci5sZW5ndGggLSAxXSAhPT0gZWRnZSApe1xuICAgICAgICB2YXIgc3JjU2hhcGUgPSBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1sgc3R5bGVbJ3NvdXJjZS1hcnJvdy1zaGFwZSddLnZhbHVlIF07XG4gICAgICAgIHZhciB0Z3RTaGFwZSA9IENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzWyBzdHlsZVsndGFyZ2V0LWFycm93LXNoYXBlJ10udmFsdWUgXTtcblxuICAgICAgICB2YXIgc3JjID0gc3JjIHx8IGVkZ2UuX3ByaXZhdGUuc291cmNlO1xuICAgICAgICB2YXIgdGd0ID0gdGd0IHx8IGVkZ2UuX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAgIHZhciB0Z3RQb3MgPSB0Z3QuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciBzcmNQb3MgPSBzcmMuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgdmFyIHNyY0FyVyA9IHNlbGYuZ2V0QXJyb3dXaWR0aCggc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSApO1xuICAgICAgICB2YXIgc3JjQXJIID0gc2VsZi5nZXRBcnJvd0hlaWdodCggc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSApO1xuXG4gICAgICAgIHZhciB0Z3RBclcgPSBzcmNBclc7XG4gICAgICAgIHZhciB0Z3RBckggPSBzcmNBckg7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgKFxuICAgICAgICAgICAgc3JjU2hhcGUucm91Z2hDb2xsaWRlKHgsIHksIHJzLmFycm93U3RhcnRYLCBycy5hcnJvd1N0YXJ0WSwgc3JjQXJXLCBzcmNBckgsIFtycy5hcnJvd1N0YXJ0WCAtIHNyY1Bvcy54LCBycy5hcnJvd1N0YXJ0WSAtIHNyY1Bvcy55XSwgMClcbiAgICAgICAgICAgICAgJiYgXG4gICAgICAgICAgICBzcmNTaGFwZS5jb2xsaWRlKHgsIHksIHJzLmFycm93U3RhcnRYLCBycy5hcnJvd1N0YXJ0WSwgc3JjQXJXLCBzcmNBckgsIFtycy5hcnJvd1N0YXJ0WCAtIHNyY1Bvcy54LCBycy5hcnJvd1N0YXJ0WSAtIHNyY1Bvcy55XSwgMClcbiAgICAgICAgICApXG4gICAgICAgICAgICB8fFxuICAgICAgICAgIChcbiAgICAgICAgICAgIHRndFNoYXBlLnJvdWdoQ29sbGlkZSh4LCB5LCBycy5hcnJvd0VuZFgsIHJzLmFycm93RW5kWSwgdGd0QXJXLCB0Z3RBckgsIFtycy5hcnJvd0VuZFggLSB0Z3RQb3MueCwgcnMuYXJyb3dFbmRZIC0gdGd0UG9zLnldLCAwKVxuICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgdGd0U2hhcGUuY29sbGlkZSh4LCB5LCBycy5hcnJvd0VuZFgsIHJzLmFycm93RW5kWSwgdGd0QXJXLCB0Z3RBckgsIFtycy5hcnJvd0VuZFggLSB0Z3RQb3MueCwgcnMuYXJyb3dFbmRZIC0gdGd0UG9zLnldLCAwKVxuICAgICAgICAgIClcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmb3IgY29tcG91bmQgZ3JhcGhzLCBoaXR0aW5nIGVkZ2UgbWF5IGFjdHVhbGx5IHdhbnQgYSBjb25uZWN0ZWQgbm9kZSBpbnN0ZWFkIChiL2MgZWRnZSBtYXkgaGF2ZSBncmVhdGVyIHotaW5kZXggcHJlY2VkZW5jZSlcbiAgICAgIGlmKCBoYXNDb21wb3VuZHMgJiYgIG5lYXIubGVuZ3RoID4gMCAmJiBuZWFyWyBuZWFyLmxlbmd0aCAtIDEgXSA9PT0gZWRnZSApe1xuICAgICAgICBjaGVja05vZGUoIHNyYyApO1xuICAgICAgICBjaGVja05vZGUoIHRndCApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSBlbGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICl7IC8vIHJldmVyc2Ugb3JkZXIgZm9yIHByZWNlZGVuY2VcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICBpZiggbmVhci5sZW5ndGggPiAwICl7IGJyZWFrOyB9IC8vIHNpbmNlIHdlIGNoZWNrIGluIHotb3JkZXIsIGZpcnN0IGZvdW5kIGlzIHRvcCBhbmQgYmVzdCByZXN1bHQgPT4gZXhpdCBlYXJseVxuXG4gICAgICBpZiggZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7IFxuICAgICAgICBjaGVja05vZGUoIGVsZXNbaV0gKTtcblxuICAgICAgfSBlbHNlICB7IC8vIHRoZW4gZWRnZVxuICAgICAgICBjaGVja0VkZ2UoIGVsZXNbaV0gKTtcbiAgICAgIH1cblxuICAgIH1cbiAgXG4gICAgXG4gICAgaWYoIG5lYXIubGVuZ3RoID4gMCApe1xuICAgICAgcmV0dXJuIG5lYXJbIG5lYXIubGVuZ3RoIC0gMSBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07IFxuXG4gIC8vICdHaXZlIG1lIGV2ZXJ5dGhpbmcgZnJvbSB0aGlzIGJveCdcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldEFsbEluQm94ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmdldENhY2hlZE5vZGVzKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDYWNoZWRFZGdlcygpO1xuICAgIHZhciBib3ggPSBbXTtcbiAgICBcbiAgICB2YXIgeDFjID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgICB2YXIgeDJjID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICB2YXIgeTFjID0gTWF0aC5taW4oeTEsIHkyKTtcbiAgICB2YXIgeTJjID0gTWF0aC5tYXgoeTEsIHkyKTsgXG5cbiAgICB4MSA9IHgxYzsgXG4gICAgeDIgPSB4MmM7IFxuICAgIHkxID0geTFjOyBcbiAgICB5MiA9IHkyYzsgXG5cbiAgICB2YXIgaGV1cjtcbiAgICBcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHBvcyA9IG5vZGVzW2ldLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIG5TaGFwZSA9IHRoaXMuZ2V0Tm9kZVNoYXBlKG5vZGVzW2ldKTtcbiAgICAgIHZhciB3ID0gdGhpcy5nZXROb2RlV2lkdGgobm9kZXNbaV0pO1xuICAgICAgdmFyIGggPSB0aGlzLmdldE5vZGVIZWlnaHQobm9kZXNbaV0pO1xuICAgICAgdmFyIGJvcmRlciA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlIC8gMjtcbiAgICAgIHZhciBzaGFwZU9iaiA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbIG5TaGFwZSBdO1xuXG4gICAgICBpZiAoIHNoYXBlT2JqLmludGVyc2VjdEJveCh4MSwgeTEsIHgyLCB5MiwgdywgaCwgcG9zLngsIHBvcy55LCBib3JkZXIpICl7XG4gICAgICAgIGJveC5wdXNoKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBycyA9IGVkZ2VzW2ldLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgICBpZiAoZWRnZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guZWRnZVR5cGUgPT0gJ3NlbGYnKSB7XG4gICAgICAgIGlmICgoaGV1ciA9ICQkLm1hdGguYm94SW5CZXppZXJWaWNpbml0eSh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgcnMuY3AyYXgsIHJzLmNwMmF5LFxuICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpXG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAoaGV1ciA9PSAyIHx8IChoZXVyID09IDEgJiYgJCQubWF0aC5jaGVja0JlemllckluQm94KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgICAgcnMuY3AyYXgsIHJzLmNwMmF5LFxuICAgICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSkpXG4gICAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAoaGV1ciA9ICQkLm1hdGguYm94SW5CZXppZXJWaWNpbml0eSh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgcnMuY3AyY3gsIHJzLmNwMmN5LFxuICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpXG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAoaGV1ciA9PSAyIHx8IChoZXVyID09IDEgJiYgJCQubWF0aC5jaGVja0JlemllckluQm94KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgICAgcnMuY3AyY3gsIHJzLmNwMmN5LFxuICAgICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSkpXG4gICAgICAgICAgKVxuICAgICAgICB7IGJveC5wdXNoKGVkZ2VzW2ldKTsgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocnMuZWRnZVR5cGUgPT0gJ2JlemllcicgJiZcbiAgICAgICAgKGhldXIgPSAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkoeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgIHJzLmNwMngsIHJzLmNwMnksXG4gICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSlcbiAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgIChoZXVyID09IDIgfHwgKGhldXIgPT0gMSAmJiAkJC5tYXRoLmNoZWNrQmV6aWVySW5Cb3goeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgICBycy5jcDJ4LCBycy5jcDJ5LFxuICAgICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSkpKVxuICAgICAgICB7IGJveC5wdXNoKGVkZ2VzW2ldKTsgfVxuICAgIFxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09ICdzdHJhaWdodCcgJiZcbiAgICAgICAgKGhldXIgPSAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkoeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgIHJzLnN0YXJ0WCAqIDAuNSArIHJzLmVuZFggKiAwLjUsIFxuICAgICAgICAgICAgcnMuc3RhcnRZICogMC41ICsgcnMuZW5kWSAqIDAuNSwgXG4gICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSlcbiAgICAgICAgICAgICAgJiYgLyogY29uc29sZS5sb2coJ3Rlc3QnLCBoZXVyKSA9PSB1bmRlZmluZWQgJiYgKi9cbiAgICAgICAgICAgIChoZXVyID09IDIgfHwgKGhldXIgPT0gMSAmJiAkJC5tYXRoLmNoZWNrU3RyYWlnaHRFZGdlSW5Cb3goeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSkpKVxuICAgICAgICB7IGJveC5wdXNoKGVkZ2VzW2ldKTsgfVxuXG5cbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PSAnaGF5c3RhY2snKXtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2VzW2ldLnRhcmdldCgpWzBdO1xuICAgICAgICB2YXIgdGd0UG9zID0gdGd0LnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBzcmMgPSBlZGdlc1tpXS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIHNyY1BvcyA9IHNyYy5wb3NpdGlvbigpO1xuXG4gICAgICAgIHZhciBzdGFydFggPSBzcmNQb3MueCArIHJzLnNvdXJjZS54O1xuICAgICAgICB2YXIgc3RhcnRZID0gc3JjUG9zLnkgKyBycy5zb3VyY2UueTtcbiAgICAgICAgdmFyIGVuZFggPSB0Z3RQb3MueCArIHJzLnRhcmdldC54O1xuICAgICAgICB2YXIgZW5kWSA9IHRndFBvcy55ICsgcnMudGFyZ2V0Lnk7XG5cbiAgICAgICAgdmFyIHN0YXJ0SW5Cb3ggPSAoeDEgPD0gc3RhcnRYICYmIHN0YXJ0WCA8PSB4MikgJiYgKHkxIDw9IHN0YXJ0WSAmJiBzdGFydFkgPD0geTIpO1xuICAgICAgICB2YXIgZW5kSW5Cb3ggPSAoeDEgPD0gZW5kWCAmJiBlbmRYIDw9IHgyKSAmJiAoeTEgPD0gZW5kWSAmJiBlbmRZIDw9IHkyKTtcblxuICAgICAgICBpZiggc3RhcnRJbkJveCAmJiBlbmRJbkJveCApe1xuICAgICAgICAgIGJveC5wdXNoKCBlZGdlc1tpXSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGJveDtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIHdpZHRoIGlzIHNldCB0byBhdXRvLFxuICAgKiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYXV0b1dpZHRoIGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSAgICAgICAgICBhIG5vZGVcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgd2lkdGggb2YgdGhlIG5vZGVcbiAgICovXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXROb2RlV2lkdGggPSBmdW5jdGlvbihub2RlKVxuICB7XG4gICAgcmV0dXJuIG5vZGUud2lkdGgoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgaGVpZ2h0IGlzIHNldCB0byBhdXRvLFxuICAgKiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgYXV0b0hlaWdodCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgICAgICAgICAgYSBub2RlXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIHdpZHRoIG9mIHRoZSBub2RlXG4gICAqL1xuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0Tm9kZUhlaWdodCA9IGZ1bmN0aW9uKG5vZGUpXG4gIHtcbiAgICByZXR1cm4gbm9kZS5oZWlnaHQoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2hhcGUgb2YgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBoZWlnaHQgb3Igd2lkdGggb2YgdGhlIGdpdmVuIG5vZGVcbiAgICogaXMgc2V0IHRvIGF1dG8sIHRoZSBub2RlIGlzIGNvbnNpZGVyZWQgdG8gYmUgYSBjb21wb3VuZC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgICAgICAgICAgYSBub2RlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgIHNoYXBlIG9mIHRoZSBub2RlXG4gICAqL1xuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0Tm9kZVNoYXBlID0gZnVuY3Rpb24obm9kZSlcbiAge1xuICAgIC8vIFRPRE8gb25seSBhbGxvdyByZWN0YW5nbGUgZm9yIGEgY29tcG91bmQgbm9kZT9cbi8vICAgIGlmIChub2RlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnZhbHVlID09ICdhdXRvJyB8fFxuLy8gICAgICAgIG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2hlaWdodCddLnZhbHVlID09ICdhdXRvJylcbi8vICAgIHtcbi8vICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuLy8gICAgfVxuXG4gICAgdmFyIHNoYXBlID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnc2hhcGUnXS52YWx1ZTtcblxuICAgIGlmKCBub2RlLmlzUGFyZW50KCkgKXtcbiAgICAgIGlmKCBzaGFwZSA9PT0gJ3JlY3RhbmdsZScgfHwgc2hhcGUgPT09ICdyb3VuZHJlY3RhbmdsZScgKXtcbiAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdyZWN0YW5nbGUnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcblxuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXROb2RlUGFkZGluZyA9IGZ1bmN0aW9uKG5vZGUpXG4gIHtcbiAgICB2YXIgbGVmdCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctbGVmdCddLnB4VmFsdWU7XG4gICAgdmFyIHJpZ2h0ID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy1yaWdodCddLnB4VmFsdWU7XG4gICAgdmFyIHRvcCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctdG9wJ10ucHhWYWx1ZTtcbiAgICB2YXIgYm90dG9tID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy1ib3R0b20nXS5weFZhbHVlO1xuXG4gICAgaWYgKGlzTmFOKGxlZnQpKVxuICAgIHtcbiAgICAgIGxlZnQgPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTihyaWdodCkpXG4gICAge1xuICAgICAgcmlnaHQgPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTih0b3ApKVxuICAgIHtcbiAgICAgIHRvcCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKGJvdHRvbSkpXG4gICAge1xuICAgICAgYm90dG9tID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge2xlZnQgOiBsZWZ0LFxuICAgICAgcmlnaHQgOiByaWdodCxcbiAgICAgIHRvcCA6IHRvcCxcbiAgICAgIGJvdHRvbSA6IGJvdHRvbX07XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnpPcmRlclNvcnQgPSAkJC5Db2xsZWN0aW9uLnpJbmRleFNvcnQ7XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUNhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmdldENhY2hlZFpTb3J0ZWRFbGVzKCB0cnVlICk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldENhY2hlZFpTb3J0ZWRFbGVzID0gZnVuY3Rpb24oIGZvcmNlUmVjYWxjICl7XG4gICAgdmFyIGxhc3ROb2RlcyA9IHRoaXMubGFzdFpPcmRlckNhY2hlZE5vZGVzO1xuICAgIHZhciBsYXN0RWRnZXMgPSB0aGlzLmxhc3RaT3JkZXJDYWNoZWRFZGdlcztcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmdldENhY2hlZE5vZGVzKCk7XG4gICAgdmFyIGVkZ2VzID0gdGhpcy5nZXRDYWNoZWRFZGdlcygpO1xuICAgIHZhciBlbGVzID0gW107XG5cbiAgICBpZiggZm9yY2VSZWNhbGMgfHwgIWxhc3ROb2RlcyB8fCAhbGFzdEVkZ2VzIHx8IGxhc3ROb2RlcyAhPT0gbm9kZXMgfHwgbGFzdEVkZ2VzICE9PSBlZGdlcyApeyBcbiAgICAgIC8vY29uc29sZS50aW1lKCdjYWNoZXpvcmRlcicpXG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIG5vZGVzW2ldLnZpc2libGUoKSAmJiAhbm9kZXNbaV0udHJhbnNwYXJlbnQoKSApe1xuICAgICAgICAgIGVsZXMucHVzaCggbm9kZXNbaV0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCBlZGdlc1tpXS52aXNpYmxlKCkgJiYgIWVkZ2VzW2ldLnRyYW5zcGFyZW50KCkgKXtcbiAgICAgICAgICBlbGVzLnB1c2goIGVkZ2VzW2ldICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlcy5zb3J0KCB0aGlzLnpPcmRlclNvcnQgKTtcbiAgICAgIHRoaXMuY2FjaGVkWlNvcnRlZEVsZXMgPSBlbGVzO1xuICAgICAgLy9jb25zb2xlLmxvZygnbWFrZSBjYWNoZScpXG5cbiAgICAgIC8vY29uc29sZS50aW1lRW5kKCdjYWNoZXpvcmRlcicpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZXMgPSB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzO1xuICAgICAgLy9jb25zb2xlLmxvZygncmVhZCBjYWNoZScpXG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB0aGlzLmxhc3RaT3JkZXJDYWNoZWRFZGdlcyA9IGVkZ2VzO1xuXG4gICAgcmV0dXJuIGVsZXM7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnByb2plY3RCZXppZXIgPSBmdW5jdGlvbihlZGdlKXtcbiAgICB2YXIgcWJlemllckF0ID0gJCQubWF0aC5xYmV6aWVyQXQ7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgYnB0cyA9IGVkZ2UuX3ByaXZhdGUucnN0eWxlLmJlemllclB0cyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gcHVzaEJlemllclB0cyhwdHMpe1xuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjA1ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4wNSApXG4gICAgICB9KTtcblxuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjI1ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC4yNSApXG4gICAgICB9KTtcblxuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjQgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjQgKVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBtaWQgPSB7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC41ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC41IClcbiAgICAgIH07XG5cbiAgICAgIGJwdHMucHVzaCggbWlkICk7XG5cbiAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnICl7XG4gICAgICAgIHJzLm1pZFggPSBycy5zZWxmRWRnZU1pZFg7XG4gICAgICAgIHJzLm1pZFkgPSBycy5zZWxmRWRnZU1pZFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBycy5taWRYID0gbWlkLng7XG4gICAgICAgIHJzLm1pZFkgPSBtaWQueTtcbiAgICAgIH1cblxuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjYgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjYgKVxuICAgICAgfSk7XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC43NSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuNzUgKVxuICAgICAgfSk7XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC45NSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuOTUgKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnc2VsZicgKXtcbiAgICAgIHB1c2hCZXppZXJQdHMoIFtycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuY3AyYXgsIHJzLmNwMmF5LCBycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWV0gKTtcbiAgICAgIHB1c2hCZXppZXJQdHMoIFtycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWSwgcnMuY3AyY3gsIHJzLmNwMmN5LCBycy5lbmRYLCBycy5lbmRZXSApO1xuICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdiZXppZXInICl7XG4gICAgICBwdXNoQmV6aWVyUHRzKCBbcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMngsIHJzLmNwMnksIHJzLmVuZFgsIHJzLmVuZFldICk7XG4gICAgfVxuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiggbm9kZSApe1xuICAgIHZhciBjb250ZW50ID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuICAgIGlmKCAhY29udGVudCB8fCBjb250ZW50Lm1hdGNoKC9eXFxzKyQvKSApeyByZXR1cm47IH1cblxuICAgIHZhciB0ZXh0WCwgdGV4dFk7XG4gICAgdmFyIG5vZGVXaWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICAgIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpO1xuICAgIHZhciBub2RlUG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtaGFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIHRleHRWYWxpZ24gPSBub2RlLl9wcml2YXRlLnN0eWxlWyd0ZXh0LXZhbGlnbiddLnN0clZhbHVlO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHJzdHlsZSA9IG5vZGUuX3ByaXZhdGUucnN0eWxlO1xuXG4gICAgc3dpdGNoKCB0ZXh0SGFsaWduICl7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICB0ZXh0WCA9IG5vZGVQb3MueCArIG5vZGVXaWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgICB9XG5cbiAgICBzd2l0Y2goIHRleHRWYWxpZ24gKXtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHRleHRZID0gbm9kZVBvcy55IC0gbm9kZUhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICB0ZXh0WSA9IG5vZGVQb3MueSArIG5vZGVIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDogLy8gZS5nLiBtaWRkbGVcbiAgICAgICAgdGV4dFkgPSBub2RlUG9zLnk7XG4gICAgfVxuICBcbiAgICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgICBycy5sYWJlbFkgPSB0ZXh0WTtcbiAgICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gICAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuXG4gICAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyggbm9kZSApO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiggZWRnZSApe1xuICAgIHZhciBjb250ZW50ID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuICAgIGlmKCAhY29udGVudCB8fCBjb250ZW50Lm1hdGNoKC9eXFxzKyQvKSApeyByZXR1cm47IH1cblxuICAgIHZhciB0ZXh0WCwgdGV4dFk7ICBcbiAgICB2YXIgZWRnZUNlbnRlclgsIGVkZ2VDZW50ZXJZO1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHJzdHlsZSA9IGVkZ2UuX3ByaXZhdGUucnN0eWxlO1xuICAgIFxuICAgIGlmIChycy5lZGdlVHlwZSA9PSAnc2VsZicpIHtcbiAgICAgIGVkZ2VDZW50ZXJYID0gcnMuc2VsZkVkZ2VNaWRYO1xuICAgICAgZWRnZUNlbnRlclkgPSBycy5zZWxmRWRnZU1pZFk7XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PSAnc3RyYWlnaHQnKSB7XG4gICAgICBlZGdlQ2VudGVyWCA9IChycy5zdGFydFggKyBycy5lbmRYKSAvIDI7XG4gICAgICBlZGdlQ2VudGVyWSA9IChycy5zdGFydFkgKyBycy5lbmRZKSAvIDI7XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PSAnYmV6aWVyJykge1xuICAgICAgZWRnZUNlbnRlclggPSAkJC5tYXRoLnFiZXppZXJBdCggcnMuc3RhcnRYLCBycy5jcDJ4LCBycy5lbmRYLCAwLjUgKTtcbiAgICAgIGVkZ2VDZW50ZXJZID0gJCQubWF0aC5xYmV6aWVyQXQoIHJzLnN0YXJ0WSwgcnMuY3AyeSwgcnMuZW5kWSwgMC41ICk7XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PSAnaGF5c3RhY2snKSB7XG4gICAgICB2YXIgc3JjUG9zID0gZWRnZS5fcHJpdmF0ZS5zb3VyY2UuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgdGd0UG9zID0gZWRnZS5fcHJpdmF0ZS50YXJnZXQuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgIGVkZ2VDZW50ZXJYID0gKHNyY1Bvcy54ICsgcnMuc291cmNlLnggKyB0Z3RQb3MueCArIHJzLnRhcmdldC54KS8yO1xuICAgICAgZWRnZUNlbnRlclkgPSAoc3JjUG9zLnkgKyBycy5zb3VyY2UueSArIHRndFBvcy55ICsgcnMudGFyZ2V0LnkpLzI7XG4gICAgfVxuICAgIFxuICAgIHRleHRYID0gZWRnZUNlbnRlclg7XG4gICAgdGV4dFkgPSBlZGdlQ2VudGVyWTtcblxuICAgIC8vIGFkZCBjZW50ZXIgcG9pbnQgdG8gc3R5bGUgc28gYm91bmRpbmcgYm94IGNhbGN1bGF0aW9ucyBjYW4gdXNlIGl0XG4gICAgcnMubGFiZWxYID0gdGV4dFg7XG4gICAgcnMubGFiZWxZID0gdGV4dFk7XG4gICAgcnN0eWxlLmxhYmVsWCA9IHRleHRYO1xuICAgIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcblxuICAgIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoIGVkZ2UgKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuYXBwbHlMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgdmFyIHJzID0gZWxlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciByc3R5bGUgPSBlbGUuX3ByaXZhdGUucnN0eWxlO1xuXG4gICAgdmFyIHRleHQgPSB0aGlzLmdldExhYmVsVGV4dCggZWxlICk7XG4gICAgdmFyIGxhYmVsRGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIHRleHQgKTtcbiBcbiAgICByc3R5bGUubGFiZWxXaWR0aCA9IGxhYmVsRGltcy53aWR0aDtcbiAgICBycy5sYWJlbFdpZHRoID0gbGFiZWxEaW1zLndpZHRoO1xuIFxuICAgIHJzdHlsZS5sYWJlbEhlaWdodCA9IGxhYmVsRGltcy5oZWlnaHQ7XG4gICAgcnMubGFiZWxIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0O1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXRMYWJlbFRleHQgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciB0ZXh0ID0gZWxlLl9wcml2YXRlLnN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG4gICAgdmFyIHRleHRUcmFuc2Zvcm0gPSBzdHlsZVsndGV4dC10cmFuc2Zvcm0nXS52YWx1ZTtcbiAgICBcbiAgICBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbm9uZScpIHtcbiAgICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICdsb3dlcmNhc2UnKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiggZWxlLCB0ZXh0ICl7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgZlN0eWxlID0gc3R5bGVbJ2ZvbnQtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgICB2YXIgc2l6ZSA9IHN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICsgJ3B4JztcbiAgICB2YXIgZmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gICAgLy8gdmFyIHZhcmlhbnQgPSBzdHlsZVsnZm9udC12YXJpYW50J10uc3RyVmFsdWU7XG4gICAgdmFyIHdlaWdodCA9IHN0eWxlWydmb250LXdlaWdodCddLnN0clZhbHVlO1xuXG4gICAgdmFyIGNhY2hlS2V5ID0gZWxlLl9wcml2YXRlLmxhYmVsS2V5O1xuICAgIHZhciBjYWNoZSA9IHIubGFiZWxEaW1DYWNoZSB8fCAoci5sYWJlbERpbUNhY2hlID0ge30pO1xuXG4gICAgaWYoIGNhY2hlW2NhY2hlS2V5XSApe1xuICAgICAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXY7XG5cbiAgICBpZiggIWRpdiApe1xuICAgICAgZGl2ID0gdGhpcy5sYWJlbENhbGNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuICAgIH1cblxuICAgIHZhciBkcyA9IGRpdi5zdHlsZTtcblxuICAgIC8vIGZyb20gZWxlIHN0eWxlXG4gICAgZHMuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgICBkcy5mb250U3R5bGUgPSBmU3R5bGU7XG4gICAgZHMuZm9udFNpemUgPSBzaXplO1xuICAgIC8vIGRzLmZvbnRWYXJpYW50ID0gdmFyaWFudDtcbiAgICBkcy5mb250V2VpZ2h0ID0gd2VpZ2h0O1xuXG4gICAgLy8gZm9yY2VkIHN0eWxlXG4gICAgZHMucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGRzLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZHMudG9wID0gJy05OTk5cHgnO1xuICAgIGRzLnpJbmRleCA9ICctMSc7XG4gICAgZHMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIGRzLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgZHMucGFkZGluZyA9ICcwJztcbiAgICBkcy5saW5lSGVpZ2h0ID0gJzEnO1xuXG4gICAgLy8gcHV0IGxhYmVsIGNvbnRlbnQgaW4gZGl2XG4gICAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcblxuICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcbiAgICAgIHdpZHRoOiBkaXYuY2xpZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IGRpdi5jbGllbnRIZWlnaHRcbiAgICB9O1xuXG4gICAgcmV0dXJuIGNhY2hlW2NhY2hlS2V5XTtcbiAgfTsgIFxuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbiggZWxlcyApe1xuICAgIHZhciBlZGdlcyA9IFtdO1xuICAgIHZhciBub2RlcyA9IFtdO1xuICAgIHZhciBoYW5kbGVkRWRnZSA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBycyA9IF9wLnJzY3JhdGNoO1xuICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICAgIHZhciBpZCA9IF9wLmRhdGEuaWQ7XG4gICAgICB2YXIgYmJTdHlsZVNhbWUgPSBycy5ib3VuZGluZ0JveEtleSAhPSBudWxsICYmIF9wLmJvdW5kaW5nQm94S2V5ID09PSBycy5ib3VuZGluZ0JveEtleTtcbiAgICAgIHZhciBsYWJlbFN0eWxlU2FtZSA9IHJzLmxhYmVsS2V5ICE9IG51bGwgJiYgX3AubGFiZWxLZXkgPT09IHJzLmxhYmVsS2V5O1xuICAgICAgdmFyIHN0eWxlU2FtZSA9IGJiU3R5bGVTYW1lICYmIGxhYmVsU3R5bGVTYW1lO1xuXG4gICAgICBpZiggZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBvc1NhbWUgPSByc3R5bGUubm9kZVggIT0gbnVsbCAmJiByc3R5bGUubm9kZVkgIT0gbnVsbCAmJiBwb3MueCA9PT0gcnN0eWxlLm5vZGVYICYmIHBvcy55ID09PSByc3R5bGUubm9kZVk7XG5cbiAgICAgICAgaWYoICFwb3NTYW1lIHx8ICFzdHlsZVNhbWUgKXtcbiAgICAgICAgICBub2Rlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJzdHlsZS5ub2RlWCA9IHBvcy54O1xuICAgICAgICByc3R5bGUubm9kZVkgPSBwb3MueTtcbiAgICAgIH0gZWxzZSB7IC8vIGVkZ2VzXG5cbiAgICAgICAgdmFyIHNyY1BvcyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2UuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciB0Z3RQb3MgPSBlbGUuX3ByaXZhdGUudGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgc3JjU2FtZSA9IHJzdHlsZS5zcmNYICE9IG51bGwgJiYgcnN0eWxlLnNyY1kgIT0gbnVsbCAmJiBzcmNQb3MueCA9PT0gcnN0eWxlLnNyY1ggJiYgc3JjUG9zLnkgPT09IHJzdHlsZS5zcmNZO1xuICAgICAgICB2YXIgdGd0U2FtZSA9IHJzdHlsZS50Z3RYICE9IG51bGwgJiYgcnN0eWxlLnRndFkgIT0gbnVsbCAmJiB0Z3RQb3MueCA9PT0gcnN0eWxlLnRndFggJiYgdGd0UG9zLnkgPT09IHJzdHlsZS50Z3RZO1xuICAgICAgICB2YXIgcG9zaXRpb25zU2FtZSA9IHNyY1NhbWUgJiYgdGd0U2FtZTtcblxuICAgICAgICBpZiggIXBvc2l0aW9uc1NhbWUgfHwgIXN0eWxlU2FtZSApe1xuICAgICAgICAgIHZhciBjdXJ2ZVR5cGUgPSBfcC5zdHlsZVsnY3VydmUtc3R5bGUnXS52YWx1ZTtcblxuICAgICAgICAgIGlmKCBjdXJ2ZVR5cGUgPT09ICdiZXppZXInICl7XG4gICAgICAgICAgICBpZiggIWhhbmRsZWRFZGdlWyBpZCBdICl7XG4gICAgICAgICAgICAgIGVkZ2VzLnB1c2goIGVsZSApO1xuICAgICAgICAgICAgICBoYW5kbGVkRWRnZVsgaWQgXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgdmFyIHBhcmFsbGVsRWRnZXMgPSBlbGUucGFyYWxsZWxFZGdlcygpO1xuICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmFsbGVsRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgICB2YXIgcEVkZ2UgPSBwYXJhbGxlbEVkZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBwSWQgPSBwRWRnZS5fcHJpdmF0ZS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAgICAgaWYoICFoYW5kbGVkRWRnZVsgcElkIF0gKXtcbiAgICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goIHBFZGdlICk7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVkRWRnZVsgcElkIF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgcG9zaXRpb25zIGRpZmZcblxuICAgICAgICAvLyB1cGRhdGUgcnN0eWxlIHBvc2l0aW9uc1xuICAgICAgICByc3R5bGUuc3JjWCA9IHNyY1Bvcy54O1xuICAgICAgICByc3R5bGUuc3JjWSA9IHNyY1Bvcy55O1xuICAgICAgICByc3R5bGUudGd0WCA9IHRndFBvcy54O1xuICAgICAgICByc3R5bGUudGd0WSA9IHRndFBvcy55O1xuXG4gICAgICB9IC8vIGlmIGVkZ2VzXG5cbiAgICAgIHJzLmJvdW5kaW5nQm94S2V5ID0gX3AuYm91bmRpbmdCb3hLZXk7XG4gICAgICBycy5sYWJlbEtleSA9IF9wLmxhYmVsS2V5O1xuICAgIH1cblxuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMoIGVkZ2VzICk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUxhYmVsUHJvamVjdGlvbnMoIG5vZGVzLCBlZGdlcyApO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZWNhbGN1bGF0ZUxhYmVsUHJvamVjdGlvbnMgPSBmdW5jdGlvbiggbm9kZXMsIGVkZ2VzICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24oIG5vZGVzW2ldICk7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb24oIGVkZ2VzW2ldICk7XG4gICAgfVxuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uKCBlZGdlcyApe1xuICAgIHRoaXMuZmluZEVkZ2VDb250cm9sUG9pbnRzKCBlZGdlcyApO1xuICB9O1xuXG5cbiAgLy8gRmluZCBlZGdlIGNvbnRyb2wgcG9pbnRzXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5maW5kRWRnZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbihlZGdlcykge1xuICAgIGlmKCAhZWRnZXMgfHwgZWRnZXMubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgdmFyIGhhc2hUYWJsZSA9IHt9O1xuICAgIHZhciBwYWlySWRzID0gW107XG4gICAgdmFyIGhheXN0YWNrRWRnZXMgPSBbXTtcblxuICAgIC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuICAgIHZhciBwYWlySWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHN0eWxlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBzdHlsZVsnY3VydmUtc3R5bGUnXS52YWx1ZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInO1xuXG4gICAgICAvLyBpZ25vcmUgZWRnZXMgd2hvIGFyZSBub3QgdG8gYmUgZGlzcGxheWVkXG4gICAgICAvLyB0aGV5IHNob3VsZG4ndCB0YWtlIHVwIHNwYWNlXG4gICAgICBpZiggc3R5bGUuZGlzcGxheS52YWx1ZSA9PT0gJ25vbmUnICl7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggc3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgICAgaGF5c3RhY2tFZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3JjSWQgPSBlZGdlLl9wcml2YXRlLmRhdGEuc291cmNlO1xuICAgICAgdmFyIHRndElkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnRhcmdldDtcblxuICAgICAgcGFpcklkID0gc3JjSWQgPiB0Z3RJZCA/XG4gICAgICAgIHRndElkICsgJy0nICsgc3JjSWQgOlxuICAgICAgICBzcmNJZCArICctJyArIHRndElkIDtcblxuICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICBwYWlySWQgPSAndW5idW5kbGVkJyArIGVkZ2UuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc2hUYWJsZVtwYWlySWRdID09IG51bGwpIHtcbiAgICAgICAgaGFzaFRhYmxlW3BhaXJJZF0gPSBbXTtcbiAgICAgICAgcGFpcklkcy5wdXNoKCBwYWlySWQgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaGFzaFRhYmxlW3BhaXJJZF0ucHVzaCggZWRnZSApO1xuXG4gICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgIGhhc2hUYWJsZVtwYWlySWRdLmhhc1VuYnVuZGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNyYywgdGd0LCBzcmNQb3MsIHRndFBvcywgc3JjVywgc3JjSCwgdGd0VywgdGd0SCwgc3JjU2hhcGUsIHRndFNoYXBlLCBzcmNCb3JkZXIsIHRndEJvcmRlcjtcbiAgICB2YXIgdmVjdG9yTm9ybUludmVyc2U7XG4gICAgdmFyIGJhZEJlemllcjtcbiAgICBcbiAgICAvLyBmb3IgZWFjaCBwYWlyIChzcmMsIHRndCksIGNyZWF0ZSB0aGUgY3RybCBwdHNcbiAgICAvLyBOZXN0ZWQgZm9yIGxvb3AgaXMgT0s7IHRvdGFsIG51bWJlciBvZiBpdGVyYXRpb25zIGZvciBib3RoIGxvb3BzID0gZWRnZUNvdW50ICBcbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhaXJJZHMubGVuZ3RoOyBwKyspIHtcbiAgICAgIHBhaXJJZCA9IHBhaXJJZHNbcF07XG4gICAgICB2YXIgcGFpckVkZ2VzID0gaGFzaFRhYmxlW3BhaXJJZF07XG4gICAgXG4gICAgICAvLyBmb3IgZWFjaCBwYWlyIGlkLCB0aGUgZWRnZXMgc2hvdWxkIGJlIHNvcnRlZCBieSBpbmRleFxuICAgICAgcGFpckVkZ2VzLnNvcnQoZnVuY3Rpb24oZWRnZTEsIGVkZ2UyKXtcbiAgICAgICAgcmV0dXJuIGVkZ2UxLl9wcml2YXRlLmluZGV4IC0gZWRnZTIuX3ByaXZhdGUuaW5kZXg7XG4gICAgICB9KTtcblxuICAgICAgc3JjID0gcGFpckVkZ2VzWzBdLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgIHRndCA9IHBhaXJFZGdlc1swXS5fcHJpdmF0ZS50YXJnZXQ7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBzcmMvdGd0IGRpc3RpbmN0aW9uIGlzIGNvbnNpc3RlbnRcbiAgICAgIC8vIChzcmMvdGd0IGluIHRoaXMgY2FzZSBhcmUganVzdCBmb3IgY3RybHB0cyBhbmQgZG9uJ3QgYWN0dWFsbHkgaGF2ZSB0byBiZSB0cnVlIHNyYy90Z3QpXG4gICAgICBpZiggc3JjLl9wcml2YXRlLmRhdGEuaWQgPiB0Z3QuX3ByaXZhdGUuZGF0YS5pZCApe1xuICAgICAgICB2YXIgdGVtcCA9IHNyYztcbiAgICAgICAgc3JjID0gdGd0O1xuICAgICAgICB0Z3QgPSB0ZW1wO1xuICAgICAgfVxuXG4gICAgICBzcmNQb3MgPSBzcmMuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB0Z3RQb3MgPSB0Z3QuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgIHNyY1cgPSB0aGlzLmdldE5vZGVXaWR0aChzcmMpO1xuICAgICAgc3JjSCA9IHRoaXMuZ2V0Tm9kZUhlaWdodChzcmMpO1xuXG4gICAgICB0Z3RXID0gdGhpcy5nZXROb2RlV2lkdGgodGd0KTtcbiAgICAgIHRndEggPSB0aGlzLmdldE5vZGVIZWlnaHQodGd0KTtcblxuICAgICAgc3JjU2hhcGUgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZShzcmMpIF07XG4gICAgICB0Z3RTaGFwZSA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKHRndCkgXTtcblxuICAgICAgc3JjQm9yZGVyID0gc3JjLl9wcml2YXRlLnN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuICAgICAgdGd0Qm9yZGVyID0gdGd0Ll9wcml2YXRlLnN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuXG4gICAgICBiYWRCZXppZXIgPSBmYWxzZTtcbiAgICAgIFxuXG4gICAgICBpZiggKHBhaXJFZGdlcy5sZW5ndGggPiAxICYmIHNyYyAhPT0gdGd0KSB8fCBwYWlyRWRnZXMuaGFzVW5idW5kbGVkICl7XG5cbiAgICAgICAgLy8gcHQgb3V0c2lkZSBzcmMgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICAgIHZhciBzcmNPdXRzaWRlID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgICBzcmNQb3MueSxcbiAgICAgICAgICBzcmNXLFxuICAgICAgICAgIHNyY0gsXG4gICAgICAgICAgdGd0UG9zLngsXG4gICAgICAgICAgdGd0UG9zLnksXG4gICAgICAgICAgc3JjQm9yZGVyIC8gMlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHB0IG91dHNpZGUgdGd0IHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgICB2YXIgdGd0T3V0c2lkZSA9IHRndFNoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgICAgdGd0UG9zLngsXG4gICAgICAgICAgdGd0UG9zLnksXG4gICAgICAgICAgdGd0VyxcbiAgICAgICAgICB0Z3RILFxuICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgIHNyY1Bvcy55LFxuICAgICAgICAgIHRndEJvcmRlciAvIDJcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbWlkcHRTcmNQdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY091dHNpZGVbMF0sXG4gICAgICAgICAgeDI6IHRndE91dHNpZGVbMF0sXG4gICAgICAgICAgeTE6IHNyY091dHNpZGVbMV0sXG4gICAgICAgICAgeTI6IHRndE91dHNpZGVbMV1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZHkgPSAoIHRndE91dHNpZGVbMV0gLSBzcmNPdXRzaWRlWzFdICk7XG4gICAgICAgIHZhciBkeCA9ICggdGd0T3V0c2lkZVswXSAtIHNyY091dHNpZGVbMF0gKTtcbiAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoIGR4KmR4ICsgZHkqZHkgKTtcblxuICAgICAgICB2YXIgdmVjdG9yID0ge1xuICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgIHk6IGR5XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgdmVjdG9yTm9ybSA9IHtcbiAgICAgICAgICB4OiB2ZWN0b3IueC9sLFxuICAgICAgICAgIHk6IHZlY3Rvci55L2xcbiAgICAgICAgfTtcbiAgICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSB7XG4gICAgICAgICAgeDogLXZlY3Rvck5vcm0ueSxcbiAgICAgICAgICB5OiB2ZWN0b3JOb3JtLnhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpZiBzcmMgaW50ZXJzZWN0aW9uIGlzIGluc2lkZSB0Z3Qgb3IgdGd0IGludGVyc2VjdGlvbiBpcyBpbnNpZGUgc3JjLCB0aGVuIG5vIGN0cmwgcHRzIHRvIGRyYXdcbiAgICAgICAgaWYoIFxuICAgICAgICAgIHRndFNoYXBlLmNoZWNrUG9pbnQoIHNyY091dHNpZGVbMF0sIHNyY091dHNpZGVbMV0sIHRndEJvcmRlci8yLCB0Z3RXLCB0Z3RILCB0Z3RQb3MueCwgdGd0UG9zLnkgKSAgfHxcbiAgICAgICAgICBzcmNTaGFwZS5jaGVja1BvaW50KCB0Z3RPdXRzaWRlWzBdLCB0Z3RPdXRzaWRlWzFdLCBzcmNCb3JkZXIvMiwgc3JjVywgc3JjSCwgc3JjUG9zLngsIHNyY1Bvcy55ICkgXG4gICAgICAgICl7XG4gICAgICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSB7fTtcbiAgICAgICAgICBiYWRCZXppZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZWRnZTtcbiAgICAgIHZhciBycztcbiAgICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlyRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWRnZSA9IHBhaXJFZGdlc1tpXTtcbiAgICAgICAgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgICBcbiAgICAgICAgdmFyIGVkZ2VJbmRleDEgPSBycy5sYXN0RWRnZUluZGV4O1xuICAgICAgICB2YXIgZWRnZUluZGV4MiA9IGk7XG5cbiAgICAgICAgdmFyIG51bUVkZ2VzMSA9IHJzLmxhc3ROdW1FZGdlcztcbiAgICAgICAgdmFyIG51bUVkZ2VzMiA9IHBhaXJFZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGVTdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgIHZhciBzdGVwU2l6ZSA9IGVTdHlsZVsnY29udHJvbC1wb2ludC1zdGVwLXNpemUnXS5weFZhbHVlO1xuICAgICAgICB2YXIgc3RlcERpc3QgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnXSAhPT0gdW5kZWZpbmVkID8gZVN0eWxlWydjb250cm9sLXBvaW50LWRpc3RhbmNlJ10ucHhWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHN0ZXBXZWlnaHQgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0J10udmFsdWU7XG4gICAgICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBlU3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJztcblxuICAgICAgICB2YXIgc3JjWDEgPSBycy5sYXN0U3JjQ3RsUHRYO1xuICAgICAgICB2YXIgc3JjWDIgPSBzcmNQb3MueDtcbiAgICAgICAgdmFyIHNyY1kxID0gcnMubGFzdFNyY0N0bFB0WTtcbiAgICAgICAgdmFyIHNyY1kyID0gc3JjUG9zLnk7XG4gICAgICAgIHZhciBzcmNXMSA9IHJzLmxhc3RTcmNDdGxQdFc7XG4gICAgICAgIHZhciBzcmNXMiA9IHNyYy5vdXRlcldpZHRoKCk7XG4gICAgICAgIHZhciBzcmNIMSA9IHJzLmxhc3RTcmNDdGxQdEg7XG4gICAgICAgIHZhciBzcmNIMiA9IHNyYy5vdXRlckhlaWdodCgpO1xuXG4gICAgICAgIHZhciB0Z3RYMSA9IHJzLmxhc3RUZ3RDdGxQdFg7XG4gICAgICAgIHZhciB0Z3RYMiA9IHRndFBvcy54O1xuICAgICAgICB2YXIgdGd0WTEgPSBycy5sYXN0VGd0Q3RsUHRZO1xuICAgICAgICB2YXIgdGd0WTIgPSB0Z3RQb3MueTtcbiAgICAgICAgdmFyIHRndFcxID0gcnMubGFzdFRndEN0bFB0VztcbiAgICAgICAgdmFyIHRndFcyID0gdGd0Lm91dGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIHRndEgxID0gcnMubGFzdFRndEN0bFB0SDtcbiAgICAgICAgdmFyIHRndEgyID0gdGd0Lm91dGVySGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIHdpZHRoMSA9IHJzLmxhc3RXO1xuICAgICAgICB2YXIgd2lkdGgyID0gZVN0eWxlWydjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSddLnB4VmFsdWU7XG5cbiAgICAgICAgaWYoIGJhZEJlemllciApe1xuICAgICAgICAgIHJzLmJhZEJlemllciA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnMuYmFkQmV6aWVyID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggc3JjWDEgPT09IHNyY1gyICYmIHNyY1kxID09PSBzcmNZMiAmJiBzcmNXMSA9PT0gc3JjVzIgJiYgc3JjSDEgPT09IHNyY0gyXG4gICAgICAgICYmICB0Z3RYMSA9PT0gdGd0WDIgJiYgdGd0WTEgPT09IHRndFkyICYmIHRndFcxID09PSB0Z3RXMiAmJiB0Z3RIMSA9PT0gdGd0SDJcbiAgICAgICAgJiYgIHdpZHRoMSA9PT0gd2lkdGgyXG4gICAgICAgICYmICAoKGVkZ2VJbmRleDEgPT09IGVkZ2VJbmRleDIgJiYgbnVtRWRnZXMxID09PSBudW1FZGdlczIpIHx8IGVkZ2VJc1VuYnVuZGxlZCkgKXtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZWRnZSBjdHJsIHB0IGNhY2hlIEhJVCcpXG4gICAgICAgICAgY29udGludWU7IC8vIHRoZW4gdGhlIGNvbnRyb2wgcG9pbnRzIGhhdmVuJ3QgY2hhbmdlZCBhbmQgd2UgY2FuIHNraXAgY2FsY3VsYXRpbmcgdGhlbVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJzLmxhc3RTcmNDdGxQdFggPSBzcmNYMjtcbiAgICAgICAgICBycy5sYXN0U3JjQ3RsUHRZID0gc3JjWTI7XG4gICAgICAgICAgcnMubGFzdFNyY0N0bFB0VyA9IHNyY1cyO1xuICAgICAgICAgIHJzLmxhc3RTcmNDdGxQdEggPSBzcmNIMjtcbiAgICAgICAgICBycy5sYXN0VGd0Q3RsUHRYID0gdGd0WDI7XG4gICAgICAgICAgcnMubGFzdFRndEN0bFB0WSA9IHRndFkyO1xuICAgICAgICAgIHJzLmxhc3RUZ3RDdGxQdFcgPSB0Z3RXMjtcbiAgICAgICAgICBycy5sYXN0VGd0Q3RsUHRIID0gdGd0SDI7XG4gICAgICAgICAgcnMubGFzdEVkZ2VJbmRleCA9IGVkZ2VJbmRleDI7XG4gICAgICAgICAgcnMubGFzdE51bUVkZ2VzID0gbnVtRWRnZXMyO1xuICAgICAgICAgIHJzLmxhc3RXaWR0aCA9IHdpZHRoMjtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZWRnZSBjdHJsIHB0IGNhY2hlIE1JU1MnKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZi1lZGdlXG4gICAgICAgIGlmICggc3JjID09PSB0Z3QgKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICBycy5lZGdlVHlwZSA9ICdzZWxmJztcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgaiA9IGk7XG4gICAgICAgICAgdmFyIGxvb3BEaXN0ID0gc3RlcFNpemU7XG5cbiAgICAgICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgICAgIGxvb3BEaXN0ID0gc3RlcERpc3Q7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gTmV3IC0tIGZpeCBmb3IgbGFyZ2Ugbm9kZXNcbiAgICAgICAgICBycy5jcDJheCA9IHNyY1Bvcy54O1xuICAgICAgICAgIHJzLmNwMmF5ID0gc3JjUG9zLnkgLSAoMSArIE1hdGgucG93KHNyY0gsIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSk7XG4gICAgICAgICAgXG4gICAgICAgICAgcnMuY3AyY3ggPSBzcmMuX3ByaXZhdGUucG9zaXRpb24ueCAtICgxICsgTWF0aC5wb3coc3JjVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKTtcbiAgICAgICAgICBycy5jcDJjeSA9IHNyY1Bvcy55O1xuICAgICAgICAgIFxuICAgICAgICAgIHJzLnNlbGZFZGdlTWlkWCA9IChycy5jcDJheCArIHJzLmNwMmN4KSAvIDIuMDtcbiAgICAgICAgICBycy5zZWxmRWRnZU1pZFkgPSAocnMuY3AyYXkgKyBycy5jcDJjeSkgLyAyLjA7XG4gICAgICAgICAgXG4gICAgICAgIC8vIFN0cmFpZ2h0IGVkZ2VcbiAgICAgICAgfSBlbHNlIGlmIChwYWlyRWRnZXMubGVuZ3RoICUgMiA9PT0gMVxuICAgICAgICAgICYmIGkgPT09IE1hdGguZmxvb3IocGFpckVkZ2VzLmxlbmd0aCAvIDIpXG4gICAgICAgICAgJiYgIWVkZ2VJc1VuYnVuZGxlZCApIHtcbiAgICAgICAgICBcbiAgICAgICAgICBycy5lZGdlVHlwZSA9ICdzdHJhaWdodCc7XG4gICAgICAgICAgXG4gICAgICAgIC8vIEJlemllciBlZGdlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5vcm1TdGVwRGlzdCA9ICgwLjUgLSBwYWlyRWRnZXMubGVuZ3RoIC8gMiArIGkpICogc3RlcFNpemU7XG4gICAgICAgICAgdmFyIG1hblN0ZXBEaXN0O1xuICAgICAgICAgIHZhciBzaWduID0gJCQubWF0aC5zaWdudW0oIG5vcm1TdGVwRGlzdCApO1xuXG4gICAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICAgICAgbWFuU3RlcERpc3QgPSBzdGVwRGlzdDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFuU3RlcERpc3QgPSBzdGVwRGlzdCAhPT0gdW5kZWZpbmVkID8gc2lnbiAqIHN0ZXBEaXN0IDogdW5kZWZpbmVkOyBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZGlzdGFuY2VGcm9tTWlkcG9pbnQgPSBtYW5TdGVwRGlzdCAhPT0gdW5kZWZpbmVkID8gbWFuU3RlcERpc3QgOiBub3JtU3RlcERpc3Q7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIHcxID0gKDEgLSBzdGVwV2VpZ2h0KTtcbiAgICAgICAgICB2YXIgdzIgPSBzdGVwV2VpZ2h0O1xuXG4gICAgICAgICAgdmFyIHN3YXBwZWREaXJlY3Rpb24gPSBlZGdlLl9wcml2YXRlLnNvdXJjZSAhPT0gc3JjO1xuICAgICAgICAgIGlmKCBzd2FwcGVkRGlyZWN0aW9uICl7XG4gICAgICAgICAgICB3MSA9IHN0ZXBXZWlnaHQ7XG4gICAgICAgICAgICB3MiA9ICgxIC0gc3RlcFdlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICAgICAgICB4OiBtaWRwdFNyY1B0cy54MSAqIHcxICsgbWlkcHRTcmNQdHMueDIgKiB3MixcbiAgICAgICAgICAgIHk6IG1pZHB0U3JjUHRzLnkxICogdzEgKyBtaWRwdFNyY1B0cy55MiAqIHcyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJzLmVkZ2VUeXBlID0gJ2Jlemllcic7XG4gICAgICAgICAgXG4gICAgICAgICAgcnMuY3AyeCA9IGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkaXN0YW5jZUZyb21NaWRwb2ludDtcbiAgICAgICAgICBycy5jcDJ5ID0gYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGRpc3RhbmNlRnJvbU1pZHBvaW50O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGVkZ2UsIG1pZFBvaW50WCwgZGlzcGxhY2VtZW50WCwgZGlzdGFuY2VGcm9tTWlkcG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBlbmRwdHMgZm9yIGVkZ2VcbiAgICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKCBlZGdlICk7XG5cbiAgICAgICAgdmFyIGJhZFN0YXJ0ID0gISQkLmlzLm51bWJlciggcnMuc3RhcnRYICkgfHwgISQkLmlzLm51bWJlciggcnMuc3RhcnRZICk7XG4gICAgICAgIHZhciBiYWRBU3RhcnQgPSAhJCQuaXMubnVtYmVyKCBycy5hcnJvd1N0YXJ0WCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLmFycm93U3RhcnRZICk7XG4gICAgICAgIHZhciBiYWRFbmQgPSAhJCQuaXMubnVtYmVyKCBycy5lbmRYICkgfHwgISQkLmlzLm51bWJlciggcnMuZW5kWSApO1xuICAgICAgICB2YXIgYmFkQUVuZCA9ICEkJC5pcy5udW1iZXIoIHJzLmFycm93RW5kWCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLmFycm93RW5kWSApO1xuXG4gICAgICAgIHZhciBtaW5DcEFEaXN0RmFjdG9yID0gMztcbiAgICAgICAgdmFyIGFycm93VyA9IHRoaXMuZ2V0QXJyb3dXaWR0aCggZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICkgKiBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlSGVpZ2h0O1xuICAgICAgICB2YXIgbWluQ3BBRGlzdCA9IG1pbkNwQURpc3RGYWN0b3IgKiBhcnJvd1c7XG4gICAgICAgIHZhciBzdGFydEFDcERpc3QgPSAkJC5tYXRoLmRpc3RhbmNlKCB7IHg6IHJzLmNwMngsIHk6IHJzLmNwMnkgfSwgeyB4OiBycy5zdGFydFgsIHk6IHJzLnN0YXJ0WSB9ICk7XG4gICAgICAgIHZhciBjbG9zZVN0YXJ0QUNwID0gc3RhcnRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICAgICAgdmFyIGVuZEFDcERpc3QgPSAkJC5tYXRoLmRpc3RhbmNlKCB7IHg6IHJzLmNwMngsIHk6IHJzLmNwMnkgfSwgeyB4OiBycy5lbmRYLCB5OiBycy5lbmRZIH0gKTtcbiAgICAgICAgdmFyIGNsb3NlRW5kQUNwID0gZW5kQUNwRGlzdCA8IG1pbkNwQURpc3Q7XG5cbiAgICAgICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyApe1xuICAgICAgICAgIHZhciBvdmVybGFwcGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYoIGJhZFN0YXJ0IHx8IGJhZEFTdGFydCB8fCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gc3JjIGNlbnRyZSB0byBvdXRzaWRlIHRoZSBzcmMgc2hhcGVcbiAgICAgICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgICAgICAgIHZhciBjcEQgPSB7IC8vIGRlbHRhXG4gICAgICAgICAgICAgIHg6IHJzLmNwMnggLSBzcmNQb3MueCxcbiAgICAgICAgICAgICAgeTogcnMuY3AyeSAtIHNyY1Bvcy55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNwTCA9IE1hdGguc3FydCggY3BELngqY3BELnggKyBjcEQueSpjcEQueSApOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgICAgICAgdmFyIGNwTSA9IHsgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICAgICAgICB2YXIgY3BQcm9qID0geyAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgICAgICAgIHg6IHJzLmNwMnggKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgICAgIHk6IHJzLmNwMnkgKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBzcmNDdHJsUHRJbnRuID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgICAgc3JjUG9zLngsXG4gICAgICAgICAgICAgIHNyY1Bvcy55LFxuICAgICAgICAgICAgICBzcmNXLFxuICAgICAgICAgICAgICBzcmNILFxuICAgICAgICAgICAgICBjcFByb2oueCxcbiAgICAgICAgICAgICAgY3BQcm9qLnksXG4gICAgICAgICAgICAgIHNyY0JvcmRlciAvIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmKCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgICAgIHJzLmNwMnggPSBycy5jcDJ4ICsgY3BNLnggKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7IFxuICAgICAgICAgICAgICBycy5jcDJ5ID0gcnMuY3AyeSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcnMuY3AyeCA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7IFxuICAgICAgICAgICAgICBycy5jcDJ5ID0gc3JjQ3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3AgKXtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSB0Z3QgY2VudHJlIHRvIG91dHNpZGUgdGhlIHRndCBzaGFwZVxuICAgICAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgICAgICAgdmFyIGNwRCA9IHsgLy8gZGVsdGFcbiAgICAgICAgICAgICAgeDogcnMuY3AyeCAtIHRndFBvcy54LFxuICAgICAgICAgICAgICB5OiBycy5jcDJ5IC0gdGd0UG9zLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KCBjcEQueCpjcEQueCArIGNwRC55KmNwRC55ICk7IC8vIGxlbmd0aCBvZiBsaW5lXG4gICAgICAgICAgICB2YXIgY3BNID0geyAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcbiAgICAgICAgICAgIHZhciBjcFByb2ogPSB7IC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgICAgICAgeDogcnMuY3AyeCArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgICAgICAgeTogcnMuY3AyeSArIGNwTS55ICogMiAqIHJhZGl1c1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRndEN0cmxQdEludG4gPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgICAgICB0Z3RQb3MueCxcbiAgICAgICAgICAgICAgdGd0UG9zLnksXG4gICAgICAgICAgICAgIHRndFcsXG4gICAgICAgICAgICAgIHRndEgsXG4gICAgICAgICAgICAgIGNwUHJvai54LFxuICAgICAgICAgICAgICBjcFByb2oueSxcbiAgICAgICAgICAgICAgdGd0Qm9yZGVyIC8gMlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYoIGNsb3NlRW5kQUNwICl7XG4gICAgICAgICAgICAgIHJzLmNwMnggPSBycy5jcDJ4ICsgY3BNLnggKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpOyBcbiAgICAgICAgICAgICAgcnMuY3AyeSA9IHJzLmNwMnkgKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBycy5jcDJ4ID0gdGd0Q3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDsgXG4gICAgICAgICAgICAgIHJzLmNwMnkgPSB0Z3RDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIG92ZXJsYXBwaW5nICl7XG4gICAgICAgICAgICAvLyByZWNhbGMgZW5kcHRzXG4gICAgICAgICAgICB0aGlzLmZpbmRFbmRwb2ludHMoIGVkZ2UgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgKXtcbiAgICAgICAgICBycy5taWRYID0gKCBzcmNYMiArIHRndFgyICkvMjtcbiAgICAgICAgICBycy5taWRZID0gKCBzcmNZMiArIHRndFkyICkvMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb2plY3QgdGhlIGVkZ2UgaW50byByc3R5bGVcbiAgICAgICAgdGhpcy5wcm9qZWN0QmV6aWVyKCBlZGdlICk7XG5cbiAgICAgIH1cbiAgICB9XG4gICAgICBcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGhheXN0YWNrRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gaGF5c3RhY2tFZGdlc1tpXTtcbiAgICAgIHZhciByc2NyYXRjaCA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICAgIGlmKCAhcnNjcmF0Y2guaGF5c3RhY2sgKXtcbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuXG4gICAgICAgIHJzY3JhdGNoLnNvdXJjZSA9IHtcbiAgICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIDIgKiBNYXRoLlBJO1xuXG4gICAgICAgIHJzY3JhdGNoLnRhcmdldCA9IHtcbiAgICAgICAgICB4OiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpXG4gICAgICAgIH07XG4gICAgICB9ICBcblxuICAgICAgLy8gYWx3YXlzIG92ZXJyaWRlIGFzIGhheXN0YWNrIGluIGNhc2Ugc2V0IHRvIGRpZmZlcmVudCB0eXBlIHByZXZpb3VzbHlcbiAgICAgIHJzY3JhdGNoLmVkZ2VUeXBlID0gJ2hheXN0YWNrJztcbiAgICAgIHJzY3JhdGNoLmhheXN0YWNrID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaFRhYmxlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5maW5kRW5kcG9pbnRzID0gZnVuY3Rpb24oZWRnZSkge1xuICAgIHZhciBpbnRlcnNlY3Q7XG5cbiAgICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgICBcbiAgICB2YXIgdGd0QXJTaGFwZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3RhcmdldC1hcnJvdy1zaGFwZSddLnZhbHVlO1xuICAgIHZhciBzcmNBclNoYXBlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnc291cmNlLWFycm93LXNoYXBlJ10udmFsdWU7XG5cbiAgICB2YXIgdGd0Qm9yZGVyVyA9IHRhcmdldC5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcbiAgICB2YXIgc3JjQm9yZGVyVyA9IHNvdXJjZS5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcblxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgXG4gICAgaWYgKGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2guZWRnZVR5cGUgPT0gJ3NlbGYnKSB7XG4gICAgICBcbiAgICAgIHZhciBjcCA9IFtycy5jcDJjeCwgcnMuY3AyY3ldO1xuICAgICAgXG4gICAgICBpbnRlcnNlY3QgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHRhcmdldCldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgodGFyZ2V0KSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHRhcmdldCksXG4gICAgICAgIGNwWzBdLFxuICAgICAgICBjcFsxXSwgXG4gICAgICAgIHRndEJvcmRlclcgLyAyXG4gICAgICApO1xuICAgICAgXG4gICAgICB2YXIgYXJyb3dFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uc3BhY2luZyhlZGdlKSk7XG4gICAgICB2YXIgZWRnZUVuZCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5nYXAoZWRnZSkpO1xuICAgICAgXG4gICAgICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgICAgIHJzLmVuZFkgPSBlZGdlRW5kWzFdO1xuICAgICAgXG4gICAgICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgICAgIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuICAgICAgXG4gICAgICB2YXIgY3AgPSBbcnMuY3AyYXgsIHJzLmNwMmF5XTtcblxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShzb3VyY2UpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHNvdXJjZSksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodChzb3VyY2UpLFxuICAgICAgICBjcFswXSwgLy9oYWxmUG9pbnRYLFxuICAgICAgICBjcFsxXSwgLy9oYWxmUG9pbnRZXG4gICAgICAgIHNyY0JvcmRlclcgLyAyXG4gICAgICApO1xuICAgICAgXG4gICAgICB2YXIgYXJyb3dTdGFydCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgICAgIHZhciBlZGdlU3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpKTtcbiAgICAgIFxuICAgICAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICAgICAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuXG5cbiAgICAgIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgICAgIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ3N0cmFpZ2h0Jykge1xuICAgIFxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHRhcmdldCksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodCh0YXJnZXQpLFxuICAgICAgICBzb3VyY2UucG9zaXRpb24oKS54LFxuICAgICAgICBzb3VyY2UucG9zaXRpb24oKS55LFxuICAgICAgICB0Z3RCb3JkZXJXIC8gMik7XG4gICAgICAgIFxuICAgICAgaWYgKGludGVyc2VjdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcnMubm9BcnJvd1BsYWNlbWVudCA9IHRydWU7XG4gIC8vICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMubm9BcnJvd1BsYWNlbWVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgYXJyb3dFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LFxuICAgICAgICBbc291cmNlLnBvc2l0aW9uKCkueCwgc291cmNlLnBvc2l0aW9uKCkueV0sXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLnNwYWNpbmcoZWRnZSkpO1xuICAgICAgdmFyIGVkZ2VFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LFxuICAgICAgICBbc291cmNlLnBvc2l0aW9uKCkueCwgc291cmNlLnBvc2l0aW9uKCkueV0sXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSk7XG5cbiAgICAgIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICAgICAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gICAgICBcbiAgICAgIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICAgICAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG4gICAgXG4gICAgICBpbnRlcnNlY3QgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgoc291cmNlKSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHNvdXJjZSksXG4gICAgICAgIHRhcmdldC5wb3NpdGlvbigpLngsXG4gICAgICAgIHRhcmdldC5wb3NpdGlvbigpLnksXG4gICAgICAgIHNyY0JvcmRlclcgLyAyKTtcbiAgICAgIFxuICAgICAgaWYgKGludGVyc2VjdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcnMubm9BcnJvd1BsYWNlbWVudCA9IHRydWU7XG4gIC8vICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMubm9BcnJvd1BsYWNlbWVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKlxuICAgICAgY29uc29sZS5sb2coXCIxOiBcIlxuICAgICAgICArIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLFxuICAgICAgICAgIHNyY0FyU2hhcGUpO1xuICAgICAgKi9cbiAgICAgIHZhciBhcnJvd1N0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCxcbiAgICAgICAgW3RhcmdldC5wb3NpdGlvbigpLngsIHRhcmdldC5wb3NpdGlvbigpLnldLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgICAgIHZhciBlZGdlU3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LFxuICAgICAgICBbdGFyZ2V0LnBvc2l0aW9uKCkueCwgdGFyZ2V0LnBvc2l0aW9uKCkueV0sXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLmdhcChlZGdlKSk7XG5cbiAgICAgIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgICAgIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcbiAgICAgIFxuICAgICAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICAgICAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuICAgICAgICAgICAgXG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PSAnYmV6aWVyJykge1xuICAgICAgLy8gaWYoIHdpbmRvdy5iYWRBcnJvdykgZGVidWdnZXI7XG4gICAgICB2YXIgY3AgPSBbcnMuY3AyeCwgcnMuY3AyeV07XG4gICAgICBcbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVNoYXBlKHRhcmdldCldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgodGFyZ2V0KSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHRhcmdldCksXG4gICAgICAgIGNwWzBdLCAvL2hhbGZQb2ludFgsXG4gICAgICAgIGNwWzFdLCAvL2hhbGZQb2ludFlcbiAgICAgICAgdGd0Qm9yZGVyVyAvIDJcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8qXG4gICAgICBjb25zb2xlLmxvZyhcIjI6IFwiXG4gICAgICAgICsgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0sXG4gICAgICAgICAgc3JjQXJTaGFwZSk7XG4gICAgICAqL1xuICAgICAgdmFyIGFycm93RW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLnNwYWNpbmcoZWRnZSkpO1xuICAgICAgdmFyIGVkZ2VFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uZ2FwKGVkZ2UpKTtcbiAgICAgIFxuICAgICAgcnMuZW5kWCA9IGVkZ2VFbmRbMF07XG4gICAgICBycy5lbmRZID0gZWRnZUVuZFsxXTtcbiAgICAgIFxuICAgICAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gICAgICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcbiAgICAgIFxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1tcbiAgICAgICAgdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICB0aGlzLmdldE5vZGVXaWR0aChzb3VyY2UpLFxuICAgICAgICB0aGlzLmdldE5vZGVIZWlnaHQoc291cmNlKSxcbiAgICAgICAgY3BbMF0sIC8vaGFsZlBvaW50WCxcbiAgICAgICAgY3BbMV0sIC8vaGFsZlBvaW50WVxuICAgICAgICBzcmNCb3JkZXJXIC8gMlxuICAgICAgKTtcbiAgICAgIFxuICAgICAgdmFyIGFycm93U3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oXG4gICAgICAgIGludGVyc2VjdCwgXG4gICAgICAgIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpXG4gICAgICApO1xuICAgICAgdmFyIGVkZ2VTdGFydCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICAgICAgaW50ZXJzZWN0LCBcbiAgICAgICAgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLmdhcChlZGdlKVxuICAgICAgKTtcbiAgICBcbiAgICAgIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgICAgIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcbiAgICAgIFxuICAgICAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICAgICAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuICAgICAgXG4gICAgICAvLyBpZiggaXNOYU4ocnMuc3RhcnRYKSB8fCBpc05hTihycy5zdGFydFkpICl7XG4gICAgICAvLyAgIGRlYnVnZ2VyO1xuICAgICAgLy8gfVxuXG4gICAgfSBlbHNlIGlmIChycy5pc0FyY0VkZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgLy8gRmluZCBhZGphY2VudCBlZGdlc1xuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZmluZEVkZ2VzID0gZnVuY3Rpb24obm9kZVNldCkge1xuICAgIFxuICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICBcbiAgICB2YXIgaGFzaFRhYmxlID0ge307XG4gICAgdmFyIGFkamFjZW50RWRnZXMgPSBbXTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2hUYWJsZVtub2RlU2V0W2ldLl9wcml2YXRlLmRhdGEuaWRdID0gbm9kZVNldFtpXTtcbiAgICB9XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc2hUYWJsZVtlZGdlc1tpXS5fcHJpdmF0ZS5kYXRhLnNvdXJjZV1cbiAgICAgICAgfHwgaGFzaFRhYmxlW2VkZ2VzW2ldLl9wcml2YXRlLmRhdGEudGFyZ2V0XSkge1xuICAgICAgICBcbiAgICAgICAgYWRqYWNlbnRFZGdlcy5wdXNoKGVkZ2VzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGFkamFjZW50RWRnZXM7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldEFycm93V2lkdGggPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0QXJyb3dIZWlnaHQgPSBmdW5jdGlvbihlZGdlV2lkdGgpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlIHx8IHt9O1xuXG4gICAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2VkZ2VXaWR0aF07XG4gICAgaWYoIGNhY2hlZFZhbCApe1xuICAgICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgICB9XG5cbiAgICBjYWNoZWRWYWwgPSAgTWF0aC5tYXgoTWF0aC5wb3coZWRnZVdpZHRoICogMTMuMzcsIDAuOSksIDI5KTtcbiAgICBjYWNoZVtlZGdlV2lkdGhdID0gY2FjaGVkVmFsO1xuXG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfTtcblxuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuXG4vLyBEcmF3IGVkZ2VcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRyYXdFZGdlID0gZnVuY3Rpb24oY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuXG4gICAgLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcbiAgICBpZiggcnMuYmFkQmV6aWVyIHx8ICggKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JykgJiYgaXNOYU4ocnMuc3RhcnRYKSkgKXsgLy8gZXh0cmEgaXNOYU4oKSBmb3Igc2FmYXJpIDcuMSBiL2MgaXQgbWFuZ2xlcyBjdHJscHQgY2FsY3NcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgIFxuICAgIC8vIEVkZ2UgbGluZSB3aWR0aFxuICAgIGlmIChzdHlsZVsnd2lkdGgnXS5weFZhbHVlIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3ZlcmxheVBhZGRpbmcgPSBzdHlsZVsnb3ZlcmxheS1wYWRkaW5nJ10ucHhWYWx1ZTtcbiAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSBzdHlsZVsnb3ZlcmxheS1vcGFjaXR5J10udmFsdWU7XG4gICAgdmFyIG92ZXJsYXlDb2xvciA9IHN0eWxlWydvdmVybGF5LWNvbG9yJ10udmFsdWU7XG5cbiAgICAvLyBFZGdlIGNvbG9yICYgb3BhY2l0eVxuICAgIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgKXtcblxuICAgICAgaWYoIG92ZXJsYXlPcGFjaXR5ID09PSAwICl7IC8vIGV4aXQgZWFybHkgaWYgbm8gb3ZlcmxheVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3Ryb2tlU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkpO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgICAgaWYoIGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2guZWRnZVR5cGUgPT0gJ3NlbGYnICYmICF1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxpbmVDb2xvciA9IHN0eWxlWydsaW5lLWNvbG9yJ10udmFsdWU7XG5cbiAgICAgIHRoaXMuc3Ryb2tlU3R5bGUoY29udGV4dCwgbGluZUNvbG9yWzBdLCBsaW5lQ29sb3JbMV0sIGxpbmVDb2xvclsyXSwgc3R5bGUub3BhY2l0eS52YWx1ZSk7XG4gICAgICBcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgXG4gICAgfVxuICAgIFxuICAgIHZhciBzdGFydE5vZGUsIGVuZE5vZGUsIHNvdXJjZSwgdGFyZ2V0O1xuICAgIHNvdXJjZSA9IHN0YXJ0Tm9kZSA9IGVkZ2UuX3ByaXZhdGUuc291cmNlO1xuICAgIHRhcmdldCA9IGVuZE5vZGUgPSBlZGdlLl9wcml2YXRlLnRhcmdldDtcblxuICAgIHZhciB0YXJnZXRQb3MgPSB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb247XG4gICAgdmFyIHRhcmdldFcgPSB0YXJnZXQud2lkdGgoKTtcbiAgICB2YXIgdGFyZ2V0SCA9IHRhcmdldC5oZWlnaHQoKTtcbiAgICB2YXIgc291cmNlUG9zID0gc291cmNlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgIHZhciBzb3VyY2VXID0gc291cmNlLndpZHRoKCk7XG4gICAgdmFyIHNvdXJjZUggPSBzb3VyY2UuaGVpZ2h0KCk7XG5cblxuICAgIHZhciBlZGdlV2lkdGggPSBzdHlsZVsnd2lkdGgnXS5weFZhbHVlICsgKGRyYXdPdmVybGF5SW5zdGVhZCA/IDIgKiBvdmVybGF5UGFkZGluZyA6IDApO1xuICAgIHZhciBsaW5lU3R5bGUgPSBkcmF3T3ZlcmxheUluc3RlYWQgPyAnc29saWQnIDogc3R5bGVbJ2xpbmUtc3R5bGUnXS52YWx1ZTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGVkZ2VXaWR0aDtcbiAgICBcbiAgICBpZiggcnMuZWRnZVR5cGUgIT09ICdoYXlzdGFjaycgKXtcbiAgICAgIC8vdGhpcy5maW5kRW5kcG9pbnRzKGVkZ2UpO1xuICAgIH1cbiAgICBcbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgIHZhciByYWRpdXMgPSBzdHlsZVsnaGF5c3RhY2stcmFkaXVzJ10udmFsdWU7XG4gICAgICB2YXIgaGFsZlJhZGl1cyA9IHJhZGl1cy8yOyAvLyBiL2MgaGF2ZSB0byBoYWxmIHdpZHRoL2hlaWdodFxuXG4gICAgICB0aGlzLmRyYXdTdHlsZWRFZGdlKFxuICAgICAgICBlZGdlLCBcbiAgICAgICAgY29udGV4dCwgXG4gICAgICAgIHJzLmhheXN0YWNrUHRzID0gW1xuICAgICAgICAgIHJzLnNvdXJjZS54ICogc291cmNlVyAqIGhhbGZSYWRpdXMgKyBzb3VyY2VQb3MueCxcbiAgICAgICAgICBycy5zb3VyY2UueSAqIHNvdXJjZUggKiBoYWxmUmFkaXVzICsgc291cmNlUG9zLnksXG4gICAgICAgICAgcnMudGFyZ2V0LnggKiB0YXJnZXRXICogaGFsZlJhZGl1cyArIHRhcmdldFBvcy54LFxuICAgICAgICAgIHJzLnRhcmdldC55ICogdGFyZ2V0SCAqIGhhbGZSYWRpdXMgKyB0YXJnZXRQb3MueVxuICAgICAgICBdLFxuICAgICAgICBsaW5lU3R5bGUsXG4gICAgICAgIGVkZ2VXaWR0aFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VsZicpIHtcbiAgICAgIFxuICAgICAgdmFyIGRldGFpbHMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgdmFyIHBvaW50cyA9IFtkZXRhaWxzLnN0YXJ0WCwgZGV0YWlscy5zdGFydFksIGRldGFpbHMuY3AyYXgsXG4gICAgICAgIGRldGFpbHMuY3AyYXksIGRldGFpbHMuc2VsZkVkZ2VNaWRYLCBkZXRhaWxzLnNlbGZFZGdlTWlkWSxcbiAgICAgICAgZGV0YWlscy5zZWxmRWRnZU1pZFgsIGRldGFpbHMuc2VsZkVkZ2VNaWRZLFxuICAgICAgICBkZXRhaWxzLmNwMmN4LCBkZXRhaWxzLmNwMmN5LCBkZXRhaWxzLmVuZFgsIGRldGFpbHMuZW5kWV07XG5cbiAgICAgIHZhciBkZXRhaWxzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHRoaXMuZHJhd1N0eWxlZEVkZ2UoZWRnZSwgY29udGV4dCwgcG9pbnRzLCBsaW5lU3R5bGUsIGVkZ2VXaWR0aCk7XG4gICAgICBcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnKSB7XG4gICAgICBcbiAgICAgIHZhciBub2RlRGlyZWN0aW9uWCA9IGVuZE5vZGUuX3ByaXZhdGUucG9zaXRpb24ueCAtIHN0YXJ0Tm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54O1xuICAgICAgdmFyIG5vZGVEaXJlY3Rpb25ZID0gZW5kTm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi55IC0gc3RhcnROb2RlLl9wcml2YXRlLnBvc2l0aW9uLnk7XG4gICAgICBcbiAgICAgIHZhciBlZGdlRGlyZWN0aW9uWCA9IHJzLmVuZFggLSBycy5zdGFydFg7XG4gICAgICB2YXIgZWRnZURpcmVjdGlvblkgPSBycy5lbmRZIC0gcnMuc3RhcnRZO1xuICAgICAgXG4gICAgICBpZiAobm9kZURpcmVjdGlvblggKiBlZGdlRGlyZWN0aW9uWFxuICAgICAgICArIG5vZGVEaXJlY3Rpb25ZICogZWRnZURpcmVjdGlvblkgPCAwKSB7XG4gICAgICAgIFxuICAgICAgICBycy5zdHJhaWdodEVkZ2VUb29TaG9ydCA9IHRydWU7ICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgZGV0YWlscyA9IHJzO1xuICAgICAgICB0aGlzLmRyYXdTdHlsZWRFZGdlKGVkZ2UsIGNvbnRleHQsIFtkZXRhaWxzLnN0YXJ0WCwgZGV0YWlscy5zdGFydFksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMuZW5kWCwgZGV0YWlscy5lbmRZXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlV2lkdGgpO1xuICAgICAgICBcbiAgICAgICAgcnMuc3RyYWlnaHRFZGdlVG9vU2hvcnQgPSBmYWxzZTsgIFxuICAgICAgfSAgXG4gICAgfSBlbHNlIHtcbiAgICAgIFxuICAgICAgdmFyIGRldGFpbHMgPSBycztcbiAgICAgIFxuICAgICAgdGhpcy5kcmF3U3R5bGVkRWRnZShlZGdlLCBjb250ZXh0LCBbZGV0YWlscy5zdGFydFgsIGRldGFpbHMuc3RhcnRZLFxuICAgICAgICBkZXRhaWxzLmNwMngsIGRldGFpbHMuY3AyeSwgZGV0YWlscy5lbmRYLCBkZXRhaWxzLmVuZFldLFxuICAgICAgICBsaW5lU3R5bGUsXG4gICAgICAgIGVkZ2VXaWR0aCk7XG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snICl7XG4gICAgICB0aGlzLmRyYXdBcnJvd2hlYWRzKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCk7XG4gICAgfSBlbHNlIGlmICggcnMubm9BcnJvd1BsYWNlbWVudCAhPT0gdHJ1ZSAmJiBycy5zdGFydFggIT09IHVuZGVmaW5lZCApe1xuICAgICAgdGhpcy5kcmF3QXJyb3doZWFkcyhjb250ZXh0LCBlZGdlLCBkcmF3T3ZlcmxheUluc3RlYWQpO1xuICAgIH1cblxuICB9O1xuICBcbiAgXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kcmF3U3R5bGVkRWRnZSA9IGZ1bmN0aW9uKFxuICAgICAgZWRnZSwgY29udGV4dCwgcHRzLCB0eXBlLCB3aWR0aCkge1xuXG4gICAgLy8gMyBwb2ludHMgZ2l2ZW4gLT4gYXNzdW1lIEJlemllclxuICAgIC8vIDIgLT4gYXNzdW1lIHN0cmFpZ2h0XG4gICAgXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FudmFzQ3h0ID0gY29udGV4dDtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcblxuXG4gICAgaWYoIHVzZVBhdGhzICl7XG5cbiAgICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBwdHM7XG4gICAgICB2YXIga2V5TGVuZ3RoTWF0Y2hlcyA9IHJzLnBhdGhDYWNoZUtleSAmJiBwYXRoQ2FjaGVLZXkubGVuZ3RoID09PSBycy5wYXRoQ2FjaGVLZXkubGVuZ3RoO1xuICAgICAgdmFyIGtleU1hdGNoZXMgPSBrZXlMZW5ndGhNYXRjaGVzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsga2V5TWF0Y2hlcyAmJiBpIDwgcGF0aENhY2hlS2V5Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCBycy5wYXRoQ2FjaGVLZXlbaV0gIT09IHBhdGhDYWNoZUtleVtpXSApe1xuICAgICAgICAgIGtleU1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZigga2V5TWF0Y2hlcyApe1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBycy5wYXRoQ2FjaGVLZXkgPSBwYXRoQ2FjaGVLZXk7XG4gICAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiggY2FudmFzQ3h0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIDYsIDMgXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCAhcGF0aENhY2hlSGl0ICl7XG4gICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuICAgICAgY29udGV4dC5tb3ZlVG8ocHRzWzBdLCBwdHNbMV0pO1xuICAgICAgXG4gICAgICBpZiAocHRzLmxlbmd0aCA9PT0gMyAqIDIpIHsgLy8gYmV6aWVyXG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwdHNbMl0sIHB0c1szXSwgcHRzWzRdLCBwdHNbNV0pO1xuICAgICAgfSBlbHNlIGlmKCBwdHMubGVuZ3RoID09PSAzICogMiAqIDIgKXsgLy8gZG91YmxlIGJlemllciBsb29wXG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwdHNbMl0sIHB0c1szXSwgcHRzWzRdLCBwdHNbNV0pO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzWzhdLCBwdHNbOV0sIHB0c1sxMF0sIHB0c1sxMV0pO1xuICAgICAgfSBlbHNlIHsgLy8gbGluZVxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdHNbMl0sIHB0c1szXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNhbnZhc0N4dDtcbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICBcbiAgICAvLyByZXNldCBhbnkgbGluZSBkYXNoZXNcbiAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICB9XG5cbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbihjb250ZXh0LCBlZGdlLCBkcmF3T3ZlcmxheUluc3RlYWQpIHtcbiAgICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkICl7IHJldHVybjsgfSAvLyBkb24ndCBkbyBhbnl0aGluZyBmb3Igb3ZlcmxheXMgXG5cbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuXG4gICAgLy8gRGlzcGxhY2VtZW50IGdpdmVzIGRpcmVjdGlvbiBmb3IgYXJyb3doZWFkIG9yaWVudGF0aW9uXG4gICAgdmFyIGRpc3BYLCBkaXNwWTtcbiAgICB2YXIgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFk7XG5cbiAgICB2YXIgc3JjUG9zID0gZWRnZS5zb3VyY2UoKS5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RQb3MgPSBlZGdlLnRhcmdldCgpLnBvc2l0aW9uKCk7XG5cbiAgICBpZiggaXNIYXlzdGFjayApe1xuICAgICAgc3RhcnRYID0gcnMuaGF5c3RhY2tQdHNbMF07XG4gICAgICBzdGFydFkgPSBycy5oYXlzdGFja1B0c1sxXTtcbiAgICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICAgIGVuZFkgPSBycy5oYXlzdGFja1B0c1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgICBzdGFydFkgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICAgIGVuZFggPSBycy5hcnJvd0VuZFg7XG4gICAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgXG4gICAgZnVuY3Rpb24gZHJhd0Fycm93aGVhZCggcHJlZml4LCB4LCB5LCBkaXNwWCwgZGlzcFkgKXtcbiAgICAgIHZhciBhcnJvd1NoYXBlID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1zaGFwZSddLnZhbHVlO1xuXG4gICAgICBpZiggYXJyb3dTaGFwZSA9PT0gJ25vbmUnICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuXG4gICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgXG4gICAgICBzZWxmLmZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAxKTtcblxuXG4gICAgICB2YXIgYXJyb3dDbGVhckZpbGwgPSBzdHlsZVtwcmVmaXggKyAnLWFycm93LWZpbGwnXS52YWx1ZSA9PT0gJ2hvbGxvdycgPyAnYm90aCcgOiAnZmlsbGVkJztcbiAgICAgIHZhciBhcnJvd0ZpbGwgPSBzdHlsZVtwcmVmaXggKyAnLWFycm93LWZpbGwnXS52YWx1ZTtcblxuICAgICAgaWYoIGFycm93U2hhcGUgPT09ICdoYWxmLXRyaWFuZ2xlLW92ZXJzaG90JyApe1xuICAgICAgICBhcnJvd0ZpbGwgPSAnaG9sbG93JztcbiAgICAgICAgYXJyb3dDbGVhckZpbGwgPSAnaG9sbG93JztcbiAgICAgIH1cblxuICAgICAgc2VsZi5kcmF3QXJyb3dTaGFwZSggZWRnZSwgcHJlZml4LCBjb250ZXh0LCBcbiAgICAgICAgYXJyb3dDbGVhckZpbGwsIHN0eWxlWyd3aWR0aCddLnB4VmFsdWUsIHN0eWxlW3ByZWZpeCArICctYXJyb3ctc2hhcGUnXS52YWx1ZSwgXG4gICAgICAgIHgsIHksIGRpc3BYLCBkaXNwWVxuICAgICAgKTtcblxuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG5cbiAgICAgIHZhciBjb2xvciA9IHN0eWxlW3ByZWZpeCArICctYXJyb3ctY29sb3InXS52YWx1ZTtcbiAgICAgIHNlbGYuZmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIHN0eWxlLm9wYWNpdHkudmFsdWUpO1xuXG4gICAgICBzZWxmLmRyYXdBcnJvd1NoYXBlKCBlZGdlLCBwcmVmaXgsIGNvbnRleHQsIFxuICAgICAgICBhcnJvd0ZpbGwsIHN0eWxlWyd3aWR0aCddLnB4VmFsdWUsIHN0eWxlW3ByZWZpeCArICctYXJyb3ctc2hhcGUnXS52YWx1ZSwgXG4gICAgICAgIHgsIHksIGRpc3BYLCBkaXNwWVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBkaXNwWCA9IHN0YXJ0WCAtIHNyY1Bvcy54O1xuICAgIGRpc3BZID0gc3RhcnRZIC0gc3JjUG9zLnk7XG5cbiAgICBpZiggIWlzSGF5c3RhY2sgJiYgIWlzTmFOKHN0YXJ0WCkgJiYgIWlzTmFOKHN0YXJ0WSkgJiYgIWlzTmFOKGRpc3BYKSAmJiAhaXNOYU4oZGlzcFkpICl7XG4gICAgICBkcmF3QXJyb3doZWFkKCAnc291cmNlJywgc3RhcnRYLCBzdGFydFksIGRpc3BYLCBkaXNwWSApO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdpbmRvdy5iYWRBcnJvdyA9IHRydWU7XG4gICAgICAvLyBkZWJ1Z2dlcjtcbiAgICB9XG4gICAgXG4gICAgdmFyIG1pZFggPSBycy5taWRYO1xuICAgIHZhciBtaWRZID0gcnMubWlkWTtcblxuICAgIGlmKCBpc0hheXN0YWNrICl7XG4gICAgICBtaWRYID0gKCBzdGFydFggKyBlbmRYICkvMjtcbiAgICAgIG1pZFkgPSAoIHN0YXJ0WSArIGVuZFkgKS8yO1xuICAgIH1cblxuICAgIGRpc3BYID0gc3RhcnRYIC0gZW5kWDtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIGVuZFk7XG5cbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdzZWxmJyApe1xuICAgICAgZGlzcFggPSAxO1xuICAgICAgZGlzcFkgPSAtMTtcbiAgICB9XG5cbiAgICBpZiggIWlzTmFOKG1pZFgpICYmICFpc05hTihtaWRZKSApe1xuICAgICAgZHJhd0Fycm93aGVhZCggJ21pZC10YXJnZXQnLCBtaWRYLCBtaWRZLCBkaXNwWCwgZGlzcFkgKTtcbiAgICB9XG5cbiAgICBkaXNwWCAqPSAtMTtcbiAgICBkaXNwWSAqPSAtMTtcblxuICAgIGlmKCAhaXNOYU4obWlkWCkgJiYgIWlzTmFOKG1pZFkpICl7XG4gICAgICBkcmF3QXJyb3doZWFkKCAnbWlkLXNvdXJjZScsIG1pZFgsIG1pZFksIGRpc3BYLCBkaXNwWSApO1xuICAgIH1cbiAgICBcbiAgICBkaXNwWCA9IGVuZFggLSB0Z3RQb3MueDtcbiAgICBkaXNwWSA9IGVuZFkgLSB0Z3RQb3MueTtcbiAgICBcbiAgICBpZiggIWlzSGF5c3RhY2sgJiYgIWlzTmFOKGVuZFgpICYmICFpc05hTihlbmRZKSAmJiAhaXNOYU4oZGlzcFgpICYmICFpc05hTihkaXNwWSkgKXtcbiAgICAgIGRyYXdBcnJvd2hlYWQoICd0YXJnZXQnLCBlbmRYLCBlbmRZLCBkaXNwWCwgZGlzcFkgKTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBEcmF3IGFycm93c2hhcGVcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRyYXdBcnJvd1NoYXBlID0gZnVuY3Rpb24oZWRnZSwgYXJyb3dUeXBlLCBjb250ZXh0LCBmaWxsLCBlZGdlV2lkdGgsIHNoYXBlLCB4LCB5LCBkaXNwWCwgZGlzcFkpIHtcbiAgICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICAgIHZhciBwYXRoO1xuICAgIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgICB2YXIgdHJhbnNsYXRpb24gPSB7IHg6IHgsIHk6IHkgfTtcblxuICAgIC8vIE5lZ2F0aXZlIG9mIHRoZSBhbmdsZVxuICAgIHZhciBhbmdsZSA9IE1hdGguYXNpbihkaXNwWSAvIChNYXRoLnNxcnQoZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkpKSk7XG4gIFxuICAgIGlmIChkaXNwWCA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtIChNYXRoLlBJIC8gMiArIGFuZ2xlKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHNpemUgPSB0aGlzLmdldEFycm93V2lkdGgoIGVkZ2VXaWR0aCApO1xuICAgIHZhciBzaGFwZUltcGwgPSBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzaGFwZV07XG5cbiAgICAvLyBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcblxuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgdmFyIHBhdGhDYWNoZUtleSA9IHNpemUgKyAnJCcgKyBzaGFwZSArICckJyArIGFuZ2xlICsgJyQnICsgeCArICckJyArIHk7XG4gICAgICBycy5hcnJvd1BhdGhDYWNoZUtleSA9IHJzLmFycm93UGF0aENhY2hlS2V5IHx8IHt9O1xuICAgICAgcnMuYXJyb3dQYXRoQ2FjaGUgPSBycy5hcnJvd1BhdGhDYWNoZSB8fCB7fTtcblxuICAgICAgdmFyIGFscmVhZHlDYWNoZWQgPSBycy5hcnJvd1BhdGhDYWNoZUtleVthcnJvd1R5cGVdID09PSBwYXRoQ2FjaGVLZXk7XG4gICAgICBpZiggYWxyZWFkeUNhY2hlZCApe1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IHJzLmFycm93UGF0aENhY2hlW2Fycm93VHlwZV07XG4gICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgcnMuYXJyb3dQYXRoQ2FjaGVLZXlbYXJyb3dUeXBlXSA9IHBhdGhDYWNoZUtleTtcbiAgICAgICAgcnMuYXJyb3dQYXRoQ2FjaGVbYXJyb3dUeXBlXSA9IHBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgIGlmKCAhcGF0aENhY2hlSGl0ICl7XG4gICAgICBzaGFwZUltcGwuZHJhdyhjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pO1xuICAgIH1cbiAgICBcbiAgICBpZiggIXNoYXBlSW1wbC5sZWF2ZVBhdGhPcGVuICYmIGNvbnRleHQuY2xvc2VQYXRoICl7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIGNvbnRleHQgPSBjYW52YXNDb250ZXh0O1xuXG4gICAgaWYoIGZpbGwgPT09ICdmaWxsZWQnIHx8IGZpbGwgPT09ICdib3RoJyApe1xuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIGZpbGwgPT09ICdob2xsb3cnIHx8IGZpbGwgPT09ICdib3RoJyApe1xuICAgICAgY29udGV4dC5saW5lV2lkdGggPSAoIHNoYXBlSW1wbC5tYXRjaEVkZ2VXaWR0aCA/IGVkZ2VXaWR0aCA6IDEgKTtcbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG5cbiAgICAvLyBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q2FjaGVkSW1hZ2UgPSBmdW5jdGlvbih1cmwsIG9uTG9hZCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSB8fCB7fTtcblxuICAgIGlmKCBpbWFnZUNhY2hlW3VybF0gJiYgaW1hZ2VDYWNoZVt1cmxdLmltYWdlICl7XG4gICAgICByZXR1cm4gaW1hZ2VDYWNoZVt1cmxdLmltYWdlO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY2FjaGUgPSBpbWFnZUNhY2hlW3VybF0gPSBpbWFnZUNhY2hlW3VybF0gfHwge307XG5cbiAgICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICBcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH07XG4gICAgXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kcmF3SW5zY3JpYmVkSW1hZ2UgPSBmdW5jdGlvbihjb250ZXh0LCBpbWcsIG5vZGUpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIG5vZGVYID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54O1xuICAgIHZhciBub2RlWSA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueTtcbiAgICB2YXIgc3R5bGUgPSBub2RlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBmaXQgPSBzdHlsZVsnYmFja2dyb3VuZC1maXQnXS52YWx1ZTtcbiAgICB2YXIgeFBvcyA9IHN0eWxlWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnXTtcbiAgICB2YXIgeVBvcyA9IHN0eWxlWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXknXTtcbiAgICB2YXIgcmVwZWF0ID0gc3R5bGVbJ2JhY2tncm91bmQtcmVwZWF0J10udmFsdWU7XG4gICAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICAgIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gICAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2xpcCA9IHN0eWxlWydiYWNrZ3JvdW5kLWNsaXAnXS52YWx1ZTtcbiAgICB2YXIgc2hvdWxkQ2xpcCA9IGNsaXAgPT09ICdub2RlJztcbiAgICB2YXIgaW1nT3BhY2l0eSA9IHN0eWxlWydiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknXS52YWx1ZTtcbiAgICBcbiAgICB2YXIgdyA9IGltZy53aWR0aDtcbiAgICB2YXIgaCA9IGltZy5oZWlnaHQ7XG5cbiAgICBpZiggdyA9PT0gMCB8fCBoID09PSAwICl7XG4gICAgICByZXR1cm47IC8vIG5vIHBvaW50IGluIGRyYXdpbmcgZW1wdHkgaW1hZ2UgKGFuZCBjaHJvbWUgaXMgYnJva2VuIGluIHRoaXMgY2FzZSlcbiAgICB9XG5cbiAgICBpZiggZml0ID09PSAnY29udGFpbicgKXtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKCBub2RlVy93LCBub2RlSC9oICk7XG5cbiAgICAgIHcgKj0gc2NhbGU7XG4gICAgICBoICo9IHNjYWxlO1xuXG4gICAgfSBlbHNlIGlmKCBmaXQgPT09ICdjb3ZlcicgKXtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KCBub2RlVy93LCBub2RlSC9oICk7XG5cbiAgICAgIHcgKj0gc2NhbGU7XG4gICAgICBoICo9IHNjYWxlO1xuICAgIH1cblxuICAgIHZhciB4ID0gKG5vZGVYIC0gbm9kZVcvMik7IC8vIGxlZnRcbiAgICBpZiggeFBvcy51bml0cyA9PT0gJyUnICl7XG4gICAgICB4ICs9IChub2RlVyAtIHcpICogeFBvcy52YWx1ZS8xMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0geFBvcy5weFZhbHVlO1xuICAgIH1cblxuICAgIHZhciB5ID0gKG5vZGVZIC0gbm9kZUgvMik7IC8vIHRvcFxuICAgIGlmKCB5UG9zLnVuaXRzID09PSAnJScgKXtcbiAgICAgIHkgKz0gKG5vZGVIIC0gaCkgKiB5UG9zLnZhbHVlLzEwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeSArPSB5UG9zLnB4VmFsdWU7XG4gICAgfVxuXG4gICAgaWYoIHJzLnBhdGhDYWNoZSApe1xuICAgICAgeCAtPSBub2RlWDtcbiAgICAgIHkgLT0gbm9kZVk7XG5cbiAgICAgIG5vZGVYID0gMDtcbiAgICAgIG5vZGVZID0gMDtcbiAgICB9XG5cbiAgICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBpbWdPcGFjaXR5O1xuXG4gICAgaWYoIHJlcGVhdCA9PT0gJ25vLXJlcGVhdCcgKXtcblxuICAgICAgaWYoIHNob3VsZENsaXAgKXtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgaWYoIHJzLnBhdGhDYWNoZSApe1xuICAgICAgICAgIGNvbnRleHQuY2xpcCggcnMucGF0aENhY2hlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhd1BhdGgoXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgICAgIG5vZGVXLCBub2RlSCk7XG5cbiAgICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1nLCAwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIHgsIHksIHcsIGggKTtcblxuICAgICAgaWYoIHNob3VsZENsaXAgKXtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKCBpbWcsIHJlcGVhdCApO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuXG4gICAgICBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3UGF0aChcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5vZGVYLCBub2RlWSwgXG4gICAgICAgICAgbm9kZVcsIG5vZGVIKTtcblxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGdBbHBoYTtcbiAgICBcbiAgfTtcblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuXG4gIC8vIERyYXcgZWRnZSB0ZXh0XG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kcmF3RWRnZVRleHQgPSBmdW5jdGlvbihjb250ZXh0LCBlZGdlKSB7XG4gICAgdmFyIHRleHQgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG5cbiAgICBpZiggIXRleHQgfHwgdGV4dC5tYXRjaCgvXlxccyskLykgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiggdGhpcy5oaWRlRWRnZXNPblZpZXdwb3J0ICYmICh0aGlzLmRyYWdEYXRhLmRpZERyYWcgfHwgdGhpcy5waW5jaGluZyB8fCB0aGlzLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCB0aGlzLmRhdGEud2hlZWwgfHwgdGhpcy5zd2lwZVBhbm5pbmcpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyBvbiBwaW5jaGluZ1xuXG4gICAgdmFyIGNvbXB1dGVkU2l6ZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ2ZvbnQtc2l6ZSddLnB4VmFsdWUgKiBlZGdlLmN5KCkuem9vbSgpO1xuICAgIHZhciBtaW5TaXplID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnbWluLXpvb21lZC1mb250LXNpemUnXS5weFZhbHVlO1xuXG4gICAgaWYoIGNvbXB1dGVkU2l6ZSA8IG1pblNpemUgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIC8vIENhbGN1bGF0ZSB0ZXh0IGRyYXcgcG9zaXRpb25cbiAgICBcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgXG4gICAgLy8gdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb24oIGVkZ2UgKTtcbiAgICBcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHRoaXMuZHJhd1RleHQoY29udGV4dCwgZWRnZSwgcnMubGFiZWxYLCBycy5sYWJlbFkpO1xuICB9O1xuXG4gIC8vIERyYXcgbm9kZSB0ZXh0XG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kcmF3Tm9kZVRleHQgPSBmdW5jdGlvbihjb250ZXh0LCBub2RlKSB7XG4gICAgdmFyIHRleHQgPSBub2RlLl9wcml2YXRlLnN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG5cbiAgICBpZiAoICF0ZXh0IHx8IHRleHQubWF0Y2goL15cXHMrJC8pICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb21wdXRlZFNpemUgPSBub2RlLl9wcml2YXRlLnN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICogbm9kZS5jeSgpLnpvb20oKTtcbiAgICB2YXIgbWluU2l6ZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ21pbi16b29tZWQtZm9udC1zaXplJ10ucHhWYWx1ZTtcblxuICAgIGlmKCBjb21wdXRlZFNpemUgPCBtaW5TaXplICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICAgXG4gICAgLy8gdGhpcy5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24oIG5vZGUgKTtcblxuICAgIHZhciB0ZXh0SGFsaWduID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsndGV4dC1oYWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgdGV4dFZhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtdmFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgIHN3aXRjaCggdGV4dEhhbGlnbiApe1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIHN3aXRjaCggdGV4dFZhbGlnbiApe1xuICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIH1cblxuICAgIHRoaXMuZHJhd1RleHQoY29udGV4dCwgbm9kZSwgcnMubGFiZWxYLCBycy5sYWJlbFkpO1xuICB9O1xuICBcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldEZvbnRDYWNoZSA9IGZ1bmN0aW9uKGNvbnRleHQpe1xuICAgIHZhciBjYWNoZTtcblxuICAgIHRoaXMuZm9udENhY2hlcyA9IHRoaXMuZm9udENhY2hlcyB8fCBbXTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5mb250Q2FjaGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICBjYWNoZSA9IHRoaXMuZm9udENhY2hlc1tpXTtcblxuICAgICAgaWYoIGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQgKXtcbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhY2hlID0ge1xuICAgICAgY29udGV4dDogY29udGV4dFxuICAgIH07XG4gICAgdGhpcy5mb250Q2FjaGVzLnB1c2goY2FjaGUpO1xuXG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIC8vIHNldCB1cCBjYW52YXMgY29udGV4dCB3aXRoIGZvbnRcbiAgLy8gcmV0dXJucyB0cmFuc2Zvcm1lZCB0ZXh0IHN0cmluZ1xuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuc2V0dXBUZXh0U3R5bGUgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbWVudCApe1xuICAgIC8vIEZvbnQgc3R5bGVcbiAgICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZW1lbnQuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGxhYmVsU3R5bGUgPSBzdHlsZVsnZm9udC1zdHlsZSddLnN0clZhbHVlO1xuICAgIHZhciBsYWJlbFNpemUgPSBzdHlsZVsnZm9udC1zaXplJ10ucHhWYWx1ZSArICdweCc7XG4gICAgdmFyIGxhYmVsRmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gICAgdmFyIGxhYmVsV2VpZ2h0ID0gc3R5bGVbJ2ZvbnQtd2VpZ2h0J10uc3RyVmFsdWU7XG4gICAgdmFyIG9wYWNpdHkgPSBzdHlsZVsndGV4dC1vcGFjaXR5J10udmFsdWUgKiBzdHlsZVsnb3BhY2l0eSddLnZhbHVlICogcGFyZW50T3BhY2l0eTtcbiAgICB2YXIgb3V0bGluZU9wYWNpdHkgPSBzdHlsZVsndGV4dC1vdXRsaW5lLW9wYWNpdHknXS52YWx1ZSAqIG9wYWNpdHk7XG4gICAgdmFyIGNvbG9yID0gc3R5bGVbJ2NvbG9yJ10udmFsdWU7XG4gICAgdmFyIG91dGxpbmVDb2xvciA9IHN0eWxlWyd0ZXh0LW91dGxpbmUtY29sb3InXS52YWx1ZTtcblxuICAgIHZhciBmb250Q2FjaGVLZXkgPSBlbGVtZW50Ll9wcml2YXRlLmZvbnRLZXk7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5nZXRGb250Q2FjaGUoY29udGV4dCk7XG5cbiAgICBpZiggY2FjaGUua2V5ICE9PSBmb250Q2FjaGVLZXkgKXtcbiAgICAgIGNvbnRleHQuZm9udCA9IGxhYmVsU3R5bGUgKyAnICcgKyBsYWJlbFdlaWdodCArICcgJyArIGxhYmVsU2l6ZSArICcgJyArIGxhYmVsRmFtaWx5O1xuXG4gICAgICBjYWNoZS5rZXkgPSBmb250Q2FjaGVLZXk7XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSBTdHJpbmcoc3R5bGVbJ2NvbnRlbnQnXS52YWx1ZSk7XG4gICAgdmFyIHRleHRUcmFuc2Zvcm0gPSBzdHlsZVsndGV4dC10cmFuc2Zvcm0nXS52YWx1ZTtcbiAgICBcbiAgICBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbm9uZScpIHtcbiAgICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICdsb3dlcmNhc2UnKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGV4dCBkcmF3IHBvc2l0aW9uIGJhc2VkIG9uIHRleHQgYWxpZ25tZW50XG4gICAgXG4gICAgLy8gc28gdGV4dCBvdXRsaW5lcyBhcmVuJ3QgamFnZ2VkXG4gICAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XG5cbiAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcbiAgICBcbiAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIG91dGxpbmVDb2xvclswXSwgb3V0bGluZUNvbG9yWzFdLCBvdXRsaW5lQ29sb3JbMl0sIG91dGxpbmVPcGFjaXR5KTtcblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIC8vIERyYXcgdGV4dFxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd1RleHQgPSBmdW5jdGlvbihjb250ZXh0LCBlbGVtZW50LCB0ZXh0WCwgdGV4dFkpIHtcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50Ll9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlbWVudC5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gICAgaWYoIHBhcmVudE9wYWNpdHkgPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdGV4dCA9IHRoaXMuc2V0dXBUZXh0U3R5bGUoIGNvbnRleHQsIGVsZW1lbnQgKTtcbiAgICBcbiAgICBpZiAoIHRleHQgIT0gbnVsbCAmJiAhaXNOYU4odGV4dFgpICYmICFpc05hTih0ZXh0WSkgKSB7XG4gICAgIFxuICAgICAgdmFyIGxpbmVXaWR0aCA9IDIgICogc3R5bGVbJ3RleHQtb3V0bGluZS13aWR0aCddLnZhbHVlOyAvLyAqMiBiL2MgdGhlIHN0cm9rZSBpcyBkcmF3biBjZW50cmVkIG9uIHRoZSBtaWRkbGVcbiAgICAgIGlmIChsaW5lV2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQodGV4dCwgdGV4dFgsIHRleHRZKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB0ZXh0WCwgdGV4dFkpO1xuICAgIH1cbiAgfTtcblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuXG4gIC8vIERyYXcgbm9kZVxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd05vZGUgPSBmdW5jdGlvbihjb250ZXh0LCBub2RlLCBkcmF3T3ZlcmxheUluc3RlYWQpIHtcblxuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgbm9kZVdpZHRoLCBub2RlSGVpZ2h0O1xuICAgIHZhciBzdHlsZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBcbiAgICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuICAgIHZhciBjYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG5cbiAgICB2YXIgb3ZlcmxheVBhZGRpbmcgPSBzdHlsZVsnb3ZlcmxheS1wYWRkaW5nJ10ucHhWYWx1ZTtcbiAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSBzdHlsZVsnb3ZlcmxheS1vcGFjaXR5J10udmFsdWU7XG4gICAgdmFyIG92ZXJsYXlDb2xvciA9IHN0eWxlWydvdmVybGF5LWNvbG9yJ10udmFsdWU7XG5cbiAgICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkICYmIG92ZXJsYXlPcGFjaXR5ID09PSAwICl7IC8vIGV4aXQgZWFybHkgaWYgZHJhd2luZyBvdmVybGF5IGJ1dCBub25lIHRvIGRyYXdcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50T3BhY2l0eSA9IG5vZGUuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICAgIGlmKCBwYXJlbnRPcGFjaXR5ID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgbm9kZVdpZHRoID0gdGhpcy5nZXROb2RlV2lkdGgobm9kZSk7XG4gICAgbm9kZUhlaWdodCA9IHRoaXMuZ2V0Tm9kZUhlaWdodChub2RlKTtcbiAgICBcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuXG4gICAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCA9PT0gdW5kZWZpbmVkIHx8ICFkcmF3T3ZlcmxheUluc3RlYWQgKXtcblxuICAgICAgLy8gTm9kZSBjb2xvciAmIG9wYWNpdHlcblxuICAgICAgdmFyIGJnQ29sb3IgPSBzdHlsZVsnYmFja2dyb3VuZC1jb2xvciddLnZhbHVlO1xuICAgICAgdmFyIGJvcmRlckNvbG9yID0gc3R5bGVbJ2JvcmRlci1jb2xvciddLnZhbHVlO1xuICAgICAgdmFyIGJvcmRlclN0eWxlID0gc3R5bGVbJ2JvcmRlci1zdHlsZSddLnZhbHVlO1xuXG4gICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBiZ0NvbG9yWzBdLCBiZ0NvbG9yWzFdLCBiZ0NvbG9yWzJdLCBzdHlsZVsnYmFja2dyb3VuZC1vcGFjaXR5J10udmFsdWUgKiBzdHlsZVsnb3BhY2l0eSddLnZhbHVlICogcGFyZW50T3BhY2l0eSk7XG4gICAgICBcbiAgICAgIHRoaXMuc3Ryb2tlU3R5bGUoY29udGV4dCwgYm9yZGVyQ29sb3JbMF0sIGJvcmRlckNvbG9yWzFdLCBib3JkZXJDb2xvclsyXSwgc3R5bGVbJ2JvcmRlci1vcGFjaXR5J10udmFsdWUgKiBzdHlsZVsnb3BhY2l0eSddLnZhbHVlICogcGFyZW50T3BhY2l0eSk7XG5cbiAgICAgIGNvbnRleHQubGluZUpvaW4gPSAnbWl0ZXInOyAvLyBzbyBib3JkZXJzIGFyZSBzcXVhcmUgd2l0aCB0aGUgbm9kZSBzaGFwZVxuXG4gICAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgICAgc3dpdGNoKCBib3JkZXJTdHlsZSApe1xuICAgICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyA0LCAyIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdzb2xpZCc6XG4gICAgICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vdmFyIGltYWdlID0gdGhpcy5nZXRDYWNoZWRJbWFnZSgndXJsJyk7XG4gICAgICBcbiAgICAgIHZhciB1cmwgPSBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddLnZhbHVlWzJdIHx8XG4gICAgICAgIHN0eWxlWydiYWNrZ3JvdW5kLWltYWdlJ10udmFsdWVbMV07XG4gICAgICBcbiAgICAgIHZhciBzdHlsZVNoYXBlID0gc3R5bGVbJ3NoYXBlJ10uc3RyVmFsdWU7XG5cbiAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgdmFyIHBhdGhDYWNoZUtleSA9IHN0eWxlU2hhcGUgKyAnJCcgKyBub2RlV2lkdGggKyckJyArIG5vZGVIZWlnaHQ7XG5cbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoIHBvcy54LCBwb3MueSApO1xuXG4gICAgICAgIGlmKCBycy5wYXRoQ2FjaGVLZXkgPT09IHBhdGhDYWNoZUtleSApe1xuICAgICAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMucGF0aENhY2hlO1xuICAgICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICFwYXRoQ2FjaGVIaXQgKXtcblxuICAgICAgICB2YXIgbnBvcyA9IHBvcztcblxuICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICBucG9zID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShub2RlKV0uZHJhd1BhdGgoXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIG5wb3MueCxcbiAgICAgICAgICAgICAgbnBvcy55LFxuICAgICAgICAgICAgICBub2RlV2lkdGgsXG4gICAgICAgICAgICAgIG5vZGVIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0ID0gY2FudmFzQ29udGV4dDtcblxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1cmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBcbiAgICAgICAgLy8gZ2V0IGltYWdlLCBhbmQgaWYgbm90IGxvYWRlZCB0aGVuIGFzayB0byByZWRyYXcgd2hlbiBsYXRlciBsb2FkZWRcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5nZXRDYWNoZWRJbWFnZSh1cmwsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYoIGltYWdlLmNvbXBsZXRlICl7XG4gICAgICAgICAgdGhpcy5kcmF3SW5zY3JpYmVkSW1hZ2UoY29udGV4dCwgaW1hZ2UsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSBcbiAgICAgIFxuICAgICAgdmFyIGRhcmtuZXNzID0gc3R5bGVbJ2JhY2tncm91bmQtYmxhY2tlbiddLnZhbHVlO1xuICAgICAgdmFyIGJvcmRlcldpZHRoID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG5cbiAgICAgIGlmKCB0aGlzLmhhc1BpZShub2RlKSApe1xuICAgICAgICB0aGlzLmRyYXdQaWUoY29udGV4dCwgbm9kZSk7XG5cbiAgICAgICAgLy8gcmVkcmF3IHBhdGggZm9yIGJsYWNrZW4gYW5kIGJvcmRlclxuICAgICAgICBpZiggZGFya25lc3MgIT09IDAgfHwgYm9yZGVyV2lkdGggIT09IDAgKXtcblxuICAgICAgICAgIGlmKCAhdXNlUGF0aHMgKXtcbiAgICAgICAgICAgIENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUobm9kZSldLmRyYXdQYXRoKFxuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgcG9zLngsXG4gICAgICAgICAgICAgICAgcG9zLnksXG4gICAgICAgICAgICAgICAgbm9kZVdpZHRoLFxuICAgICAgICAgICAgICAgIG5vZGVIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggZGFya25lc3MgPiAwICl7XG4gICAgICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIDAsIDAsIDAsIGRhcmtuZXNzKTtcblxuICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiggZGFya25lc3MgPCAwICl7XG4gICAgICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIC1kYXJrbmVzcyk7XG4gICAgICAgIFxuICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCb3JkZXIgd2lkdGgsIGRyYXcgYm9yZGVyXG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG5cbiAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGJvcmRlclN0eWxlID09PSAnZG91YmxlJyApe1xuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWUvMztcblxuICAgICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuXG4gICAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCAtcG9zLngsIC1wb3MueSApO1xuICAgICAgfVxuXG4gICAgICAvLyByZXNldCBpbiBjYXNlIHdlIGNoYW5nZWQgdGhlIGJvcmRlciBzdHlsZVxuICAgICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgIH1cblxuICAgIC8vIGRyYXcgdGhlIG92ZXJsYXlcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiggb3ZlcmxheU9wYWNpdHkgPiAwICl7XG4gICAgICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIG92ZXJsYXlDb2xvclswXSwgb3ZlcmxheUNvbG9yWzFdLCBvdmVybGF5Q29sb3JbMl0sIG92ZXJsYXlPcGFjaXR5KTtcblxuICAgICAgICBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddLmRyYXdQYXRoKFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgICBub2RlV2lkdGggKyBvdmVybGF5UGFkZGluZyAqIDIsXG4gICAgICAgICAgbm9kZUhlaWdodCArIG92ZXJsYXlQYWRkaW5nICogMlxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICB9O1xuXG4gIC8vIGRvZXMgdGhlIG5vZGUgaGF2ZSBhdCBsZWFzdCBvbmUgcGllIHBpZWNlP1xuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuaGFzUGllID0gZnVuY3Rpb24obm9kZSl7XG4gICAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG4gICAgXG4gICAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuaGFzUGllO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kcmF3UGllID0gZnVuY3Rpb24oY29udGV4dCwgbm9kZSl7XG4gICAgbm9kZSA9IG5vZGVbMF07IC8vIGVuc3VyZSBlbGUgcmVmXG5cbiAgICB2YXIgcGllU2l6ZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BpZS1zaXplJ107XG4gICAgdmFyIG5vZGVXID0gdGhpcy5nZXROb2RlV2lkdGgoIG5vZGUgKTtcbiAgICB2YXIgbm9kZUggPSB0aGlzLmdldE5vZGVIZWlnaHQoIG5vZGUgKTtcbiAgICB2YXIgeCA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueDtcbiAgICB2YXIgeSA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueTtcbiAgICB2YXIgcmFkaXVzID0gTWF0aC5taW4oIG5vZGVXLCBub2RlSCApIC8gMjsgLy8gbXVzdCBmaXQgaW4gbm9kZVxuICAgIHZhciBsYXN0UGVyY2VudCA9IDA7IC8vIHdoYXQgJSB0byBjb250aW51ZSBkcmF3aW5nIHBpZSBzbGljZXMgZnJvbSBvbiBbMCwgMV1cbiAgICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICB4ID0gMDtcbiAgICAgIHkgPSAwO1xuICAgIH1cblxuICAgIGlmKCBwaWVTaXplLnVuaXRzID09PSAnJScgKXtcbiAgICAgIHJhZGl1cyA9IHJhZGl1cyAqIHBpZVNpemUudmFsdWUgLyAxMDA7XG4gICAgfSBlbHNlIGlmKCBwaWVTaXplLnB4VmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgcmFkaXVzID0gcGllU2l6ZS5weFZhbHVlIC8gMjtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAkJC5zdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrICl7IC8vIDEuLk5cbiAgICAgIHZhciBzaXplID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnXS52YWx1ZTtcbiAgICAgIHZhciBjb2xvciA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1jb2xvciddLnZhbHVlO1xuICAgICAgdmFyIG9wYWNpdHkgPSBub2RlLl9wcml2YXRlLnN0eWxlWydwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eSddLnZhbHVlO1xuICAgICAgdmFyIHBlcmNlbnQgPSBzaXplIC8gMTAwOyAvLyBtYXAgaW50ZWdlciByYW5nZSBbMCwgMTAwXSB0byBbMCwgMV1cbiAgICAgIHZhciBhbmdsZVN0YXJ0ID0gMS41ICogTWF0aC5QSSArIDIgKiBNYXRoLlBJICogbGFzdFBlcmNlbnQ7IC8vIHN0YXJ0IGF0IDEyIG8nY2xvY2sgYW5kIGdvIGNsb2Nrd2lzZVxuICAgICAgdmFyIGFuZ2xlRGVsdGEgPSAyICogTWF0aC5QSSAqIHBlcmNlbnQ7XG4gICAgICB2YXIgYW5nbGVFbmQgPSBhbmdsZVN0YXJ0ICsgYW5nbGVEZWx0YTtcblxuICAgICAgLy8gaWdub3JlIGlmXG4gICAgICAvLyAtIHplcm8gc2l6ZVxuICAgICAgLy8gLSB3ZSdyZSBhbHJlYWR5IGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICAgIC8vIC0gYWRkaW5nIHRoZSBjdXJyZW50IHNsaWNlIHdvdWxkIGdvIGJleW9uZCB0aGUgZnVsbCBjaXJjbGVcbiAgICAgIGlmKCBzaXplID09PSAwIHx8IGxhc3RQZXJjZW50ID49IDEgfHwgbGFzdFBlcmNlbnQgKyBwZXJjZW50ID4gMSApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHgsIHkpO1xuICAgICAgY29udGV4dC5hcmMoIHgsIHksIHJhZGl1cywgYW5nbGVTdGFydCwgYW5nbGVFbmQgKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuXG4gICAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgICAgbGFzdFBlcmNlbnQgKz0gcGVyY2VudDtcbiAgICB9XG5cbiAgfTtcblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuXG4gIC8vIHZhciBpc0ZpcmVmb3ggPSB0eXBlb2YgSW5zdGFsbFRyaWdnZXIgIT09ICd1bmRlZmluZWQnO1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24oKXsgXG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmRhdGEuY29udGV4dHNbMF07XG5cbiAgICBpZiggdGhpcy5mb3JjZWRQaXhlbFJhdGlvICE9IG51bGwgKXtcbiAgICAgIHJldHVybiB0aGlzLmZvcmNlZFBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgdmFyIGJhY2tpbmdTdG9yZSA9IGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjb250ZXh0Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGNvbnRleHQubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgIC8vY29uc29sZS5sb2cod2luZG93LmRldmljZVBpeGVsUmF0aW8sIGJhY2tpbmdTdG9yZSk7XG5cbiAgICAvLyBpZiggaXNGaXJlZm94ICl7IC8vIGJlY2F1c2UgZmYgY2FuJ3Qgc2NhbGUgY2FudmFzIHByb3Blcmx5XG4gICAgLy8gICByZXR1cm4gMTtcbiAgICAvLyB9XG5cbiAgICByZXR1cm4gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIC8gYmFja2luZ1N0b3JlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5wYWludENhY2hlID0gZnVuY3Rpb24oY29udGV4dCl7XG4gICAgdmFyIGNhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzIHx8IFtdO1xuICAgIHZhciBuZWVkVG9DcmVhdGVDYWNoZSA9IHRydWU7XG4gICAgdmFyIGNhY2hlO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNhY2hlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgY2FjaGUgPSBjYWNoZXNbaV07XG5cbiAgICAgIGlmKCBjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0ICl7XG4gICAgICAgIG5lZWRUb0NyZWF0ZUNhY2hlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBuZWVkVG9DcmVhdGVDYWNoZSApe1xuICAgICAgY2FjaGUgPSB7XG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH07XG4gICAgICBjYWNoZXMucHVzaCggY2FjaGUgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmZpbGxTdHlsZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHIsIGcsIGIsIGEpe1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gICAgXG4gICAgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuXG4gICAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gICAgLy8gdmFyIGZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gICAgLy8gaWYoIGNhY2hlLmZpbGxTdHlsZSAhPT0gZmlsbFN0eWxlICl7XG4gICAgLy8gICBjb250ZXh0LmZpbGxTdHlsZSA9IGNhY2hlLmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAvLyB9XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnN0cm9rZVN0eWxlID0gZnVuY3Rpb24oY29udGV4dCwgciwgZywgYiwgYSl7XG4gICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAgIFxuICAgIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAgIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcblxuICAgIC8vIHZhciBzdHJva2VTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuXG4gICAgLy8gaWYoIGNhY2hlLnN0cm9rZVN0eWxlICE9PSBzdHJva2VTdHlsZSApe1xuICAgIC8vICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNhY2hlLnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG4gICAgLy8gfVxuICB9O1xuXG4gIC8vIFJlc2l6ZSBjYW52YXNcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLm1hdGNoQ2FudmFzU2l6ZSA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciB3aWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgIHZhciBjYW52YXNXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICB2YXIgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgICB2YXIgY2FudmFzO1xuXG4gICAgaWYoIGNhbnZhc1dpZHRoID09PSB0aGlzLmNhbnZhc1dpZHRoICYmIGNhbnZhc0hlaWdodCA9PT0gdGhpcy5jYW52YXNIZWlnaHQgKXtcbiAgICAgIHJldHVybjsgLy8gc2F2ZSBjeWNsZXMgaWYgc2FtZVxuICAgIH1cblxuICAgIHRoaXMuZm9udENhY2hlcyA9IG51bGw7IC8vIHJlc2l6aW5nIHJlc2V0cyB0aGUgc3R5bGVcblxuICAgIHZhciBjYW52YXNDb250YWluZXIgPSBkYXRhLmNhbnZhc0NvbnRhaW5lcjtcbiAgICBjYW52YXNDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlM7IGkrKykge1xuXG4gICAgICBjYW52YXMgPSBkYXRhLmNhbnZhc2VzW2ldO1xuICAgICAgXG4gICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ2FudmFzUmVuZGVyZXIuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICAgIFxuICAgICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1tpXTtcbiAgICAgIFxuICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgIFxuICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGV4dHVyZU11bHQgPSAxO1xuICAgIGlmKCBwaXhlbFJhdGlvIDw9IDEgKXtcbiAgICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbIENhbnZhc1JlbmRlcmVyLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICAgIHRoaXMudGV4dHVyZU11bHQgPSAyO1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiB0aGlzLnRleHR1cmVNdWx0O1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodCAqIHRoaXMudGV4dHVyZU11bHQ7XG4gICAgfVxuXG4gICAgdGhpcy5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIHRoaXMuY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRvID0gZnVuY3Rpb24oIGN4dCwgem9vbSwgcGFuLCBweFJhdGlvICl7XG4gICAgdGhpcy5yZWRyYXcoe1xuICAgICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICAgIGZvcmNlZFBhbjogcGFuLFxuICAgICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICAgIGZvcmNlZFB4UmF0aW86IHB4UmF0aW9cbiAgICB9KTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUudGltZVRvUmVuZGVyID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5yZWRyYXdUb3RhbFRpbWUgLyB0aGlzLnJlZHJhd0NvdW50O1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLm1pblJlZHJhd0xpbWl0ID0gMTAwMC82MDsgLy8gcGVvcGxlIGNhbid0IHNlZSBtdWNoIGJldHRlciB0aGFuIDYwZnBzXG4gIENhbnZhc1JlbmRlcmVyLm1heFJlZHJhd0xpbWl0ID0gMTAwMDsgIC8vIGRvbid0IGNhcCBtYXggYi9jIGl0J3MgbW9yZSBpbXBvcnRhbnQgdG8gYmUgcmVzcG9uc2l2ZSB0aGFuIHNtb290aFxuICBDYW52YXNSZW5kZXJlci5tb3Rpb25CbHVyRGVsYXkgPSAxMDA7XG5cbiAgLy8gUmVkcmF3IGZyYW1lXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdyZWRyYXcnKTtcblxuICAgIHZhciBmb3JjZWRDb250ZXh0ID0gb3B0aW9ucy5mb3JjZWRDb250ZXh0O1xuICAgIHZhciBkcmF3QWxsTGF5ZXJzID0gb3B0aW9ucy5kcmF3QWxsTGF5ZXJzO1xuICAgIHZhciBkcmF3T25seU5vZGVMYXllciA9IG9wdGlvbnMuZHJhd09ubHlOb2RlTGF5ZXI7XG4gICAgdmFyIGZvcmNlZFpvb20gPSBvcHRpb25zLmZvcmNlZFpvb207XG4gICAgdmFyIGZvcmNlZFBhbiA9IG9wdGlvbnMuZm9yY2VkUGFuO1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IG9wdGlvbnMuZm9yY2VkUHhSYXRpbyA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXRQaXhlbFJhdGlvKCkgOiBvcHRpb25zLmZvcmNlZFB4UmF0aW87XG4gICAgdmFyIGN5ID0gci5kYXRhLmN5OyB2YXIgZGF0YSA9IHIuZGF0YTsgXG4gICAgdmFyIG5lZWREcmF3ID0gZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcbiAgICB2YXIgbW90aW9uQmx1ciA9IG9wdGlvbnMubW90aW9uQmx1ciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tb3Rpb25CbHVyIDogci5tb3Rpb25CbHVyO1xuICAgIG1vdGlvbkJsdXIgPSBtb3Rpb25CbHVyICYmICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1ckVuYWJsZWQ7XG5cbiAgICBpZiggbW90aW9uQmx1ciAmJiByLm1vdGlvbkJsdXJUaW1lb3V0ICl7XG4gICAgICBjbGVhclRpbWVvdXQoIHIubW90aW9uQmx1clRpbWVvdXQgKTtcbiAgICB9XG5cbiAgICBpZiggIWZvcmNlZENvbnRleHQgJiYgdGhpcy5yZWRyYXdUaW1lb3V0ICl7XG4gICAgICBjbGVhclRpbWVvdXQoIHRoaXMucmVkcmF3VGltZW91dCApO1xuICAgIH1cbiAgICB0aGlzLnJlZHJhd1RpbWVvdXQgPSBudWxsO1xuXG4gICAgaWYoIHRoaXMuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyB0aGlzLmF2ZXJhZ2VSZWRyYXdUaW1lID0gMDsgfVxuXG4gICAgdmFyIG1pblJlZHJhd0xpbWl0ID0gQ2FudmFzUmVuZGVyZXIubWluUmVkcmF3TGltaXQ7IFxuICAgIHZhciBtYXhSZWRyYXdMaW1pdCA9IENhbnZhc1JlbmRlcmVyLm1heFJlZHJhd0xpbWl0O1xuXG4gICAgdmFyIHJlZHJhd0xpbWl0ID0gdGhpcy5hdmVyYWdlUmVkcmF3VGltZTsgLy8gZXN0aW1hdGUgdGhlIGlkZWFsIHJlZHJhdyBsaW1pdCBiYXNlZCBvbiBob3cgZmFzdCB3ZSBjYW4gZHJhd1xuICAgIHJlZHJhd0xpbWl0ID0gbWluUmVkcmF3TGltaXQgPiByZWRyYXdMaW1pdCA/IG1pblJlZHJhd0xpbWl0IDogcmVkcmF3TGltaXQ7XG4gICAgcmVkcmF3TGltaXQgPSByZWRyYXdMaW1pdCA8IG1heFJlZHJhd0xpbWl0ID8gcmVkcmF3TGltaXQgOiBtYXhSZWRyYXdMaW1pdDtcblxuICAgIC8vY29uc29sZS5sb2coJy0tXFxuaWRlYWw6ICVpOyBlZmZlY3RpdmU6ICVpJywgdGhpcy5hdmVyYWdlUmVkcmF3VGltZSwgcmVkcmF3TGltaXQpO1xuXG4gICAgaWYoIHRoaXMubGFzdERyYXdUaW1lID09PSB1bmRlZmluZWQgKXsgdGhpcy5sYXN0RHJhd1RpbWUgPSAwOyB9XG5cbiAgICB2YXIgbm93VGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciB0aW1lRWxhcHNlZCA9IG5vd1RpbWUgLSB0aGlzLmxhc3REcmF3VGltZTtcbiAgICB2YXIgY2FsbEFmdGVyTGltaXQgPSB0aW1lRWxhcHNlZCA+PSByZWRyYXdMaW1pdDtcblxuICAgIGlmKCAhZm9yY2VkQ29udGV4dCApe1xuICAgICAgaWYoICFjYWxsQWZ0ZXJMaW1pdCB8fCB0aGlzLmN1cnJlbnRseURyYXdpbmcgKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tIHNraXAnKTtcblxuICAgICAgICAvLyB3ZSBoYXZlIG5ldyB0aGluZ3MgdG8gZHJhdyBidXQgd2UncmUgYnVzeSwgc28gdHJ5IGFnYWluIHdoZW4gcG9zc2libHkgZnJlZVxuICAgICAgICB0aGlzLnJlZHJhd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSwgcmVkcmF3TGltaXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdERyYXdUaW1lID0gbm93VGltZTtcbiAgICAgIHRoaXMuY3VycmVudGx5RHJhd2luZyA9IHRydWU7XG4gICAgfVxuXG5cbiAgICB2YXIgc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICAvL2NvbnNvbGUubG9nKCctLSByZWRyYXcgLS0nKVxuXG5cbiAgICBmdW5jdGlvbiBkcmF3VG9Db250ZXh0KCl7IFxuICAgICAgLy8gc3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICAvLyBjb25zb2xlLnByb2ZpbGUoJ2RyYXcnICsgc3RhcnRUaW1lKVxuICAgICAgdmFyIGVkZ2VzID0gci5nZXRDYWNoZWRFZGdlcygpO1xuICAgICAgdmFyIGNvcmVTdHlsZSA9IGN5LnN0eWxlKCkuX3ByaXZhdGUuY29yZVN0eWxlO1xuICAgICAgXG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBlZmZlY3RpdmVab29tID0gZm9yY2VkWm9vbSAhPT0gdW5kZWZpbmVkID8gZm9yY2VkWm9vbSA6IHpvb207XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgZWZmZWN0aXZlUGFuID0ge1xuICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgeTogcGFuLnlcbiAgICAgIH07XG5cbiAgICAgIGlmKCBmb3JjZWRQYW4gKXtcbiAgICAgICAgZWZmZWN0aXZlUGFuID0gZm9yY2VkUGFuO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBwaXhlbCByYXRpb1xuXG4gICAgICBlZmZlY3RpdmVab29tICo9IHBpeGVsUmF0aW87XG4gICAgICBlZmZlY3RpdmVQYW4ueCAqPSBwaXhlbFJhdGlvO1xuICAgICAgZWZmZWN0aXZlUGFuLnkgKj0gcGl4ZWxSYXRpbztcbiAgICAgIFxuICAgICAgdmFyIGVsZXMgPSB7XG4gICAgICAgIGRyYWc6IHtcbiAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgZWRnZXM6IFtdLFxuICAgICAgICAgIGVsZXM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIG5vbmRyYWc6IHtcbiAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgZWRnZXM6IFtdLFxuICAgICAgICAgIGVsZXM6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHNldENvbnRleHRUcmFuc2Zvcm0oY29udGV4dCwgY2xlYXIpe1xuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgICBpZiggY2xlYXIgPT09ICdtb3Rpb25CbHVyJyApe1xuICAgICAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICAgICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW91dCc7XG4gICAgICAgICAgci5maWxsU3R5bGUoIGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIDAuNjY2ICk7XG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG5cbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgICAgfSBlbHNlIGlmKCAhZm9yY2VkQ29udGV4dCAmJiAoY2xlYXIgPT09IHVuZGVmaW5lZCB8fCBjbGVhcikgKXtcbiAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGVmZmVjdGl2ZVBhbi54LCBlZmZlY3RpdmVQYW4ueSk7XG4gICAgICAgICAgY29udGV4dC5zY2FsZShlZmZlY3RpdmVab29tLCBlZmZlY3RpdmVab29tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiggZm9yY2VkUGFuICl7XG4gICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoZm9yY2VkUGFuLngsIGZvcmNlZFBhbi55KTtcbiAgICAgICAgfSBcbiAgICAgICAgaWYoIGZvcmNlZFpvb20gKXtcbiAgICAgICAgICBjb250ZXh0LnNjYWxlKGZvcmNlZFpvb20sIGZvcmNlZFpvb20pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0dXJlRHJhdyA9IHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgJiYgKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyk7XG5cbiAgICAgIGlmKCB0ZXh0dXJlRHJhdyApe1xuXG4gICAgICAgIHZhciBiYjtcblxuICAgICAgICBpZiggIXIudGV4dHVyZUNhY2hlICl7XG4gICAgICAgICAgci50ZXh0dXJlQ2FjaGUgPSB7fTtcblxuICAgICAgICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmIgPSBjeS5lbGVtZW50cygpLmJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgICByLnRleHR1cmVDYWNoZS50ZXh0dXJlID0gci5kYXRhLmJ1ZmZlckNhbnZhc2VzWyBDYW52YXNSZW5kZXJlci5URVhUVVJFX0JVRkZFUiBdO1xuXG4gICAgICAgICAgdmFyIGN4dCA9IHIuZGF0YS5idWZmZXJDb250ZXh0c1sgQ2FudmFzUmVuZGVyZXIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgICAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgICAgY3h0LmNsZWFyUmVjdCgwLCAwLCByLmNhbnZhc1dpZHRoICogci50ZXh0dXJlTXVsdCwgci5jYW52YXNIZWlnaHQgKiByLnRleHR1cmVNdWx0KTtcbiAgICAgICAgICBcbiAgICAgICAgICByLnJlZHJhdyh7XG4gICAgICAgICAgICBmb3JjZWRDb250ZXh0OiBjeHQsXG4gICAgICAgICAgICBkcmF3T25seU5vZGVMYXllcjogdHJ1ZSxcbiAgICAgICAgICAgIGZvcmNlZFB4UmF0aW86IHBpeGVsUmF0aW8gKiByLnRleHR1cmVNdWx0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgdnAgPSByLnRleHR1cmVDYWNoZS52aWV3cG9ydCA9IHtcbiAgICAgICAgICAgIHpvb206IGN5Lnpvb20oKSxcbiAgICAgICAgICAgIHBhbjogY3kucGFuKCksXG4gICAgICAgICAgICB3aWR0aDogci5jYW52YXNXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogci5jYW52YXNIZWlnaHRcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdnAubXBhbiA9IHtcbiAgICAgICAgICAgIHg6ICgwIC0gdnAucGFuLngpL3ZwLnpvb20sXG4gICAgICAgICAgICB5OiAoMCAtIHZwLnBhbi55KS92cC56b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5lZWREcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gZmFsc2U7XG4gICAgICAgIG5lZWREcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHRzW0NhbnZhc1JlbmRlcmVyLk5PREVdO1xuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gci50ZXh0dXJlQ2FjaGUudGV4dHVyZTtcbiAgICAgICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQ7XG4gICAgICAgIGJiID0gci50ZXh0dXJlQ2FjaGUuYmI7XG5cbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHZwLndpZHRoLCB2cC5oZWlnaHQpO1xuXG4gICAgICAgIHZhciBvdXRzaWRlQmdDb2xvciA9IGNvcmVTdHlsZVsnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJ10udmFsdWU7XG4gICAgICAgIHZhciBvdXRzaWRlQmdPcGFjaXR5ID0gY29yZVN0eWxlWydvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSddLnZhbHVlO1xuICAgICAgICByLmZpbGxTdHlsZSggY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSApO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0ICk7XG5cbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgIFxuICAgICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBmYWxzZSApO1xuXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGgvdnAuem9vbS9waXhlbFJhdGlvLCB2cC5oZWlnaHQvdnAuem9vbS9waXhlbFJhdGlvICk7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCB0ZXh0dXJlLCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGgvdnAuem9vbS9waXhlbFJhdGlvLCB2cC5oZWlnaHQvdnAuem9vbS9waXhlbFJhdGlvICk7XG5cbiAgICAgIH0gZWxzZSBpZiggci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCApeyAvLyBjbGVhciB0aGUgY2FjaGUgc2luY2Ugd2UgZG9uJ3QgbmVlZCBpdFxuICAgICAgICByLnRleHR1cmVDYWNoZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB2cE1hbmlwID0gKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMpO1xuICAgICAgdmFyIGhpZGVFZGdlcyA9IHIuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuICAgICAgdmFyIGhpZGVMYWJlbHMgPSByLmhpZGVMYWJlbHNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG5cbiAgICAgIGlmIChuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSB8fCBuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IGRyYXdPbmx5Tm9kZUxheWVyKSB7XG4gICAgICAgIC8vTkIgOiBWRVJZIEVYUEVOU0lWRVxuXG4gICAgICAgIGlmKCBoaWRlRWRnZXMgKXsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgci5maW5kRWRnZUNvbnRyb2xQb2ludHMoZWRnZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHpFbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgICAgICB2YXIgZXh0ZW50ID0gY3kuZXh0ZW50KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6RWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSB6RWxlc1tpXTtcbiAgICAgICAgICB2YXIgbGlzdDtcbiAgICAgICAgICB2YXIgYmIgPSBmb3JjZWRDb250ZXh0ID8gbnVsbCA6IGVsZS5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgIHZhciBpbnNpZGVFeHRlbnQgPSBmb3JjZWRDb250ZXh0ID8gdHJ1ZSA6ICQkLm1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdCggZXh0ZW50LCBiYiApO1xuXG4gICAgICAgICAgaWYoICFpbnNpZGVFeHRlbnQgKXsgY29udGludWU7IH0gLy8gbm8gbmVlZCB0byByZW5kZXJcblxuICAgICAgICAgIGlmICggZWxlLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyICkge1xuICAgICAgICAgICAgbGlzdCA9IGVsZXMuZHJhZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdCA9IGVsZXMubm9uZHJhZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0LmVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGRyYXdFbGVtZW50cyggbGlzdCwgY29udGV4dCApe1xuICAgICAgICB2YXIgZWxlcyA9IGxpc3QuZWxlcztcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgICAgIHIuZHJhd05vZGUoY29udGV4dCwgZWxlKTtcblxuICAgICAgICAgICAgaWYoICFoaWRlTGFiZWxzICl7XG4gICAgICAgICAgICAgIHIuZHJhd05vZGVUZXh0KGNvbnRleHQsIGVsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhd05vZGUoY29udGV4dCwgZWxlLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYoICFoaWRlRWRnZXMgKSB7XG4gICAgICAgICAgICByLmRyYXdFZGdlKGNvbnRleHQsIGVsZSk7XG5cbiAgICAgICAgICAgIGlmKCAhaGlkZUxhYmVscyApe1xuICAgICAgICAgICAgICByLmRyYXdFZGdlVGV4dChjb250ZXh0LCBlbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYXdFZGdlKGNvbnRleHQsIGVsZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVMYXllck5lZWRzTW90aW9uQ2xlYXIgPSBuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSAmJiAhbmVlZERyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkTm9kZUxheWVyRm9yTW90aW9uQmx1cjtcbiAgICAgIGlmKCBub2RlTGF5ZXJOZWVkc01vdGlvbkNsZWFyICl7IHIuY2xlYXJlZE5vZGVMYXllckZvck1vdGlvbkJsdXIgPSB0cnVlOyB9XG5cbiAgICAgIGlmKCBuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IGRyYXdPbmx5Tm9kZUxheWVyIHx8IG5vZGVMYXllck5lZWRzTW90aW9uQ2xlYXIgKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlZHJhd2luZyBub2RlIGxheWVyJyk7XG4gICAgICAgIFxuICAgICAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgZGF0YS5jb250ZXh0c1tDYW52YXNSZW5kZXJlci5OT0RFXTtcblxuICAgICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBtb3Rpb25CbHVyICYmICFub2RlTGF5ZXJOZWVkc01vdGlvbkNsZWFyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkICk7XG4gICAgICAgIGRyYXdFbGVtZW50cyhlbGVzLm5vbmRyYWcsIGNvbnRleHQpO1xuICAgICAgICBcbiAgICAgICAgaWYoICFkcmF3QWxsTGF5ZXJzICl7XG4gICAgICAgICAgbmVlZERyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSBmYWxzZTsgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddIHx8IGRyYXdBbGxMYXllcnMpICkge1xuICAgICAgICBcbiAgICAgICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8IGRhdGEuY29udGV4dHNbQ2FudmFzUmVuZGVyZXIuRFJBR107XG4gICAgICAgIFxuICAgICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBtb3Rpb25CbHVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkICk7XG4gICAgICAgIGRyYXdFbGVtZW50cyhlbGVzLmRyYWcsIGNvbnRleHQpO1xuICAgICAgICBcbiAgICAgICAgaWYoICFkcmF3QWxsTGF5ZXJzICl7XG4gICAgICAgICAgbmVlZERyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggci5zaG93RnBzIHx8ICghZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdICYmICFkcmF3QWxsTGF5ZXJzKSkgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZWRyYXdpbmcgc2VsZWN0aW9uIGJveCcpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8IGRhdGEuY29udGV4dHNbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF07XG5cbiAgICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCApO1xuXG4gICAgICAgIGlmKCBkYXRhLnNlbGVjdFs0XSA9PSAxICYmIHIuaG92ZXJEYXRhLnNlbGVjdGluZyApe1xuICAgICAgICAgIHZhciB6b29tID0gZGF0YS5jeS56b29tKCk7XG4gICAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCddLnZhbHVlIC8gem9vbTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKFwiIFxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtY29sb3InXS52YWx1ZVswXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1jb2xvciddLnZhbHVlWzFdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWNvbG9yJ10udmFsdWVbMl0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSddLnZhbHVlICsgXCIpXCI7XG4gICAgICAgICAgXG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdChcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0WzBdLFxuICAgICAgICAgICAgZGF0YS5zZWxlY3RbMV0sXG4gICAgICAgICAgICBkYXRhLnNlbGVjdFsyXSAtIGRhdGEuc2VsZWN0WzBdLFxuICAgICAgICAgICAgZGF0YS5zZWxlY3RbM10gLSBkYXRhLnNlbGVjdFsxXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IFwicmdiYShcIiBcbiAgICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMF0gKyBcIixcIlxuICAgICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InXS52YWx1ZVsxXSArIFwiLFwiXG4gICAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvciddLnZhbHVlWzJdICsgXCIsXCJcbiAgICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eSddLnZhbHVlICsgXCIpXCI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdChcbiAgICAgICAgICAgICAgZGF0YS5zZWxlY3RbMF0sXG4gICAgICAgICAgICAgIGRhdGEuc2VsZWN0WzFdLFxuICAgICAgICAgICAgICBkYXRhLnNlbGVjdFsyXSAtIGRhdGEuc2VsZWN0WzBdLFxuICAgICAgICAgICAgICBkYXRhLnNlbGVjdFszXSAtIGRhdGEuc2VsZWN0WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nICl7XG4gICAgICAgICAgdmFyIHpvb20gPSBkYXRhLmN5Lnpvb20oKTtcbiAgICAgICAgICB2YXIgcG9zID0gZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbjtcblxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gXCJyZ2JhKFwiIFxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1jb2xvciddLnZhbHVlWzBdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydhY3RpdmUtYmctY29sb3InXS52YWx1ZVsxXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLWNvbG9yJ10udmFsdWVbMl0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1vcGFjaXR5J10udmFsdWUgKyBcIilcIjtcblxuICAgICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY29udGV4dC5hcmMocG9zLngsIHBvcy55LCBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1zaXplJ10ucHhWYWx1ZSAvIHpvb20sIDAsIDIgKiBNYXRoLlBJKTsgXG4gICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciB0aW1lVG9SZW5kZXIgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lO1xuICAgICAgICBpZiggci5zaG93RnBzICYmIHRpbWVUb1JlbmRlciApe1xuICAgICAgICAgIHRpbWVUb1JlbmRlciA9IE1hdGgucm91bmQoIHRpbWVUb1JlbmRlciApO1xuICAgICAgICAgIHZhciBmcHMgPSBNYXRoLnJvdW5kKDEwMDAvdGltZVRvUmVuZGVyKTtcblxuICAgICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICAgICAgLy9jb250ZXh0LmZvbnQgPSAnMjBweCBoZWx2ZXRpY2EnO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCAnMSBmcmFtZSA9ICcgKyB0aW1lVG9SZW5kZXIgKyAnIG1zID0gJyArIGZwcyArICcgZnBzJywgMCwgMjApO1xuXG4gICAgICAgICAgdmFyIG1heEZwcyA9IDYwO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlUmVjdCgwLCAzMCwgMjUwLCAyMCk7XG4gICAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAzMCwgMjUwICogTWF0aC5taW4oZnBzL21heEZwcywgMSksIDIwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgICAgIG5lZWREcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gZmFsc2U7IFxuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgdmFyIGVuZFRpbWUgPSArbmV3IERhdGUoKTtcblxuICAgICAgaWYoIHIuYXZlcmFnZVJlZHJhd1RpbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHIucmVkcmF3Q291bnQgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByLnJlZHJhd0NvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgci5yZWRyYXdDb3VudCsrO1xuXG4gICAgICBpZiggci5yZWRyYXdUb3RhbFRpbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByLnJlZHJhd1RvdGFsVGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3VG90YWxUaW1lICs9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICByLmxhc3RSZWRyYXdUaW1lID0gZW5kVGltZSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gdXNlIGEgd2VpZ2h0ZWQgYXZlcmFnZSB3aXRoIGEgYmlhcyBmcm9tIHRoZSBwcmV2aW91cyBhdmVyYWdlIHNvIHdlIGRvbid0IHNwaWtlIHNvIGVhc2lseVxuICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IHIuYXZlcmFnZVJlZHJhd1RpbWUvMiArIChlbmRUaW1lIC0gc3RhcnRUaW1lKS8yO1xuICAgICAgLy9jb25zb2xlLmxvZygnYWN0dWFsOiAlaSwgYXZlcmFnZTogJWknLCBlbmRUaW1lIC0gc3RhcnRUaW1lLCB0aGlzLmF2ZXJhZ2VSZWRyYXdUaW1lKTtcblxuICAgICAgci5jdXJyZW50bHlEcmF3aW5nID0gZmFsc2U7XG5cbiAgICAgIC8vIGNvbnNvbGUucHJvZmlsZUVuZCgnZHJhdycgKyBzdGFydFRpbWUpXG5cbiAgICAgIGlmKCByLmNsZWFyaW5nTW90aW9uQmx1ciApe1xuICAgICAgICByLmNsZWFyaW5nTW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgICByLm1vdGlvbkJsdXJDbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgci5tb3Rpb25CbHVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIG1vdGlvbkJsdXIgKXsgXG4gICAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ21vdGlvbiBibHVyIGNsZWFyJyk7XG5cbiAgICAgICAgICByLmNsZWFyZWROb2RlTGF5ZXJGb3JNb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgICAgci5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSB0cnVlO1xuXG4gICAgICAgICAgbmVlZERyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlOyBcbiAgICAgICAgICBuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IHRydWU7IFxuXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSwgQ2FudmFzUmVuZGVyZXIubW90aW9uQmx1ckRlbGF5KTtcbiAgICAgIH1cbiAgICB9IC8vIGRyYXcgdG8gY29udGV4dFxuXG4gICAgaWYoICFmb3JjZWRDb250ZXh0ICl7XG4gICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3VG9Db250ZXh0KTsgLy8gbWFrZXMgZGlyZWN0IHJlbmRlcnMgdG8gc2NyZWVuIGEgYml0IG1vcmUgcmVzcG9uc2l2ZVxuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3VG9Db250ZXh0KCk7XG4gICAgfVxuXG4gICAgaWYoICFmb3JjZWRDb250ZXh0ICYmICFyLmluaXRyZW5kZXIgKXtcbiAgICAgIHIuaW5pdHJlbmRlciA9IHRydWU7XG4gICAgICBjeS50cmlnZ2VyKCdpbml0cmVuZGVyJyk7XG4gICAgfVxuICAgIFxuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuXG4gIC8vIEBPIFBvbHlnb24gZHJhd2luZ1xuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd1BvbHlnb25QYXRoID0gZnVuY3Rpb24oXG4gICAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG5cbiAgICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcblxuICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICBjb250ZXh0Lm1vdmVUbyggeCArIGhhbGZXICogcG9pbnRzWzBdLCB5ICsgaGFsZkggKiBwb2ludHNbMV0gKTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY29udGV4dC5saW5lVG8oIHggKyBoYWxmVyAqIHBvaW50c1tpICogMl0sIHkgKyBoYWxmSCAqIHBvaW50c1tpICogMiArIDFdICk7XG4gICAgfVxuICAgIFxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG4gIFxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd1BvbHlnb24gPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcblxuICAgIC8vIERyYXcgcGF0aFxuICAgIHRoaXMuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG4gICAgXG4gICAgLy8gRmlsbCBwYXRoXG4gICAgY29udGV4dC5maWxsKCk7XG4gIH07XG4gIFxuICAvLyBSb3VuZCByZWN0YW5nbGUgZHJhd2luZ1xuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgIFxuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSAkJC5tYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG4gICAgXG4gICAgLy8gU3RhcnQgYXQgdG9wIG1pZGRsZVxuICAgIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICAvLyBBcmMgZnJvbSBtaWRkbGUgdG9wIHRvIHJpZ2h0IHNpZGVcbiAgICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4ICsgaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG4gICAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gICAgLy8gQXJjIGZyb20gYm90dG9tIHRvIGxlZnQgc2lkZVxuICAgIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gICAgLy8gQXJjIGZyb20gbGVmdCBzaWRlIHRvIHRvcEJvcmRlclxuICAgIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHgsIHkgLSBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEpvaW4gbGluZVxuICAgIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICBcbiAgICBcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuICBcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRyYXdSb3VuZFJlY3RhbmdsZSA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgIFxuICAgIHRoaXMuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICAgIFxuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xuXG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgYnVmZmVyLndpZHRoID0gdztcbiAgICBidWZmZXIuaGVpZ2h0ID0gaDtcbiAgICBcbiAgICByZXR1cm4gW2J1ZmZlciwgYnVmZmVyLmdldENvbnRleHQoJzJkJyldO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5idWZmZXJDYW52YXNJbWFnZSA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGN5ID0gZGF0YS5jeTtcbiAgICB2YXIgYmIgPSBjeS5lbGVtZW50cygpLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLncpIDogdGhpcy5kYXRhLmNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLmgpIDogdGhpcy5kYXRhLmNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHNjYWxlID0gMTtcblxuICAgIGlmKCBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHdpZHRoICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgICBoZWlnaHQgKj0gb3B0aW9ucy5zY2FsZTtcblxuICAgICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICAgIH1cblxuICAgIHZhciBidWZmQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICBidWZmQ2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgYnVmZkNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBidWZmQ2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGJ1ZmZDYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgIHZhciBidWZmQ3h0ID0gYnVmZkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgLy8gUmFzdGVyaXplIHRoZSBsYXllcnMsIGJ1dCBvbmx5IGlmIGNvbnRhaW5lciBoYXMgbm9uemVybyBzaXplXG4gICAgaWYgKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKSB7XG5cbiAgICAgIGJ1ZmZDeHQuY2xlYXJSZWN0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmJnICl7XG4gICAgICAgIGJ1ZmZDeHQuZmlsbFN0eWxlID0gb3B0aW9ucy5iZztcbiAgICAgICAgYnVmZkN4dC5yZWN0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgICAgIGJ1ZmZDeHQuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICBidWZmQ3h0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG5cbiAgICAgIGlmKCBvcHRpb25zLmZ1bGwgKXsgLy8gZHJhdyB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIGdyYXBoXG4gICAgICAgIHRoaXMucmVkcmF3KHtcbiAgICAgICAgICBmb3JjZWRDb250ZXh0OiBidWZmQ3h0LFxuICAgICAgICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgICAgICAgZm9yY2VkWm9vbTogc2NhbGUsXG4gICAgICAgICAgZm9yY2VkUGFuOiB7IHg6IC1iYi54MSpzY2FsZSwgeTogLWJiLnkxKnNjYWxlIH0sXG4gICAgICAgICAgZm9yY2VkUHhSYXRpbzogMVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7IC8vIGRyYXcgdGhlIGN1cnJlbnQgdmlld1xuICAgICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgdmFyIHBhbiA9IHtcbiAgICAgICAgICB4OiBjeVBhbi54ICogc2NhbGUsXG4gICAgICAgICAgeTogY3lQYW4ueSAqIHNjYWxlXG4gICAgICAgIH07XG4gICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpICogc2NhbGU7XG5cbiAgICAgICAgdGhpcy5yZWRyYXcoe1xuICAgICAgICAgIGZvcmNlZENvbnRleHQ6IGJ1ZmZDeHQsXG4gICAgICAgICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICAgICAgICBmb3JjZWRab29tOiB6b29tLFxuICAgICAgICAgIGZvcmNlZFBhbjogcGFuLFxuICAgICAgICAgIGZvcmNlZFB4UmF0aW86IDFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZDYW52YXM7XG4gIH07IFxuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5wbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlckNhbnZhc0ltYWdlKCBvcHRpb25zICkudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpe1xuICAgIHRoaXMuYmluZGluZ3MucHVzaCh7XG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICB1c2VDYXB0dXJlOiB1c2VDYXB0dXJlXG4gICAgfSk7XG5cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLm5vZGVJc0RyYWdnYWJsZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5fcHJpdmF0ZS5zdHlsZVsnb3BhY2l0eSddLnZhbHVlICE9PSAwXG4gICAgICAmJiBub2RlLl9wcml2YXRlLnN0eWxlWyd2aXNpYmlsaXR5J10udmFsdWUgPT0gJ3Zpc2libGUnXG4gICAgICAmJiBub2RlLl9wcml2YXRlLnN0eWxlWydkaXNwbGF5J10udmFsdWUgPT0gJ2VsZW1lbnQnXG4gICAgICAmJiAhbm9kZS5sb2NrZWQoKVxuICAgICAgJiYgbm9kZS5ncmFiYmFibGUoKSApIHtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcztcblxuICAgIHZhciBnZXREcmFnTGlzdElkcyA9IGZ1bmN0aW9uKG9wdHMpe1xuICAgICAgdmFyIGxpc3RIYXNJZDtcblxuICAgICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmIHIuZGF0YS5jeS5oYXNDb21wb3VuZE5vZGVzKCkgKXsgLy8gb25seSBuZWVkZWQgZm9yIGNvbXBvdW5kIGdyYXBoc1xuICAgICAgICBpZiggIW9wdHMuYWRkVG9MaXN0Lmhhc0lkICl7IC8vIGJ1aWxkIGlkcyBsb29rdXAgaWYgZG9lc24ndCBhbHJlYWR5IGV4aXN0XG4gICAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWQgPSB7fTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3B0cy5hZGRUb0xpc3QubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlbGUgPSBvcHRzLmFkZFRvTGlzdFtpXTtcblxuICAgICAgICAgICAgb3B0cy5hZGRUb0xpc3QuaGFzSWRbIGVsZS5pZCgpIF0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RIYXNJZCA9IG9wdHMuYWRkVG9MaXN0Lmhhc0lkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdEhhc0lkIHx8IHt9O1xuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoaWNoIGNoaWxkIG5vZGVzIGFuZCBpbm5lciBlZGdlc1xuICAgIC8vIG9mIGEgY29tcG91bmQgbm9kZSB0byBiZSBkcmFnZ2VkIGFzIHdlbGwgYXMgdGhlIGdyYWJiZWQgYW5kIHNlbGVjdGVkIG5vZGVzXG4gICAgdmFyIGFkZERlc2NlbmRhbnRzVG9EcmFnID0gZnVuY3Rpb24obm9kZSwgb3B0cyl7XG4gICAgICBpZiggIW5vZGUuX3ByaXZhdGUuY3kuaGFzQ29tcG91bmROb2RlcygpICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuXG4gICAgICAvLyBUT0RPIGRvIG5vdCBkcmFnIGhpZGRlbiBjaGlsZHJlbiAmIGNoaWxkcmVuIG9mIGhpZGRlbiBjaGlsZHJlbj9cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaW5uZXJOb2Rlcy5zaXplKCk7IGkrKyApe1xuICAgICAgICB2YXIgaU5vZGUgPSBpbm5lck5vZGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBpTm9kZS5fcHJpdmF0ZTtcblxuICAgICAgICBpZiggb3B0cy5pbkRyYWdMYXllciApe1xuICAgICAgICAgIF9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiAhbGlzdEhhc0lkWyBpTm9kZS5pZCgpIF0gKXtcbiAgICAgICAgICBvcHRzLmFkZFRvTGlzdC5wdXNoKCBpTm9kZSApO1xuICAgICAgICAgIGxpc3RIYXNJZFsgaU5vZGUuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgIF9wLmdyYWJiZWQgPSB0cnVlOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlZGdlcyA9IF9wLmVkZ2VzO1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgb3B0cy5pbkRyYWdMYXllciAmJiBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICBlZGdlc1tqXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gYWRkcyB0aGUgZ2l2ZW4gbm9kZXMsIGFuZCBpdHMgZWRnZXMgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgICB2YXIgYWRkTm9kZVRvRHJhZyA9IGZ1bmN0aW9uKG5vZGUsIG9wdHMpe1xuXG4gICAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICAgICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICl7XG4gICAgICAgIF9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdHMuYWRkVG9MaXN0ICYmICFsaXN0SGFzSWRbIG5vZGUuaWQoKSBdICl7XG4gICAgICAgIG9wdHMuYWRkVG9MaXN0LnB1c2goIG5vZGUgKTtcbiAgICAgICAgbGlzdEhhc0lkWyBub2RlLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgX3AuZ3JhYmJlZCA9IHRydWU7IFxuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSBfcC5lZGdlcztcbiAgICAgIGZvciggdmFyIGkgPSAwOyBvcHRzLmluRHJhZ0xheWVyICYmIGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBlZGdlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGFkZERlc2NlbmRhbnRzVG9EcmFnKCBub2RlLCBvcHRzICk7IC8vIGFsd2F5cyBhZGQgdG8gZHJhZ1xuXG4gICAgICAvLyBhbHNvIGFkZCBub2RlcyBhbmQgZWRnZXMgcmVsYXRlZCB0byB0aGUgdG9wbW9zdCBhbmNlc3RvclxuICAgICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIoIG5vZGUsIHtcbiAgICAgICAgaW5EcmFnTGF5ZXI6IHRydWVcbiAgICAgIH0gKTtcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBhbmNlc3RvciBub2RlcyBhbmQgZWRnZXMgc2hvdWxkIGdvXG4gICAgLy8gdG8gdGhlIGRyYWcgbGF5ZXIgKG9yIHNob3VsZCBiZSByZW1vdmVkIGZyb20gZHJhZyBsYXllcikuXG4gICAgdmFyIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyID0gZnVuY3Rpb24obm9kZSwgb3B0cykge1xuICAgICAgLy8gZmluZCB0b3AtbGV2ZWwgcGFyZW50XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZTtcblxuICAgICAgaWYoICFub2RlLl9wcml2YXRlLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdoaWxlKCBwYXJlbnQucGFyZW50KCkubm9uZW1wdHkoKSApe1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KClbMF07XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIHBhcmVudCBub2RlOiBubyBub2RlcyB0byBhZGQgdG8gdGhlIGRyYWcgbGF5ZXJcbiAgICAgIGlmKCBwYXJlbnQgPT0gbm9kZSApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlcyA9IHBhcmVudFxuICAgICAgICAuZGVzY2VuZGFudHMoKVxuICAgICAgICAuYWRkKCBwYXJlbnQgKVxuICAgICAgICAubm90KCBub2RlIClcbiAgICAgICAgLm5vdCggbm9kZS5kZXNjZW5kYW50cygpIClcbiAgICAgIDtcblxuICAgICAgdmFyIGVkZ2VzID0gbm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMuc2l6ZSgpOyBpKysgKXtcbiAgICAgICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIG5vZGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gb3B0cy5pbkRyYWdMYXllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiAhbGlzdEhhc0lkWyBub2Rlc1tpXS5pZCgpIF0gKXtcbiAgICAgICAgICBvcHRzLmFkZFRvTGlzdC5wdXNoKCBub2Rlc1tpXSApO1xuICAgICAgICAgIGxpc3RIYXNJZFsgbm9kZXNbaV0uaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgIG5vZGVzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBvcHRzLmluRHJhZ0xheWVyICE9PSB1bmRlZmluZWQgJiYgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICkge1xuICAgICAgICBlZGdlc1tqXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IG9wdHMuaW5EcmFnTGF5ZXI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmKCB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiggbXV0bnMgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBtdXRucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBtdXRuID0gbXV0bnNbaV07XG4gICAgICAgICAgdmFyIHJOb2RlcyA9IG11dG4ucmVtb3ZlZE5vZGVzO1xuXG4gICAgICAgICAgaWYoIHJOb2RlcyApeyBmb3IoIHZhciBqID0gMDsgaiA8IHJOb2Rlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgdmFyIHJOb2RlID0gck5vZGVzW2pdO1xuXG4gICAgICAgICAgICBpZiggck5vZGUgPT09IHIuZGF0YS5jb250YWluZXIgKXtcbiAgICAgICAgICAgICAgci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgci5yZW1vdmVPYnNlcnZlci5vYnNlcnZlKCByLmRhdGEuY29udGFpbmVyLnBhcmVudE5vZGUsIHsgY2hpbGRMaXN0OiB0cnVlIH0gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ0RPTU5vZGVSZW1vdmVkJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG5cblxuICAgIC8vIGF1dG8gcmVzaXplXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAncmVzaXplJywgJCQudXRpbC5kZWJvdW5jZSggZnVuY3Rpb24oZSkge1xuICAgICAgci5pbnZhbGlkYXRlQ29udGFpbmVyQ2xpZW50Q29vcmRzQ2FjaGUoKTtcblxuICAgICAgci5tYXRjaENhbnZhc1NpemUoci5kYXRhLmNvbnRhaW5lcik7XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlO1xuICAgICAgci5yZWRyYXcoKTtcbiAgICB9LCAxMDAgKSApO1xuXG4gICAgdmFyIGludmFsQ3RuckJCT25TY3JvbGwgPSBmdW5jdGlvbihkb21FbGUpe1xuICAgICAgci5yZWdpc3RlckJpbmRpbmcoZG9tRWxlLCAnc2Nyb2xsJywgZnVuY3Rpb24oZSl7XG4gICAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG4gICAgICB9ICk7XG4gICAgfTtcblxuICAgIHZhciBiYkN0bnIgPSByLmRhdGEuY3kuY29udGFpbmVyKCk7XG5cbiAgICBmb3IoIDs7ICl7XG4gICAgICBcbiAgICAgIGludmFsQ3RuckJCT25TY3JvbGwoIGJiQ3RuciApO1xuXG4gICAgICBpZiggYmJDdG5yLnBhcmVudE5vZGUgKXtcbiAgICAgICAgYmJDdG5yID0gYmJDdG5yLnBhcmVudE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cblxuICAgIC8vIHN0b3AgcmlnaHQgY2xpY2sgbWVudSBmcm9tIGFwcGVhcmluZyBvbiBjeVxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdjb250ZXh0bWVudScsIGZ1bmN0aW9uKGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgdmFyIGluQm94U2VsZWN0aW9uID0gZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiByLmRhdGEuc2VsZWN0WzRdICE9PSAwO1xuICAgIH07XG5cbiAgICAvLyBQcmltYXJ5IGtleVxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7IFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgICByLmhvdmVyRGF0YS53aGljaCA9IGUud2hpY2g7XG4gICAgICBcbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTsgXG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSk7XG4gICAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcblxuICAgICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBwb3M7XG5cbiAgICAgIHZhciBjaGVja0ZvclRhcGhvbGQgPSBmdW5jdGlvbigpe1xuICAgICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KCByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCApO1xuXG4gICAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgICAgaWYoIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVsZSA9IHIuaG92ZXJEYXRhLmRvd247XG5cbiAgICAgICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICAgICAgZWxlLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFJpZ2h0IGNsaWNrIGJ1dHRvblxuICAgICAgaWYoIGUud2hpY2ggPT0gMyApe1xuXG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBjeHRFdnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsIFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfSBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgICAgbmVhci50cmlnZ2VyKCBjeHRFdnQgKTtcblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAgIC8vIFByaW1hcnkgYnV0dG9uXG4gICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMSkge1xuICAgICAgICBcbiAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFbGVtZW50IGRyYWdnaW5nXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgaXMgdW5kZXIgdGhlIGN1cnNvciBhbmQgaXQgaXMgZHJhZ2dhYmxlLCBwcmVwYXJlIHRvIGdyYWIgaXRcbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZShuZWFyKSApe1xuXG4gICAgICAgICAgICAgIHZhciBncmFiRXZlbnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdncmFiJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCBuZWFyLmlzTm9kZSgpICYmICFuZWFyLnNlbGVjdGVkKCkgKXtcblxuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBuZWFyLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzIH0gKTtcblxuICAgICAgICAgICAgICAgIG5lYXIudHJpZ2dlcihncmFiRXZlbnQpO1xuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG5lYXIuaXNOb2RlKCkgJiYgbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IFsgIF07XG5cbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuaXNOb2RlKCkgJiYgdGhpcy5zZWxlY3RlZCgpOyB9KTtcblxuICAgICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKyApe1xuXG4gICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkZCB0aGlzIHNlbGVjdGVkIG5vZGUgdG8gZHJhZyBpZiBpdCBpcyBkcmFnZ2FibGUsIGVnLiBoYXMgbm9uemVybyBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUoIHNlbGVjdGVkTm9kZXNbaV0gKSApe1xuICAgICAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBzZWxlY3RlZE5vZGVzW2ldLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZW1lbnRzIH0gKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoIGdyYWJFdmVudCApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gdHJ1ZTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBzdGFydCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9IGVsc2UgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgY3lcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZWRvd24nLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgci5ob3ZlckRhdGEuZG93biA9IG5lYXI7XG4gICAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuXG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICAvLyBTZWxlY3Rpb24gYm94XG4gICAgICAgIGlmICggbmVhciA9PSBudWxsIHx8IG5lYXIuaXNFZGdlKCkgKSB7XG4gICAgICAgICAgc2VsZWN0WzRdID0gMTtcbiAgICAgICAgICB2YXIgdGltZVVudGlsQWN0aXZlID0gTWF0aC5tYXgoIDAsIENhbnZhc1JlbmRlcmVyLnBhbk9yQm94U2VsZWN0RGVsYXkgLSAoK25ldyBEYXRlKCkgLSByLmhvdmVyRGF0YS5kb3duVGltZSkgKTtcblxuICAgICAgICAgIGNsZWFyVGltZW91dCggci5iZ0FjdGl2ZVRpbWVvdXQgKTtcblxuICAgICAgICAgIGlmKCBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgfHwgKCBuZWFyICYmIG5lYXIuaXNFZGdlKCkgKSApe1xuICAgICAgICAgICAgci5iZ0FjdGl2ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgICAgICAgbmVhci51bmFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGNoZWNrRm9yVGFwaG9sZCgpO1xuXG4gICAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICBcbiAgICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0sIHRpbWVVbnRpbEFjdGl2ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNoZWNrRm9yVGFwaG9sZCgpO1xuXG4gICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgIFxuICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgfSBcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb24gYm94IGNvb3JkaW5hdGVzXG4gICAgICBzZWxlY3RbMF0gPSBzZWxlY3RbMl0gPSBwb3NbMF07XG4gICAgICBzZWxlY3RbMV0gPSBzZWxlY3RbM10gPSBwb3NbMV07XG4gICAgICBcbiAgICB9LCBmYWxzZSk7XG4gICAgXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnbW91c2Vtb3ZlJywgJCQudXRpbC50aHJvdHRsZSggZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgICB2YXIgY2FwdHVyZSA9IHIuaG92ZXJEYXRhLmNhcHR1cmU7XG5cbiAgICAgIC8vIHNhdmUgY3ljbGVzIGlmIG1vdXNlIGV2ZW50cyBhcmVuJ3QgdG8gYmUgY2FwdHVyZWRcbiAgICAgIGlmICggIWNhcHR1cmUgKXtcbiAgICAgICAgdmFyIGNvbnRhaW5lclBhZ2VDb29yZHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcblxuICAgICAgICBpZiAoZS5jbGllbnRYID4gY29udGFpbmVyUGFnZUNvb3Jkc1swXSAmJiBlLmNsaWVudFggPCBjb250YWluZXJQYWdlQ29vcmRzWzBdICsgci5jYW52YXNXaWR0aFxuICAgICAgICAgICYmIGUuY2xpZW50WSA+IGNvbnRhaW5lclBhZ2VDb29yZHNbMV0gJiYgZS5jbGllbnRZIDwgY29udGFpbmVyUGFnZUNvb3Jkc1sxXSArIHIuY2FudmFzSGVpZ2h0XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGluc2lkZSBjb250YWluZXIgYm91bmRzIHNvIE9LXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN5Q29udGFpbmVyID0gci5kYXRhLmNvbnRhaW5lcjtcbiAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICB2YXIgdFBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgY29udGFpbmVySXNUYXJnZXQgPSBmYWxzZTtcblxuICAgICAgICB3aGlsZSggdFBhcmVudCApe1xuICAgICAgICAgIGlmKCB0UGFyZW50ID09PSBjeUNvbnRhaW5lciApe1xuICAgICAgICAgICAgY29udGFpbmVySXNUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFBhcmVudCA9IHRQYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhY29udGFpbmVySXNUYXJnZXQgKXsgcmV0dXJuOyB9IC8vIGlmIHRhcmdldCBpcyBvdXRpc2RlIGN5IGNvbnRhaW5lciwgdGhlbiB0aGlzIGV2ZW50IGlzIG5vdCBmb3IgdXNcbiAgICAgIH1cblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5O1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuICAgICAgXG4gICAgICB2YXIgbmVhciA9IG51bGw7XG4gICAgICBpZiggIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyApe1xuICAgICAgICBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIGxhc3QgPSByLmhvdmVyRGF0YS5sYXN0O1xuICAgICAgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgICAgXG4gICAgICB2YXIgZGlzcCA9IFtwb3NbMF0gLSBzZWxlY3RbMl0sIHBvc1sxXSAtIHNlbGVjdFszXV07XG5cbiAgICAgIHZhciBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzO1xuXG4gICAgICB2YXIgZHggPSBzZWxlY3RbMl0gLSBzZWxlY3RbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IHNlbGVjdFszXSAtIHNlbGVjdFsxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207XG5cbiAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSB0cnVlO1xuXG4gICAgICB2YXIgdXBkYXRlRHJhZ0RlbHRhID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICBpZiggZHJhZ0RlbHRhLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKDApO1xuICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG5cbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgLy8gTW91c2Vtb3ZlIGV2ZW50XG4gICAgICB7XG4gICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG4gICAgICAgICAgXG4gICAgICAgIH0gZWxzZSBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgY3lcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdtb3VzZW1vdmUnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZW1vdmUnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWcnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIHRyaWdnZXIgY29udGV4dCBkcmFnIGlmIHJtb3VzZSBkb3duXG4gICAgICBpZiggci5ob3ZlckRhdGEud2hpY2ggPT09IDMgKXtcbiAgICAgICAgdmFyIGN4dEV2dCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggZG93biApe1xuICAgICAgICAgIGRvd24udHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiggIXIuaG92ZXJEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci5ob3ZlckRhdGEuY3h0T3ZlciApe1xuXG4gICAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmN4dE92ZXIgKXtcbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjeHRkcmFnb3V0ICcgKyByLmhvdmVyRGF0YS5jeHRPdmVyLmlkKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmN4dE92ZXIgPSBuZWFyO1xuXG4gICAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY3h0ZHJhZ292ZXIgJyArIG5lYXIuaWQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgYXJlIGRyYWcgcGFubmluZyB0aGUgZW50aXJlIGdyYXBoXG4gICAgICB9IGVsc2UgaWYgKHIuaG92ZXJEYXRhLmRyYWdnaW5nKSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgICBpZiggY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApe1xuICAgICAgICAgIHZhciBkZWx0YVA7XG5cbiAgICAgICAgICBpZiggci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gKXtcbiAgICAgICAgICAgIHZhciBtZFBvcyA9IHIuaG92ZXJEYXRhLm1kb3duUG9zO1xuXG4gICAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICAgIHg6ICggcG9zWzBdIC0gbWRQb3NbMF0gKSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6ICggcG9zWzFdIC0gbWRQb3NbMV0gKSAqIHpvb21cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gZmFsc2U7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjeS5wYW5CeSggZGVsdGFQICk7XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE5lZWRzIHJlcHJvamVjdCBkdWUgdG8gcGFuIGNoYW5naW5nIHZpZXdwb3J0XG4gICAgICAgIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICAgIC8vIENoZWNrcyBwcmltYXJ5IGJ1dHRvbiBkb3duICYgb3V0IG9mIHRpbWUgJiBtb3VzZSBub3QgbW92ZWQgbXVjaFxuICAgICAgfSBlbHNlIGlmKFxuICAgICAgICAgIHNlbGVjdFs0XSA9PSAxICYmIChkb3duID09IG51bGwgfHwgZG93bi5pc0VkZ2UoKSlcbiAgICAgICAgICAmJiAoICFjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgfHwgKCtuZXcgRGF0ZSgpIC0gci5ob3ZlckRhdGEuZG93blRpbWUgPj0gQ2FudmFzUmVuZGVyZXIucGFuT3JCb3hTZWxlY3REZWxheSkgKVxuICAgICAgICAgIC8vJiYgKE1hdGguYWJzKHNlbGVjdFszXSAtIHNlbGVjdFsxXSkgKyBNYXRoLmFicyhzZWxlY3RbMl0gLSBzZWxlY3RbMF0pIDwgNClcbiAgICAgICAgICAmJiAhci5ob3ZlckRhdGEuc2VsZWN0aW5nXG4gICAgICAgICAgJiYgcmRpc3QyID49IHIudGFwVGhyZXNob2xkMlxuICAgICAgICAgICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKClcbiAgICAgICl7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0WzRdID0gMDtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVhY3RpdmF0ZSBiZyBvbiBib3ggc2VsZWN0aW9uXG4gICAgICAgIGlmIChjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgTWF0aC5wb3coc2VsZWN0WzJdIC0gc2VsZWN0WzBdLCAyKSArIE1hdGgucG93KHNlbGVjdFszXSAtIHNlbGVjdFsxXSwgMikgPiA3ICYmIHNlbGVjdFs0XSl7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KCByLmJnQWN0aXZlVGltZW91dCApO1xuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggZG93biAmJiBkb3duLmlzRWRnZSgpICYmIGRvd24uYWN0aXZlKCkgKXsgZG93bi51bmFjdGl2YXRlKCk7IH1cblxuICAgICAgICBpZiAobmVhciAhPSBsYXN0KSB7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApOyBcblxuICAgICAgICAgICAgbGFzdC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZ291dCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTsgXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdtb3VzZW92ZXInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7IFxuXG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTsgXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGRvd24gJiYgZG93bi5pc05vZGUoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShkb3duKSApe1xuXG4gICAgICAgICAgaWYoIHJkaXN0MiA+PSByLnRhcFRocmVzaG9sZDIgKXsgLy8gdGhlbiBkcmFnXG5cbiAgICAgICAgICAgIHZhciBqdXN0U3RhcnRlZERyYWcgPSAhci5kcmFnRGF0YS5kaWREcmFnO1xuXG4gICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICkge1xuICAgICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlOyAvLyBpbmRpY2F0ZSB0aGF0IHdlIGFjdHVhbGx5IGRpZCBkcmFnIHRoZSBub2RlXG5cbiAgICAgICAgICAgIHZhciB0b1RyaWdnZXIgPSBbXTtcblxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIGRFbGUgPSBkcmFnZ2VkRWxlbWVudHNbaV07XG5cbiAgICAgICAgICAgICAgLy8gbm93LCBhZGQgdGhlIGVsZW1lbnRzIHRvIHRoZSBkcmFnIGxheWVyIGlmIG5vdCBkb25lIGFscmVhZHlcbiAgICAgICAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgKXsgXG4gICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggZEVsZSwgeyBpbkRyYWdMYXllcjogdHJ1ZSB9ICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBMb2NrZWQgbm9kZXMgbm90IGRyYWdnYWJsZSwgYXMgd2VsbCBhcyBub24tdmlzaWJsZSBub2Rlc1xuICAgICAgICAgICAgICBpZiggZEVsZS5pc05vZGUoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShkRWxlKSAmJiBkRWxlLmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICAgIHZhciBkUG9zID0gZEVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgIHRvVHJpZ2dlci5wdXNoKCBkRWxlICk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoICQkLmlzLm51bWJlcihkaXNwWzBdKSAmJiAkJC5pcy5udW1iZXIoZGlzcFsxXSkgKXtcbiAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRpc3BbMV07XG5cbiAgICAgICAgICAgICAgICAgIGlmKCBqdXN0U3RhcnRlZERyYWcgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIuaG92ZXJEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKGRyYWdEZWx0YVswXSkgJiYgJCQuaXMubnVtYmVyKGRyYWdEZWx0YVsxXSkgKXtcbiAgICAgICAgICAgICAgICAgICAgICBkUG9zLnggKz0gZHJhZ0RlbHRhWzBdO1xuICAgICAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdGNvbCA9IChuZXcgJCQuQ29sbGVjdGlvbihjeSwgdG9UcmlnZ2VyKSk7XG5cbiAgICAgICAgICAgIHRjb2wudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRjb2wudHJpZ2dlcigncG9zaXRpb24gZHJhZycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBzYXZlIGRyYWcgZGVsdGEgZm9yIHdoZW4gd2UgYWN0dWFsbHkgc3RhcnQgZHJhZ2dpbmcgc28gdGhlIHJlbGF0aXZlIGdyYWIgcG9zIGlzIGNvbnN0YW50XG4gICAgICAgICAgICB1cGRhdGVEcmFnRGVsdGEoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IHRoZSBkcmFnZ2luZyBmcm9tIHRyaWdnZXJpbmcgdGV4dCBzZWxlY3Rpb24gb24gdGhlIHBhZ2VcbiAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZWxlY3RbMl0gPSBwb3NbMF07IHNlbGVjdFszXSA9IHBvc1sxXTtcbiAgICAgIFxuICAgICAgaWYoIHByZXZlbnREZWZhdWx0ICl7IFxuICAgICAgICBpZihlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICBpZihlLnByZXZlbnREZWZhdWx0KSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgMTAwMC8zMCwgeyB0cmFpbGluZzogdHJ1ZSB9KSwgZmFsc2UpO1xuICAgIFxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnLS1cXG5tb3VzZXVwJywgZSlcblxuICAgICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuICAgICAgaWYgKCFjYXB0dXJlKSB7IHJldHVybjsgfVxuICAgICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IGZhbHNlO1xuICAgIFxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5OyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTsgdmFyIHNlbGVjdCA9IHIuZGF0YS5zZWxlY3Q7XG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlKTsgXG4gICAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50czsgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgICAgdmFyIHNoaWZ0RG93biA9IGUuc2hpZnRLZXk7XG4gICAgICBcbiAgICAgIGlmKCByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gKXtcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkOyAvLyBub3QgYWN0aXZlIGJnIG5vd1xuICAgICAgY2xlYXJUaW1lb3V0KCByLmJnQWN0aXZlVGltZW91dCApO1xuXG4gICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuXG4gICAgICBpZiggZG93biApe1xuICAgICAgICBkb3duLnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYoIHIuaG92ZXJEYXRhLndoaWNoID09PSAzICl7XG4gICAgICAgIHZhciBjeHRFdnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggZG93biApe1xuICAgICAgICAgIGRvd24udHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIXIuaG92ZXJEYXRhLmN4dERyYWdnZWQgKXtcbiAgICAgICAgICB2YXIgY3h0VGFwID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgIHR5cGU6ICdjeHR0YXAnLFxuICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiggZG93biApe1xuICAgICAgICAgICAgZG93bi50cmlnZ2VyKCBjeHRUYXAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kudHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICByLmhvdmVyRGF0YS53aGljaCA9IG51bGw7XG5cbiAgICAgIC8vIGlmIG5vdCByaWdodCBtb3VzZVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBEZXNlbGVjdCBhbGwgZWxlbWVudHMgaWYgbm90aGluZyBpcyBjdXJyZW50bHkgdW5kZXIgdGhlIG1vdXNlIGN1cnNvciBhbmQgd2UgYXJlbid0IGRyYWdnaW5nIHNvbWV0aGluZ1xuICAgICAgICBpZiAoIChkb3duID09IG51bGwpIC8vIG5vdCBtb3VzZWRvd24gb24gbm9kZVxuICAgICAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IG1vdmUgdGhlIG5vZGUgYXJvdW5kXG4gICAgICAgICAgJiYgIShNYXRoLnBvdyhzZWxlY3RbMl0gLSBzZWxlY3RbMF0sIDIpICsgTWF0aC5wb3coc2VsZWN0WzNdIC0gc2VsZWN0WzFdLCAyKSA+IDcgJiYgc2VsZWN0WzRdKSAvLyBub3QgYm94IHNlbGVjdGlvblxuICAgICAgICAgICYmICFyLmhvdmVyRGF0YS5kcmFnZ2luZyAvLyBub3QgcGFubmluZ1xuICAgICAgICApIHtcblxuICAgICAgICAgIGN5LiQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkKCk7XG4gICAgICAgICAgfSkudW5zZWxlY3QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBkcmFnZ2VkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgXG4gICAgICAgIFxuICAgICAgICAvLyBNb3VzZXVwIGV2ZW50XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygndHJpZ2dlciBtb3VzZXVwIGV0IGFsJyk7XG5cbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICAgIGN5XG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGljayBldmVudFxuICAgICAgICB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3RyaWdnZXIgY2xpY2sgZXQgYWwnKTtcblxuICAgICAgICAgIGlmIChNYXRoLnBvdyhzZWxlY3RbMl0gLSBzZWxlY3RbMF0sIDIpICsgTWF0aC5wb3coc2VsZWN0WzNdIC0gc2VsZWN0WzFdLCAyKSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3RhcCcsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndmNsaWNrJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgY3lcbiAgICAgICAgICAgICAgICAudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdjbGljaycsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndGFwJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgICAudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd2Y2xpY2snLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2luZ2xlIHNlbGVjdGlvblxuICAgICAgICBpZiAobmVhciA9PSBkb3duICYmICFyLmRyYWdEYXRhLmRpZERyYWcpIHtcbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsICYmIG5lYXIuX3ByaXZhdGUuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2luZ2xlIHNlbGVjdGlvbicpXG5cbiAgICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZyApe1xuICAgICAgICAgICAgICAvLyBpZiBwYW5uaW5nLCBkb24ndCBjaGFuZ2Ugc2VsZWN0aW9uIHN0YXRlXG4gICAgICAgICAgICB9IGVsc2UgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyB8fCBzaGlmdERvd24gKXtcbiAgICAgICAgICAgICAgaWYoIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICAgIG5lYXIudW5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWFyLnNlbGVjdCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiggIXNoaWZ0RG93biApe1xuICAgICAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLm5vdCggbmVhciApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgbmVhci5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgaWYgKCBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgIE1hdGgucG93KHNlbGVjdFsyXSAtIHNlbGVjdFswXSwgMikgKyBNYXRoLnBvdyhzZWxlY3RbM10gLSBzZWxlY3RbMV0sIDIpID4gNyAmJiBzZWxlY3RbNF0gKSB7ICAgICAgICAgXG4gICAgICAgICAgdmFyIG5ld2x5U2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgICB2YXIgYm94ID0gci5nZXRBbGxJbkJveCggc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdICk7XG5cbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgICAgaWYoIGJveC5sZW5ndGggPiAwICkgeyBcbiAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7IFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYm94Lmxlbmd0aDsgaSsrICl7IFxuICAgICAgICAgICAgaWYoIGJveFtpXS5fcHJpdmF0ZS5zZWxlY3RhYmxlICl7XG4gICAgICAgICAgICAgIG5ld2x5U2VsZWN0ZWQucHVzaCggYm94W2ldICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld2x5U2VsQ29sID0gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBuZXdseVNlbGVjdGVkICk7XG5cbiAgICAgICAgICBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnICl7XG4gICAgICAgICAgICBuZXdseVNlbENvbC5zZWxlY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoICFzaGlmdERvd24gKXtcbiAgICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykubm90KCBuZXdseVNlbENvbCApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5ld2x5U2VsQ29sLnNlbGVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGFsd2F5cyBuZWVkIHJlZHJhdyBpbiBjYXNlIGVsZXMgdW5zZWxlY3RhYmxlXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FuY2VsIGRyYWcgcGFuXG4gICAgICAgIGlmKCByLmhvdmVyRGF0YS5kcmFnZ2luZyApe1xuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXNlbGVjdFs0XSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmcmVlIGF0IGVuZCcsIGRyYWdnZWRFbGVtZW50cylcblxuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IHRydWU7IFxuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7IFxuICAgICAgICAgIFxuICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGRyYWdnZWRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihkcmFnZ2VkRWxlbWVudHNbaV0uX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycpIHsgXG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50c1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHNbaV0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdmFyIHNFZGdlcyA9IGRyYWdnZWRFbGVtZW50c1tpXS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzRWRnZXMubGVuZ3RoOyBqKysgKXsgc0VkZ2VzW2pdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7IH1cblxuICAgICAgICAgICAgICAvLyBmb3IgY29tcG91bmQgbm9kZXMsIGFsc28gcmVtb3ZlIHJlbGF0ZWQgbm9kZXMgYW5kIGVkZ2VzIGZyb20gdGhlIGRyYWcgbGF5ZXJcbiAgICAgICAgICAgICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIoZHJhZ2dlZEVsZW1lbnRzW2ldLCB7IGluRHJhZ0xheWVyOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2UgaWYoIGRyYWdnZWRFbGVtZW50c1tpXS5fcHJpdmF0ZS5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBkb3duICl7IGRvd24udHJpZ2dlcignZnJlZScpOyB9XG5cbiAgLy8gICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbXTtcbiAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgXG4gICAgICB9IC8vIGVsc2Ugbm90IHJpZ2h0IG1vdXNlXG5cbiAgICAgIHNlbGVjdFs0XSA9IDA7IHIuaG92ZXJEYXRhLmRvd24gPSBudWxsO1xuICAgICAgXG4gICAgICAvL3IuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7IFxuICAgICAgXG4vLyAgICAgIGNvbnNvbGUubG9nKCdtdScsIHBvc1swXSwgcG9zWzFdKTtcbi8vICAgICAgY29uc29sZS5sb2coJ3NzJywgc2VsZWN0KTtcbiAgICAgIFxuICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSBbXTtcbiAgICAgIFxuICAgIH0sIGZhbHNlKTtcblxuICAgIHZhciB3aGVlbEhhbmRsZXIgPSBmdW5jdGlvbihlKSB7IFxuICAgICAgaWYoIHIuc2Nyb2xsaW5nUGFnZSApeyByZXR1cm47IH0gLy8gd2hpbGUgc2Nyb2xsaW5nLCBpZ25vcmUgd2hlZWwtdG8tem9vbVxuXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHZhciBycG9zID0gW3Bvc1swXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLngsXG4gICAgICAgICAgICAgICAgICAgIHBvc1sxXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLnldO1xuICAgICAgXG4gICAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgfHwgaW5Cb3hTZWxlY3Rpb24oKSApeyAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiggY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgXG4gICAgICAgIHIuZGF0YS53aGVlbFpvb21pbmcgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQoIHIuZGF0YS53aGVlbFRpbWVvdXQgKTtcbiAgICAgICAgci5kYXRhLndoZWVsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gZmFsc2U7XG5cbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlOyBcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9LCAxNTApO1xuXG4gICAgICAgIHZhciBkaWZmID0gZS5kZWx0YVkgLyAtMjUwIHx8IGUud2hlZWxEZWx0YVkgLyAxMDAwIHx8IGUud2hlZWxEZWx0YSAvIDEwMDA7XG4gICAgICAgIGRpZmYgPSBkaWZmICogci53aGVlbFNlbnNpdGl2aXR5O1xuXG4gICAgICAgIHZhciBuZWVkc1doZWVsRml4ID0gZS5kZWx0YU1vZGUgPT09IDE7XG4gICAgICAgIGlmKCBuZWVkc1doZWVsRml4ICl7IC8vIGZpeGVzIHNsb3cgd2hlZWwgZXZlbnRzIG9uIGZmL2xpbnV4IGFuZCBmZi93aW5kb3dzXG4gICAgICAgICAgZGlmZiAqPSAzMztcbiAgICAgICAgfVxuXG4gICAgICAgIGN5Lnpvb20oe1xuICAgICAgICAgIGxldmVsOiBjeS56b29tKCkgKiBNYXRoLnBvdygxMCwgZGlmZiksXG4gICAgICAgICAgcmVuZGVyZWRQb3NpdGlvbjogeyB4OiBycG9zWzBdLCB5OiBycG9zWzFdIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIFxuICAgIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggd2hldGhlciBtb3VzZSB3aGVlbCBzaG91bGQgdHJpZ2dlciB6b29taW5nXG4gICAgLy8gLS1cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnd2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuXG4gICAgLy8gZGlzYWJsZSBub25zdGFuZGFyZCB3aGVlbCBldmVudHNcbiAgICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gICAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ0RPTU1vdXNlU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnTW96TW91c2VQaXhlbFNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7IC8vIG9sZGVyIGZpcmVmb3hcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Njcm9sbCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgci5zY3JvbGxpbmdQYWdlID0gdHJ1ZTtcblxuICAgICAgY2xlYXJUaW1lb3V0KCByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ICk7XG4gICAgICByLnNjcm9sbGluZ1BhZ2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICByLnNjcm9sbGluZ1BhZ2UgPSBmYWxzZTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgXG4gICAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCBoYW5kbGluZyBtb3VzZW91dC9tb3VzZW92ZXIgb24gdGhlIEN5dG9zY2FwZSBjb250YWluZXJcbiAgICAgICAgICAvLyBIYW5kbGUgbW91c2VvdXQgb24gQ3l0b3NjYXBlIGNvbnRhaW5lclxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdtb3VzZW91dCcsIGZ1bmN0aW9uKGUpIHsgXG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgci5kYXRhLmN5LnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9KSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIFxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdtb3VzZW92ZXInLCBmdW5jdGlvbihlKSB7IFxuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICAgIHIuZGF0YS5jeS50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgIHR5cGU6ICdtb3VzZW92ZXInLFxuICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgIH0pKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgXG4gICAgdmFyIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTE7IC8vIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICAgIHZhciBkaXN0YW5jZTEsIGRpc3RhbmNlMVNxOyAvLyBpbml0aWFsIGRpc3RhbmNlIGJldHdlZW4gZmluZ2VyIDEgYW5kIGZpbmdlciAyIGZvciBwaW5jaC10by16b29tXG4gICAgdmFyIGNlbnRlcjEsIG1vZGVsQ2VudGVyMTsgLy8gY2VudGVyIHBvaW50IG9uIHN0YXJ0IHBpbmNoIHRvIHpvb21cbiAgICB2YXIgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wO1xuICAgIHZhciBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0O1xuICAgIHZhciB0d29GaW5nZXJzU3RhcnRJbnNpZGU7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mil7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KCAoeDIteDEpKih4Mi14MSkgKyAoeTIteTEpKih5Mi15MSkgKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpc3RhbmNlU3EgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mil7XG4gICAgICByZXR1cm4gKHgyLXgxKSooeDIteDEpICsgKHkyLXkxKSooeTIteTEpO1xuICAgIH07XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLnRocmVlRmluZ2VyU2VsZWN0VGltZW91dCApO1xuXG4gICAgICBpZiggZS50YXJnZXQgIT09IHIuZGF0YS5saW5rICl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICBcbiAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7IFxuICAgICAgdmFyIG5vZGVzID0gci5nZXRDYWNoZWROb2RlcygpO1xuICAgICAgdmFyIGVkZ2VzID0gci5nZXRDYWNoZWRFZGdlcygpO1xuICAgICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICAgIFxuICAgICAgaWYgKGUudG91Y2hlc1swXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuICAgIFxuXG4gICAgICAvLyByZWNvcmQgc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG4gICAgICBpZiggZS50b3VjaGVzWzFdICl7XG5cbiAgICAgICAgLy8gYW55dGhpbmcgaW4gdGhlIHNldCBvZiBkcmFnZ2VkIGVsZXMgc2hvdWxkIGJlIHJlbGVhc2VkXG4gICAgICAgIHZhciByZWxlYXNlID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIGVsZXNbaV0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoIGVsZXNbaV0uYWN0aXZlKCkgKXsgZWxlc1tpXS51bmFjdGl2YXRlKCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlbGVhc2Uobm9kZXMpO1xuICAgICAgICByZWxlYXNlKGVkZ2VzKTtcblxuICAgICAgICB2YXIgb2Zmc2V0cyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcbiAgICAgICAgY29udGFpbmVyV2lkdGggPSBvZmZzZXRzWzJdO1xuICAgICAgICBjb250YWluZXJIZWlnaHQgPSBvZmZzZXRzWzNdO1xuXG4gICAgICAgIGYxeDEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICAgIGYxeTEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgXG4gICAgICAgIGYyeDEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICAgIGYyeTEgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgICB0d29GaW5nZXJzU3RhcnRJbnNpZGUgPSBcbiAgICAgICAgICAgICAwIDw9IGYxeDEgJiYgZjF4MSA8PSBjb250YWluZXJXaWR0aFxuICAgICAgICAgICYmIDAgPD0gZjJ4MSAmJiBmMngxIDw9IGNvbnRhaW5lcldpZHRoXG4gICAgICAgICAgJiYgMCA8PSBmMXkxICYmIGYxeTEgPD0gY29udGFpbmVySGVpZ2h0XG4gICAgICAgICAgJiYgMCA8PSBmMnkxICYmIGYyeTEgPD0gY29udGFpbmVySGVpZ2h0XG4gICAgICAgIDtcblxuICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlKCBmMXgxLCBmMXkxLCBmMngxLCBmMnkxICk7XG4gICAgICAgIGRpc3RhbmNlMVNxID0gZGlzdGFuY2VTcSggZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSApO1xuICAgICAgICBjZW50ZXIxID0gWyAoZjF4MSArIGYyeDEpLzIsIChmMXkxICsgZjJ5MSkvMiBdO1xuICAgICAgICBtb2RlbENlbnRlcjEgPSBbIFxuICAgICAgICAgIChjZW50ZXIxWzBdIC0gcGFuLngpIC8gem9vbSxcbiAgICAgICAgICAoY2VudGVyMVsxXSAtIHBhbi55KSAvIHpvb21cbiAgICAgICAgXTtcblxuICAgICAgICAvLyBjb25zaWRlciBjb250ZXh0IHRhcFxuICAgICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZCA9IDIwMDtcbiAgICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGRTcSA9IGN4dERpc3RUaHJlc2hvbGQgKiBjeHREaXN0VGhyZXNob2xkO1xuICAgICAgICBpZiggZGlzdGFuY2UxU3EgPCBjeHREaXN0VGhyZXNob2xkU3EgJiYgIWUudG91Y2hlc1syXSApe1xuXG4gICAgICAgICAgdmFyIG5lYXIxID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUpO1xuICAgICAgICAgIHZhciBuZWFyMiA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1syXSwgbm93WzNdLCB0cnVlKTtcblxuICAgICAgICAgIC8vY29uc29sZS5sb2coZGlzdGFuY2UxKVxuXG4gICAgICAgICAgaWYoIG5lYXIxICYmIG5lYXIxLmlzTm9kZSgpICl7XG4gICAgICAgICAgICBuZWFyMS5hY3RpdmF0ZSgpLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHR0YXBzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjE7XG4gICAgICAgICAgXG4gICAgICAgICAgfSBlbHNlIGlmKCBuZWFyMiAmJiBuZWFyMi5pc05vZGUoKSApe1xuICAgICAgICAgICAgbmVhcjIuYWN0aXZhdGUoKS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIyO1xuICAgICAgICAgIFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgfSBcblxuICAgICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSB0cnVlO1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKCdjeHR0YXBzdGFydCcpXG5cbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGNlbnRlcjEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndG91Y2hzdGFydCBwdHonKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2cob2Zmc2V0TGVmdCwgb2Zmc2V0VG9wKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZjF4MSwgZjF5MSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGYyeDEsIGYyeTEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhkaXN0YW5jZTEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhjZW50ZXIxKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5sb2coJ2Fub3RoZXIgdGFwc3RhcnQnKVxuICAgICAgXG4gICAgICBcbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlKTtcblxuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBuZWFyLmlzTm9kZSgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKG5lYXIpICl7XG5cbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcyA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICAvLyByZXNldCBkcmFnIGVsZW1lbnRzLCBzaW5jZSBuZWFyIHdpbGwgYmUgYWRkZWQgYWdhaW5cblxuICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc05vZGUoKSAmJiB0aGlzLnNlbGVjdGVkKCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGsrKyApe1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW2tdO1xuXG4gICAgICAgICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKHNlbGVjdGVkTm9kZSkgKXtcbiAgICAgICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIHNlbGVjdGVkTm9kZSwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzIH0gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIG5lYXIsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlcyB9ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2dyYWInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIG5lYXJcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNkb3duJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG4gICAgICAgIH0gaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgIGN5XG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZWRvd24nLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDtcblxuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgIHk6IHBvc1sxXVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvLyBUYXAsIHRhcGhvbGRcbiAgICAgICAgLy8gLS0tLS1cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxub3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25baV0gPSBub3dbaV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hTdGFydFRpbWUgPSArbmV3IERhdGUoKTtcbiAgICAgICAgXG4gICAgICAgIGNsZWFyVGltZW91dCggci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgKTtcbiAgICAgICAgci50b3VjaERhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZVxuICAgICAgICAgICAgICAmJiAhci5waW5jaGluZyAvLyBpZiBwaW5jaGluZywgdGhlbiB0YXBob2xkIHVuc2VsZWN0IHNob3VsZG4ndCB0YWtlIGVmZmVjdFxuXG4gICAgICAgICAgICAgIC8vIFRoaXMgdGltZSBkb3VibGUgY29uc3RyYWludCBwcmV2ZW50cyBtdWx0aXBsZSBxdWljayB0YXBzXG4gICAgICAgICAgICAgIC8vIGZvbGxvd2VkIGJ5IGEgdGFwaG9sZCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRhcGhvbGQgZXZlbnRzXG4gICAgICAgICAgICAgIC8vJiYgRGF0ZS5ub3coKSAtIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID4gMjUwXG4gICAgICAgICAgKXtcbiAgICAgICAgICAgIGlmIChyLnRvdWNoRGF0YS5zdGFydCkge1xuICAgICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHIuZGF0YS5jeS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuXG4vLyAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0YXBob2xkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vci5yZWRyYXcoKTtcbiAgICAgIFxuICAgIH0sIGZhbHNlKTtcbiAgICBcbi8vIGNvbnNvbGUubG9nID0gZnVuY3Rpb24obSl7ICQoJyNjb25zb2xlJykuYXBwZW5kKCc8ZGl2PicrbSsnPC9kaXY+Jyk7IH07XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaG1vdmUnLCAkJC51dGlsLnRocm90dGxlKGZ1bmN0aW9uKGUpIHtcbiAgICBcbiAgICAgIHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuICAgICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlOyAvL2lmICghY2FwdHVyZSkgeyByZXR1cm47IH07IFxuICAgICAgaWYoIGNhcHR1cmUgKXsgZS5wcmV2ZW50RGVmYXVsdCgpOyB9XG4gICAgXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7IFxuICAgICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdzsgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICBcbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cbiAgICAgIHZhciBkaXNwID0gW107IGZvciAodmFyIGo9MDtqPG5vdy5sZW5ndGg7aisrKSB7IGRpc3Bbal0gPSBub3dbal0gLSBlYXJsaWVyW2pdOyB9XG4gICAgICBcbiAgICAgIHZhciBzdGFydFBvcyA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb247XG5cbiAgICAgIHZhciBkeCA9IG5vd1swXSAtIHN0YXJ0UG9zWzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBub3dbMV0gLSBzdGFydFBvc1sxXTtcbiAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207XG5cbiAgICAgIGlmKCBjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgICB2YXIgZjF4MiA9IGUudG91Y2hlc1swXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjF5MiA9IGUudG91Y2hlc1swXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICB2YXIgZjJ4MiA9IGUudG91Y2hlc1sxXS5jbGllbnRYIC0gb2Zmc2V0TGVmdCwgZjJ5MiA9IGUudG91Y2hlc1sxXS5jbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgICAgICAvLyB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgICAgdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgICB2YXIgZmFjdG9yU3EgPSBkaXN0YW5jZTJTcSAvIGRpc3RhbmNlMVNxO1xuXG4gICAgICAgIHZhciBkaXN0VGhyZXNob2xkID0gMTUwO1xuICAgICAgICB2YXIgZGlzdFRocmVzaG9sZFNxID0gZGlzdFRocmVzaG9sZCAqIGRpc3RUaHJlc2hvbGQ7XG4gICAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGQgPSAxLjU7XG4gICAgICAgIHZhciBmYWN0b3JUaHJlc2hvbGRTcSA9IGZhY3RvclRocmVzaG9sZCAqIGZhY3RvclRocmVzaG9sZDtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKGZhY3RvciwgZGlzdGFuY2UyKVxuXG4gICAgICAgIC8vIGNhbmNlbCBjdHggZ2VzdHVyZXMgaWYgdGhlIGRpc3RhbmNlIGIvdCB0aGUgZmluZ2VycyBpbmNyZWFzZXNcbiAgICAgICAgaWYoIGZhY3RvclNxID49IGZhY3RvclRocmVzaG9sZFNxIHx8IGRpc3RhbmNlMlNxID49IGRpc3RUaHJlc2hvbGRTcSApe1xuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC51bmFjdGl2YXRlKCk7IHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDsgfVxuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIGN4dEV2dCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9ICBcblxuICAgICAgaWYoIGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0ICl7IFxuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgIH0pO1xuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2N4dGRyYWcnKVxuXG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUpO1xuXG4gICAgICAgIGlmKCAhci50b3VjaERhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLnRvdWNoRGF0YS5jeHRPdmVyICl7XG5cbiAgICAgICAgICBpZiggci50b3VjaERhdGEuY3h0T3ZlciApe1xuICAgICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2N4dGRyYWdvdXQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyID0gbmVhcjtcblxuICAgICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2N4dGRyYWdvdmVyJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmKCBjYXB0dXJlICYmIGUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgKXsgXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLnRocmVlRmluZ2VyU2VsZWN0VGltZW91dCApO1xuICAgICAgICB0aGlzLmxhc3RUaHJlZVRvdWNoID0gK25ldyBEYXRlKCk7XG5cbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICBpZiggIXNlbGVjdCB8fCBzZWxlY3QubGVuZ3RoID09PSAwIHx8IHNlbGVjdFswXSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgc2VsZWN0WzBdID0gKG5vd1swXSArIG5vd1syXSArIG5vd1s0XSkvMztcbiAgICAgICAgICBzZWxlY3RbMV0gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKS8zO1xuICAgICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pLzMgKyAxO1xuICAgICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pLzMgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGVjdFsyXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pLzM7XG4gICAgICAgICAgc2VsZWN0WzNdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkvMztcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdFs0XSA9IDE7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgfSBlbHNlIGlmICggY2FwdHVyZSAmJiBlLnRvdWNoZXNbMV0gJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICkgeyAvLyB0d28gZmluZ2VycyA9PiBwaW5jaCB0byB6b29tXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgIGlmKCBkcmFnZ2VkRWxlcyApeyBcbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndG91Y2htb3ZlIHB0eicpO1xuXG4gICAgICAgIC8vICh4MiwgeTIpIGZvciBmaW5nZXJzIDEgYW5kIDJcbiAgICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggZjF4MiwgZjF5MiApXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBmMngyLCBmMnkyIClcblxuICAgICAgICB2YXIgZGlzdGFuY2UyID0gZGlzdGFuY2UoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgICAgLy8gdmFyIGRpc3RhbmNlMlNxID0gZGlzdGFuY2VTcSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgICAvLyB2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KCBkaXN0YW5jZTJTcSApIC8gTWF0aC5zcXJ0KCBkaXN0YW5jZTFTcSApO1xuICAgICAgICB2YXIgZmFjdG9yID0gZGlzdGFuY2UyIC8gZGlzdGFuY2UxO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGRpc3RhbmNlMilcbiAgICAgICAgLy8gY29uc29sZS5sb2coZmFjdG9yKVxuXG4gICAgICAgIGlmKCBmYWN0b3IgIT0gMSAmJiB0d29GaW5nZXJzU3RhcnRJbnNpZGUpe1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coZmFjdG9yKVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGRpc3RhbmNlMiArICcgLyAnICsgZGlzdGFuY2UxKTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0nKTtcblxuICAgICAgICAgIC8vIGRlbHRhIGZpbmdlcjFcbiAgICAgICAgICB2YXIgZGYxeCA9IGYxeDIgLSBmMXgxO1xuICAgICAgICAgIHZhciBkZjF5ID0gZjF5MiAtIGYxeTE7XG5cbiAgICAgICAgICAvLyBkZWx0YSBmaW5nZXIgMlxuICAgICAgICAgIHZhciBkZjJ4ID0gZjJ4MiAtIGYyeDE7XG4gICAgICAgICAgdmFyIGRmMnkgPSBmMnkyIC0gZjJ5MTtcblxuICAgICAgICAgIC8vIHRyYW5zbGF0aW9uIGlzIHRoZSBub3JtYWxpc2VkIHZlY3RvciBvZiB0aGUgdHdvIGZpbmdlcnMgbW92ZW1lbnRcbiAgICAgICAgICAvLyBpLmUuIHNvIHBpbmNoaW5nIGNhbmNlbHMgb3V0IGFuZCBtb3ZpbmcgdG9nZXRoZXIgcGFuc1xuICAgICAgICAgIHZhciB0eCA9IChkZjF4ICsgZGYyeCkvMjtcbiAgICAgICAgICB2YXIgdHkgPSAoZGYxeSArIGRmMnkpLzI7XG5cbiAgICAgICAgICAvLyBhZGp1c3QgZmFjdG9yIGJ5IHRoZSBzcGVlZCBtdWx0aXBsaWVyXG4gICAgICAgICAgLy8gdmFyIHNwZWVkID0gMS41O1xuICAgICAgICAgIC8vIGlmKCBmYWN0b3IgPiAxICl7XG4gICAgICAgICAgLy8gICBmYWN0b3IgPSAoZmFjdG9yIC0gMSkgKiBzcGVlZCArIDE7XG4gICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAvLyAgIGZhY3RvciA9IDEgLSAoMSAtIGZhY3RvcikgKiBzcGVlZDtcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAvLyBub3cgY2FsY3VsYXRlIHRoZSB6b29tXG4gICAgICAgICAgdmFyIHpvb20xID0gY3kuem9vbSgpO1xuICAgICAgICAgIHZhciB6b29tMiA9IHpvb20xICogZmFjdG9yO1xuICAgICAgICAgIHZhciBwYW4xID0gY3kucGFuKCk7XG5cbiAgICAgICAgICAvLyB0aGUgbW9kZWwgY2VudGVyIHBvaW50IGNvbnZlcnRlZCB0byB0aGUgY3VycmVudCByZW5kZXJlZCBwb3NcbiAgICAgICAgICB2YXIgY3RyeCA9IG1vZGVsQ2VudGVyMVswXSAqIHpvb20xICsgcGFuMS54O1xuICAgICAgICAgIHZhciBjdHJ5ID0gbW9kZWxDZW50ZXIxWzFdICogem9vbTEgKyBwYW4xLnk7XG5cbiAgICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICAgIHg6IC16b29tMi96b29tMSAqIChjdHJ4IC0gcGFuMS54IC0gdHgpICsgY3RyeCxcbiAgICAgICAgICAgIHk6IC16b29tMi96b29tMSAqIChjdHJ5IC0gcGFuMS55IC0gdHkpICsgY3RyeVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhwYW4yKTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyh6b29tMik7XG5cbiAgICAgICAgICAvLyByZW1vdmUgZHJhZ2dlZCBlbGVzXG4gICAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgICAgICAgIGlmKCBkcmFnZ2VkRWxlcyApeyBmb3IoIHZhciBpID0gMDsgaSA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gfVxuXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0XG4gICAgICAgICAgICAgIC50cmlnZ2VyKCdmcmVlJylcbiAgICAgICAgICAgICAgLnRyaWdnZXIoJ3VuYWN0aXZhdGUnKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LnZpZXdwb3J0KHtcbiAgICAgICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICAgICAgcGFuOiBwYW4yLFxuICAgICAgICAgICAgY2FuY2VsT25GYWlsZWRab29tOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZTI7ICBcbiAgICAgICAgICBmMXgxID0gZjF4MjtcbiAgICAgICAgICBmMXkxID0gZjF5MjtcbiAgICAgICAgICBmMngxID0gZjJ4MjtcbiAgICAgICAgICBmMnkxID0gZjJ5MjtcblxuICAgICAgICAgIHIucGluY2hpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSZS1wcm9qZWN0XG4gICAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgICBpZiAoZS50b3VjaGVzWzFdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICAgICAgaWYgKGUudG91Y2hlc1syXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG5cbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuICAgICAgICB2YXIgbGFzdCA9IHIudG91Y2hEYXRhLmxhc3Q7XG4gICAgICAgIHZhciBuZWFyID0gbmVhciB8fCByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYoIHN0YXJ0ICE9IG51bGwgJiYgc3RhcnQuX3ByaXZhdGUuZ3JvdXAgPT0gJ25vZGVzJyAmJiByLm5vZGVJc0RyYWdnYWJsZShzdGFydCkgKXtcblxuICAgICAgICAgIGlmKCByZGlzdDIgPj0gci50YXBUaHJlc2hvbGQyICl7IC8vIHRoZW4gZHJhZ2dpbmcgY2FuIGhhcHBlblxuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IGRyYWdnZWRFbGVzLmxlbmd0aDsgaysrICl7XG4gICAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlID0gZHJhZ2dlZEVsZXNba107XG5cbiAgICAgICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKGRyYWdnZWRFbGUpICYmIGRyYWdnZWRFbGUuaXNOb2RlKCkgJiYgZHJhZ2dlZEVsZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBkUG9zID0gZHJhZ2dlZEVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcztcblxuICAgICAgICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoZGlzcFswXSkgJiYgJCQuaXMubnVtYmVyKGRpc3BbMV0pICl7XG4gICAgICAgICAgICAgICAgICBkUG9zLnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCBqdXN0U3RhcnRlZERyYWcgKXtcbiAgICAgICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIGRyYWdnZWRFbGUsIHsgaW5EcmFnTGF5ZXI6IHRydWUgfSApO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKGRyYWdEZWx0YVswXSkgJiYgJCQuaXMubnVtYmVyKGRyYWdEZWx0YVsxXSkgKXtcbiAgICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGNvbCA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBkcmFnZ2VkRWxlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGNvbC51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICAgICAgdGNvbC50cmlnZ2VyKCdwb3NpdGlvbiBkcmFnJyk7XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKCBcbiAgICAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSA9PSBlYXJsaWVyWzBdXG4gICAgICAgICAgICAgICYmIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gPT0gZWFybGllclsxXVxuICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJpc2Uga2VlcCB0cmFjayBvZiBkcmFnIGRlbHRhIGZvciBsYXRlclxuICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YSB8fCBbXTtcblxuICAgICAgICAgICAgaWYoIGRyYWdEZWx0YS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhLnB1c2goMCk7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhWzBdICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVG91Y2htb3ZlIGV2ZW50XG4gICAgICAgIHtcblxuICAgICAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApOyBcblxuICAgICAgICAgICAgc3RhcnQudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWcnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7IFxuXG4gICAgICAgICAgICBzdGFydC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlbW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTsgXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7IFxuXG4gICAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7IFxuICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7IFxuXG4gICAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZycsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5lYXIgPT0gbnVsbCkgeyBcbiAgICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTsgXG5cbiAgICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZycsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7IFxuXG4gICAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVhciAhPSBsYXN0KSB7XG4gICAgICAgICAgICBpZiAobGFzdCkgeyBsYXN0LnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHsgdHlwZTogJ3RhcGRyYWdvdXQnLCBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH0gfSkpOyB9XG4gICAgICAgICAgICBpZiAobmVhcikgeyBuZWFyLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHsgdHlwZTogJ3RhcGRyYWdvdmVyJywgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9IH0pKTsgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIudG91Y2hEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDaGVjayB0byBjYW5jZWwgdGFwaG9sZFxuICAgICAgICBmb3IgKHZhciBpPTA7aTxub3cubGVuZ3RoO2krKykge1xuICAgICAgICAgIGlmIChub3dbaV0gXG4gICAgICAgICAgICAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldXG4gICAgICAgICAgICAmJiBNYXRoLmFicyhub3dbaV0gLSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldKSA+IDQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihcbiAgICAgICAgICAgIGNhcHR1cmVcbiAgICAgICAgICAgICYmICggc3RhcnQgPT0gbnVsbCB8fCBzdGFydC5pc0VkZ2UoKSApXG4gICAgICAgICAgICAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpXG4gICAgICAgICl7XG5cbiAgICAgICAgICBpZiggci5zd2lwZVBhbm5pbmcgKXtcbiAgICAgICAgICAgIGN5LnBhbkJ5KHtcbiAgICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIH0gZWxzZSBpZiggcmRpc3QyID49IHIudGFwVGhyZXNob2xkMiApe1xuICAgICAgICAgICAgci5zd2lwZVBhbm5pbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICAgIHg6IGR4ICogem9vbSxcbiAgICAgICAgICAgICAgeTogZHkgKiB6b29tXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcblxuICAgICAgICAgICAgaWYoICFyLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gKXtcbiAgICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IG5vd1swXSxcbiAgICAgICAgICAgICAgICB5OiBub3dbMV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZS1wcm9qZWN0XG4gICAgICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICAgIG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGo9MDsgajxub3cubGVuZ3RoOyBqKyspIHsgZWFybGllcltqXSA9IG5vd1tqXTsgfVxuICAgICAgLy9yLnJlZHJhdygpO1xuICAgICAgXG4gICAgfSwgMTAwMC8zMCwgeyB0cmFpbGluZzogdHJ1ZSB9KSwgZmFsc2UpO1xuICAgIFxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNoY2FuY2VsJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3RvdWNoZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG5cbiAgICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTsgXG5cbiAgICAgIGlmKCBjYXB0dXJlICl7XG4gICAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHNlbGVjdCA9IHIuZGF0YS5zZWxlY3Q7XG5cbiAgICAgIHIuc3dpcGVQYW5uaW5nID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5OyBcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdztcbiAgICAgIHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcblxuICAgICAgaWYgKGUudG91Y2hlc1swXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuICAgICAgXG4gICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4VGFwZW5kO1xuICAgICAgaWYoIHIudG91Y2hEYXRhLmN4dCApe1xuICAgICAgICBjdHhUYXBlbmQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHR0YXBlbmQnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggc3RhcnQgKXtcbiAgICAgICAgICBzdGFydC50cmlnZ2VyKCBjdHhUYXBlbmQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjdHhUYXBlbmQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2N4dHRhcGVuZCcpXG5cbiAgICAgICAgaWYoICFyLnRvdWNoRGF0YS5jeHREcmFnZ2VkICl7XG4gICAgICAgICAgdmFyIGN0eFRhcCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgICAgICBzdGFydC50cmlnZ2VyKCBjdHhUYXAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kudHJpZ2dlciggY3R4VGFwICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnY3h0dGFwJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApeyByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7IH1cbiAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcblxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG1vcmUgYm94IHNlbGVjdGlvbiBpZiB3ZSBkb24ndCBoYXZlIHRocmVlIGZpbmdlcnNcbiAgICAgIGlmKCAhZS50b3VjaGVzWzJdICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSApe1xuICAgICAgICBjbGVhclRpbWVvdXQoIHRoaXMudGhyZWVGaW5nZXJTZWxlY3RUaW1lb3V0ICk7XG4gICAgICAgIC8vdGhpcy50aHJlZUZpbmdlclNlbGVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIG5ld2x5U2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgICB2YXIgYm94ID0gci5nZXRBbGxJbkJveCggc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdICk7XG5cbiAgICAgICAgICBzZWxlY3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc2VsZWN0WzFdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGVjdFsyXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxlY3RbM10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc2VsZWN0WzRdID0gMDtcblxuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhib3gpO1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpPCBib3gubGVuZ3RoOyBpKysgKSB7IFxuICAgICAgICAgICAgaWYoIGJveFtpXS5fcHJpdmF0ZS5zZWxlY3RhYmxlICl7XG4gICAgICAgICAgICAgIG5ld2x5U2VsZWN0ZWQucHVzaCggYm94W2ldICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld2x5U2VsQ29sID0gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBuZXdseVNlbGVjdGVkICk7XG5cbiAgICAgICAgICBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnc2luZ2xlJyApe1xuICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykubm90KCBuZXdseVNlbENvbCApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV3bHlTZWxDb2wuc2VsZWN0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIG5ld2x5U2VsQ29sLmxlbmd0aCA+IDAgKSB7IFxuICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTsgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vfSwgMTAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZVN0YXJ0U3R5bGUgPSBmYWxzZTtcblxuICAgICAgaWYoIHN0YXJ0ICE9IG51bGwgKXtcbiAgICAgICAgc3RhcnQuX3ByaXZhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHVwZGF0ZVN0YXJ0U3R5bGUgPSB0cnVlO1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIHtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgXG4gICAgICAvLyBMYXN0IHRvdWNoIHJlbGVhc2VkXG4gICAgICB9IGVsc2UgaWYgKCFlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgXG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICBpZiAoc3RhcnQgIT0gbnVsbCApIHtcblxuICAgICAgICAgIGlmKCBzdGFydC5fcHJpdmF0ZS5ncmFiYmVkICl7XG4gICAgICAgICAgICBzdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgICBzdGFydC50cmlnZ2VyKCdmcmVlJyk7XG4gICAgICAgICAgICBzdGFydC5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgc0VkZ2VzID0gc3RhcnQuX3ByaXZhdGUuZWRnZXM7XG4gICAgICAgICAgZm9yICh2YXIgaj0wO2o8c0VkZ2VzLmxlbmd0aDtqKyspIHsgc0VkZ2VzW2pdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7IH1cbiAgICAgICAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihzdGFydCwgZmFsc2UpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBzdGFydC5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlcyA9IGN5LiQoJ25vZGU6c2VsZWN0ZWQnKTtcblxuICAgICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBzZWxlY3RlZE5vZGVzLmxlbmd0aDsgaysrICl7XG5cbiAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IHNlbGVjdGVkTm9kZXNba107XG4gICAgICAgICAgICAgIHNlbGVjdGVkTm9kZS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgICAgICBzZWxlY3RlZE5vZGUuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIHZhciBzRWRnZXMgPSBzZWxlY3RlZE5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgajxzRWRnZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzRWRnZXNbal0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKHNlbGVjdGVkTm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IHRydWU7IFxuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7IFxuICAgICAgICAgIFxuICAgICAgICAgIHN0YXJ0XG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndG91Y2hlbmQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGVuZCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNldXAnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgIDtcbiAgICAgICAgICBcbiAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICAgIGlmIChuZWFyICE9IG51bGwpIHsgXG4gICAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2V1cCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWFyID09IG51bGwpIHsgXG4gICAgICAgICAgICBjeVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBlbmQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzBdIC0gbm93WzBdO1xuICAgICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgICAgdmFyIGR5ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblsxXSAtIG5vd1sxXTtcbiAgICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgICAgdmFyIHJkaXN0MiA9IGRpc3QyICogem9vbSAqIHpvb207XG4gICAgICAgIFxuICAgICAgICAvLyBQcmVwYXJlIHRvIHNlbGVjdCB0aGUgY3VycmVudGx5IHRvdWNoZWQgbm9kZSwgb25seSBpZiBpdCBoYXNuJ3QgYmVlbiBkcmFnZ2VkIHBhc3QgYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICAgIGlmIChzdGFydCAhPSBudWxsIFxuICAgICAgICAgICAgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgZHJhZyBub2RlcyBhcm91bmRcbiAgICAgICAgICAgICYmIHN0YXJ0Ll9wcml2YXRlLnNlbGVjdGFibGUgXG4gICAgICAgICAgICAmJiByZGlzdDIgPCByLnRhcFRocmVzaG9sZDJcbiAgICAgICAgICAgICYmICFyLnBpbmNoaW5nIC8vIHBpbmNoIHRvIHpvb20gc2hvdWxkIG5vdCBhZmZlY3Qgc2VsZWN0aW9uXG4gICAgICAgICkge1xuXG4gICAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ3NpbmdsZScgKXtcbiAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLm5vdCggc3RhcnQgKS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgc3RhcnQuc2VsZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCBzdGFydC5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgIHN0YXJ0LnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGFydC5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGVTdGFydFN0eWxlID0gdHJ1ZTtcblxuICAgICAgICAgIFxuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7IFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUYXAgZXZlbnQsIHJvdWdobHkgc2FtZSBhcyBtb3VzZSBjbGljayBldmVudCBmb3IgdG91Y2hcbiAgICAgICAgaWYgKCByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID09PSBmYWxzZSApIHtcblxuICAgICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnRcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ZjbGljaycsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndmNsaWNrJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuLy8gICAgICAgICAgY29uc29sZS5sb2coJ3RhcCcpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBub3cubGVuZ3RoOyBqKysgKXsgZWFybGllcltqXSA9IG5vd1tqXTsgfVxuXG4gICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSBmYWxzZTsgLy8gcmVzZXQgZm9yIG5leHQgbW91c2Vkb3duXG5cbiAgICAgIGlmKCBlLnRvdWNoZXNbMF0gKXtcbiAgICAgICAgci50b3VjaERhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmKCB1cGRhdGVTdGFydFN0eWxlICYmIHN0YXJ0ICl7XG4gICAgICAgIHN0YXJ0LnVwZGF0ZVN0eWxlKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYoIGUudG91Y2hlcy5sZW5ndGggPCAyICl7XG4gICAgICAgIHIucGluY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTsgXG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIC8vci5yZWRyYXcoKTtcbiAgICAgIFxuICAgIH0sIGZhbHNlKTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciByZW5kZXJlciA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcbiAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcblxuICAvLyBOb2RlIHNoYXBlIGNvbnRyYWN0OlxuICAvL1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIGludGVyc2VjdExpbmU6IHJlcG9ydCBpbnRlcnNlY3Rpb24gZnJvbSB4LCB5LCB0byBub2RlIGNlbnRlclxuICAvLyBjaGVja1BvaW50OiBjaGVjayB4LCB5IGluIG5vZGVcblxuICB2YXIgbm9kZVNoYXBlcyA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXMgPSB7fTtcblxuICB2YXIgc2luMCA9IE1hdGguc2luKDApO1xuICB2YXIgY29zMCA9IE1hdGguY29zKDApO1xuXG4gIHZhciBzaW4gPSB7fTtcbiAgdmFyIGNvcyA9IHt9O1xuXG4gIHZhciBlbGxpcHNlU3RlcFNpemUgPSAwLjE7XG5cbiAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplICkge1xuICAgIHNpbltpXSA9IE1hdGguc2luKGkpO1xuICAgIGNvc1tpXSA9IE1hdGguY29zKGkpO1xuICB9XG5cbiAgbm9kZVNoYXBlc1snZWxsaXBzZSddID0ge1xuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIG5vZGVTaGFwZXNbJ2VsbGlwc2UnXS5kcmF3UGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgXG4vLyAgICAgIGNvbnNvbGUubG9nKCdkcmF3aW5nIGVsbGlwc2UnKTtcbi8vICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXdQYXRoOiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBcbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgICAgIHZhciB4UG9zLCB5UG9zO1xuICAgICAgICB2YXIgcncgPSB3aWR0aC8yO1xuICAgICAgICB2YXIgcmggPSBoZWlnaHQvMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplICkge1xuICAgICAgICAgICAgeFBvcyA9IGNlbnRlclggLSAocncgKiBzaW5baV0pICogc2luMCArIChydyAqIGNvc1tpXSkgKiBjb3MwO1xuICAgICAgICAgICAgeVBvcyA9IGNlbnRlclkgKyAocmggKiBjb3NbaV0pICogc2luMCArIChyaCAqIHNpbltpXSkgKiBjb3MwO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgICAgIC8vIEF0IG9yaWdpbiwgcmFkaXVzIDEsIDAgdG8gMnBpXG4gICAgICAgIGNvbnRleHQuYXJjKDAsIDAsIDEsIDAsIE1hdGguUEkgKiAyICogMC45OTksIGZhbHNlKTsgLy8gKjAuOTk5IGIvYyBjaHJvbWUgcmVuZGVyaW5nIGJ1ZyBvbiBmdWxsIGNpcmNsZVxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGNvbnRleHQuc2NhbGUoMi93aWR0aCwgMi9oZWlnaHQpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtY2VudGVyWCwgLWNlbnRlclkpO1xuXG4gICAgICB9XG4gICAgICBcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgdmFyIGludGVyc2VjdCA9ICQkLm1hdGguaW50ZXJzZWN0TGluZUVsbGlwc2UoXG4gICAgICAgIHgsIHksXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGggLyAyICsgcGFkZGluZyxcbiAgICAgICAgaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICByZXR1cm4gaW50ZXJzZWN0O1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbihcbiAgICAgIHgxLCB5MSwgeDIsIHkyLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLmJveEludGVyc2VjdEVsbGlwc2UoXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9LFxuICAgIFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4vLyAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgICBcbiAgICAgIHggLT0gY2VudGVyWDtcbiAgICAgIHkgLT0gY2VudGVyWTtcbiAgICAgIFxuICAgICAgeCAvPSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICB5IC89IChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHJldHVybiAoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSA8PSAxKTtcbiAgICB9XG4gIH07XG4gIFxuICBub2RlU2hhcGVzWyd0cmlhbmdsZSddID0ge1xuICAgIHBvaW50czogJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoMywgMCksXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb24oY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgbm9kZVNoYXBlc1sndHJpYW5nbGUnXS5wb2ludHMpO1xuICAgIH0sXG4gICAgXG4gICAgZHJhd1BhdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBub2RlU2hhcGVzWyd0cmlhbmdsZSddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlU2hhcGVzWyd0cmlhbmdsZSddLnBvaW50cyxcbiAgICAgICAgbm9kZVgsXG4gICAgICAgIG5vZGVZLFxuICAgICAgICB3aWR0aCAvIDIsIGhlaWdodCAvIDIsXG4gICAgICAgIHBhZGRpbmcpO1xuICAgIFxuICAgICAgLypcbiAgICAgIHBvbHlnb25JbnRlcnNlY3RMaW5lKHgsIHksIGJhc2VQb2ludHMsIGNlbnRlclgsIGNlbnRlclksIFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgICAgICovXG4gICAgICBcbiAgICAgIFxuICAgICAgLypcbiAgICAgIHJldHVybiByZW5kZXJlci5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgbm9kZSwgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgeCwgeSwgbm9kZVNoYXBlc1sndHJpYW5nbGUnXS5wb2ludHMpO1xuICAgICAgKi9cbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICB4MSwgeTEsIHgyLCB5Miwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICAgICAgXG4gICAgICB2YXIgcG9pbnRzID0gbm9kZVNoYXBlc1sndHJpYW5nbGUnXS5wb2ludHM7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLmJveEludGVyc2VjdFBvbHlnb24oXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICBwb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oXG4gICAgICB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgbm9kZVNoYXBlc1sndHJpYW5nbGUnXS5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbiAgXG4gIG5vZGVTaGFwZXNbJ3NxdWFyZSddID0ge1xuICAgIHBvaW50czogJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb24oY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgbm9kZVNoYXBlc1snc3F1YXJlJ10ucG9pbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXdQYXRoOiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3UG9seWdvblBhdGgoY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgbm9kZVNoYXBlc1snc3F1YXJlJ10ucG9pbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuICQkLm1hdGgucG9seWdvbkludGVyc2VjdExpbmUoXG4gICAgICAgICAgeCwgeSxcbiAgICAgICAgICBub2RlU2hhcGVzWydzcXVhcmUnXS5wb2ludHMsXG4gICAgICAgICAgbm9kZVgsXG4gICAgICAgICAgbm9kZVksXG4gICAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyLFxuICAgICAgICAgIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbihcbiAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgXG4gICAgICBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgICBcbiAgICAgIHZhciBwb2ludHMgPSBub2RlU2hhcGVzWydzcXVhcmUnXS5wb2ludHM7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLmJveEludGVyc2VjdFBvbHlnb24oXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICBwb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIFxuICAgICAgICBjZW50ZXJZLCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1snc3F1YXJlJ10ucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG4gIFxuICBub2RlU2hhcGVzWydyZWN0YW5nbGUnXSA9IG5vZGVTaGFwZXNbJ3NxdWFyZSddO1xuICBcbiAgbm9kZVNoYXBlc1snb2N0b2dvbiddID0ge307XG4gIFxuICBub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddID0ge1xuICAgIHBvaW50czogJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCksXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1JvdW5kUmVjdGFuZ2xlKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIDEwKTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXdQYXRoOiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3Um91bmRSZWN0YW5nbGVQYXRoKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIDEwKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuICQkLm1hdGgucm91bmRSZWN0YW5nbGVJbnRlcnNlY3RMaW5lKFxuICAgICAgICAgIHgsIHksXG4gICAgICAgICAgbm9kZVgsXG4gICAgICAgICAgbm9kZVksXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICB4MSwgeTEsIHgyLCB5MixcbiAgICAgIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIFxuICAgICAgY2VudGVyWSwgcGFkZGluZykge1xuXG4gICAgICByZXR1cm4gJCQubWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdEJveChcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsIFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIC8vIExvb2tzIGxpa2UgdGhlIHdpZHRoIHBhc3NlZCBpbnRvIHRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgdGhlIHRvdGFsIHdpZHRoIC8gMlxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4gICAgICB2YXIgY29ybmVyUmFkaXVzID0gJCQubWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaEJveFxuICAgICAgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIG5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10ucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0IC0gMiAqIGNvcm5lclJhZGl1cywgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIHZCb3hcbiAgICAgIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGggLSAyICogY29ybmVyUmFkaXVzLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgY2hlY2tJbkVsbGlwc2UgPSBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gICAgICAgIHggLT0gY2VudGVyWDtcbiAgICAgICAgeSAtPSBjZW50ZXJZO1xuICAgICAgICBcbiAgICAgICAgeCAvPSAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgICAgIHkgLz0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSA8PSAxKTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdG9wIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvKlxuICAgICAgaWYgKHJlbmRlcmVyLmJveEludGVyc2VjdEVsbGlwc2UoeCwgeSwgeCwgeSwgcGFkZGluZywgXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsXG4gICAgICAgIGNlbnRlclggLSB3aWR0aCArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSAtIGhlaWdodCArIGNvcm5lclJhZGl1cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAqL1xuICAgICAgXG4gICAgICAvLyBDaGVjayB0b3AgcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZIC0gaGVpZ2h0IC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBib3R0b20gcmlnaHQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBib3R0b20gbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksXG4gICAgICAgIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nKSkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIFxuICBub2RlU2hhcGVzWydwZW50YWdvbiddID0ge1xuICAgIHBvaW50czogJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCksXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb24oY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgbm9kZVNoYXBlc1sncGVudGFnb24nXS5wb2ludHMpO1xuICAgIH0sXG4gICAgXG4gICAgZHJhd1BhdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBub2RlU2hhcGVzWydwZW50YWdvbiddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVNoYXBlc1sncGVudGFnb24nXS5wb2ludHMsXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyLFxuICAgICAgICBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICB4MSwgeTEsIHgyLCB5Miwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICAgICAgXG4gICAgICB2YXIgcG9pbnRzID0gbm9kZVNoYXBlc1sncGVudGFnb24nXS5wb2ludHM7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLmJveEludGVyc2VjdFBvbHlnb24oXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICBwb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oXG4gICAgICB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBub2RlU2hhcGVzWydwZW50YWdvbiddLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfVxuICB9O1xuICBcbiAgbm9kZVNoYXBlc1snaGV4YWdvbiddID0ge1xuICAgIHBvaW50czogJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNiwgMCksXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb24oY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgbm9kZVNoYXBlc1snaGV4YWdvbiddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIG5vZGVTaGFwZXNbJ2hleGFnb24nXS5wb2ludHMpO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24obm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gJCQubWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVNoYXBlc1snaGV4YWdvbiddLnBvaW50cyxcbiAgICAgICAgbm9kZVgsXG4gICAgICAgIG5vZGVZLFxuICAgICAgICB3aWR0aCAvIDIsIGhlaWdodCAvIDIsXG4gICAgICAgIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbihcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICAgICAgXG4gICAgICB2YXIgcG9pbnRzID0gbm9kZVNoYXBlc1snaGV4YWdvbiddLnBvaW50cztcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGguYm94SW50ZXJzZWN0UG9seWdvbihcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgIHBvaW50cywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIG5vZGVTaGFwZXNbJ2hleGFnb24nXS5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbiAgXG4gIG5vZGVTaGFwZXNbJ2hlcHRhZ29uJ10gPSB7XG4gICAgcG9pbnRzOiAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3UG9seWdvbihjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBub2RlU2hhcGVzWydoZXB0YWdvbiddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIG5vZGVTaGFwZXNbJ2hlcHRhZ29uJ10ucG9pbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLnBvbHlnb25JbnRlcnNlY3RMaW5lKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlU2hhcGVzWydoZXB0YWdvbiddLnBvaW50cyxcbiAgICAgICAgbm9kZVgsXG4gICAgICAgIG5vZGVZLFxuICAgICAgICB3aWR0aCAvIDIsIGhlaWdodCAvIDIsXG4gICAgICAgIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbihcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICAgIFxuICAgICAgdmFyIHBvaW50cyA9IG5vZGVTaGFwZXNbJ2hlcHRhZ29uJ10ucG9pbnRzO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVuZGVyZXIuYm94SW50ZXJzZWN0UG9seWdvbihcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgIHBvaW50cywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfSxcblxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1snaGVwdGFnb24nXS5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbiAgXG4gIG5vZGVTaGFwZXNbJ29jdGFnb24nXSA9IHtcbiAgICBwb2ludHM6ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIG5vZGVTaGFwZXNbJ29jdGFnb24nXS5wb2ludHMpO1xuICAgIH0sXG4gICAgXG4gICAgZHJhd1BhdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBub2RlU2hhcGVzWydvY3RhZ29uJ10ucG9pbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLnBvbHlnb25JbnRlcnNlY3RMaW5lKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlU2hhcGVzWydvY3RhZ29uJ10ucG9pbnRzLFxuICAgICAgICBub2RlWCxcbiAgICAgICAgbm9kZVksXG4gICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMixcbiAgICAgICAgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uKFxuICAgICAgICB4MSwgeTEsIHgyLCB5Miwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICAgICAgXG4gICAgICB2YXIgcG9pbnRzID0gbm9kZVNoYXBlc1snb2N0YWdvbiddLnBvaW50cztcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlbmRlcmVyLmJveEludGVyc2VjdFBvbHlnb24oXG4gICAgICAgICAgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgcG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1snb2N0YWdvbiddLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfVxuICB9O1xuICBcbiAgdmFyIHN0YXI1UG9pbnRzID0gbmV3IEFycmF5KDIwKTtcbiAge1xuICAgIHZhciBvdXRlclBvaW50cyA9ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyg1LCAwKTtcbiAgICB2YXIgaW5uZXJQb2ludHMgPSAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgTWF0aC5QSSAvIDUpO1xuICAgIFxuLy8gICAgY29uc29sZS5sb2cob3V0ZXJQb2ludHMpO1xuLy8gICAgY29uc29sZS5sb2coaW5uZXJQb2ludHMpO1xuICAgIFxuICAgIC8vIE91dGVyIHJhZGl1cyBpcyAxOyBpbm5lciByYWRpdXMgb2Ygc3RhciBpcyBzbWFsbGVyXG4gICAgdmFyIGlubmVyUmFkaXVzID0gMC41ICogKDMgLSBNYXRoLnNxcnQoNSkpO1xuICAgIGlubmVyUmFkaXVzICo9IDEuNTc7XG4gICAgXG4gICAgZm9yICh2YXIgaT0wO2k8aW5uZXJQb2ludHMubGVuZ3RoLzI7aSsrKSB7XG4gICAgICBpbm5lclBvaW50c1tpKjJdICo9IGlubmVyUmFkaXVzO1xuICAgICAgaW5uZXJQb2ludHNbaSoyKzFdICo9IGlubmVyUmFkaXVzO1xuICAgIH1cbiAgICBcbiAgICBmb3IgKHZhciBpPTA7aTwyMC80O2krKykge1xuICAgICAgc3RhcjVQb2ludHNbaSo0XSA9IG91dGVyUG9pbnRzW2kqMl07XG4gICAgICBzdGFyNVBvaW50c1tpKjQrMV0gPSBvdXRlclBvaW50c1tpKjIrMV07XG4gICAgICBcbiAgICAgIHN0YXI1UG9pbnRzW2kqNCsyXSA9IGlubmVyUG9pbnRzW2kqMl07XG4gICAgICBzdGFyNVBvaW50c1tpKjQrM10gPSBpbm5lclBvaW50c1tpKjIrMV07XG4gICAgfVxuICAgIFxuLy8gICAgY29uc29sZS5sb2coc3RhcjVQb2ludHMpO1xuICB9XG5cbiAgc3RhcjVQb2ludHMgPSAkJC5tYXRoLmZpdFBvbHlnb25Ub1NxdWFyZSggc3RhcjVQb2ludHMgKTtcbiAgXG4gIG5vZGVTaGFwZXNbJ3N0YXI1J10gPSBub2RlU2hhcGVzWydzdGFyJ10gPSB7XG4gICAgcG9pbnRzOiBzdGFyNVBvaW50cyxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3UG9seWdvbihjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBub2RlU2hhcGVzWydzdGFyNSddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIG5vZGVTaGFwZXNbJ3N0YXI1J10ucG9pbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLnBvbHlnb25JbnRlcnNlY3RMaW5lKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlU2hhcGVzWydzdGFyNSddLnBvaW50cyxcbiAgICAgICAgbm9kZVgsXG4gICAgICAgIG5vZGVZLFxuICAgICAgICB3aWR0aCAvIDIsIGhlaWdodCAvIDIsXG4gICAgICAgIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbihcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICAgIFxuICAgICAgdmFyIHBvaW50cyA9IG5vZGVTaGFwZXNbJ3N0YXI1J10ucG9pbnRzO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVuZGVyZXIuYm94SW50ZXJzZWN0UG9seWdvbihcbiAgICAgICAgICB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICBwb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oXG4gICAgICB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBub2RlU2hhcGVzWydzdGFyNSddLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfVxuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYW5pbWF0ZTogdHJ1ZSwgLy8gd2hldGhlciB0byBzaG93IHRoZSBsYXlvdXQgYXMgaXQncyBydW5uaW5nXG4gICAgbWF4U2ltdWxhdGlvblRpbWU6IDQwMDAsIC8vIG1heCBsZW5ndGggaW4gbXMgdG8gcnVuIHRoZSBsYXlvdXRcbiAgICBmaXQ6IHRydWUsIC8vIG9uIGV2ZXJ5IGxheW91dCByZXBvc2l0aW9uIG9mIG5vZGVzLCBmaXQgdGhlIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgYXJvdW5kIHRoZSBzaW11bGF0aW9uXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgdW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nOiBmYWxzZSwgLy8gc28geW91IGNhbid0IGRyYWcgbm9kZXMgZHVyaW5nIGxheW91dFxuXG4gICAgLy8gY2FsbGJhY2tzIG9uIGxheW91dCBldmVudHNcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeSBcbiAgICBzdG9wOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcblxuICAgIC8vIGZvcmNlcyB1c2VkIGJ5IGFyYm9yICh1c2UgYXJib3IgZGVmYXVsdCBvbiB1bmRlZmluZWQpXG4gICAgcmVwdWxzaW9uOiB1bmRlZmluZWQsXG4gICAgc3RpZmZuZXNzOiB1bmRlZmluZWQsXG4gICAgZnJpY3Rpb246IHVuZGVmaW5lZCxcbiAgICBncmF2aXR5OiB0cnVlLFxuICAgIGZwczogdW5kZWZpbmVkLFxuICAgIHByZWNpc2lvbjogdW5kZWZpbmVkLFxuXG4gICAgLy8gc3RhdGljIG51bWJlcnMgb3IgZnVuY3Rpb25zIHRoYXQgZHluYW1pY2FsbHkgcmV0dXJuIHdoYXQgdGhlc2VcbiAgICAvLyB2YWx1ZXMgc2hvdWxkIGJlIGZvciBlYWNoIGVsZW1lbnRcbiAgICAvLyBlLmcuIG5vZGVNYXNzOiBmdW5jdGlvbihuKXsgcmV0dXJuIG4uZGF0YSgnd2VpZ2h0JykgfVxuICAgIG5vZGVNYXNzOiB1bmRlZmluZWQsIFxuICAgIGVkZ2VMZW5ndGg6IHVuZGVmaW5lZCxcblxuICAgIHN0ZXBTaXplOiAwLjEsIC8vIHNtb290aGluZyBvZiBhcmJvciBib3VuZGluZyBib3hcblxuICAgIC8vIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBzeXN0ZW0gaXMgc3RhYmxlIHRvIGluZGljYXRlXG4gICAgLy8gdGhhdCB0aGUgbGF5b3V0IGNhbiBiZSBzdG9wcGVkXG4gICAgc3RhYmxlRW5lcmd5OiBmdW5jdGlvbiggZW5lcmd5ICl7XG4gICAgICB2YXIgZSA9IGVuZXJneTsgXG4gICAgICByZXR1cm4gKGUubWF4IDw9IDAuNSkgfHwgKGUubWVhbiA8PSAwLjMpO1xuICAgIH0sXG5cbiAgICAvLyBpbmZpbml0ZSBsYXlvdXQgb3B0aW9uc1xuICAgIGluZmluaXRlOiBmYWxzZSAvLyBvdmVycmlkZXMgYWxsIG90aGVyIG9wdGlvbnMgZm9yIGEgZm9yY2VzLWFsbC10aGUtdGltZSBtb2RlXG4gIH07XG4gIFxuICBmdW5jdGlvbiBBcmJvckxheW91dChvcHRpb25zKXtcbiAgICB0aGlzLl9wcml2YXRlID0ge307XG5cbiAgICB0aGlzLl9wcml2YXRlLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gICAgXG4gIEFyYm9yTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5fcHJpdmF0ZS5vcHRpb25zO1xuXG4gICAgJCQudXRpbC5yZXF1aXJlKCdhcmJvcicsIGZ1bmN0aW9uKGFyYm9yKXtcblxuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgICAgdmFyIGVkZ2VzID0gZWxlcy5lZGdlcygpO1xuICAgICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICB9ICk7XG4gICAgICB2YXIgc2ltVXBkYXRpbmdQb3MgPSBmYWxzZTtcblxuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSBmb3Igb2xkIGFuaW1hdGlvbiBvcHRpb25cbiAgICAgIGlmKCBvcHRpb25zLmxpdmVVcGRhdGUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICBvcHRpb25zLmFuaW1hdGUgPSBvcHRpb25zLmxpdmVVcGRhdGU7XG4gICAgICB9XG5cbiAgICAgIC8vIGFyYm9yIGRvZXNuJ3Qgd29yayB3aXRoIGp1c3QgMSBub2RlIFxuICAgICAgaWYoIGN5Lm5vZGVzKCkuc2l6ZSgpIDw9IDEgKXtcbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kucmVzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN5Lm5vZGVzKCkucG9zaXRpb24oe1xuICAgICAgICAgIHg6IE1hdGgucm91bmQoIChiYi54MSArIGJiLngyKS8yICksXG4gICAgICAgICAgeTogTWF0aC5yb3VuZCggKGJiLnkxICsgYmIueTIpLzIgKVxuICAgICAgICB9KTtcblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3lzID0gbGF5b3V0Ll9wcml2YXRlLnN5c3RlbSA9IGFyYm9yLlBhcnRpY2xlU3lzdGVtKCk7XG5cbiAgICAgIHN5cy5wYXJhbWV0ZXJzKHtcbiAgICAgICAgcmVwdWxzaW9uOiBvcHRpb25zLnJlcHVsc2lvbixcbiAgICAgICAgc3RpZmZuZXNzOiBvcHRpb25zLnN0aWZmbmVzcywgXG4gICAgICAgIGZyaWN0aW9uOiBvcHRpb25zLmZyaWN0aW9uLCBcbiAgICAgICAgZ3Jhdml0eTogb3B0aW9ucy5ncmF2aXR5LCBcbiAgICAgICAgZnBzOiBvcHRpb25zLmZwcywgXG4gICAgICAgIGR0OiBvcHRpb25zLmR0LCBcbiAgICAgICAgcHJlY2lzaW9uOiBvcHRpb25zLnByZWNpc2lvblxuICAgICAgfSk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5maXQgKXtcbiAgICAgICAgY3kuZml0KCBiYiwgb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBkb25lVGltZSA9IDI1MDtcbiAgICAgIHZhciBkb25lVGltZW91dDtcbiAgICAgIFxuICAgICAgdmFyIHJlYWR5ID0gZmFsc2U7XG4gICAgICBcbiAgICAgIHZhciBsYXN0RHJhdyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgdmFyIHN5c1JlbmRlcmVyID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihzeXN0ZW0pe1xuICAgICAgICB9LFxuICAgICAgICByZWRyYXc6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIGVuZXJneSA9IHN5cy5lbmVyZ3koKTtcblxuICAgICAgICAgIC8vIGlmIHdlJ3JlIHN0YWJsZSAoYWNjb3JkaW5nIHRvIHRoZSBjbGllbnQpLCB3ZSdyZSBkb25lXG4gICAgICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICYmIG9wdGlvbnMuc3RhYmxlRW5lcmd5ICE9IG51bGwgJiYgZW5lcmd5ICE9IG51bGwgJiYgZW5lcmd5Lm4gPiAwICYmIG9wdGlvbnMuc3RhYmxlRW5lcmd5KGVuZXJneSkgKXtcbiAgICAgICAgICAgIGxheW91dC5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICYmIGRvbmVUaW1lICE9IEluZmluaXR5ICl7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZG9uZVRpbWVvdXQpO1xuICAgICAgICAgICAgZG9uZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmVIYW5kbGVyLCBkb25lVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHZhciBtb3ZlZE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgIFxuICAgICAgICAgIHN5cy5lYWNoTm9kZShmdW5jdGlvbihuLCBwb2ludCl7IFxuICAgICAgICAgICAgdmFyIGRhdGEgPSBuLmRhdGE7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRhdGEuZWxlbWVudDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIG5vZGUgPT0gbnVsbCApe1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCAhbm9kZS5sb2NrZWQoKSAmJiAhbm9kZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgICAgbm9kZS5zaWxlbnRQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgeDogYmIueDEgKyBwb2ludC54LFxuICAgICAgICAgICAgICAgIHk6IGJiLnkxICsgcG9pbnQueVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBtb3ZlZE5vZGVzLm1lcmdlKCBub2RlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG5cbiAgICAgICAgICBpZiggb3B0aW9ucy5hbmltYXRlICYmIG1vdmVkTm9kZXMubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgc2ltVXBkYXRpbmdQb3MgPSB0cnVlO1xuXG4gICAgICAgICAgICBtb3ZlZE5vZGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuXG4gICAgICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdERyYXcgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHNpbVVwZGF0aW5nUG9zID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXG4gICAgICAgICAgaWYoICFyZWFkeSApe1xuICAgICAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfTtcbiAgICAgIHN5cy5yZW5kZXJlciA9IHN5c1JlbmRlcmVyO1xuICAgICAgc3lzLnNjcmVlblNpemUoIGJiLncsIGJiLmggKTtcbiAgICAgIHN5cy5zY3JlZW5QYWRkaW5nKCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgIHN5cy5zY3JlZW5TdGVwKCBvcHRpb25zLnN0ZXBTaXplICk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVZhbHVlRm9yRWxlbWVudChlbGVtZW50LCB2YWx1ZSl7XG4gICAgICAgIGlmKCB2YWx1ZSA9PSBudWxsICl7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmKCB0eXBlb2YgdmFsdWUgPT0gdHlwZW9mIGZ1bmN0aW9uKCl7fSApe1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseShlbGVtZW50LCBbZWxlbWVudC5fcHJpdmF0ZS5kYXRhLCB7XG4gICAgICAgICAgICBub2Rlczogbm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICB9XSk7IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ3JhYkhhbmRsZXI7XG4gICAgICBub2Rlcy5vbignZ3JhYiBmcmVlIHBvc2l0aW9uJywgZ3JhYkhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgaWYoIHNpbVVwZGF0aW5nUG9zICl7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBhcG9zID0gc3lzLmZyb21TY3JlZW4oIHBvcyApO1xuICAgICAgICBpZiggIWFwb3MgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIHAgPSBhcmJvci5Qb2ludChhcG9zLngsIGFwb3MueSk7XG4gICAgICAgIHZhciBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nO1xuXG4gICAgICAgIGlmKFxuICAgICAgICAgIGJiLngxICsgcGFkZGluZyA8PSBwb3MueCAmJiBwb3MueCA8PSBiYi54MiAtIHBhZGRpbmcgJiZcbiAgICAgICAgICBiYi55MSArIHBhZGRpbmcgPD0gcG9zLnkgJiYgcG9zLnkgPD0gYmIueTIgLSBwYWRkaW5nXG4gICAgICAgICl7XG4gICAgICAgICAgdGhpcy5zY3JhdGNoKCkuYXJib3IucCA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCggZS50eXBlICl7XG4gICAgICAgIGNhc2UgJ2dyYWInOlxuICAgICAgICAgIHRoaXMuc2NyYXRjaCgpLmFyYm9yLmZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnJlZSc6XG4gICAgICAgICAgdGhpcy5zY3JhdGNoKCkuYXJib3IuZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgICAvL3RoaXMuc2NyYXRjaCgpLmFyYm9yLnRlbXBNYXNzID0gMTAwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBsb2NrSGFuZGxlcjtcbiAgICAgIG5vZGVzLm9uKCdsb2NrIHVubG9jaycsIGxvY2tIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIG5vZGUuc2NyYXRjaCgpLmFyYm9yLmZpeGVkID0gbm9kZS5sb2NrZWQoKTtcbiAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICB2YXIgcmVtb3ZlSGFuZGxlcjtcbiAgICAgIGVsZXMub24oJ3JlbW92ZScsIHJlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbihlKXsgcmV0dXJuOyAvLyBUT0RPIGVuYWJsZSB3aGVuIGxheW91dCBhZGQvcmVtb3ZlIGFwaSBhZGRlZFxuICAgICAgICAvLyB2YXIgZWxlID0gdGhpcztcbiAgICAgICAgLy8gdmFyIGFyYm9yRWxlID0gZWxlLnNjcmF0Y2goKS5hcmJvcjtcblxuICAgICAgICAvLyBpZiggIWFyYm9yRWxlICl7IHJldHVybjsgfVxuXG4gICAgICAgIC8vIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgLy8gICBzeXMucHJ1bmVOb2RlKCBhcmJvckVsZSApO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgIHN5cy5wcnVuZUVkZ2UoIGFyYm9yRWxlICk7XG4gICAgICAgIC8vIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYWRkSGFuZGxlcjtcbiAgICAgIGN5Lm9uKCdhZGQnLCAnKicsIGFkZEhhbmRsZXIgPSBmdW5jdGlvbigpeyByZXR1cm47IC8vIFRPRE8gZW5hYmxlIHdoZW4gbGF5b3V0IGFkZC9yZW1vdmUgYXBpIGFkZGVkXG4gICAgICAgIC8vIHZhciBlbGUgPSB0aGlzO1xuXG4gICAgICAgIC8vIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgLy8gICBhZGROb2RlKCBlbGUgKTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICBhZGRFZGdlKCBlbGUgKTtcbiAgICAgICAgLy8gfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciByZXNpemVIYW5kbGVyO1xuICAgICAgY3kub24oJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCA9PSBudWxsICYmIGxheW91dC5fcHJpdmF0ZS5zeXN0ZW0gIT0gbnVsbCApe1xuICAgICAgICAgIHZhciB3ID0gY3kud2lkdGgoKTtcbiAgICAgICAgICB2YXIgaCA9IGN5LmhlaWdodCgpO1xuXG4gICAgICAgICAgc3lzLnNjcmVlblNpemUoIHcsIGggKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE5vZGUoIG5vZGUgKXtcbiAgICAgICAgaWYoIG5vZGUuaXNGdWxsQXV0b1BhcmVudCgpICl7IHJldHVybjsgfSAvLyB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSBzaW1cblxuICAgICAgICB2YXIgaWQgPSBub2RlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBtYXNzID0gY2FsY3VsYXRlVmFsdWVGb3JFbGVtZW50KG5vZGUsIG9wdGlvbnMubm9kZU1hc3MpO1xuICAgICAgICB2YXIgbG9ja2VkID0gbm9kZS5fcHJpdmF0ZS5sb2NrZWQ7XG4gICAgICAgIHZhciBuUG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHBvcyA9IHN5cy5mcm9tU2NyZWVuKHtcbiAgICAgICAgICB4OiBuUG9zLngsXG4gICAgICAgICAgeTogblBvcy55XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5vZGUuc2NyYXRjaCgpLmFyYm9yID0gc3lzLmFkZE5vZGUoaWQsIHtcbiAgICAgICAgICBlbGVtZW50OiBub2RlLFxuICAgICAgICAgIG1hc3M6IG1hc3MsXG4gICAgICAgICAgZml4ZWQ6IGxvY2tlZCxcbiAgICAgICAgICB4OiBsb2NrZWQgPyBwb3MueCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB5OiBsb2NrZWQgPyBwb3MueSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkRWRnZSggZWRnZSApe1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKS5pZCgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKS5pZCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY2FsY3VsYXRlVmFsdWVGb3JFbGVtZW50KGVkZ2UsIG9wdGlvbnMuZWRnZUxlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICBlZGdlLnNjcmF0Y2goKS5hcmJvciA9IHN5cy5hZGRFZGdlKHNyYywgdGd0LCB7XG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgICAgfSk7IFxuICAgICAgfVxuXG4gICAgICBub2Rlcy5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpe1xuICAgICAgICBhZGROb2RlKCBub2RlICk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZWRnZXMuZWFjaChmdW5jdGlvbihpLCBlZGdlKXtcbiAgICAgICAgYWRkRWRnZSggZWRnZSApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHZhciBncmFiYmFibGVOb2RlcyA9IG5vZGVzLmZpbHRlcihcIjpncmFiYmFibGVcIik7XG4gICAgICAvLyBkaXNhYmxlIGdyYWJiaW5nIGlmIHNvIHNldFxuICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgIGdyYWJiYWJsZU5vZGVzLnVuZ3JhYmlmeSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZG9uZUhhbmRsZXIgPSBsYXlvdXQuX3ByaXZhdGUuZG9uZUhhbmRsZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICBsYXlvdXQuX3ByaXZhdGUuZG9uZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgIGlmKCAhb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgICBjeS5yZXNldCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5iaW5kIGhhbmRsZXJzXG4gICAgICAgIG5vZGVzLm9mZignZ3JhYiBmcmVlIHBvc2l0aW9uJywgZ3JhYkhhbmRsZXIpO1xuICAgICAgICBub2Rlcy5vZmYoJ2xvY2sgdW5sb2NrJywgbG9ja0hhbmRsZXIpO1xuICAgICAgICBlbGVzLm9mZigncmVtb3ZlJywgcmVtb3ZlSGFuZGxlcik7XG4gICAgICAgIGN5Lm9mZignYWRkJywgJyonLCBhZGRIYW5kbGVyKTtcbiAgICAgICAgY3kub2ZmKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGVuYWJsZSBiYWNrIGdyYWJiaW5nIGlmIHNvIHNldFxuICAgICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgICBncmFiYmFibGVOb2Rlcy5ncmFiaWZ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgc3lzLnN0YXJ0KCk7XG4gICAgICBpZiggIW9wdGlvbnMuaW5maW5pdGUgJiYgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSAhPSBudWxsICYmIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUgPiAwICYmIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUgIT09IEluZmluaXR5ICl7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBsYXlvdXQuc3RvcCgpO1xuICAgICAgICB9LCBvcHRpb25zLm1heFNpbXVsYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICBcbiAgICB9KTsgLy8gcmVxdWlyZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cblxuICBBcmJvckxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIHRoaXMuX3ByaXZhdGUuc3lzdGVtICE9IG51bGwgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuc3lzdGVtLnN0b3AoKTtcbiAgICB9XG5cbiAgICBpZiggdGhpcy5fcHJpdmF0ZS5kb25lSGFuZGxlciApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5kb25lSGFuZGxlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdhcmJvcicsIEFyYm9yTGF5b3V0KTtcbiAgXG4gIFxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBkaXJlY3RlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBvbiBmaXRcbiAgICBjaXJjbGU6IGZhbHNlLCAvLyBwdXQgZGVwdGhzIGluIGNvbmNlbnRyaWMgY2lyY2xlcyBpZiB0cnVlLCBwdXQgZGVwdGhzIHRvcCBkb3duIGlmIGZhbHNlXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgcm9vdHM6IHVuZGVmaW5lZCwgLy8gdGhlIHJvb3RzIG9mIHRoZSB0cmVlc1xuICAgIG1heGltYWxBZGp1c3RtZW50czogMCwgLy8gaG93IG1hbnkgdGltZXMgdG8gdHJ5IHRvIHBvc2l0aW9uIHRoZSBub2RlcyBpbiBhIG1heGltYWwgd2F5IChpLmUuIG5vIGJhY2t0cmFja2luZylcbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gQnJlYWR0aEZpcnN0TGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgQnJlYWR0aEZpcnN0TGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgXG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICB2YXIgZ3JhcGggPSBlbGVzO1xuICAgIFxuICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICB9ICk7XG5cbiAgICB2YXIgcm9vdHM7XG4gICAgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24ob3B0aW9ucy5yb290cykgKXtcbiAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgICB9IGVsc2UgaWYoICQkLmlzLmFycmF5KG9wdGlvbnMucm9vdHMpICl7XG4gICAgICB2YXIgcm9vdHNBcnJheSA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdGlvbnMucm9vdHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGlkID0gb3B0aW9ucy5yb290c1tpXTtcbiAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuICAgICAgICByb290c0FycmF5LnB1c2goIGVsZSApO1xuICAgICAgfVxuXG4gICAgICByb290cyA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcm9vdHNBcnJheSApO1xuICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdHMpICl7XG4gICAgICByb290cyA9IGN5LiQoIG9wdGlvbnMucm9vdHMgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiggb3B0aW9ucy5kaXJlY3RlZCApe1xuICAgICAgICByb290cyA9IG5vZGVzLnJvb3RzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB2YXIgdW5oYW5kbGVkTm9kZXMgPSBub2RlcztcblxuICAgICAgICB3aGlsZSggdW5oYW5kbGVkTm9kZXMubGVuZ3RoID4gMCApe1xuICAgICAgICAgIHZhciBjdXJyQ29tcCA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgICAgIGVsZXMuYmZzKHtcbiAgICAgICAgICAgIHJvb3RzOiB1bmhhbmRsZWROb2Rlc1swXSxcbiAgICAgICAgICAgIHZpc2l0OiBmdW5jdGlvbihpLCBkZXB0aCwgbm9kZSwgZWRnZSwgcE5vZGUpe1xuICAgICAgICAgICAgICBjdXJyQ29tcCA9IGN1cnJDb21wLmFkZCggbm9kZSApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpcmVjdGVkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdW5oYW5kbGVkTm9kZXMgPSB1bmhhbmRsZWROb2Rlcy5ub3QoIGN1cnJDb21wICk7XG4gICAgICAgICAgY29tcG9uZW50cy5wdXNoKCBjdXJyQ29tcCApO1xuICAgICAgICB9XG5cbiAgICAgICAgcm9vdHMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBjb21wID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICB2YXIgbWF4RGVncmVlID0gY29tcC5tYXhEZWdyZWUoIGZhbHNlICk7XG4gICAgICAgICAgdmFyIGNvbXBSb290cyA9IGNvbXAuZmlsdGVyKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWdyZWUoZmFsc2UpID09PSBtYXhEZWdyZWU7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByb290cyA9IHJvb3RzLmFkZCggY29tcFJvb3RzICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgZGVwdGhzID0gW107XG4gICAgdmFyIGZvdW5kQnlCZnMgPSB7fTtcbiAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICB2YXIgcHJldk5vZGUgPSB7fTtcbiAgICB2YXIgcHJldkVkZ2UgPSB7fTtcbiAgICB2YXIgc3VjY2Vzc29ycyA9IHt9O1xuXG4gICAgLy8gZmluZCB0aGUgZGVwdGhzIG9mIHRoZSBub2Rlc1xuICAgIGdyYXBoLmJmcyh7XG4gICAgICByb290czogcm9vdHMsXG4gICAgICBkaXJlY3RlZDogb3B0aW9ucy5kaXJlY3RlZCxcbiAgICAgIHZpc2l0OiBmdW5jdGlvbihpLCBkZXB0aCwgbm9kZSwgZWRnZSwgcE5vZGUpe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG5cbiAgICAgICAgaWYoICFkZXB0aHNbZGVwdGhdICl7XG4gICAgICAgICAgZGVwdGhzW2RlcHRoXSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBlbGUgKTtcbiAgICAgICAgZm91bmRCeUJmc1sgaWQgXSA9IHRydWU7XG4gICAgICAgIGlkMmRlcHRoWyBpZCBdID0gZGVwdGg7XG4gICAgICAgIHByZXZOb2RlWyBpZCBdID0gcE5vZGU7XG4gICAgICAgIHByZXZFZGdlWyBpZCBdID0gZWRnZTtcblxuICAgICAgICBpZiggcE5vZGUgKXtcbiAgICAgICAgICB2YXIgcHJldklkID0gcE5vZGUuaWQoKTtcbiAgICAgICAgICB2YXIgc3VjYyA9IHN1Y2Nlc3NvcnNbIHByZXZJZCBdID0gc3VjY2Vzc29yc1sgcHJldklkIF0gfHwgW107XG4gICAgICAgICAgXG4gICAgICAgICAgc3VjYy5wdXNoKCBub2RlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGNoZWNrIGZvciBub2RlcyBub3QgZm91bmQgYnkgYmZzXG4gICAgdmFyIG9ycGhhbk5vZGVzID0gW107XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuXG4gICAgICBpZiggZm91bmRCeUJmc1sgZWxlLmlkKCkgXSApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ycGhhbk5vZGVzLnB1c2goIGVsZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFzc2lnbiBvcnBoYW4gbm9kZXMgYSBkZXB0aCBmcm9tIHRoZWlyIG5laWdoYm9yaG9vZFxuICAgIHZhciBtYXhDaGVja3MgPSBvcnBoYW5Ob2Rlcy5sZW5ndGggKiAzO1xuICAgIHZhciBjaGVja3MgPSAwO1xuICAgIHdoaWxlKCBvcnBoYW5Ob2Rlcy5sZW5ndGggIT09IDAgJiYgY2hlY2tzIDwgbWF4Q2hlY2tzICl7XG4gICAgICB2YXIgbm9kZSA9IG9ycGhhbk5vZGVzLnNoaWZ0KCk7XG4gICAgICB2YXIgbmVpZ2hib3JzID0gbm9kZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpO1xuICAgICAgdmFyIGFzc2lnbmVkRGVwdGggPSBmYWxzZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIG5laWdoYm9yc1tpXS5pZCgpIF07XG5cbiAgICAgICAgaWYoIGRlcHRoICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBkZXB0aHNbZGVwdGhdLnB1c2goIG5vZGUgKTtcbiAgICAgICAgICBhc3NpZ25lZERlcHRoID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIWFzc2lnbmVkRGVwdGggKXtcbiAgICAgICAgb3JwaGFuTm9kZXMucHVzaCggbm9kZSApO1xuICAgICAgfVxuXG4gICAgICBjaGVja3MrKztcbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIHRoYXQgYXJlIHN0aWxsIGxlZnQgdG8gdGhlIGRlcHRoIG9mIHRoZWlyIHN1YmdyYXBoXG4gICAgd2hpbGUoIG9ycGhhbk5vZGVzLmxlbmd0aCAhPT0gMCApe1xuICAgICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgICAgLy92YXIgc3ViZ3JhcGggPSBncmFwaC5iZnMoIG5vZGUgKS5wYXRoO1xuICAgICAgdmFyIGFzc2lnbmVkRGVwdGggPSBmYWxzZTtcblxuICAgICAgLy8gZm9yKCB2YXIgaSA9IDA7IGkgPCBzdWJncmFwaC5sZW5ndGg7IGkrKyApe1xuICAgICAgLy8gICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgc3ViZ3JhcGhbaV0uaWQoKSBdO1xuXG4gICAgICAvLyAgIGlmKCBkZXB0aCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAvLyAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBub2RlICk7XG4gICAgICAvLyAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgICAvLyAgICAgYnJlYWs7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgaWYoICFhc3NpZ25lZERlcHRoICl7IC8vIHdvcnN0IGNhc2UgaWYgdGhlIGdyYXBoIHJlYWxseSBpc24ndCB0cmVlIGZyaWVuZGx5LCB0aGVuIGp1c3QgZHVtcCBpdCBpbiAwXG4gICAgICAgIGlmKCBkZXB0aHMubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgZGVwdGhzLnB1c2goW10pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBkZXB0aHNbMF0ucHVzaCggbm9kZSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFzc2lnbiB0aGUgbm9kZXMgYSBkZXB0aCBhbmQgaW5kZXhcbiAgICB2YXIgYXNzaWduRGVwdGhzVG9FbGVzID0gZnVuY3Rpb24oKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGVzID0gZGVwdGhzW2ldO1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2pdO1xuXG4gICAgICAgICAgZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0ID0ge1xuICAgICAgICAgICAgZGVwdGg6IGksXG4gICAgICAgICAgICBpbmRleDogalxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGFzc2lnbkRlcHRoc1RvRWxlcygpO1xuXG5cbiAgICB2YXIgaW50ZXJzZWN0c0RlcHRoID0gZnVuY3Rpb24oIG5vZGUgKXsgLy8gcmV0dXJucyB0cnVlIGlmIGhhcyBlZGdlcyBwb2ludGluZyBpbiBmcm9tIGEgaGlnaGVyIGRlcHRoXG4gICAgICB2YXIgZWRnZXMgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ3RhcmdldCcpID09PSBub2RlLmlkKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciB0aGlzSW5mbyA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICB2YXIgaGlnaGVzdERlcHRoT2ZPdGhlciA9IDA7XG4gICAgICB2YXIgaGlnaGVzdE90aGVyO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIG90aGVySW5mbyA9IG90aGVyTm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcblxuICAgICAgICBpZiggdGhpc0luZm8uZGVwdGggPD0gb3RoZXJJbmZvLmRlcHRoICYmIGhpZ2hlc3REZXB0aE9mT3RoZXIgPCBvdGhlckluZm8uZGVwdGggKXtcbiAgICAgICAgICBoaWdoZXN0RGVwdGhPZk90aGVyID0gb3RoZXJJbmZvLmRlcHRoO1xuICAgICAgICAgIGhpZ2hlc3RPdGhlciA9IG90aGVyTm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGlnaGVzdE90aGVyO1xuICAgIH07XG5cbiAgICAgLy8gbWFrZSBtYXhpbWFsIGlmIHNvIHNldCBieSBhZGp1c3RpbmcgZGVwdGhzXG4gICAgZm9yKCB2YXIgYWRqID0gMDsgYWRqIDwgb3B0aW9ucy5tYXhpbWFsQWRqdXN0bWVudHM7IGFkaisrICl7XG5cbiAgICAgIHZhciBuRGVwdGhzID0gZGVwdGhzLmxlbmd0aDtcbiAgICAgIHZhciBlbGVzVG9Nb3ZlID0gW107XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5EZXB0aHM7IGkrKyApe1xuICAgICAgICB2YXIgZGVwdGggPSBkZXB0aHNbaV07XG5cbiAgICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoLmxlbmd0aDtcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBuRGVwdGg7IGorKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBkZXB0aFtqXTtcbiAgICAgICAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgICAgICB2YXIgaW50RWxlID0gaW50ZXJzZWN0c0RlcHRoKGVsZSk7XG5cbiAgICAgICAgICBpZiggaW50RWxlICl7XG4gICAgICAgICAgICBpbmZvLmludEVsZSA9IGludEVsZTtcbiAgICAgICAgICAgIGVsZXNUb01vdmUucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvTW92ZS5sZW5ndGg7IGkrKyApeyBcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNUb01vdmVbaV07XG4gICAgICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgICB2YXIgaW50RWxlID0gaW5mby5pbnRFbGU7XG4gICAgICAgIHZhciBpbnRJbmZvID0gaW50RWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuXG4gICAgICAgIGRlcHRoc1sgaW5mby5kZXB0aCBdLnNwbGljZSggaW5mby5pbmRleCwgMSApOyAvLyByZW1vdmUgZnJvbSBvbGQgZGVwdGggJiBpbmRleFxuXG4gICAgICAgIC8vIGFkZCB0byBlbmQgb2YgbmV3IGRlcHRoXG4gICAgICAgIHZhciBuZXdEZXB0aCA9IGludEluZm8uZGVwdGggKyAxO1xuICAgICAgICB3aGlsZSggbmV3RGVwdGggPiBkZXB0aHMubGVuZ3RoIC0gMSApe1xuICAgICAgICAgIGRlcHRocy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aHNbIG5ld0RlcHRoIF0ucHVzaCggZWxlICk7XG5cbiAgICAgICAgaW5mby5kZXB0aCA9IG5ld0RlcHRoO1xuICAgICAgICBpbmZvLmluZGV4ID0gZGVwdGhzW25ld0RlcHRoXS5sZW5ndGggLSAxO1xuICAgICAgfVxuXG4gICAgICBhc3NpZ25EZXB0aHNUb0VsZXMoKTtcbiAgICB9XG5cbiAgICAvLyBmaW5kIG1pbiBkaXN0YW5jZSB3ZSBuZWVkIHRvIGxlYXZlIGJldHdlZW4gbm9kZXNcbiAgICB2YXIgbWluRGlzdGFuY2UgPSAwO1xuICAgIGlmKCBvcHRpb25zLmF2b2lkT3ZlcmxhcCApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdyA9IG5vZGVzW2ldLm91dGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIGggPSBub2Rlc1tpXS5vdXRlckhlaWdodCgpO1xuICAgICAgICBcbiAgICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgICB9XG4gICAgICBtaW5EaXN0YW5jZSAqPSAxLjc1OyAvLyBqdXN0IHRvIGhhdmUgc29tZSBuaWNlIHNwYWNpbmdcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHdlaWdodGVkIHBlcmNlbnQgZm9yIGFuIGVsZW1lbnQgYmFzZWQgb24gaXRzIGNvbm5lY3Rpdml0eSB0byBvdGhlciBsZXZlbHNcbiAgICB2YXIgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50ID0ge307XG4gICAgdmFyIGdldFdlaWdodGVkUGVyY2VudCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIGlmKCBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF0gKXtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFdlaWdodGVkUGVyY2VudFsgZWxlLmlkKCkgXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZURlcHRoID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0LmRlcHRoO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGVsZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpO1xuICAgICAgdmFyIHBlcmNlbnQgPSAwO1xuICAgICAgdmFyIHNhbXBsZXMgPSAwO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG4gICAgICAgIHZhciBpbmRleCA9IG5laWdoYm9yLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0LmluZGV4O1xuICAgICAgICB2YXIgZGVwdGggPSBuZWlnaGJvci5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdC5kZXB0aDtcbiAgICAgICAgdmFyIG5EZXB0aCA9IGRlcHRoc1tkZXB0aF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmKCBlbGVEZXB0aCA+IGRlcHRoIHx8IGVsZURlcHRoID09PSAwICl7IC8vIG9ubHkgZ2V0IGluZmx1ZW5jZWQgYnkgZWxlbWVudHMgYWJvdmVcbiAgICAgICAgICBwZXJjZW50ICs9IGluZGV4IC8gbkRlcHRoO1xuICAgICAgICAgIHNhbXBsZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzYW1wbGVzID0gTWF0aC5tYXgoMSwgc2FtcGxlcyk7XG4gICAgICBwZXJjZW50ID0gcGVyY2VudCAvIHNhbXBsZXM7XG5cbiAgICAgIGlmKCBzYW1wbGVzID09PSAwICl7IC8vIHNvIGxvbmUgbm9kZXMgaGF2ZSBhIFwiZG9uJ3QgY2FyZVwiIHN0YXRlIGluIHNvcnRpbmdcbiAgICAgICAgcGVyY2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdID0gcGVyY2VudDtcbiAgICAgIHJldHVybiBwZXJjZW50O1xuICAgIH07XG5cblxuICAgIC8vIHJlYXJyYW5nZSB0aGUgaW5kaWNlcyBpbiBlYWNoIGRlcHRoIGxldmVsIGJhc2VkIG9uIGNvbm5lY3Rpdml0eVxuXG4gICAgdmFyIHNvcnRGbiA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgdmFyIGFwY3QgPSBnZXRXZWlnaHRlZFBlcmNlbnQoIGEgKTtcbiAgICAgIHZhciBicGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KCBiICk7XG5cbiAgICAgIHJldHVybiBhcGN0IC0gYnBjdDtcbiAgICB9O1xuXG4gICAgZm9yKCB2YXIgdGltZXMgPSAwOyB0aW1lcyA8IDM7IHRpbWVzKysgKXsgLy8gZG8gaXQgYSBmZXcgdGltZXMgYi9jIHRoZSBkZXB0aHMgYXJlIGR5bmFtaWMgYW5kIHdlIHdhbnQgYSBtb3JlIHN0YWJsZSByZXN1bHRcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZGVwdGhzW2ldID0gZGVwdGhzW2ldLnNvcnQoIHNvcnRGbiApO1xuICAgICAgfVxuICAgICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7IC8vIGFuZCB1cGRhdGVcblxuICAgIH1cblxuICAgIHZhciBiaWdnZXN0RGVwdGhTaXplID0gMDtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRlcHRocy5sZW5ndGg7IGkrKyApe1xuICAgICAgYmlnZ2VzdERlcHRoU2l6ZSA9IE1hdGgubWF4KCBkZXB0aHNbaV0ubGVuZ3RoLCBiaWdnZXN0RGVwdGhTaXplICk7XG4gICAgfVxuXG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IGJiLngxICsgYmIudy8yLFxuICAgICAgeTogYmIueDEgKyBiYi5oLzJcbiAgICB9O1xuICAgXG4gICAgdmFyIGdldFBvc2l0aW9uID0gZnVuY3Rpb24oIGVsZSwgaXNCb3R0b21EZXB0aCApe1xuICAgICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICB2YXIgZGVwdGggPSBpbmZvLmRlcHRoO1xuICAgICAgdmFyIGluZGV4ID0gaW5mby5pbmRleDtcbiAgICAgIHZhciBkZXB0aFNpemUgPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgICAgaWYoIG9wdGlvbnMuc3RyaWN0SGllcmFyY2h5ICl7XG4gICAgICAgIGRlcHRoU2l6ZSA9IGJpZ2dlc3REZXB0aFNpemU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLm1heCggYmIudyAvIChkZXB0aFNpemUgKyAxKSwgbWluRGlzdGFuY2UgKTtcbiAgICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLm1heCggYmIuaCAvIChkZXB0aHMubGVuZ3RoICsgMSksIG1pbkRpc3RhbmNlICk7XG4gICAgICB2YXIgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1pbiggYmIudyAvIDIgLyBkZXB0aHMubGVuZ3RoLCBiYi5oIC8gMiAvIGRlcHRocy5sZW5ndGggKTtcbiAgICAgIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5tYXgoIHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSApO1xuXG4gICAgICBpZiggb3B0aW9ucy5zdHJpY3RIaWVyYXJjaHkgJiYgIW9wdGlvbnMuY2lyY2xlICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgZXBvcyA9IHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkvMikgKiBkaXN0YW5jZVgsXG4gICAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggaXNCb3R0b21EZXB0aCApe1xuICAgICAgICAgIHJldHVybiBlcG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN1Y2NzID0gc3VjY2Vzc29yc1sgZWxlLmlkKCkgXTtcbiAgICAgICAgaWYoIHN1Y2NzICl7XG4gICAgICAgICAgZXBvcy54ID0gMDtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwIDsgaSA8IHN1Y2NzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgc3BvcyA9IHBvc1sgc3VjY3NbaV0uaWQoKSBdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBlcG9zLnggKz0gc3Bvcy54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVwb3MueCAvPSBzdWNjcy5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9kZWJ1Z2dlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcG9zO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiggb3B0aW9ucy5jaXJjbGUgKXtcbiAgICAgICAgICB2YXIgcmFkaXVzID0gcmFkaXVzU3RlcFNpemUgKiBkZXB0aCArIHJhZGl1c1N0ZXBTaXplIC0gKGRlcHRocy5sZW5ndGggPiAwICYmIGRlcHRoc1swXS5sZW5ndGggPD0gMyA/IHJhZGl1c1N0ZXBTaXplLzIgOiAwKTtcbiAgICAgICAgICB2YXIgdGhldGEgPSAyICogTWF0aC5QSSAvIGRlcHRoc1tkZXB0aF0ubGVuZ3RoICogaW5kZXg7XG5cbiAgICAgICAgICBpZiggZGVwdGggPT09IDAgJiYgZGVwdGhzWzBdLmxlbmd0aCA9PT0gMSApe1xuICAgICAgICAgICAgcmFkaXVzID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY2VudGVyLnggKyByYWRpdXMgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgICAgICAgICB5OiBjZW50ZXIueSArIHJhZGl1cyAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpLzIpICogZGlzdGFuY2VYLFxuICAgICAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICB9O1xuXG4gICAgLy8gZ2V0IHBvc2l0aW9ucyBpbiByZXZlcnNlIGRlcHRoIG9yZGVyXG4gICAgdmFyIHBvcyA9IHt9O1xuICAgIGZvciggdmFyIGkgPSBkZXB0aHMubGVuZ3RoIC0gMTsgaSA+PTA7IGktLSApe1xuICAgICAgdmFyIGRlcHRoID0gZGVwdGhzW2ldO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGRlcHRoLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBub2RlID0gZGVwdGhbal07XG5cbiAgICAgICAgcG9zWyBub2RlLmlkKCkgXSA9IGdldFBvc2l0aW9uKCBub2RlLCBpID09PSBkZXB0aHMubGVuZ3RoIC0gMSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHBvc1sgdGhpcy5pZCgpIF07XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ2JyZWFkdGhmaXJzdCcsIEJyZWFkdGhGaXJzdExheW91dCk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLCAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIHByZXZlbnRzIG5vZGUgb3ZlcmxhcCwgbWF5IG92ZXJmbG93IGJvdW5kaW5nQm94IGFuZCByYWRpdXMgaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIHJhZGl1czogdW5kZWZpbmVkLCAvLyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICBzdGFydEFuZ2xlOiAzLzIgKiBNYXRoLlBJLCAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG5vZGVcbiAgICBjb3VudGVyY2xvY2t3aXNlOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjb3VudGVyY2xvY2t3aXNlICh0cnVlKSBvciBjbG9ja3dpc2UgKGZhbHNlKVxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBDaXJjbGVMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBDaXJjbGVMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICBcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgICBcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgXG4gICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgIH0gKTtcblxuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICB4OiBiYi54MSArIGJiLncvMixcbiAgICAgIHk6IGJiLnkxICsgYmIuaC8yXG4gICAgfTtcbiAgICBcbiAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGRUaGV0YSA9IDIgKiBNYXRoLlBJIC8gbm9kZXMubGVuZ3RoO1xuICAgIHZhciByO1xuXG4gICAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdyA9IG5vZGVzW2ldLm91dGVyV2lkdGgoKTtcbiAgICAgIHZhciBoID0gbm9kZXNbaV0ub3V0ZXJIZWlnaHQoKTtcbiAgICAgIFxuICAgICAgbWluRGlzdGFuY2UgPSBNYXRoLm1heChtaW5EaXN0YW5jZSwgdywgaCk7XG4gICAgfVxuXG4gICAgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLnJhZGl1cykgKXtcbiAgICAgIHIgPSBvcHRpb25zLnJhZGl1cztcbiAgICB9IGVsc2UgaWYoIG5vZGVzLmxlbmd0aCA8PSAxICl7XG4gICAgICByID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IE1hdGgubWluKCBiYi5oLCBiYi53ICkvMiAtIG1pbkRpc3RhbmNlO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gICAgaWYoIG5vZGVzLmxlbmd0aCA+IDEgJiYgb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gYnV0IG9ubHkgaWYgbW9yZSB0aGFuIG9uZSBub2RlIChjYW4ndCBvdmVybGFwKVxuICAgICAgbWluRGlzdGFuY2UgKj0gMS43NTsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG5cbiAgICAgIHZhciBkVGhldGEgPSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgdmFyIGRzaW4gPSBNYXRoLnNpbihkVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICB2YXIgck1pbiA9IE1hdGguc3FydCggbWluRGlzdGFuY2UgKiBtaW5EaXN0YW5jZSAvICggZGNvcypkY29zICsgZHNpbipkc2luICkgKTsgLy8gcy50LiBubyBub2RlcyBvdmVybGFwcGluZ1xuICAgICAgciA9IE1hdGgubWF4KCByTWluLCByICk7XG4gICAgfVxuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKCBpLCBlbGUgKXtcbiAgICAgIHZhciByeCA9IHIgKiBNYXRoLmNvcyggdGhldGEgKTtcbiAgICAgIHZhciByeSA9IHIgKiBNYXRoLnNpbiggdGhldGEgKTtcbiAgICAgIHZhciBwb3MgPSB7XG4gICAgICAgIHg6IGNlbnRlci54ICsgcngsXG4gICAgICAgIHk6IGNlbnRlci55ICsgcnlcbiAgICAgIH07XG5cbiAgICAgIHRoZXRhID0gb3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlID8gdGhldGEgLSBkVGhldGEgOiB0aGV0YSArIGRUaGV0YTtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfTtcbiAgICBcbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ2NpcmNsZScsIENpcmNsZUxheW91dCk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGFuaW1hdGU6IHRydWUsIC8vIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGF5b3V0IGFzIGl0J3MgcnVubmluZ1xuICAgIHJlZnJlc2g6IDEsIC8vIG51bWJlciBvZiB0aWNrcyBwZXIgZnJhbWU7IGhpZ2hlciBpcyBmYXN0ZXIgYnV0IG1vcmUgamVya3lcbiAgICBtYXhTaW11bGF0aW9uVGltZTogNDAwMCwgLy8gbWF4IGxlbmd0aCBpbiBtcyB0byBydW4gdGhlIGxheW91dFxuICAgIHVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZzogZmFsc2UsIC8vIHNvIHlvdSBjYW4ndCBkcmFnIG5vZGVzIGR1cmluZyBsYXlvdXRcbiAgICBmaXQ6IHRydWUsIC8vIG9uIGV2ZXJ5IGxheW91dCByZXBvc2l0aW9uIG9mIG5vZGVzLCBmaXQgdGhlIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgYXJvdW5kIHRoZSBzaW11bGF0aW9uXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG5cbiAgICAvLyBsYXlvdXQgZXZlbnQgY2FsbGJhY2tzXG4gICAgcmVhZHk6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHN0b3BcblxuICAgIC8vIHBvc2l0aW9uaW5nIG9wdGlvbnNcbiAgICByYW5kb21pemU6IGZhbHNlLCAvLyB1c2UgcmFuZG9tIG5vZGUgcG9zaXRpb25zIGF0IGJlZ2lubmluZyBvZiBsYXlvdXRcbiAgICBhdm9pZE92ZXJsYXA6IHRydWUsIC8vIGlmIHRydWUsIHByZXZlbnRzIG92ZXJsYXAgb2Ygbm9kZSBib3VuZGluZyBib3hlc1xuICAgIGhhbmRsZURpc2Nvbm5lY3RlZDogdHJ1ZSwgLy8gaWYgdHJ1ZSwgYXZvaWRzIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIGZyb20gb3ZlcmxhcHBpbmdcbiAgICBub2RlU3BhY2luZzogZnVuY3Rpb24oIG5vZGUgKXsgcmV0dXJuIDEwOyB9LCAvLyBleHRyYSBzcGFjaW5nIGFyb3VuZCBub2Rlc1xuICAgIGZsb3c6IHVuZGVmaW5lZCwgLy8gdXNlIERBRy90cmVlIGZsb3cgbGF5b3V0IGlmIHNwZWNpZmllZCwgZS5nLiB7IGF4aXM6ICd5JywgbWluU2VwYXJhdGlvbjogMzAgfVxuICAgIGFsaWdubWVudDogdW5kZWZpbmVkLCAvLyByZWxhdGl2ZSBhbGlnbm1lbnQgY29uc3RyYWludHMgb24gbm9kZXMsIGUuZy4gZnVuY3Rpb24oIG5vZGUgKXsgcmV0dXJuIHsgeDogMCwgeTogMSB9IH1cblxuICAgIC8vIGRpZmZlcmVudCBtZXRob2RzIG9mIHNwZWNpZnlpbmcgZWRnZSBsZW5ndGhcbiAgICAvLyBlYWNoIGNhbiBiZSBhIGNvbnN0YW50IG51bWVyaWNhbCB2YWx1ZSBvciBhIGZ1bmN0aW9uIGxpa2UgYGZ1bmN0aW9uKCBlZGdlICl7IHJldHVybiAyOyB9YFxuICAgIGVkZ2VMZW5ndGg6IHVuZGVmaW5lZCwgLy8gc2V0cyBlZGdlIGxlbmd0aCBkaXJlY3RseSBpbiBzaW11bGF0aW9uXG4gICAgZWRnZVN5bURpZmZMZW5ndGg6IHVuZGVmaW5lZCwgLy8gc3ltbWV0cmljIGRpZmYgZWRnZSBsZW5ndGggaW4gc2ltdWxhdGlvblxuICAgIGVkZ2VKYWNjYXJkTGVuZ3RoOiB1bmRlZmluZWQsIC8vIGphY2NhcmQgZWRnZSBsZW5ndGggaW4gc2ltdWxhdGlvblxuXG4gICAgLy8gaXRlcmF0aW9ucyBvZiBjb2xhIGFsZ29yaXRobTsgdXNlcyBkZWZhdWx0IHZhbHVlcyBvbiB1bmRlZmluZWRcbiAgICB1bmNvbnN0ckl0ZXI6IHVuZGVmaW5lZCwgLy8gdW5jb25zdHJhaW5lZCBpbml0aWFsIGxheW91dCBpdGVyYXRpb25zXG4gICAgdXNlckNvbnN0SXRlcjogdW5kZWZpbmVkLCAvLyBpbml0aWFsIGxheW91dCBpdGVyYXRpb25zIHdpdGggdXNlci1zcGVjaWZpZWQgY29uc3RyYWludHNcbiAgICBhbGxDb25zdEl0ZXI6IHVuZGVmaW5lZCwgLy8gaW5pdGlhbCBsYXlvdXQgaXRlcmF0aW9ucyB3aXRoIGFsbCBjb25zdHJhaW50cyBpbmNsdWRpbmcgbm9uLW92ZXJsYXBcblxuICAgIC8vIGluZmluaXRlIGxheW91dCBvcHRpb25zXG4gICAgaW5maW5pdGU6IGZhbHNlIC8vIG92ZXJyaWRlcyBhbGwgb3RoZXIgb3B0aW9ucyBmb3IgYSBmb3JjZXMtYWxsLXRoZS10aW1lIG1vZGVcbiAgfTtcblxuICAvLyBjb25zdHJ1Y3RvclxuICAvLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAgZnVuY3Rpb24gQ29sYUxheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7IFxuICB9XG5cbiAgLy8gcnVucyB0aGUgbGF5b3V0XG4gIENvbGFMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAkJC51dGlsLnJlcXVpcmUoJ2NvbGEnLCBmdW5jdGlvbihjb2xhKXtcblxuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTsgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gICAgICB2YXIgZWRnZXMgPSBlbGVzLmVkZ2VzKCk7XG4gICAgICB2YXIgcmVhZHkgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICB9ICk7XG5cbiAgICAgIHZhciBnZXRPcHRWYWwgPSBmdW5jdGlvbiggdmFsLCBlbGUgKXtcbiAgICAgICAgaWYoICQkLmlzLmZuKHZhbCkgKXtcbiAgICAgICAgICB2YXIgZm4gPSB2YWw7XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KCBlbGUsIFsgZWxlIF0gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgdXBkYXRlTm9kZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB4ID0geyBtaW46IEluZmluaXR5LCBtYXg6IC1JbmZpbml0eSB9O1xuICAgICAgICB2YXIgeSA9IHsgbWluOiBJbmZpbml0eSwgbWF4OiAtSW5maW5pdHkgfTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICB2YXIgc2NyYXRjaCA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhO1xuXG4gICAgICAgICAgeC5taW4gPSBNYXRoLm1pbiggeC5taW4sIHNjcmF0Y2gueCApO1xuICAgICAgICAgIHgubWF4ID0gTWF0aC5tYXgoIHgubWF4LCBzY3JhdGNoLnggKTtcblxuICAgICAgICAgIHkubWluID0gTWF0aC5taW4oIHkubWluLCBzY3JhdGNoLnkgKTtcbiAgICAgICAgICB5Lm1heCA9IE1hdGgubWF4KCB5Lm1heCwgc2NyYXRjaC55ICk7XG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoZnVuY3Rpb24oaSwgbm9kZSl7XG4gICAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgdmFyIHNjcmF0Y2ggPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcblxuICAgICAgICAgIGlmKCAhbm9kZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgIHBvcy54ID0gYmIueDEgKyBzY3JhdGNoLnggLSB4Lm1pbjtcbiAgICAgICAgICAgIHBvcy55ID0gYmIueTEgKyBzY3JhdGNoLnkgLSB5Lm1pbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCAhcmVhZHkgKXtcbiAgICAgICAgICBvblJlYWR5KCk7XG4gICAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG9uRG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxheW91dC5tYW51YWxseVN0b3BwZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgICBncmFiYmFibGVOb2Rlcy5ncmFiaWZ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBub2Rlcy5vZmYoJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyKTtcbiAgICAgICAgbm9kZXMub2ZmKCdsb2NrIHVubG9jaycsIGxvY2tIYW5kbGVyKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGxheW91dHN0b3Agd2hlbiB0aGUgbGF5b3V0IHN0b3BzIChlLmcuIGZpbmlzaGVzKVxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIG9uUmVhZHkgPSBmdW5jdGlvbigpe1xuICAgICAgICAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgdGlja3NQZXJGcmFtZSA9IG9wdGlvbnMucmVmcmVzaDtcbiAgICAgIHZhciB0aWNrU2tpcCA9IDE7IC8vIGZyYW1lcyB1bnRpbCBhIHRpY2s7IHVzZWQgdG8gc2xvdyBkb3duIHNpbSBmb3IgZGVidWdnaW5nXG5cbiAgICAgIGlmKCBvcHRpb25zLnJlZnJlc2ggPCAwICl7XG4gICAgICAgIHRpY2tTa2lwID0gTWF0aC5hYnMoIG9wdGlvbnMucmVmcmVzaCApO1xuICAgICAgICB0aWNrc1BlckZyYW1lID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpY2tzUGVyRnJhbWUgPSBNYXRoLm1heCggMSwgdGlja3NQZXJGcmFtZSApOyAvLyBhdCBsZWFzdCAxXG4gICAgICB9XG5cbiAgICAgIHZhciBhZGFwdG9yID0gY29sYS5hZGFwdG9yKHtcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oIGUgKXsgLy8gb24gc2ltIGV2ZW50XG4gICAgICAgICAgc3dpdGNoKCBlLnR5cGUgKXtcbiAgICAgICAgICAgIGNhc2UgJ3RpY2snOlxuICAgICAgICAgICAgICBpZiggb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdlbmQnOiBcbiAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucygpO1xuICAgICAgICAgICAgICBpZiggIW9wdGlvbnMuaW5maW5pdGUgfHwgbGF5b3V0Lm1hbnVhbGx5U3RvcHBlZCApeyBvbkRvbmUoKTsgfSAgICAgICAgICAgXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBraWNrOiBmdW5jdGlvbiggdGljayApeyAvLyBraWNrIG9mZiB0aGUgc2ltdWxhdGlvblxuICAgICAgICAgIHZhciBza2lwID0gMDtcblxuICAgICAgICAgIHZhciBpbmZ0aWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciByZXQgPSB0aWNrKCk7XG5cbiAgICAgICAgICAgIGlmKCByZXQgJiYgb3B0aW9ucy5pbmZpbml0ZSApeyAvLyByZXN1bWUgbGF5b3V0IGlmIGRvbmVcbiAgICAgICAgICAgICAgYWRhcHRvci5yZXN1bWUoKTsgLy8gcmVzdW1lID0+IG5ldyBraWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiByZXQ7IC8vIGFsbG93IHJlZ3VsYXIgZmluaXNoIGIvYyBvZiBuZXcga2lja1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgbXVsdGl0aWNrID0gZnVuY3Rpb24oKXsgLy8gbXVsdGlwbGUgdGlja3MgaW4gYSByb3dcbiAgICAgICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgICAgIC8vIHNraXAgdGlja3MgdG8gc2xvdyBkb3duIGxheW91dCBmb3IgZGVidWdnaW5nXG4gICAgICAgICAgICB2YXIgdGhpc1NraXAgPSBza2lwO1xuICAgICAgICAgICAgc2tpcCA9IChza2lwICsgMSkgJSB0aWNrU2tpcDtcbiAgICAgICAgICAgIGlmKCB0aGlzU2tpcCAhPT0gMCApe1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGlja3NQZXJGcmFtZSAmJiAhcmV0OyBpKysgKXtcbiAgICAgICAgICAgICAgcmV0ID0gcmV0IHx8IGluZnRpY2soKTsgLy8gcGljayB1cCB0cnVlIHJldCB2YWxzID0+IHNpbSBkb25lXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICAgIHZhciBmcmFtZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBtdWx0aXRpY2soKSApeyByZXR1cm47IH1cblxuICAgICAgICAgICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnJhbWUgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICQkLnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmcmFtZSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSggIWluZnRpY2soKSApe31cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgb246IGZ1bmN0aW9uKCB0eXBlLCBsaXN0ZW5lciApe30sIC8vIGR1bW15OyBub3QgbmVlZGVkXG5cbiAgICAgICAgZHJhZzogZnVuY3Rpb24oKXt9IC8vIFRPRE9cbiAgICAgIH0pO1xuICAgICAgbGF5b3V0LmFkYXB0b3IgPSBhZGFwdG9yO1xuXG4gICAgICAvLyBpZiBzZXQgbm8gZ3JhYmJpbmcgZHVyaW5nIGxheW91dFxuICAgICAgdmFyIGdyYWJiYWJsZU5vZGVzID0gbm9kZXMuZmlsdGVyKCc6Z3JhYmJhYmxlJyk7XG4gICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgZ3JhYmJhYmxlTm9kZXMudW5ncmFiaWZ5KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBub2RlIGRyYWdnaW5nXG4gICAgICB2YXIgZ3JhYkhhbmRsZXI7XG4gICAgICBub2Rlcy5vbignZ3JhYiBmcmVlIHBvc2l0aW9uJywgZ3JhYkhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xuICAgICAgICB2YXIgc2NyQ29sYSA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhO1xuICAgICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICBpZiggbm9kZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICBzY3JDb2xhLnggPSBwb3MueCAtIGJiLngxO1xuICAgICAgICAgIHNjckNvbGEueSA9IHBvcy55IC0gYmIueTE7XG5cbiAgICAgICAgICBhZGFwdG9yLmRyYWdzdGFydCggc2NyQ29sYSApO1xuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihzY3JDb2xhLngpICYmICQkLmlzLm51bWJlcihzY3JDb2xhLnkpICl7XG4gICAgICAgICAgcG9zLnggPSBzY3JDb2xhLnggKyBiYi54MTtcbiAgICAgICAgICBwb3MueSA9IHNjckNvbGEueSArIGJiLnkxO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoKCBlLnR5cGUgKXtcbiAgICAgICAgICBjYXNlICdncmFiJzpcbiAgICAgICAgICAgIGFkYXB0b3IuZHJhZ3N0YXJ0KCBzY3JDb2xhICk7XG4gICAgICAgICAgICBhZGFwdG9yLnJlc3VtZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZnJlZSc6XG4gICAgICAgICAgICBhZGFwdG9yLmRyYWdlbmQoIHNjckNvbGEgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfSk7XG5cbiAgICAgIHZhciBsb2NrSGFuZGxlcjtcbiAgICAgIG5vZGVzLm9uKCdsb2NrIHVubG9jaycsIGxvY2tIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciBub2RlID0gdGhpcztcbiAgICAgICAgdmFyIHNjckNvbGEgPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcbiAgICAgIFxuICAgICAgICBpZiggbm9kZS5sb2NrZWQoKSApe1xuICAgICAgICAgIGFkYXB0b3IuZHJhZ3N0YXJ0KCBzY3JDb2xhICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRhcHRvci5kcmFnZW5kKCBzY3JDb2xhICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbm9ucGFyZW50Tm9kZXMgPSBub2Rlcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgcmV0dXJuICFub2RlLmlzUGFyZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gYWRkIG5vZGVzIHRvIGNvbGFcbiAgICAgIGFkYXB0b3Iubm9kZXMoIG5vbnBhcmVudE5vZGVzLm1hcChmdW5jdGlvbiggbm9kZSwgaSApe1xuICAgICAgICB2YXIgcGFkZGluZyA9IGdldE9wdFZhbCggb3B0aW9ucy5ub2RlU3BhY2luZywgbm9kZSApO1xuICAgICAgICB2YXIgcG9zID0gbm9kZS5wb3NpdGlvbigpO1xuXG4gICAgICAgIHZhciBzdHJ1Y3QgPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYSA9IHtcbiAgICAgICAgICB4OiBvcHRpb25zLnJhbmRvbWl6ZSA/IE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBiYi53ICkgOiBwb3MueCxcbiAgICAgICAgICB5OiBvcHRpb25zLnJhbmRvbWl6ZSA/IE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBiYi5oICkgOiBwb3MueSxcbiAgICAgICAgICB3aWR0aDogbm9kZS5vdXRlcldpZHRoKCkgKyAyKnBhZGRpbmcsXG4gICAgICAgICAgaGVpZ2h0OiBub2RlLm91dGVySGVpZ2h0KCkgKyAyKnBhZGRpbmcsXG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc3RydWN0O1xuICAgICAgfSkgKTtcblxuICAgICAgaWYoIG9wdGlvbnMuYWxpZ25tZW50ICl7IC8vIHRoZW4gc2V0IGFsaWdubWVudCBjb25zdHJhaW50c1xuXG4gICAgICAgIHZhciBvZmZzZXRzWCA9IFtdO1xuICAgICAgICB2YXIgb2Zmc2V0c1kgPSBbXTtcblxuICAgICAgICBub25wYXJlbnROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgICAgdmFyIGFsaWduID0gZ2V0T3B0VmFsKCBvcHRpb25zLmFsaWdubWVudCwgbm9kZSApO1xuICAgICAgICAgIHZhciBzY3JDb2xhID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG4gICAgICAgICAgdmFyIGluZGV4ID0gc2NyQ29sYS5pbmRleDtcblxuICAgICAgICAgIGlmKCAhYWxpZ24gKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgICBpZiggYWxpZ24ueCAhPSBudWxsICl7XG4gICAgICAgICAgICBvZmZzZXRzWC5wdXNoKHtcbiAgICAgICAgICAgICAgbm9kZTogaW5kZXgsXG4gICAgICAgICAgICAgIG9mZnNldDogYWxpZ24ueFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGFsaWduLnkgIT0gbnVsbCApe1xuICAgICAgICAgICAgb2Zmc2V0c1kucHVzaCh7XG4gICAgICAgICAgICAgIG5vZGU6IGluZGV4LFxuICAgICAgICAgICAgICBvZmZzZXQ6IGFsaWduLnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWRkIGFsaWdubWVudCBjb25zdHJhaW50cyBvbiBub2Rlc1xuICAgICAgICB2YXIgY29uc3RyYWludHMgPSBbXTtcblxuICAgICAgICBpZiggb2Zmc2V0c1gubGVuZ3RoID4gMCApe1xuICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2FsaWdubWVudCcsXG4gICAgICAgICAgICBheGlzOiAneCcsXG4gICAgICAgICAgICBvZmZzZXRzOiBvZmZzZXRzWFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9mZnNldHNZLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdhbGlnbm1lbnQnLFxuICAgICAgICAgICAgYXhpczogJ3knLFxuICAgICAgICAgICAgb2Zmc2V0czogb2Zmc2V0c1lcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgYWRhcHRvci5jb25zdHJhaW50cyggY29uc3RyYWludHMgKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBhZGQgY29tcG91bmQgbm9kZXMgdG8gY29sYVxuICAgICAgYWRhcHRvci5ncm91cHMoIG5vZGVzLnN0ZEZpbHRlcihmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICByZXR1cm4gbm9kZS5pc1BhcmVudCgpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKCBub2RlLCBpICl7IC8vIGFkZCBiYXNpYyBncm91cCBpbmNsIGxlYWYgbm9kZXNcbiAgICAgICAgbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEgPSB7XG4gICAgICAgICAgaW5kZXg6IGksXG5cbiAgICAgICAgICBsZWF2ZXM6IG5vZGUuY2hpbGRyZW4oKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGNoaWxkICl7XG4gICAgICAgICAgICByZXR1cm4gIWNoaWxkLmlzUGFyZW50KCk7XG4gICAgICAgICAgfSkubWFwKGZ1bmN0aW9uKCBjaGlsZCApe1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkWzBdLl9wcml2YXRlLnNjcmF0Y2guY29sYS5pbmRleDtcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKCBub2RlICl7IC8vIGFkZCBzdWJncm91cHNcbiAgICAgICAgbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEuZ3JvdXBzID0gbm9kZS5jaGlsZHJlbigpLnN0ZEZpbHRlcihmdW5jdGlvbiggY2hpbGQgKXtcbiAgICAgICAgICByZXR1cm4gY2hpbGQuaXNQYXJlbnQoKTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uKCBjaGlsZCApe1xuICAgICAgICAgIHJldHVybiBjaGlsZC5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEuaW5kZXg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcbiAgICAgIH0pICk7XG5cbiAgICAgIC8vIGdldCB0aGUgZWRnZSBsZW5ndGggc2V0dGluZyBtZWNoYW5pc21cbiAgICAgIHZhciBsZW5ndGg7XG4gICAgICB2YXIgbGVuZ3RoRm5OYW1lO1xuICAgICAgaWYoIG9wdGlvbnMuZWRnZUxlbmd0aCAhPSBudWxsICl7XG4gICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZWRnZUxlbmd0aDtcbiAgICAgICAgbGVuZ3RoRm5OYW1lID0gJ2xpbmtEaXN0YW5jZSc7XG4gICAgICB9IGVsc2UgaWYoIG9wdGlvbnMuZWRnZVN5bURpZmZMZW5ndGggIT0gbnVsbCApe1xuICAgICAgICBsZW5ndGggPSBvcHRpb25zLmVkZ2VTeW1EaWZmTGVuZ3RoO1xuICAgICAgICBsZW5ndGhGbk5hbWUgPSAnc3ltbWV0cmljRGlmZkxpbmtMZW5ndGhzJztcbiAgICAgIH0gZWxzZSBpZiggb3B0aW9ucy5lZGdlSmFjY2FyZExlbmd0aCAhPSBudWxsICl7XG4gICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZWRnZUphY2NhcmRMZW5ndGg7XG4gICAgICAgIGxlbmd0aEZuTmFtZSA9ICdqYWNjYXJkTGlua0xlbmd0aHMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuZ3RoID0gMTAwO1xuICAgICAgICBsZW5ndGhGbk5hbWUgPSAnbGlua0Rpc3RhbmNlJztcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aEdldHRlciA9IGZ1bmN0aW9uKCBsaW5rICl7XG4gICAgICAgIHJldHVybiBsaW5rLmNhbGNMZW5ndGg7XG4gICAgICB9O1xuXG4gICAgICAvLyBhZGQgdGhlIGVkZ2VzIHRvIGNvbGFcbiAgICAgIGFkYXB0b3IubGlua3MoIGVkZ2VzLnN0ZEZpbHRlcihmdW5jdGlvbiggZWRnZSApe1xuICAgICAgICByZXR1cm4gIWVkZ2Uuc291cmNlKCkuaXNQYXJlbnQoKSAmJiAhZWRnZS50YXJnZXQoKS5pc1BhcmVudCgpO1xuICAgICAgfSkubWFwKGZ1bmN0aW9uKCBlZGdlLCBpICl7XG4gICAgICAgIHZhciBjID0gZWRnZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEgPSB7XG4gICAgICAgICAgc291cmNlOiBlZGdlLnNvdXJjZSgpWzBdLl9wcml2YXRlLnNjcmF0Y2guY29sYS5pbmRleCxcbiAgICAgICAgICB0YXJnZXQ6IGVkZ2UudGFyZ2V0KClbMF0uX3ByaXZhdGUuc2NyYXRjaC5jb2xhLmluZGV4XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGxlbmd0aCAhPSBudWxsICl7XG4gICAgICAgICAgYy5jYWxjTGVuZ3RoID0gZ2V0T3B0VmFsKCBsZW5ndGgsIGVkZ2UgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfSkgKTtcblxuICAgICAgYWRhcHRvci5zaXplKFsgYmIudywgYmIuaCBdKTtcblxuICAgICAgaWYoIGxlbmd0aCAhPSBudWxsICl7XG4gICAgICAgIGFkYXB0b3JbIGxlbmd0aEZuTmFtZSBdKCBsZW5ndGhHZXR0ZXIgKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBmbG93IG9mIGNvbGFcbiAgICAgIGlmKCBvcHRpb25zLmZsb3cgKXtcbiAgICAgICAgdmFyIGZsb3c7XG4gICAgICAgIHZhciBkZWZBeGlzID0gJ3knO1xuICAgICAgICB2YXIgZGVmTWluU2VwID0gNTA7XG5cbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyhvcHRpb25zLmZsb3cpICl7XG4gICAgICAgICAgZmxvdyA9IHtcbiAgICAgICAgICAgIGF4aXM6IG9wdGlvbnMuZmxvdyxcbiAgICAgICAgICAgIG1pblNlcGFyYXRpb246IGRlZk1pblNlcFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMuZmxvdykgKXtcbiAgICAgICAgICBmbG93ID0ge1xuICAgICAgICAgICAgYXhpczogZGVmQXhpcyxcbiAgICAgICAgICAgIG1pblNlcGFyYXRpb246IG9wdGlvbnMuZmxvd1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3Qob3B0aW9ucy5mbG93KSApe1xuICAgICAgICAgIGZsb3cgPSBvcHRpb25zLmZsb3c7XG5cbiAgICAgICAgICBmbG93LmF4aXMgPSBmbG93LmF4aXMgfHwgZGVmQXhpcztcbiAgICAgICAgICBmbG93Lm1pblNlcGFyYXRpb24gPSBmbG93Lm1pblNlcGFyYXRpb24gIT0gbnVsbCA/IGZsb3cubWluU2VwYXJhdGlvbiA6IGRlZk1pblNlcDtcbiAgICAgICAgfSBlbHNlIHsgLy8gZS5nLiBvcHRpb25zLmZsb3c6IHRydWVcbiAgICAgICAgICBmbG93ID0ge1xuICAgICAgICAgICAgYXhpczogZGVmQXhpcyxcbiAgICAgICAgICAgIG1pblNlcGFyYXRpb246IGRlZk1pblNlcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBhZGFwdG9yLmZsb3dMYXlvdXQoIGZsb3cuYXhpcyAsIGZsb3cubWluU2VwYXJhdGlvbiApO1xuICAgICAgfVxuXG4gICAgICBhZGFwdG9yXG4gICAgICAgIC5hdm9pZE92ZXJsYXBzKCBvcHRpb25zLmF2b2lkT3ZlcmxhcCApXG4gICAgICAgIC5oYW5kbGVEaXNjb25uZWN0ZWQoIG9wdGlvbnMuaGFuZGxlRGlzY29ubmVjdGVkIClcbiAgICAgICAgLnN0YXJ0KCBvcHRpb25zLnVuY29uc3RySXRlciwgb3B0aW9ucy51c2VyQ29uc3RJdGVyLCBvcHRpb25zLmFsbENvbnN0SXRlcilcbiAgICAgIDtcblxuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICl7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBhZGFwdG9yLnN0b3AoKTtcbiAgICAgICAgfSwgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICB9KTsgLy8gcmVxdWlyZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gIENvbGFMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIGlmKCB0aGlzLmFkYXB0b3IgKXtcbiAgICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWRhcHRvci5zdG9wKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gcmVnaXN0ZXIgdGhlIGxheW91dFxuICAkJCgnbGF5b3V0JywgJ2NvbGEnLCBDb2xhTGF5b3V0KTtcblxufSkoY3l0b3NjYXBlKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgcGFkZGluZzogMzAsIC8vIHRoZSBwYWRkaW5nIG9uIGZpdFxuICAgIHN0YXJ0QW5nbGU6IDMvMiAqIE1hdGguUEksIC8vIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgbm9kZVxuICAgIGNvdW50ZXJjbG9ja3dpc2U6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBsYXlvdXQgc2hvdWxkIGdvIGNvdW50ZXJjbG9ja3dpc2UvYW50aWNsb2Nrd2lzZSAodHJ1ZSkgb3IgY2xvY2t3aXNlIChmYWxzZSlcbiAgICBtaW5Ob2RlU3BhY2luZzogMTAsIC8vIG1pbiBzcGFjaW5nIGJldHdlZW4gb3V0c2lkZSBvZiBub2RlcyAodXNlZCBmb3IgcmFkaXVzIGFkanVzdG1lbnQpXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgaGVpZ2h0OiB1bmRlZmluZWQsIC8vIGhlaWdodCBvZiBsYXlvdXQgYXJlYSAob3ZlcnJpZGVzIGNvbnRhaW5lciBoZWlnaHQpXG4gICAgd2lkdGg6IHVuZGVmaW5lZCwgLy8gd2lkdGggb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgd2lkdGgpXG4gICAgY29uY2VudHJpYzogZnVuY3Rpb24oKXsgLy8gcmV0dXJucyBudW1lcmljIHZhbHVlIGZvciBlYWNoIG5vZGUsIHBsYWNpbmcgaGlnaGVyIG5vZGVzIGluIGxldmVscyB0b3dhcmRzIHRoZSBjZW50cmVcbiAgICAgIHJldHVybiB0aGlzLmRlZ3JlZSgpO1xuICAgIH0sXG4gICAgbGV2ZWxXaWR0aDogZnVuY3Rpb24obm9kZXMpeyAvLyB0aGUgdmFyaWF0aW9uIG9mIGNvbmNlbnRyaWMgdmFsdWVzIGluIGVhY2ggbGV2ZWxcbiAgICAgIHJldHVybiBub2Rlcy5tYXhEZWdyZWUoKSAvIDQ7XG4gICAgfSxcbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gQ29uY2VudHJpY0xheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIENvbmNlbnRyaWNMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICBcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgXG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgIFxuICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICB9ICk7XG5cbiAgICB2YXIgY2VudGVyID0ge1xuICAgICAgeDogYmIueDEgKyBiYi53LzIsXG4gICAgICB5OiBiYi55MSArIGJiLmgvMlxuICAgIH07XG4gICAgXG4gICAgdmFyIG5vZGVWYWx1ZXMgPSBbXTsgLy8geyBub2RlLCB2YWx1ZSB9XG4gICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlO1xuICAgIHZhciBtYXhOb2RlU2l6ZSA9IDA7XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgdmFsdWVcbiAgICAgIHZhbHVlID0gb3B0aW9ucy5jb25jZW50cmljLmNhbGwobm9kZSk7XG4gICAgICBub2RlVmFsdWVzLnB1c2goe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG5vZGU6IG5vZGVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBmb3Igc3R5bGUgbWFwcGluZ1xuICAgICAgbm9kZS5fcHJpdmF0ZS5sYXlvdXREYXRhLmNvbmNlbnRyaWMgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBpbiBjYXNlIHdlIHVzZWQgdGhlIGBjb25jZW50cmljYCBpbiBzdHlsZVxuICAgIG5vZGVzLnVwZGF0ZVN0eWxlKCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgbWF4IHNpemUgbm93IGJhc2VkIG9uIHBvdGVudGlhbGx5IHVwZGF0ZWQgbWFwcGVyc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgIG1heE5vZGVTaXplID0gTWF0aC5tYXgoIG1heE5vZGVTaXplLCBub2RlLm91dGVyV2lkdGgoKSwgbm9kZS5vdXRlckhlaWdodCgpICk7XG4gICAgfVxuXG4gICAgLy8gc29ydCBub2RlIHZhbHVlcyBpbiBkZXNjcmVhc2luZyBvcmRlclxuICAgIG5vZGVWYWx1ZXMuc29ydChmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBiLnZhbHVlIC0gYS52YWx1ZTtcbiAgICB9KTtcblxuICAgIHZhciBsZXZlbFdpZHRoID0gb3B0aW9ucy5sZXZlbFdpZHRoKCBub2RlcyApO1xuXG4gICAgLy8gcHV0IHRoZSB2YWx1ZXMgaW50byBsZXZlbHNcbiAgICB2YXIgbGV2ZWxzID0gWyBbXSBdO1xuICAgIHZhciBjdXJyZW50TGV2ZWwgPSBsZXZlbHNbMF07XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2RlVmFsdWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgdmFsID0gbm9kZVZhbHVlc1tpXTtcblxuICAgICAgaWYoIGN1cnJlbnRMZXZlbC5sZW5ndGggPiAwICl7XG4gICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMoIGN1cnJlbnRMZXZlbFswXS52YWx1ZSAtIHZhbC52YWx1ZSApO1xuXG4gICAgICAgIGlmKCBkaWZmID49IGxldmVsV2lkdGggKXtcbiAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBbXTtcbiAgICAgICAgICBsZXZlbHMucHVzaCggY3VycmVudExldmVsICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3VycmVudExldmVsLnB1c2goIHZhbCApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBwb3NpdGlvbnMgZnJvbSBsZXZlbHNcblxuICAgIHZhciBwb3MgPSB7fTsgLy8gaWQgPT4gcG9zaXRpb25cbiAgICB2YXIgciA9IDA7XG4gICAgdmFyIG1pbkRpc3QgPSBtYXhOb2RlU2l6ZSArIG9wdGlvbnMubWluTm9kZVNwYWNpbmc7IC8vIG1pbiBkaXN0IGJldHdlZW4gbm9kZXNcblxuICAgIGlmKCAhb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXsgLy8gdGhlbiBzdHJpY3RseSBjb25zdHJhaW4gdG8gYmJcbiAgICAgIHZhciBmaXJzdEx2bEhhc011bHRpID0gbGV2ZWxzLmxlbmd0aCA+IDAgJiYgbGV2ZWxzWzBdLmxlbmd0aCA+IDE7XG4gICAgICB2YXIgbWF4UiA9ICggTWF0aC5taW4oYmIudywgYmIuaCkgLyAyIC0gbWluRGlzdCApO1xuICAgICAgdmFyIHJTdGVwID0gbWF4UiAvICggbGV2ZWxzLmxlbmd0aCArIGZpcnN0THZsSGFzTXVsdGkgPyAxIDogMCApO1xuXG4gICAgICBtaW5EaXN0ID0gTWF0aC5taW4oIG1pbkRpc3QsIHJTdGVwICk7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgIHZhciBkVGhldGEgPSAyICogTWF0aC5QSSAvIGxldmVsLmxlbmd0aDtcblxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgICAgIGlmKCBsZXZlbC5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgICAgdmFyIGRjb3MgPSBNYXRoLmNvcyhkVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgICAgICB2YXIgck1pbiA9IE1hdGguc3FydCggbWluRGlzdCAqIG1pbkRpc3QgLyAoIGRjb3MqZGNvcyArIGRzaW4qZHNpbiApICk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcbiAgICAgICAgciA9IE1hdGgubWF4KCByTWluLCByICk7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbGV2ZWwubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHZhbCA9IGxldmVsW2pdO1xuICAgICAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGUgKyAob3B0aW9ucy5jb3VudGVyY2xvY2t3aXNlID8gMSA6IC0xKSAqIGRUaGV0YSAqIGo7XG5cbiAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICAgIHk6IGNlbnRlci55ICsgciAqIE1hdGguc2luKHRoZXRhKVxuICAgICAgICB9O1xuXG4gICAgICAgIHBvc1sgdmFsLm5vZGUuaWQoKSBdID0gcDtcbiAgICAgIH1cblxuICAgICAgciArPSBtaW5EaXN0O1xuICAgICAgXG4gICAgfSBcblxuICAgIC8vIHBvc2l0aW9uIHRoZSBub2Rlc1xuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgdmFyIGlkID0gdGhpcy5pZCgpO1xuXG4gICAgICByZXR1cm4gcG9zW2lkXTtcbiAgICB9KTtcbiAgXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ2NvbmNlbnRyaWMnLCBDb25jZW50cmljTGF5b3V0KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbi8qXG4gIFRoZSBDb1NFIGxheW91dCB3YXMgd3JpdHRlbiBieSBHZXJhcmRvIEh1Y2suXG5cbiAgTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG5cbjsoZnVuY3Rpb24oJCQpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBERUJVRztcblxuICAvKipcbiAgICogQGJyaWVmIDogIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICAvLyBDYWxsZWQgb24gYGxheW91dHJlYWR5YFxuICAgIHJlYWR5ICAgICAgICAgICAgICAgOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRzdG9wYFxuICAgIHN0b3AgICAgICAgICAgICAgICAgOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLy8gV2hldGhlciB0byBhbmltYXRlIHdoaWxlIHJ1bm5pbmcgdGhlIGxheW91dFxuICAgIGFuaW1hdGUgICAgICAgICAgICAgOiB0cnVlLFxuXG4gICAgLy8gTnVtYmVyIG9mIGl0ZXJhdGlvbnMgYmV0d2VlbiBjb25zZWN1dGl2ZSBzY3JlZW4gcG9zaXRpb25zIHVwZGF0ZSAoMCAtPiBvbmx5IHVwZGF0ZWQgb24gdGhlIGVuZClcbiAgICByZWZyZXNoICAgICAgICAgICAgIDogNCxcbiAgICBcbiAgICAvLyBXaGV0aGVyIHRvIGZpdCB0aGUgbmV0d29yayB2aWV3IGFmdGVyIHdoZW4gZG9uZVxuICAgIGZpdCAgICAgICAgICAgICAgICAgOiB0cnVlLCBcblxuICAgIC8vIFBhZGRpbmcgb24gZml0XG4gICAgcGFkZGluZyAgICAgICAgICAgICA6IDMwLCBcblxuICAgIC8vIENvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGJvdW5kaW5nQm94ICAgICAgICAgOiB1bmRlZmluZWQsXG5cbiAgICAvLyBXaGV0aGVyIHRvIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9ucyBvbiB0aGUgYmVnaW5uaW5nXG4gICAgcmFuZG9taXplICAgICAgICAgICA6IHRydWUsXG4gICAgXG4gICAgLy8gV2hldGhlciB0byB1c2UgdGhlIEpTIGNvbnNvbGUgdG8gcHJpbnQgZGVidWcgbWVzc2FnZXNcbiAgICBkZWJ1ZyAgICAgICAgICAgICAgIDogZmFsc2UsXG5cbiAgICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gICAgbm9kZVJlcHVsc2lvbiAgICAgICA6IDQwMDAwMCxcbiAgICBcbiAgICAvLyBOb2RlIHJlcHVsc2lvbiAob3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgICBub2RlT3ZlcmxhcCAgICAgICAgIDogMTAsXG4gICAgXG4gICAgLy8gSWRlYWwgZWRnZSAobm9uIG5lc3RlZCkgbGVuZ3RoXG4gICAgaWRlYWxFZGdlTGVuZ3RoICAgICA6IDEwLFxuICAgIFxuICAgIC8vIERpdmlzb3IgdG8gY29tcHV0ZSBlZGdlIGZvcmNlc1xuICAgIGVkZ2VFbGFzdGljaXR5ICAgICAgOiAxMDAsXG4gICAgXG4gICAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICAgIG5lc3RpbmdGYWN0b3IgICAgICAgOiA1LCBcbiAgICBcbiAgICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgICBncmF2aXR5ICAgICAgICAgICAgIDogMjUwLCBcbiAgICBcbiAgICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgICBudW1JdGVyICAgICAgICAgICAgIDogMTAwLFxuICAgIFxuICAgIC8vIEluaXRpYWwgdGVtcGVyYXR1cmUgKG1heGltdW0gbm9kZSBkaXNwbGFjZW1lbnQpXG4gICAgaW5pdGlhbFRlbXAgICAgICAgICA6IDIwMCxcbiAgICBcbiAgICAvLyBDb29saW5nIGZhY3RvciAoaG93IHRoZSB0ZW1wZXJhdHVyZSBpcyByZWR1Y2VkIGJldHdlZW4gY29uc2VjdXRpdmUgaXRlcmF0aW9uc1xuICAgIGNvb2xpbmdGYWN0b3IgICAgICAgOiAwLjk1LCBcbiAgICBcbiAgICAvLyBMb3dlciB0ZW1wZXJhdHVyZSB0aHJlc2hvbGQgKGJlbG93IHRoaXMgcG9pbnQgdGhlIGxheW91dCB3aWxsIGVuZClcbiAgICBtaW5UZW1wICAgICAgICAgICAgIDogMS4wXG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICAgICAgIDogY29uc3RydWN0b3JcbiAgICogQGFyZyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIENvc2VMYXlvdXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7IFxuICB9XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogcnVucyB0aGUgbGF5b3V0XG4gICAqL1xuICBDb3NlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgY3kgICAgICA9IG9wdGlvbnMuY3k7XG4gICAgdmFyIGxheW91dCAgPSB0aGlzO1xuXG4gICAgbGF5b3V0LnN0b3BwZWQgPSBmYWxzZTtcblxuICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAvLyBTZXQgREVCVUcgLSBHbG9iYWwgdmFyaWFibGVcbiAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5kZWJ1Zykge1xuICAgICAgREVCVUcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBERUJVRyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEdldCBzdGFydCB0aW1lXG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIGxheW91dCBpbmZvXG4gICAgdmFyIGxheW91dEluZm8gPSBjcmVhdGVMYXlvdXRJbmZvKGN5LCBsYXlvdXQsIG9wdGlvbnMpO1xuICAgIFxuICAgIC8vIFNob3cgTGF5b3V0SW5mbyBjb250ZW50cyBpZiBkZWJ1Z2dpbmdcbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIHByaW50TGF5b3V0SW5mbyhsYXlvdXRJbmZvKTtcbiAgICB9XG5cbiAgICAvLyBJZiByZXF1aXJlZCwgcmFuZG9taXplIG5vZGUgcG9zaXRpb25zXG4gICAgaWYgKHRydWUgPT09IG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgICByYW5kb21pemVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3kpO1xuICAgIH1cblxuICAgIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgbWFpbkxvb3AgPSBmdW5jdGlvbihpKXtcbiAgICAgIGlmKCBsYXlvdXQuc3RvcHBlZCApe1xuICAgICAgICBsb2dEZWJ1ZyhcIkxheW91dCBtYW51YWxseSBzdG9wcGVkLiBTdG9wcGluZyBjb21wdXRhdGlvbiBpbiBzdGVwIFwiICsgaSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gRG8gb25lIHN0ZXAgaW4gdGhlIHBoaXNpY2FsIHNpbXVsYXRpb25cbiAgICAgIHN0ZXAobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMsIGkpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdGVtcGVyYXR1cmVcbiAgICAgIGxheW91dEluZm8udGVtcGVyYXR1cmUgPSBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlICogb3B0aW9ucy5jb29saW5nRmFjdG9yO1xuICAgICAgbG9nRGVidWcoXCJOZXcgdGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG5cbiAgICAgIGlmIChsYXlvdXRJbmZvLnRlbXBlcmF0dXJlIDwgb3B0aW9ucy5taW5UZW1wKSB7XG4gICAgICAgIGxvZ0RlYnVnKFwiVGVtcGVyYXR1cmUgZHJvcCBiZWxvdyBtaW5pbXVtIHRocmVzaG9sZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgZG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcblxuICAgICAgLy8gRml0IHRoZSBncmFwaCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICh0cnVlID09PSBvcHRpb25zLmZpdCkge1xuICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgZW5kIHRpbWVcbiAgICAgIHZhciBlbmRUaW1lID0gbmV3IERhdGUoKTtcblxuICAgICAgY29uc29sZS5pbmZvKCdMYXlvdXQgdG9vayAnICsgKGVuZFRpbWUgLSBzdGFydFRpbWUpICsgJyBtcycpO1xuXG4gICAgICAvLyBMYXlvdXQgaGFzIGZpbmlzaGVkXG4gICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICB9O1xuXG4gICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGZyYW1lID0gZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgZiA9IDA7XG4gICAgICAgIHZhciBsb29wUmV0O1xuICAgICAgICB3aGlsZSggZiA8IG9wdGlvbnMucmVmcmVzaCAmJiBpIDwgb3B0aW9ucy5udW1JdGVyICl7XG4gICAgICAgICAgdmFyIGxvb3BSZXQgPSBtYWluTG9vcChpKTtcbiAgICAgICAgICBpZiggbG9vcFJldCA9PT0gZmFsc2UgKXsgYnJlYWs7IH1cblxuICAgICAgICAgIGYrKztcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICByZWZyZXNoUG9zaXRpb25zKGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggbG9vcFJldCAhPT0gZmFsc2UgJiYgaSArIDEgPCBvcHRpb25zLm51bUl0ZXIgKSB7XG4gICAgICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZyYW1lICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9uZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnJhbWUgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLm51bUl0ZXI7IGkrKykge1xuICAgICAgICBpZiggbWFpbkxvb3AoaSkgPT09IGZhbHNlICl7IGJyZWFrOyB9XG4gICAgICB9XG5cbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gICBcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAgICovXG4gIENvc2VMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgIDogQ3JlYXRlcyBhbiBvYmplY3Qgd2hpY2ggaXMgY29udGFpbnMgYWxsIHRoZSBkYXRhXG4gICAqICAgICAgICAgICAgICB1c2VkIGluIHRoZSBsYXlvdXQgcHJvY2Vzc1xuICAgKiBAYXJnIGN5ICAgIDogY3l0b3NjYXBlLmpzIG9iamVjdFxuICAgKiBAcmV0dXJuICAgIDogbGF5b3V0SW5mbyBvYmplY3QgaW5pdGlhbGl6ZWRcbiAgICovXG4gIHZhciBjcmVhdGVMYXlvdXRJbmZvID0gZnVuY3Rpb24oY3ksIGxheW91dCwgb3B0aW9ucykge1xuICAgIC8vIFNob3J0Y3V0XG4gICAgdmFyIGVkZ2VzID0gb3B0aW9ucy5lbGVzLmVkZ2VzKCk7XG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG5cbiAgICB2YXIgbGF5b3V0SW5mbyAgID0ge1xuICAgICAgbGF5b3V0ICAgICAgIDogbGF5b3V0LFxuICAgICAgbGF5b3V0Tm9kZXMgIDogW10sIFxuICAgICAgaWRUb0luZGV4ICAgIDoge30sXG4gICAgICBub2RlU2l6ZSAgICAgOiBub2Rlcy5zaXplKCksXG4gICAgICBncmFwaFNldCAgICAgOiBbXSxcbiAgICAgIGluZGV4VG9HcmFwaCA6IFtdLCBcbiAgICAgIGxheW91dEVkZ2VzICA6IFtdLFxuICAgICAgZWRnZVNpemUgICAgIDogZWRnZXMuc2l6ZSgpLFxuICAgICAgdGVtcGVyYXR1cmUgIDogb3B0aW9ucy5pbml0aWFsVGVtcCxcbiAgICAgIGNsaWVudFdpZHRoICA6IGN5LndpZHRoKCksXG4gICAgICBjbGllbnRIZWlnaHQgOiBjeS53aWR0aCgpLFxuICAgICAgYm91bmRpbmdCb3ggIDogJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICAgICAgICAgICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICAgICAgICAgICAgICAgICB9IClcbiAgICB9OyBcbiAgICBcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG5vZGVzLCBjcmVhdGluZyBsYXlvdXQgbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIHRlbXBOb2RlICAgICAgICA9IHt9O1xuICAgICAgdGVtcE5vZGUuaWQgICAgICAgICA9IG5vZGVzW2ldLmRhdGEoJ2lkJyk7XG4gICAgICB0ZW1wTm9kZS5wYXJlbnRJZCAgID0gbm9kZXNbaV0uZGF0YSgncGFyZW50Jyk7ICAgICAgXG4gICAgICB0ZW1wTm9kZS5jaGlsZHJlbiAgID0gW107XG4gICAgICB0ZW1wTm9kZS5wb3NpdGlvblggID0gbm9kZXNbaV0ucG9zaXRpb24oJ3gnKTtcbiAgICAgIHRlbXBOb2RlLnBvc2l0aW9uWSAgPSBub2Rlc1tpXS5wb3NpdGlvbigneScpO1xuICAgICAgdGVtcE5vZGUub2Zmc2V0WCAgICA9IDA7ICAgICAgXG4gICAgICB0ZW1wTm9kZS5vZmZzZXRZICAgID0gMDtcbiAgICAgIHRlbXBOb2RlLmhlaWdodCAgICAgPSBub2Rlc1tpXS5oZWlnaHQoKTtcbiAgICAgIHRlbXBOb2RlLndpZHRoICAgICAgPSBub2Rlc1tpXS53aWR0aCgpO1xuICAgICAgdGVtcE5vZGUubWF4WCAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWCArIHRlbXBOb2RlLndpZHRoICAvIDI7XG4gICAgICB0ZW1wTm9kZS5taW5YICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25YIC0gdGVtcE5vZGUud2lkdGggIC8gMjtcbiAgICAgIHRlbXBOb2RlLm1heFkgICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblkgKyB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgICAgdGVtcE5vZGUubWluWSAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWSAtIHRlbXBOb2RlLmhlaWdodCAvIDI7XG4gICAgICB0ZW1wTm9kZS5wYWRMZWZ0ICAgID0gbm9kZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctbGVmdCddLnB4VmFsdWU7XG4gICAgICB0ZW1wTm9kZS5wYWRSaWdodCAgID0gbm9kZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5weFZhbHVlO1xuICAgICAgdGVtcE5vZGUucGFkVG9wICAgICA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLXRvcCddLnB4VmFsdWU7XG4gICAgICB0ZW1wTm9kZS5wYWRCb3R0b20gID0gbm9kZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10ucHhWYWx1ZTtcbiAgICAgIFxuICAgICAgLy8gQWRkIG5ldyBub2RlXG4gICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzLnB1c2godGVtcE5vZGUpO1xuICAgICAgLy8gQWRkIGVudHJ5IHRvIGlkLWluZGV4IG1hcFxuICAgICAgbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcE5vZGUuaWRdID0gaTtcbiAgICB9XG5cbiAgICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHN0YXJ0ID0gMDsgICAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICAgIHZhciBlbmQgICA9IC0xOyAgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgICB2YXIgdGVtcEdyYXBoID0gW107XG5cbiAgICAvLyBTZWNvbmQgcGFzcyB0byBhZGQgY2hpbGQgaW5mb3JtYXRpb24gYW5kIFxuICAgIC8vIGluaXRpYWxpemUgcXVldWUgZm9yIGhpZXJhcmNoaWNhbCB0cmF2ZXJzYWxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgdmFyIHBfaWQgPSBuLnBhcmVudElkO1xuICAgICAgLy8gQ2hlY2sgaWYgbm9kZSBuIGhhcyBhIHBhcmVudCBub2RlXG4gICAgICBpZiAobnVsbCAhPSBwX2lkKSB7XG4gICAgICAvLyBBZGQgbm9kZSBJZCB0byBwYXJlbnQncyBsaXN0IG9mIGNoaWxkcmVuXG4gICAgICBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BfaWRdXS5jaGlsZHJlbi5wdXNoKG4uaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGEgbm9kZSBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHRoZW4gaXQncyBpbiB0aGUgcm9vdCBncmFwaFxuICAgICAgcXVldWVbKytlbmRdID0gbi5pZDtcbiAgICAgIHRlbXBHcmFwaC5wdXNoKG4uaWQpOyAgICBcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHJvb3QgZ3JhcGggdG8gZ3JhcGhTZXRcbiAgICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2godGVtcEdyYXBoKTtcblxuICAgIC8vIFRyYXZlcnNlIHRoZSBncmFwaCwgbGV2ZWwgYnkgbGV2ZWwsIFxuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgIC8vIEdldCB0aGUgbm9kZSB0byB2aXNpdCBhbmQgcmVtb3ZlIGl0IGZyb20gcXVldWVcbiAgICAgIHZhciBub2RlX2lkICA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgICAgdmFyIG5vZGVfaXggID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZV9pZF07XG4gICAgICB2YXIgbm9kZSAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVfaXhdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBBZGQgY2hpbGRyZW4gbm9kZXMgYXMgYSBuZXcgZ3JhcGggdG8gZ3JhcGggc2V0XG4gICAgICBsYXlvdXRJbmZvLmdyYXBoU2V0LnB1c2goY2hpbGRyZW4pO1xuICAgICAgLy8gQWRkIGNoaWxkcmVuIHRvIHF1ZSBxdWV1ZSB0byBiZSB2aXNpdGVkXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBpbmRleFRvR3JhcGggbWFwXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSsrKSB7ICAgICAgXG4gICAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncmFwaC5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dO1xuICAgICAgbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbaW5kZXhdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBlZGdlcywgY3JlYXRpbmcgTGF5b3V0IEVkZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICAgIHZhciBlID0gZWRnZXNbaV07XG4gICAgICB2YXIgdGVtcEVkZ2UgPSB7fTsgICAgICBcbiAgICAgIHRlbXBFZGdlLmlkICAgICAgID0gZS5kYXRhKCdpZCcpO1xuICAgICAgdGVtcEVkZ2Uuc291cmNlSWQgPSBlLmRhdGEoJ3NvdXJjZScpO1xuICAgICAgdGVtcEVkZ2UudGFyZ2V0SWQgPSBlLmRhdGEoJ3RhcmdldCcpO1xuXG4gICAgICAvLyBDb21wdXRlIGlkZWFsIGxlbmd0aFxuICAgICAgdmFyIGlkZWFsTGVuZ3RoID0gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7XG5cbiAgICAgIC8vIENoZWNrIGlmIGl0J3MgYW4gaW50ZXIgZ3JhcGggZWRnZVxuICAgICAgdmFyIHNvdXJjZUl4ICAgID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2Uuc291cmNlSWRdO1xuICAgICAgdmFyIHRhcmdldEl4ICAgID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcEVkZ2UudGFyZ2V0SWRdO1xuICAgICAgdmFyIHNvdXJjZUdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbc291cmNlSXhdO1xuICAgICAgdmFyIHRhcmdldEdyYXBoID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbdGFyZ2V0SXhdO1xuXG4gICAgICBpZiAoc291cmNlR3JhcGggIT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIC8vIEZpbmQgbG93ZXN0IGNvbW1vbiBncmFwaCBhbmNlc3RvclxuICAgICAgdmFyIGxjYSA9IGZpbmRMQ0EodGVtcEVkZ2Uuc291cmNlSWQsIHRlbXBFZGdlLnRhcmdldElkLCBsYXlvdXRJbmZvKTtcblxuICAgICAgLy8gQ29tcHV0ZSBzdW0gb2Ygbm9kZSBkZXB0aHMsIHJlbGF0aXZlIHRvIGxjYSBncmFwaFxuICAgICAgdmFyIGxjYUdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtsY2FdO1xuICAgICAgdmFyIGRlcHRoICAgID0gMDtcblxuICAgICAgLy8gU291cmNlIGRlcHRoXG4gICAgICB2YXIgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3NvdXJjZUl4XTtcbiAgICAgIHdoaWxlICgtMSA9PT0gJC5pbkFycmF5KHRlbXBOb2RlLmlkLCBsY2FHcmFwaCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhcmdldCBkZXB0aFxuICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcbiAgICAgIHdoaWxlICgtMSA9PT0gJC5pbkFycmF5KHRlbXBOb2RlLmlkLCBsY2FHcmFwaCkpIHtcbiAgICAgICAgdGVtcE5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLnBhcmVudElkXV07XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG5cbiAgICAgIGxvZ0RlYnVnKCdMQ0Egb2Ygbm9kZXMgJyArIHRlbXBFZGdlLnNvdXJjZUlkICsgJyBhbmQgJyArIHRlbXBFZGdlLnRhcmdldElkICsgIFxuICAgICAgICAgXCIuIEluZGV4OiBcIiArIGxjYSArIFwiIENvbnRlbnRzOiBcIiArIGxjYUdyYXBoLnRvU3RyaW5nKCkgKyBcbiAgICAgICAgIFwiLiBEZXB0aDogXCIgKyBkZXB0aCk7XG5cbiAgICAgIC8vIFVwZGF0ZSBpZGVhbExlbmd0aFxuICAgICAgaWRlYWxMZW5ndGggKj0gZGVwdGggKiBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gICAgICB9XG5cbiAgICAgIHRlbXBFZGdlLmlkZWFsTGVuZ3RoID0gaWRlYWxMZW5ndGg7XG5cbiAgICAgIGxheW91dEluZm8ubGF5b3V0RWRnZXMucHVzaCh0ZW1wRWRnZSk7XG4gICAgfVxuXG4gICAgLy8gRmluYWxseSwgcmV0dXJuIGxheW91dEluZm8gb2JqZWN0XG4gICAgcmV0dXJuIGxheW91dEluZm87XG4gIH07XG5cbiAgXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbG93ZXN0IGNvbW1vbiBcbiAgICogICAgICAgICAgZ3JhcGggYW5jZXN0b3IgYmV0d2VlbiAyIG5vZGVzIGluIHRoZSBzdWJ0cmVlIFxuICAgKiAgICAgICAgICAoZnJvbSB0aGUgZ3JhcGggaGllcmFyY2h5IGluZHVjZWQgdHJlZSkgd2hvc2VcbiAgICogICAgICAgICAgcm9vdCBpcyBncmFwaEl4XG4gICAqXG4gICAqIEBhcmcgbm9kZTE6IG5vZGUxJ3MgSURcbiAgICogQGFyZyBub2RlMjogbm9kZTIncyBJRFxuICAgKiBAYXJnIGxheW91dEluZm86IGxheW91dEluZm8gb2JqZWN0XG4gICAqXG4gICAqL1xuICB2YXIgZmluZExDQSA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbykge1xuICAgIC8vIEZpbmQgdGhlaXIgY29tbW9uIGFuY2VzdGVyLCBzdGFydGluZyBmcm9tIHRoZSByb290IGdyYXBoXG4gICAgdmFyIHJlcyA9IGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgMCwgbGF5b3V0SW5mbyk7XG4gICAgaWYgKDIgPiByZXMuY291bnQpIHtcbiAgICAgIC8vIElmIGF1eCBmdW5jdGlvbiBjb3VsZG4ndCBmaW5kIHRoZSBjb21tb24gYW5jZXN0ZXIsIFxuICAgICAgLy8gdGhlbiBpdCBpcyB0aGUgcm9vdCBncmFwaFxuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXMuZ3JhcGg7XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IEF1eGlsaWFyeSBmdW5jdGlvbiB1c2VkIGZvciBMQ0EgY29tcHV0YXRpb25cbiAgICogXG4gICAqIEBhcmcgbm9kZTEgICAgICA6IG5vZGUxJ3MgSURcbiAgICogQGFyZyBub2RlMiAgICAgIDogbm9kZTIncyBJRFxuICAgKiBAYXJnIGdyYXBoSXggICAgOiBzdWJncmFwaCBpbmRleFxuICAgKiBAYXJnIGxheW91dEluZm8gOiBsYXlvdXRJbmZvIG9iamVjdFxuICAgKlxuICAgKiBAcmV0dXJuICAgICAgICAgOiBvYmplY3Qgb2YgdGhlIGZvcm0ge2NvdW50OiBYLCBncmFwaDogWX0sIHdoZXJlOlxuICAgKiAgICAgICAgICAgICAgICAgICBYIGlzIHRoZSBudW1iZXIgb2YgYW5jZXN0ZXJzIChtYXg6IDIpIGZvdW5kIGluIFxuICAgKiAgICAgICAgICAgICAgICAgICBncmFwaEl4IChhbmQgaXQncyBzdWJncmFwaHMpLFxuICAgKiAgICAgICAgICAgICAgICAgICBZIGlzIHRoZSBncmFwaCBpbmRleCBvZiB0aGUgbG93ZXN0IGdyYXBoIGNvbnRhaW5pbmcgXG4gICAqICAgICAgICAgICAgICAgICAgIGFsbCBYIG5vZGVzXG4gICAqL1xuICB2YXIgZmluZExDQV9hdXggPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGdyYXBoSXgsIGxheW91dEluZm8pIHtcbiAgICB2YXIgZ3JhcGggPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2dyYXBoSXhdO1xuICAgIC8vIElmIGJvdGggbm9kZXMgYmVsb25ncyB0byBncmFwaEl4XG4gICAgaWYgKC0xIDwgJC5pbkFycmF5KG5vZGUxLCBncmFwaCkgJiYgLTEgPCAkLmluQXJyYXkobm9kZTIsIGdyYXBoKSkge1xuICAgICAgcmV0dXJuIHtjb3VudDoyLCBncmFwaDpncmFwaEl4fTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHJlY3Vyc2l2ZSBjYWxscyBmb3IgYWxsIHN1YmdyYXBoc1xuICAgIHZhciBjID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbm9kZUlkICAgPSBncmFwaFtpXTtcbiAgICAgIHZhciBub2RlSXggICA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJeF0uY2hpbGRyZW47XG5cbiAgICAgIC8vIElmIHRoZSBub2RlIGhhcyBubyBjaGlsZCwgc2tpcCBpdFxuICAgICAgaWYgKDAgPT09IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZEdyYXBoSXggPSBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlblswXV1dO1xuICAgICAgdmFyIHJlc3VsdCA9IGZpbmRMQ0FfYXV4KG5vZGUxLCBub2RlMiwgY2hpbGRHcmFwaEl4LCBsYXlvdXRJbmZvKTtcbiAgICAgIGlmICgwID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE5laXRoZXIgbm9kZTEgbm9yIG5vZGUyIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICgxID09PSByZXN1bHQuY291bnQpIHtcbiAgICAgIC8vIE9uZSBvZiAobm9kZTEsIG5vZGUyKSBpcyBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIGMrKztcbiAgICAgIGlmICgyID09PSBjKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgZm91bmQgYm90aCBub2Rlcywgbm8gbmVlZCB0byBrZWVwIHNlYXJjaGluZ1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIG5vZGVzIGFyZSBwcmVzZW50IGluIHRoaXMgc3ViZ3JhcGhcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9ICAgICAgXG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7Y291bnQ6YywgZ3JhcGg6Z3JhcGhJeH07XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmOiBwcmludHNMYXlvdXRJbmZvIGludG8ganMgY29uc29sZVxuICAgKiAgICAgICAgIE9ubHkgdXNlZCBmb3IgZGViYnVnaW5nIFxuICAgKi9cbiAgdmFyIHByaW50TGF5b3V0SW5mbyA9IGZ1bmN0aW9uKGxheW91dEluZm8pIHtcbiAgICBpZiAoIURFQlVHKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUuZGVidWcoXCJsYXlvdXROb2RlczpcIik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIHZhciBzID0gXG4gICAgICBcIlxcbmluZGV4OiBcIiAgICAgKyBpICsgXG4gICAgICBcIlxcbklkOiBcIiAgICAgICAgKyBuLmlkICsgXG4gICAgICBcIlxcbkNoaWxkcmVuOiBcIiAgKyBuLmNoaWxkcmVuLnRvU3RyaW5nKCkgKyAgXG4gICAgICBcIlxcbnBhcmVudElkOiBcIiAgKyBuLnBhcmVudElkICArIFxuICAgICAgXCJcXG5wb3NpdGlvblg6IFwiICsgbi5wb3NpdGlvblggKyBcbiAgICAgIFwiXFxucG9zaXRpb25ZOiBcIiArIG4ucG9zaXRpb25ZICtcbiAgICAgIFwiXFxuT2Zmc2V0WDogXCIgKyBuLm9mZnNldFggKyBcbiAgICAgIFwiXFxuT2Zmc2V0WTogXCIgKyBuLm9mZnNldFkgKyBcbiAgICAgIFwiXFxucGFkTGVmdDogXCIgKyBuLnBhZExlZnQgKyBcbiAgICAgIFwiXFxucGFkUmlnaHQ6IFwiICsgbi5wYWRSaWdodCArIFxuICAgICAgXCJcXG5wYWRUb3A6IFwiICsgbi5wYWRUb3AgKyBcbiAgICAgIFwiXFxucGFkQm90dG9tOiBcIiArIG4ucGFkQm90dG9tO1xuXG4gICAgICBjb25zb2xlLmRlYnVnKHMpOyAgICBcbiAgICB9ICBcbiAgICBcbiAgICBjb25zb2xlLmRlYnVnKCdpZFRvSW5kZXgnKTtcbiAgICBmb3IgKHZhciBpIGluIGxheW91dEluZm8uaWRUb0luZGV4KSB7XG4gICAgICBjb25zb2xlLmRlYnVnKFwiSWQ6IFwiICsgaSArIFwiXFxuSW5kZXg6IFwiICsgbGF5b3V0SW5mby5pZFRvSW5kZXhbaV0pO1xuICAgIH1cblxuICAgIGNvbnNvbGUuZGVidWcoJ0dyYXBoIFNldCcpO1xuICAgIHZhciBzZXQgPSBsYXlvdXRJbmZvLmdyYXBoU2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSArKykge1xuICAgICAgY29uc29sZS5kZWJ1ZyhcIlNldCA6IFwiICsgaSArIFwiOiBcIiArIHNldFtpXS50b1N0cmluZygpKTtcbiAgICB9IFxuXG4gICAgdmFyIHMgPSAnSW5kZXhUb0dyYXBoJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uaW5kZXhUb0dyYXBoLmxlbmd0aDsgaSArKykge1xuICAgICAgcyArPSBcIlxcbkluZGV4IDogXCIgKyBpICsgXCIgR3JhcGg6IFwiKyBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaFtpXTtcbiAgICB9XG4gICAgY29uc29sZS5kZWJ1ZyhzKTtcblxuICAgIHMgPSAnTGF5b3V0IEVkZ2VzJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubGF5b3V0RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1tpXTtcbiAgICAgIHMgKz0gXCJcXG5FZGdlIEluZGV4OiBcIiArIGkgKyBcIiBJRDogXCIgKyBlLmlkICsgXG4gICAgICBcIiBTb3VjZUlEOiBcIiArIGUuc291cmNlSWQgKyBcIiBUYXJnZXRJZDogXCIgKyBlLnRhcmdldElkICsgXG4gICAgICBcIiBJZGVhbCBMZW5ndGg6IFwiICsgZS5pZGVhbExlbmd0aDtcbiAgICB9XG4gICAgY29uc29sZS5kZWJ1ZyhzKTtcblxuICAgIHMgPSAgXCJub2RlU2l6ZTogXCIgKyBsYXlvdXRJbmZvLm5vZGVTaXplO1xuICAgIHMgKz0gXCJcXG5lZGdlU2l6ZTogXCIgKyBsYXlvdXRJbmZvLmVkZ2VTaXplO1xuICAgIHMgKz0gXCJcXG50ZW1wZXJhdHVyZTogXCIgKyBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlO1xuICAgIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgICByZXR1cm47XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogUmFuZG9taXplcyB0aGUgcG9zaXRpb24gb2YgYWxsIG5vZGVzXG4gICAqL1xuICB2YXIgcmFuZG9taXplUG9zaXRpb25zID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3kpIHtcbiAgICB2YXIgd2lkdGggICAgID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ICAgID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgLy8gTm8gbmVlZCB0byByYW5kb21pemUgY29tcG91bmQgbm9kZXNcbiAgICAgIGlmICh0cnVlIHx8IDAgPT09IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIG4ucG9zaXRpb25YID0gTWF0aC5yYW5kb20oKSAqIHdpZHRoO1xuICAgICAgICBuLnBvc2l0aW9uWSA9IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFxuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogVXBkYXRlcyB0aGUgcG9zaXRpb25zIG9mIG5vZGVzIGluIHRoZSBuZXR3b3JrXG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0XG4gICAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIHZhciByZWZyZXNoUG9zaXRpb25zID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHsgIFxuICAgIHZhciBzID0gJ1JlZnJlc2hpbmcgcG9zaXRpb25zJztcbiAgICBsb2dEZWJ1ZyhzKTtcblxuICAgIHZhciBsYXlvdXQgPSBsYXlvdXRJbmZvLmxheW91dDtcbiAgICB2YXIgbm9kZXMgPSBvcHRpb25zLmVsZXMubm9kZXMoKTtcbiAgICB2YXIgYmIgPSBsYXlvdXRJbmZvLmJvdW5kaW5nQm94O1xuICAgIHZhciBjb3NlQkIgPSB7IHgxOiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTE6IEluZmluaXR5LCB5MjogLUluZmluaXR5IH07XG4gICAgXG4gICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggKXtcbiAgICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlLmRhdGEoJ2lkJyldXTtcblxuICAgICAgICBjb3NlQkIueDEgPSBNYXRoLm1pbiggY29zZUJCLngxLCBsbm9kZS5wb3NpdGlvblggKTtcbiAgICAgICAgY29zZUJCLngyID0gTWF0aC5tYXgoIGNvc2VCQi54MiwgbG5vZGUucG9zaXRpb25YICk7XG5cbiAgICAgICAgY29zZUJCLnkxID0gTWF0aC5taW4oIGNvc2VCQi55MSwgbG5vZGUucG9zaXRpb25ZICk7XG4gICAgICAgIGNvc2VCQi55MiA9IE1hdGgubWF4KCBjb3NlQkIueTIsIGxub2RlLnBvc2l0aW9uWSApO1xuICAgICAgfSk7XG5cbiAgICAgIGNvc2VCQi53ID0gY29zZUJCLngyIC0gY29zZUJCLngxO1xuICAgICAgY29zZUJCLmggPSBjb3NlQkIueTIgLSBjb3NlQkIueTE7XG4gICAgfVxuXG4gICAgbm9kZXMucG9zaXRpb25zKGZ1bmN0aW9uKGksIGVsZSkge1xuICAgICAgdmFyIGxub2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtlbGUuZGF0YSgnaWQnKV1dO1xuICAgICAgcyA9IFwiTm9kZTogXCIgKyBsbm9kZS5pZCArIFwiLiBSZWZyZXNoZWQgcG9zaXRpb246IChcIiArIFxuICAgICAgbG5vZGUucG9zaXRpb25YICsgXCIsIFwiICsgbG5vZGUucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgICAgbG9nRGVidWcocyk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7IC8vIHRoZW4gYWRkIGV4dHJhIGJvdW5kaW5nIGJveCBjb25zdHJhaW50XG4gICAgICAgIHZhciBwY3RYID0gKGxub2RlLnBvc2l0aW9uWCAtIGNvc2VCQi54MSkgLyBjb3NlQkIudztcbiAgICAgICAgdmFyIHBjdFkgPSAobG5vZGUucG9zaXRpb25ZIC0gY29zZUJCLnkxKSAvIGNvc2VCQi5oO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogYmIueDEgKyBwY3RYICogYmIudyxcbiAgICAgICAgICB5OiBiYi55MSArIHBjdFkgKiBiYi5oXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGxub2RlLnBvc2l0aW9uWCxcbiAgICAgICAgICB5OiBsbm9kZS5wb3NpdGlvbllcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRyaWdnZXIgbGF5b3V0UmVhZHkgb25seSBvbiBmaXJzdCBjYWxsXG4gICAgaWYgKHRydWUgIT09IGxheW91dEluZm8ucmVhZHkpIHtcbiAgICAgIHMgPSAnVHJpZ2dlcmluZyBsYXlvdXRyZWFkeSc7XG4gICAgICBsb2dEZWJ1ZyhzKTtcbiAgICAgIGxheW91dEluZm8ucmVhZHkgPSB0cnVlO1xuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiB0aGlzIH0pO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBQZXJmb3JtcyBvbmUgaXRlcmF0aW9uIG9mIHRoZSBwaHlzaWNhbCBzaW11bGF0aW9uXG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IExheW91dEluZm8gb2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICogQGFyZyBjeSAgICAgICAgIDogQ3l0b3NjYXBlIG9iamVjdFxuICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgKi9cbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucywgc3RlcCkgeyAgXG4gICAgdmFyIHMgPSBcIlxcblxcbiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcIjtcbiAgICBzICs9IFwiXFxuU1RFUDogXCIgKyBzdGVwO1xuICAgIHMgKz0gXCJcXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXFxuXCI7XG4gICAgbG9nRGVidWcocyk7XG5cbiAgICAvLyBDYWxjdWxhdGUgbm9kZSByZXB1bHNpb25zXG4gICAgY2FsY3VsYXRlTm9kZUZvcmNlcyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgLy8gQ2FsY3VsYXRlIGVkZ2UgZm9yY2VzXG4gICAgY2FsY3VsYXRlRWRnZUZvcmNlcyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgLy8gQ2FsY3VsYXRlIGdyYXZpdHkgZm9yY2VzXG4gICAgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgLy8gUHJvcGFnYXRlIGZvcmNlcyBmcm9tIHBhcmVudCB0byBjaGlsZFxuICAgIHByb3BhZ2F0ZUZvcmNlcyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgLy8gVXBkYXRlIHBvc2l0aW9ucyBiYXNlZCBvbiBjYWxjdWxhdGVkIGZvcmNlc1xuICAgIHVwZGF0ZVBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDb21wdXRlcyB0aGUgbm9kZSByZXB1bHNpb24gZm9yY2VzXG4gICAqL1xuICB2YXIgY2FsY3VsYXRlTm9kZUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gICAgLy8gR28gdGhyb3VnaCBlYWNoIG9mIHRoZSBncmFwaHMgaW4gZ3JhcGhTZXRcbiAgICAvLyBOb2RlcyBvbmx5IHJlcGVsIGVhY2ggb3RoZXIgaWYgdGhleSBiZWxvbmcgdG8gdGhlIHNhbWUgZ3JhcGhcbiAgICB2YXIgcyA9ICdjYWxjdWxhdGVOb2RlRm9yY2VzJztcbiAgICBsb2dEZWJ1ZyhzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZ3JhcGhTZXQubGVuZ3RoOyBpICsrKSB7XG4gICAgICB2YXIgZ3JhcGggICAgPSBsYXlvdXRJbmZvLmdyYXBoU2V0W2ldO1xuICAgICAgdmFyIG51bU5vZGVzID0gZ3JhcGgubGVuZ3RoO1xuXG4gICAgICBzID0gXCJTZXQ6IFwiICsgZ3JhcGgudG9TdHJpbmcoKTtcbiAgICAgIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBOb3cgZ2V0IGFsbCB0aGUgcGFpcnMgb2Ygbm9kZXMgXG4gICAgICAvLyBPbmx5IGdldCBlYWNoIHBhaXIgb25jZSwgKEEsIEIpID0gKEIsIEEpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgIHZhciBub2RlMSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgICAgdmFyIG5vZGUyID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFtrXV1dO1xuICAgICAgICBub2RlUmVwdWxzaW9uKG5vZGUxLCBub2RlMiwgbGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgICAgfSBcbiAgICAgIH1cbiAgICB9IFxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IENvbXB1dGUgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGEgcGFpciBvZiBub2Rlc1xuICAgKi9cbiAgdmFyIG5vZGVSZXB1bHNpb24gPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gICAgdmFyIHMgPSBcIk5vZGUgcmVwdWxzaW9uLiBOb2RlMTogXCIgKyBub2RlMS5pZCArIFwiIE5vZGUyOiBcIiArIG5vZGUyLmlkO1xuXG4gICAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgICB2YXIgZGlyZWN0aW9uWCA9IG5vZGUyLnBvc2l0aW9uWCAtIG5vZGUxLnBvc2l0aW9uWDtcbiAgICB2YXIgZGlyZWN0aW9uWSA9IG5vZGUyLnBvc2l0aW9uWSAtIG5vZGUxLnBvc2l0aW9uWTtcbiAgICBzICs9IFwiXFxuZGlyZWN0aW9uWDogXCIgKyBkaXJlY3Rpb25YICsgXCIsIGRpcmVjdGlvblk6IFwiICsgZGlyZWN0aW9uWTtcblxuICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGFwcGx5IGEgcmFuZG9tIGZvcmNlXG4gICAgaWYgKDAgPT09IGRpcmVjdGlvblggJiYgMCA9PT0gZGlyZWN0aW9uWSkge1xuICAgICAgcyArPSBcIlxcbk5vZGVzIGhhdmUgdGhlIHNhbWUgcG9zaXRpb24uXCI7XG4gICAgICByZXR1cm47IC8vIFRPRE9cbiAgICB9XG5cbiAgICB2YXIgb3ZlcmxhcCA9IG5vZGVzT3ZlcmxhcChub2RlMSwgbm9kZTIsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgIFxuICAgIGlmIChvdmVybGFwID4gMCkge1xuICAgICAgcyArPSBcIlxcbk5vZGVzIERPIG92ZXJsYXAuXCI7XG4gICAgICBzICs9IFwiXFxuT3ZlcmxhcDogXCIgKyBvdmVybGFwO1xuICAgICAgLy8gSWYgbm9kZXMgb3ZlcmxhcCwgcmVwdWxzaW9uIGZvcmNlIGlzIHByb3BvcnRpb25hbCBcbiAgICAgIC8vIHRvIHRoZSBvdmVybGFwXG4gICAgICB2YXIgZm9yY2UgICAgPSBvcHRpb25zLm5vZGVPdmVybGFwICogb3ZlcmxhcDtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkaXJlY3Rpb25YICogZGlyZWN0aW9uWCArIGRpcmVjdGlvblkgKiBkaXJlY3Rpb25ZKTtcbiAgICAgIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcbiAgICAgIHZhciBmb3JjZVggICA9IGZvcmNlICogZGlyZWN0aW9uWCAvIGRpc3RhbmNlO1xuICAgICAgdmFyIGZvcmNlWSAgID0gZm9yY2UgKiBkaXJlY3Rpb25ZIC8gZGlzdGFuY2U7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSBcIlxcbk5vZGVzIGRvIE5PVCBvdmVybGFwLlwiO1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBvdmVybGFwLCBmb3JjZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIFxuICAgICAgLy8gdG8gc3F1YXJlZCBkaXN0YW5jZVxuXG4gICAgICAvLyBHZXQgY2xpcHBpbmcgcG9pbnRzIGZvciBib3RoIG5vZGVzXG4gICAgICB2YXIgcG9pbnQxID0gZmluZENsaXBwaW5nUG9pbnQobm9kZTEsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUyLCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG5cbiAgICAgIC8vIFVzZSBjbGlwcGluZyBwb2ludHMgdG8gY29tcHV0ZSBkaXN0YW5jZVxuICAgICAgdmFyIGRpc3RhbmNlWCAgID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgIHZhciBkaXN0YW5jZVkgICA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgICB2YXIgZGlzdGFuY2VTcXIgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICB2YXIgZGlzdGFuY2UgICAgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXIpO1xuICAgICAgcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGRpc3RhbmNlO1xuXG4gICAgICAvLyBDb21wdXRlIHRoZSBtb2R1bGUgYW5kIGNvbXBvbmVudHMgb2YgdGhlIGZvcmNlIHZlY3RvclxuICAgICAgdmFyIGZvcmNlICA9IG9wdGlvbnMubm9kZVJlcHVsc2lvbiAvIGRpc3RhbmNlU3FyO1xuICAgICAgdmFyIGZvcmNlWCA9IGZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICB2YXIgZm9yY2VZID0gZm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBmb3JjZVxuICAgIG5vZGUxLm9mZnNldFggLT0gZm9yY2VYO1xuICAgIG5vZGUxLm9mZnNldFkgLT0gZm9yY2VZO1xuICAgIG5vZGUyLm9mZnNldFggKz0gZm9yY2VYO1xuICAgIG5vZGUyLm9mZnNldFkgKz0gZm9yY2VZO1xuXG4gICAgcyArPSBcIlxcbkZvcmNlWDogXCIgKyBmb3JjZVggKyBcIiBGb3JjZVk6IFwiICsgZm9yY2VZO1xuICAgIGxvZ0RlYnVnKHMpO1xuXG4gICAgcmV0dXJuO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IEZpbmRzIHRoZSBwb2ludCBpbiB3aGljaCBhbiBlZGdlIChkaXJlY3Rpb24gZFgsIGRZKSBpbnRlcnNlY3RzIFxuICAgKiAgICAgICAgICB0aGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYm94IG9mIGl0J3Mgc291cmNlL3RhcmdldCBub2RlIFxuICAgKi9cbiAgdmFyIGZpbmRDbGlwcGluZ1BvaW50ID0gZnVuY3Rpb24obm9kZSwgZFgsIGRZKSB7XG5cbiAgICAvLyBTaG9yY3V0c1xuICAgIHZhciBYID0gbm9kZS5wb3NpdGlvblg7XG4gICAgdmFyIFkgPSBub2RlLnBvc2l0aW9uWTtcbiAgICB2YXIgSCA9IG5vZGUuaGVpZ2h0O1xuICAgIHZhciBXID0gbm9kZS53aWR0aDtcbiAgICB2YXIgZGlyU2xvcGUgICAgID0gZFkgLyBkWDtcbiAgICB2YXIgbm9kZVNsb3BlICAgID0gSCAvIFc7XG5cbiAgICB2YXIgcyA9ICdDb21wdXRpbmcgY2xpcHBpbmcgcG9pbnQgb2Ygbm9kZSAnICsgbm9kZS5pZCArIFxuICAgICAgXCIgLiBIZWlnaHQ6ICBcIiArIEggKyBcIiwgV2lkdGg6IFwiICsgVyArIFxuICAgICAgXCJcXG5EaXJlY3Rpb24gXCIgKyBkWCArIFwiLCBcIiArIGRZOyBcbiAgICBcbiAgICAvLyBDb21wdXRlIGludGVyc2VjdGlvblxuICAgIHZhciByZXMgPSB7fTtcbiAgICBkbyB7XG4gICAgICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKHVwKVxuICAgICAgaWYgKDAgPT09IGRYICYmIDAgPCBkWSkge1xuICAgICAgICByZXMueCA9IFg7XG4gICAgICAgIHMgKz0gXCJcXG5VcCBkaXJlY3Rpb25cIjtcbiAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXNlOiBWZXJ0aWNhbCBkaXJlY3Rpb24gKGRvd24pXG4gICAgICBpZiAoMCA9PT0gZFggJiYgMCA+IGRZKSB7XG4gICAgICAgIHJlcy54ID0gWDtcbiAgICAgICAgcmVzLnkgPSBZICsgSCAvIDI7XG4gICAgICAgIHMgKz0gXCJcXG5Eb3duIGRpcmVjdGlvblwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gICAgICBcblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgcmlnaHQgYm9yZGVyXG4gICAgICBpZiAoMCA8IGRYICYmIFxuICAgICAgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgXG4gICAgICBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICAgICAgcmVzLnggPSBYICsgVyAvIDI7XG4gICAgICAgIHJlcy55ID0gWSArIChXICogZFkgLyAyIC8gZFgpO1xuICAgICAgICBzICs9IFwiXFxuUmlnaHRib3JkZXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGxlZnQgYm9yZGVyXG4gICAgICBpZiAoMCA+IGRYICYmIFxuICAgICAgLTEgKiBub2RlU2xvcGUgPD0gZGlyU2xvcGUgJiYgXG4gICAgICBkaXJTbG9wZSA8PSBub2RlU2xvcGUpIHtcbiAgICAgICAgcmVzLnggPSBYIC0gVyAvIDI7XG4gICAgICAgIHJlcy55ID0gWSAtIChXICogZFkgLyAyIC8gZFgpO1xuICAgICAgICBzICs9IFwiXFxuTGVmdGJvcmRlclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgdG9wIGJvcmRlclxuICAgICAgaWYgKDAgPCBkWSAmJiBcbiAgICAgICggZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHxcbiAgICAgICAgZGlyU2xvcGUgPj0gbm9kZVNsb3BlICkpIHtcbiAgICAgICAgcmVzLnggPSBYICsgKEggKiBkWCAvIDIgLyBkWSk7XG4gICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICBzICs9IFwiXFxuVG9wIGJvcmRlclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogSW50ZXJzZWN0cyB0aGUgYm90dG9tIGJvcmRlclxuICAgICAgaWYgKDAgPiBkWSAmJiBcbiAgICAgICggZGlyU2xvcGUgPD0gLTEgKiBub2RlU2xvcGUgfHxcbiAgICAgICAgZGlyU2xvcGUgPj0gbm9kZVNsb3BlICkpIHtcbiAgICAgICAgcmVzLnggPSBYIC0gKEggKiBkWCAvIDIgLyBkWSk7XG4gICAgICAgIHJlcy55ID0gWSAtIEggLyAyO1xuICAgICAgICBzICs9IFwiXFxuQm90dG9tIGJvcmRlclwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0gd2hpbGUgKGZhbHNlKTtcblxuICAgIHMgKz0gXCJcXG5DbGlwcGluZyBwb2ludCBmb3VuZCBhdCBcIiArIHJlcy54ICsgXCIsIFwiICsgcmVzLnk7XG4gICAgbG9nRGVidWcocyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgIDogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byBub2RlcyBvdmVybGFwIG9yIG5vdFxuICAgKiBAcmV0dXJuIDogQW1vdW50IG9mIG92ZXJsYXBwaW5nICgwID0+IG5vIG92ZXJsYXApXG4gICAqL1xuICB2YXIgbm9kZXNPdmVybGFwID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyLCBkWCwgZFkpIHtcblxuICAgIGlmIChkWCA+IDApIHtcbiAgICAgIHZhciBvdmVybGFwWCA9IG5vZGUxLm1heFggLSBub2RlMi5taW5YO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMi5tYXhYIC0gbm9kZTEubWluWDtcbiAgICB9XG5cbiAgICBpZiAoZFkgPiAwKSB7XG4gICAgICB2YXIgb3ZlcmxhcFkgPSBub2RlMS5tYXhZIC0gbm9kZTIubWluWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTIubWF4WSAtIG5vZGUxLm1pblk7XG4gICAgfVxuXG4gICAgaWYgKG92ZXJsYXBYID49IDAgJiYgb3ZlcmxhcFkgPj0gMCkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydChvdmVybGFwWCAqIG92ZXJsYXBYICsgb3ZlcmxhcFkgKiBvdmVybGFwWSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcbiAgICBcbiAgXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDYWxjdWxhdGVzIGFsbCBlZGdlIGZvcmNlc1xuICAgKi9cbiAgdmFyIGNhbGN1bGF0ZUVkZ2VGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8uZWRnZVNpemU7IGkrKykge1xuICAgICAgLy8gR2V0IGVkZ2UsIHNvdXJjZSAmIHRhcmdldCBub2Rlc1xuICAgICAgdmFyIGVkZ2UgICAgID0gbGF5b3V0SW5mby5sYXlvdXRFZGdlc1tpXTtcbiAgICAgIHZhciBzb3VyY2VJeCA9IGxheW91dEluZm8uaWRUb0luZGV4W2VkZ2Uuc291cmNlSWRdO1xuICAgICAgdmFyIHNvdXJjZSAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG4gICAgICB2YXIgdGFyZ2V0SXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnRhcmdldElkXTtcbiAgICAgIHZhciB0YXJnZXQgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbdGFyZ2V0SXhdO1xuXG4gICAgICAvLyBHZXQgZGlyZWN0aW9uIG9mIGxpbmUgY29ubmVjdGluZyBib3RoIG5vZGUgY2VudGVyc1xuICAgICAgdmFyIGRpcmVjdGlvblggPSB0YXJnZXQucG9zaXRpb25YIC0gc291cmNlLnBvc2l0aW9uWDtcbiAgICAgIHZhciBkaXJlY3Rpb25ZID0gdGFyZ2V0LnBvc2l0aW9uWSAtIHNvdXJjZS5wb3NpdGlvblk7XG4gICAgICBcbiAgICAgIC8vIElmIGJvdGggY2VudGVycyBhcmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcuXG4gICAgICAvLyBBIHJhbmRvbSBmb3JjZSBoYXMgYWxyZWFkeSBiZWVuIGFwcGxpZWQgYXMgbm9kZSByZXB1bHNpb25cbiAgICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KHNvdXJjZSwgZGlyZWN0aW9uWCwgZGlyZWN0aW9uWSk7XG4gICAgICB2YXIgcG9pbnQyID0gZmluZENsaXBwaW5nUG9pbnQodGFyZ2V0LCAtMSAqIGRpcmVjdGlvblgsIC0xICogZGlyZWN0aW9uWSk7XG5cblxuICAgICAgdmFyIGx4ID0gcG9pbnQyLnggLSBwb2ludDEueDtcbiAgICAgIHZhciBseSA9IHBvaW50Mi55IC0gcG9pbnQxLnk7XG4gICAgICB2YXIgbCAgPSBNYXRoLnNxcnQobHggKiBseCArIGx5ICogbHkpO1xuXG4gICAgICB2YXIgZm9yY2UgID0gTWF0aC5wb3coZWRnZS5pZGVhbExlbmd0aCAtIGwsIDIpIC8gb3B0aW9ucy5lZGdlRWxhc3RpY2l0eTsgXG5cbiAgICAgIGlmICgwICE9PSBsKSB7XG4gICAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGx4IC8gbDtcbiAgICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogbHkgLyBsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZvcmNlWCA9IDA7XG4gICAgICAgIHZhciBmb3JjZVkgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhpcyBmb3JjZSB0byB0YXJnZXQgYW5kIHNvdXJjZSBub2Rlc1xuICAgICAgc291cmNlLm9mZnNldFggKz0gZm9yY2VYO1xuICAgICAgc291cmNlLm9mZnNldFkgKz0gZm9yY2VZO1xuICAgICAgdGFyZ2V0Lm9mZnNldFggLT0gZm9yY2VYO1xuICAgICAgdGFyZ2V0Lm9mZnNldFkgLT0gZm9yY2VZO1xuXG4gICAgICB2YXIgcyA9ICdFZGdlIGZvcmNlIGJldHdlZW4gbm9kZXMgJyArIHNvdXJjZS5pZCArICcgYW5kICcgKyB0YXJnZXQuaWQ7XG4gICAgICBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgbCArIFwiIEZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIilcIjtcbiAgICAgIGxvZ0RlYnVnKHMpO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDb21wdXRlcyBncmF2aXR5IGZvcmNlcyBmb3IgYWxsIG5vZGVzXG4gICAqL1xuICB2YXIgY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7XG4gICAgdmFyIHMgPSAnY2FsY3VsYXRlR3Jhdml0eUZvcmNlcyc7XG4gICAgbG9nRGVidWcocyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGdyYXBoICAgID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDtcblxuICAgICAgcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICBsb2dEZWJ1ZyhzKTtcbiAgICAgICAgICBcbiAgICAgIC8vIENvbXB1dGUgZ3JhcGggY2VudGVyXG4gICAgICBpZiAoMCA9PT0gaSkge1xuICAgICAgICB2YXIgY2VudGVyWCAgID0gbGF5b3V0SW5mby5jbGllbnRIZWlnaHQgLyAyO1xuICAgICAgICB2YXIgY2VudGVyWSAgID0gbGF5b3V0SW5mby5jbGllbnRXaWR0aCAgLyAyOyAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCBQYXJlbnQgbm9kZSBmb3IgdGhpcyBncmFwaCwgYW5kIHVzZSBpdHMgcG9zaXRpb24gYXMgY2VudGVyXG4gICAgICAgIHZhciB0ZW1wICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtncmFwaFswXV1dO1xuICAgICAgICB2YXIgcGFyZW50ICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbdGVtcC5wYXJlbnRJZF1dO1xuICAgICAgICB2YXIgY2VudGVyWCA9IHBhcmVudC5wb3NpdGlvblg7XG4gICAgICAgIHZhciBjZW50ZXJZID0gcGFyZW50LnBvc2l0aW9uWTtcbiAgICAgIH1cbiAgICAgIHMgPSBcIkNlbnRlciBmb3VuZCBhdDogXCIgKyBjZW50ZXJYICsgXCIsIFwiICsgY2VudGVyWTtcbiAgICAgIGxvZ0RlYnVnKHMpO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZSB0byBhbGwgbm9kZXMgaW4gZ3JhcGhcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICB2YXIgbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbal1dXTtcbiAgICAgICAgcyA9IFwiTm9kZTogXCIgKyBub2RlLmlkO1xuICAgICAgICB2YXIgZHggPSBjZW50ZXJYIC0gbm9kZS5wb3NpdGlvblg7XG4gICAgICAgIHZhciBkeSA9IGNlbnRlclkgLSBub2RlLnBvc2l0aW9uWTtcbiAgICAgICAgdmFyIGQgID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgaWYgKGQgPiAxLjApIHsgLy8gVE9ETzogVXNlIGdsb2JhbCB2YXJpYWJsZSBmb3IgZGlzdGFuY2UgdGhyZXNob2xkXG4gICAgICAgICAgdmFyIGZ4ID0gb3B0aW9ucy5ncmF2aXR5ICogZHggLyBkO1xuICAgICAgICAgIHZhciBmeSA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR5IC8gZDtcbiAgICAgICAgICBub2RlLm9mZnNldFggKz0gZng7XG4gICAgICAgICAgbm9kZS5vZmZzZXRZICs9IGZ5O1xuICAgICAgICAgIHMgKz0gXCI6IEFwcGxpZWQgZm9yY2U6IFwiICsgZnggKyBcIiwgXCIgKyBmeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzICs9IFwiOiBza3lwcGVkIHNpbmNlIGl0J3MgdG9vIGNsb3NlIHRvIGNlbnRlclwiO1xuICAgICAgICB9XG4gICAgICAgIGxvZ0RlYnVnKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBUaGlzIGZ1bmN0aW9uIHByb3BhZ2F0ZXMgdGhlIGV4aXN0aW5nIG9mZnNldHMgZnJvbSBcbiAgICogICAgICAgICAgICAgICAgICAgcGFyZW50IG5vZGVzIHRvIGl0cyBkZXNjZW5kZW50cy5cbiAgICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBPYmplY3RcbiAgICogQGFyZyBjeSAgICAgICAgIDogY3l0b3NjYXBlIE9iamVjdFxuICAgKiBAYXJnIG9wdGlvbnMgICAgOiBMYXlvdXQgb3B0aW9uc1xuICAgKi9cbiAgdmFyIHByb3BhZ2F0ZUZvcmNlcyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7ICBcbiAgICAvLyBJbmxpbmUgaW1wbGVtZW50YXRpb24gb2YgYSBxdWV1ZSwgdXNlZCBmb3IgdHJhdmVyc2luZyB0aGUgZ3JhcGggaW4gQkZTIG9yZGVyXG4gICAgdmFyIHF1ZXVlID0gW107XG4gICAgdmFyIHN0YXJ0ID0gMDsgICAvLyBQb2ludHMgdG8gdGhlIHN0YXJ0IHRoZSBxdWV1ZVxuICAgIHZhciBlbmQgICA9IC0xOyAgLy8gUG9pbnRzIHRvIHRoZSBlbmQgb2YgdGhlIHF1ZXVlXG5cbiAgICBsb2dEZWJ1ZygncHJvcGFnYXRlRm9yY2VzJyk7XG5cbiAgICAvLyBTdGFydCBieSB2aXNpdGluZyB0aGUgbm9kZXMgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICBxdWV1ZS5wdXNoLmFwcGx5KHF1ZXVlLCBsYXlvdXRJbmZvLmdyYXBoU2V0WzBdKTtcbiAgICBlbmQgKz0gbGF5b3V0SW5mby5ncmFwaFNldFswXS5sZW5ndGg7XG5cbiAgICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLCBcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgICB2YXIgbm9kZUlkICAgID0gcXVldWVbc3RhcnQrK107XG4gICAgICB2YXIgbm9kZUluZGV4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZUlkXTtcbiAgICAgIHZhciBub2RlICAgICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW25vZGVJbmRleF07XG4gICAgICB2YXIgY2hpbGRyZW4gID0gbm9kZS5jaGlsZHJlbjtcblxuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG5vZGUgaWYgaXQncyBjb21wb3VuZFxuICAgICAgaWYgKDAgPCBjaGlsZHJlbi5sZW5ndGgpIHsgICAgXG4gICAgICB2YXIgb2ZmWCA9IG5vZGUub2Zmc2V0WDtcbiAgICAgIHZhciBvZmZZID0gbm9kZS5vZmZzZXRZO1xuXG4gICAgICB2YXIgcyA9IFwiUHJvcGFnYXRpbmcgb2Zmc2V0IGZyb20gcGFyZW50IG5vZGUgOiBcIiArIG5vZGUuaWQgKyBcbiAgICAgICAgXCIuIE9mZnNldFg6IFwiICsgb2ZmWCArIFwiLiBPZmZzZXRZOiBcIiArIG9mZlk7XG4gICAgICBzICs9IFwiXFxuIENoaWxkcmVuOiBcIiArIGNoaWxkcmVuLnRvU3RyaW5nKCk7XG4gICAgICBsb2dEZWJ1ZyhzKTtcbiAgICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtjaGlsZHJlbltpXV1dO1xuICAgICAgICAvLyBQcm9wYWdhdGUgb2Zmc2V0XG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRYICs9IG9mZlg7XG4gICAgICAgIGNoaWxkTm9kZS5vZmZzZXRZICs9IG9mZlk7XG4gICAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWV1ZSB0byBiZSB2aXNpdGVkXG4gICAgICAgIHF1ZXVlWysrZW5kXSA9IGNoaWxkcmVuW2ldO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXNldCBwYXJlbnQgb2Zmc2V0c1xuICAgICAgbm9kZS5vZmZzZXRYID0gMDtcbiAgICAgIG5vZGUub2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogVXBkYXRlcyB0aGUgbGF5b3V0IG1vZGVsIHBvc2l0aW9ucywgYmFzZWQgb24gXG4gICAqICAgICAgICAgIHRoZSBhY2N1bXVsYXRlZCBmb3JjZXNcbiAgICovXG4gIHZhciB1cGRhdGVQb3NpdGlvbnMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIHZhciBzID0gJ1VwZGF0aW5nIHBvc2l0aW9ucyc7XG4gICAgbG9nRGVidWcocyk7XG5cbiAgICAvLyBSZXNldCBib3VuZGFyaWVzIGZvciBjb21wb3VuZCBub2Rlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIGxvZ0RlYnVnKFwiUmVzZXR0aW5nIGJvdW5kYXJpZXMgb2YgY29tcG91bmQgbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgbi5tYXhYID0gdW5kZWZpbmVkO1xuICAgICAgICBuLm1pblggPSB1bmRlZmluZWQ7XG4gICAgICAgIG4ubWF4WSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbi5taW5ZID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2V0IGNvbXBvdW5kIG5vZGUgcG9zaXRpb25cbiAgICAgICAgbG9nRGVidWcoXCJTa2lwcGluZyBwb3NpdGlvbiB1cGRhdGUgb2Ygbm9kZTogXCIgKyBuLmlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzID0gXCJOb2RlOiBcIiArIG4uaWQgKyBcIiBQcmV2aW91cyBwb3NpdGlvbjogKFwiICsgXG4gICAgICBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiOyBcblxuICAgICAgLy8gTGltaXQgZGlzcGxhY2VtZW50IGluIG9yZGVyIHRvIGltcHJvdmUgc3RhYmlsaXR5XG4gICAgICB2YXIgdGVtcEZvcmNlID0gbGltaXRGb3JjZShuLm9mZnNldFgsIG4ub2Zmc2V0WSwgbGF5b3V0SW5mby50ZW1wZXJhdHVyZSk7XG4gICAgICBuLnBvc2l0aW9uWCArPSB0ZW1wRm9yY2UueDsgXG4gICAgICBuLnBvc2l0aW9uWSArPSB0ZW1wRm9yY2UueTtcbiAgICAgIG4ub2Zmc2V0WCA9IDA7XG4gICAgICBuLm9mZnNldFkgPSAwO1xuICAgICAgbi5taW5YICAgID0gbi5wb3NpdGlvblggLSBuLndpZHRoOyBcbiAgICAgIG4ubWF4WCAgICA9IG4ucG9zaXRpb25YICsgbi53aWR0aDsgXG4gICAgICBuLm1pblkgICAgPSBuLnBvc2l0aW9uWSAtIG4uaGVpZ2h0OyBcbiAgICAgIG4ubWF4WSAgICA9IG4ucG9zaXRpb25ZICsgbi5oZWlnaHQ7IFxuICAgICAgcyArPSBcIiBOZXcgUG9zaXRpb246IChcIiArIG4ucG9zaXRpb25YICsgXCIsIFwiICsgbi5wb3NpdGlvblkgKyBcIikuXCI7XG4gICAgICBsb2dEZWJ1ZyhzKTtcblxuICAgICAgLy8gVXBkYXRlIGFuY2VzdHJ5IGJvdWRhcmllc1xuICAgICAgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzKG4sIGxheW91dEluZm8pO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzaXplLCBwb3NpdGlvbiBvZiBjb21wdW5kIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIGlmICgwIDwgbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgbi5wb3NpdGlvblggPSAobi5tYXhYICsgbi5taW5YKSAvIDI7XG4gICAgICAgIG4ucG9zaXRpb25ZID0gKG4ubWF4WSArIG4ubWluWSkgLyAyO1xuICAgICAgICBuLndpZHRoICAgICA9IG4ubWF4WCAtIG4ubWluWDtcbiAgICAgICAgbi5oZWlnaHQgICAgPSBuLm1heFkgLSBuLm1pblk7XG4gICAgICAgIHMgPSBcIlVwZGF0aW5nIHBvc2l0aW9uLCBzaXplIG9mIGNvbXBvdW5kIG5vZGUgXCIgKyBuLmlkO1xuICAgICAgICBzICs9IFwiXFxuUG9zaXRpb25YOiBcIiArIG4ucG9zaXRpb25YICsgXCIsIFBvc2l0aW9uWTogXCIgKyBuLnBvc2l0aW9uWTtcbiAgICAgICAgcyArPSBcIlxcbldpZHRoOiBcIiArIG4ud2lkdGggKyBcIiwgSGVpZ2h0OiBcIiArIG4uaGVpZ2h0O1xuICAgICAgICBsb2dEZWJ1ZyhzKTtcbiAgICAgIH1cbiAgICB9ICBcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBMaW1pdHMgYSBmb3JjZSAoZm9yY2VYLCBmb3JjZVkpIHRvIGJlIG5vdCBcbiAgICogICAgICAgICAgZ3JlYXRlciAoaW4gbW9kdWxvKSB0aGFuIG1heC4gXG4gICA4ICAgICAgICAgIFByZXNlcnZlcyBmb3JjZSBkaXJlY3Rpb24uIFxuICAgKi9cbiAgdmFyIGxpbWl0Rm9yY2UgPSBmdW5jdGlvbihmb3JjZVgsIGZvcmNlWSwgbWF4KSB7XG4gICAgdmFyIHMgPSBcIkxpbWl0aW5nIGZvcmNlOiAoXCIgKyBmb3JjZVggKyBcIiwgXCIgKyBmb3JjZVkgKyBcIikuIE1heDogXCIgKyBtYXg7XG4gICAgdmFyIGZvcmNlID0gTWF0aC5zcXJ0KGZvcmNlWCAqIGZvcmNlWCArIGZvcmNlWSAqIGZvcmNlWSk7XG5cbiAgICBpZiAoZm9yY2UgPiBtYXgpIHtcbiAgICAgIHZhciByZXMgPSB7XG4gICAgICB4IDogbWF4ICogZm9yY2VYIC8gZm9yY2UsXG4gICAgICB5IDogbWF4ICogZm9yY2VZIC8gZm9yY2VcbiAgICAgIH07ICAgICAgXG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgIHggOiBmb3JjZVgsXG4gICAgICB5IDogZm9yY2VZXG4gICAgICB9O1xuICAgIH1cblxuICAgIHMgKz0gXCIuXFxuUmVzdWx0OiAoXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55ICsgXCIpXCI7XG4gICAgbG9nRGVidWcocyk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IEZ1bmN0aW9uIHVzZWQgZm9yIGtlZXBpbmcgdHJhY2sgb2YgY29tcG91bmQgbm9kZSBcbiAgICogICAgICAgICAgc2l6ZXMsIHNpbmNlIHRoZXkgc2hvdWxkIGJvdW5kIGFsbCB0aGVpciBzdWJub2Rlcy5cbiAgICovXG4gIHZhciB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMgPSBmdW5jdGlvbihub2RlLCBsYXlvdXRJbmZvKSB7XG4gICAgdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG5ldyBwb3NpdGlvbi9zaXplIG9mIG5vZGUgXCIgKyBub2RlLmlkO1xuICAgIHZhciBwYXJlbnRJZCA9IG5vZGUucGFyZW50SWQ7XG4gICAgaWYgKG51bGwgPT0gcGFyZW50SWQpIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSBhcmUgZG9uZVxuICAgICAgcyArPSBcIi4gTm8gcGFyZW50IG5vZGUuXCI7XG4gICAgICBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBHZXQgUGFyZW50IE5vZGVcbiAgICB2YXIgcCA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbcGFyZW50SWRdXTtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuXG4gICAgLy8gTWF4WFxuICAgIGlmIChudWxsID09IHAubWF4WCB8fCBub2RlLm1heFggKyBwLnBhZFJpZ2h0ID4gcC5tYXhYKSB7XG4gICAgICBwLm1heFggPSBub2RlLm1heFggKyBwLnBhZFJpZ2h0O1xuICAgICAgZmxhZyA9IHRydWU7XG4gICAgICBzICs9IFwiXFxuTmV3IG1heFggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWF4WDtcbiAgICB9XG5cbiAgICAvLyBNaW5YXG4gICAgaWYgKG51bGwgPT0gcC5taW5YIHx8IG5vZGUubWluWCAtIHAucGFkTGVmdCA8IHAubWluWCkge1xuICAgICAgcC5taW5YID0gbm9kZS5taW5YIC0gcC5wYWRMZWZ0O1xuICAgICAgZmxhZyA9IHRydWU7XG4gICAgICBzICs9IFwiXFxuTmV3IG1pblggZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWDtcbiAgICB9XG5cbiAgICAvLyBNYXhZXG4gICAgaWYgKG51bGwgPT0gcC5tYXhZIHx8IG5vZGUubWF4WSArIHAucGFkQm90dG9tID4gcC5tYXhZKSB7XG4gICAgICBwLm1heFkgPSBub2RlLm1heFkgKyBwLnBhZEJvdHRvbTtcbiAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgcyArPSBcIlxcbk5ldyBtYXhZIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFk7XG4gICAgfVxuXG4gICAgLy8gTWluWVxuICAgIGlmIChudWxsID09IHAubWluWSB8fCBub2RlLm1pblkgLSBwLnBhZFRvcCA8IHAubWluWSkge1xuICAgICAgcC5taW5ZID0gbm9kZS5taW5ZIC0gcC5wYWRUb3A7XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIHMgKz0gXCJcXG5OZXcgbWluWSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5taW5ZO1xuICAgIH1cblxuICAgIC8vIElmIHVwZGF0ZWQgYm91bmRhcmllcywgcHJvcGFnYXRlIGNoYW5nZXMgdXB3YXJkXG4gICAgaWYgKGZsYWcpIHtcbiAgICAgIGxvZ0RlYnVnKHMpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhwLCBsYXlvdXRJbmZvKTtcbiAgICB9IFxuXG4gICAgcyArPSBcIi4gTm8gY2hhbmdlcyBpbiBib3VuZGFyaWVzL3Bvc2l0aW9uIG9mIHBhcmVudCBub2RlIFwiICsgcC5pZDsgIFxuICAgIGxvZ0RlYnVnKHMpO1xuICAgIHJldHVybjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBMb2dzIGEgZGVidWcgbWVzc2FnZSBpbiBKUyBjb25zb2xlLCBpZiBERUJVRyBpcyBPTlxuICAgKi9cbiAgdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24odGV4dCkge1xuICAgIGlmIChERUJVRykge1xuICAgICAgY29uc29sZS5kZWJ1Zyh0ZXh0KTtcbiAgICB9XG4gIH07XG5cblxuICAvLyByZWdpc3RlciB0aGUgbGF5b3V0XG4gICQkKCdsYXlvdXQnLCAnY29zZScsIENvc2VMYXlvdXQpO1xuXG59KShjeXRvc2NhcGUpO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICAvLyBkYWdyZSBhbGdvIG9wdGlvbnMsIHVzZXMgZGVmYXVsdCB2YWx1ZSBvbiB1bmRlZmluZWRcbiAgICBub2RlU2VwOiB1bmRlZmluZWQsIC8vIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gYWRqYWNlbnQgbm9kZXMgaW4gdGhlIHNhbWUgcmFua1xuICAgIGVkZ2VTZXA6IHVuZGVmaW5lZCwgLy8gdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBhZGphY2VudCBlZGdlcyBpbiB0aGUgc2FtZSByYW5rXG4gICAgcmFua1NlcDogdW5kZWZpbmVkLCAvLyB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIGFkamFjZW50IG5vZGVzIGluIHRoZSBzYW1lIHJhbmtcbiAgICByYW5rRGlyOiB1bmRlZmluZWQsIC8vICdUQicgZm9yIHRvcCB0byBib3R0b20gZmxvdywgJ0xSJyBmb3IgbGVmdCB0byByaWdodFxuICAgIG1pbkxlbjogZnVuY3Rpb24oIGVkZ2UgKXsgcmV0dXJuIDE7IH0sIC8vIG51bWJlciBvZiByYW5rcyB0byBrZWVwIGJldHdlZW4gdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IG9mIHRoZSBlZGdlXG4gICAgXG4gICAgLy8gZ2VuZXJhbCBsYXlvdXQgb3B0aW9uc1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdG8gdmlld3BvcnRcbiAgICBwYWRkaW5nOiAzMCwgLy8gZml0IHBhZGRpbmdcbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgcmVhZHk6IGZ1bmN0aW9uKCl7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiBmdW5jdGlvbigpe30gLy8gb24gbGF5b3V0c3RvcFxuICB9O1xuXG4gIC8vIGNvbnN0cnVjdG9yXG4gIC8vIG9wdGlvbnMgOiBvYmplY3QgY29udGFpbmluZyBsYXlvdXQgb3B0aW9uc1xuICBmdW5jdGlvbiBEYWdyZUxheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7IFxuICB9XG5cbiAgLy8gcnVucyB0aGUgbGF5b3V0XG4gIERhZ3JlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuXG4gICAgJCQudXRpbC5yZXF1aXJlKCdkYWdyZScsIGZ1bmN0aW9uKGRhZ3JlKXtcblxuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTsgLy8gY3kgaXMgYXV0b21hdGljYWxseSBwb3B1bGF0ZWQgZm9yIHVzIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG5cbiAgICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgfSApO1xuXG4gICAgICB2YXIgZyA9IG5ldyBkYWdyZS5EaWdyYXBoKCk7XG5cbiAgICAgIC8vIGFkZCBub2RlcyB0byBkYWdyZVxuICAgICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgIGcuYWRkTm9kZSggbm9kZS5pZCgpLCB7XG4gICAgICAgICAgd2lkdGg6IG5vZGUud2lkdGgoKSxcbiAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0KClcbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgZWRnZXMgdG8gZGFncmVcbiAgICAgIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgICAgICBnLmFkZEVkZ2UoIGVkZ2UuaWQoKSwgZWRnZS5zb3VyY2UoKS5pZCgpLCBlZGdlLnRhcmdldCgpLmlkKCksIHtcbiAgICAgICAgICBtaW5MZW46ICQkLmlzLmZuKG9wdGlvbnMubWluTGVuKSA/IG9wdGlvbnMubWluTGVuLmFwcGx5KCBlZGdlLCBbIGVkZ2UgXSApIDogb3B0aW9ucy5taW5MZW5cbiAgICAgICAgfSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZCA9IGRhZ3JlLmxheW91dCgpO1xuXG4gICAgICBpZiggb3B0aW9ucy5ub2RlU2VwICl7XG4gICAgICAgIGQubm9kZVNlcCggb3B0aW9ucy5ub2RlU2VwICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRpb25zLmVkZ2VTZXAgKXtcbiAgICAgICAgZC5lZGdlU2VwKCBvcHRpb25zLmVkZ2VTZXAgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIG9wdGlvbnMucmFua1NlcCApe1xuICAgICAgICBkLnJhbmtTZXAoIG9wdGlvbnMucmFua1NlcCApO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0aW9ucy5yYW5rRGlyICl7XG4gICAgICAgIGQucmFua0Rpciggb3B0aW9ucy5yYW5rRGlyICk7XG4gICAgICB9XG4gICAgICAgIFxuICAgICAgZCA9IGQucnVuKGcpO1xuXG4gICAgICBkLmVhY2hOb2RlKGZ1bmN0aW9uKGlkLCBuKSB7XG4gICAgICAgIGN5LmdldEVsZW1lbnRCeUlkKGlkKS5zY3JhdGNoKCkuZGFncmUgPSBuO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBkYWdyZUJCO1xuXG4gICAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApe1xuICAgICAgICBkYWdyZUJCID0geyB4MTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkxOiBJbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgICAgdmFyIGRNb2RlbCA9IG5vZGUuc2NyYXRjaCgpLmRhZ3JlO1xuXG4gICAgICAgICAgZGFncmVCQi54MSA9IE1hdGgubWluKCBkYWdyZUJCLngxLCBkTW9kZWwueCApO1xuICAgICAgICAgIGRhZ3JlQkIueDIgPSBNYXRoLm1heCggZGFncmVCQi54MiwgZE1vZGVsLnggKTtcblxuICAgICAgICAgIGRhZ3JlQkIueTEgPSBNYXRoLm1pbiggZGFncmVCQi55MSwgZE1vZGVsLnkgKTtcbiAgICAgICAgICBkYWdyZUJCLnkyID0gTWF0aC5tYXgoIGRhZ3JlQkIueTIsIGRNb2RlbC55ICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRhZ3JlQkIudyA9IGRhZ3JlQkIueDIgLSBkYWdyZUJCLngxO1xuICAgICAgICBkYWdyZUJCLmggPSBkYWdyZUJCLnkyIC0gZGFncmVCQi55MTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhZ3JlQkIgPSBiYjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnN0cmFpblBvcyA9IGZ1bmN0aW9uKCBwICl7XG4gICAgICAgIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7XG4gICAgICAgICAgdmFyIHhQY3QgPSAocC54IC0gZGFncmVCQi54MSkgLyBkYWdyZUJCLnc7XG4gICAgICAgICAgdmFyIHlQY3QgPSAocC55IC0gZGFncmVCQi55MSkgLyBkYWdyZUJCLmg7XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogYmIueDEgKyB4UGN0ICogYmIudyxcbiAgICAgICAgICAgIHk6IGJiLnkxICsgeVBjdCAqIGJiLmhcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgZE1vZGVsID0gdGhpcy5zY3JhdGNoKCkuZGFncmU7XG5cbiAgICAgICAgcmV0dXJuIGNvbnN0cmFpblBvcyh7XG4gICAgICAgICAgeDogZE1vZGVsLngsXG4gICAgICAgICAgeTogZE1vZGVsLnlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIH0pOyAvLyByZXF1aXJlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvLyByZWdpc3RlciB0aGUgbGF5b3V0XG4gICQkKCdsYXlvdXQnLCAnZGFncmUnLCBEYWdyZUxheW91dCk7XG5cbn0pKGN5dG9zY2FwZSk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIHVzZWQgb24gZml0XG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgcm93czogdW5kZWZpbmVkLCAvLyBmb3JjZSBudW0gb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICAgIGNvbHVtbnM6IHVuZGVmaW5lZCwgLy8gZm9yY2UgbnVtIG9mIGNvbHMgaW4gdGhlIGdyaWRcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24oIG5vZGUgKXt9LCAvLyByZXR1cm5zIHsgcm93LCBjb2wgfSBmb3IgZWxlbWVudFxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBHcmlkTGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgR3JpZExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIFxuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgXG4gICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgIH0gKTtcblxuICAgIGlmKCBiYi5oID09PSAwIHx8IGJiLncgPT09IDApe1xuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB7IHg6IGJiLngxLCB5OiBiYi55MSB9O1xuICAgICAgfSk7XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgXG4gICAgICAvLyB3aWR0aC9oZWlnaHQgKiBzcGxpdHNeMiA9IGNlbGxzIHdoZXJlIHNwbGl0cyBpcyBudW1iZXIgb2YgdGltZXMgdG8gc3BsaXQgd2lkdGhcbiAgICAgIHZhciBjZWxscyA9IG5vZGVzLnNpemUoKTtcbiAgICAgIHZhciBzcGxpdHMgPSBNYXRoLnNxcnQoIGNlbGxzICogYmIuaC9iYi53ICk7XG4gICAgICB2YXIgcm93cyA9IE1hdGgucm91bmQoIHNwbGl0cyApO1xuICAgICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKCBiYi53L2JiLmggKiBzcGxpdHMgKTtcblxuICAgICAgdmFyIHNtYWxsID0gZnVuY3Rpb24odmFsKXtcbiAgICAgICAgaWYoIHZhbCA9PSBudWxsICl7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgICAgICBpZiggbWluID09IHJvd3MgKXtcbiAgICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICB2YXIgbGFyZ2UgPSBmdW5jdGlvbih2YWwpe1xuICAgICAgICBpZiggdmFsID09IG51bGwgKXtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgICAgIGlmKCBtYXggPT0gcm93cyApe1xuICAgICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIGlmIHJvd3Mgb3IgY29sdW1ucyB3ZXJlIHNldCBpbiBvcHRpb25zLCB1c2UgdGhvc2UgdmFsdWVzXG4gICAgICBpZiggb3B0aW9ucy5yb3dzICE9IG51bGwgJiYgb3B0aW9ucy5jb2x1bW5zICE9IG51bGwgKXtcbiAgICAgICAgcm93cyA9IG9wdGlvbnMucm93cztcbiAgICAgICAgY29scyA9IG9wdGlvbnMuY29sdW1ucztcbiAgICAgIH0gZWxzZSBpZiggb3B0aW9ucy5yb3dzICE9IG51bGwgJiYgb3B0aW9ucy5jb2x1bW5zID09IG51bGwgKXtcbiAgICAgICAgcm93cyA9IG9wdGlvbnMucm93cztcbiAgICAgICAgY29scyA9IE1hdGguY2VpbCggY2VsbHMgLyByb3dzICk7XG4gICAgICB9IGVsc2UgaWYoIG9wdGlvbnMucm93cyA9PSBudWxsICYmIG9wdGlvbnMuY29sdW1ucyAhPSBudWxsICl7XG4gICAgICAgIGNvbHMgPSBvcHRpb25zLmNvbHVtbnM7XG4gICAgICAgIHJvd3MgPSBNYXRoLmNlaWwoIGNlbGxzIC8gY29scyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcbiAgICAgIFxuICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHVwLCBzZWUgaWYgd2UgY2FuIHJlZHVjZSByb3dzIG9yIGNvbHVtbnNcbiAgICAgIGVsc2UgaWYoIGNvbHMgKiByb3dzID4gY2VsbHMgKXtcbiAgICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgICAgdmFyIGxnID0gbGFyZ2UoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuICAgICAgICBpZiggKHNtIC0gMSkgKiBsZyA+PSBjZWxscyApe1xuICAgICAgICAgIHNtYWxsKHNtIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiggKGxnIC0gMSkgKiBzbSA+PSBjZWxscyApe1xuICAgICAgICAgIGxhcmdlKGxnIC0gMSk7XG4gICAgICAgIH0gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBcbiAgICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHRvbyBsb3csIGFkZCByb3dzIG9yIGNvbHVtbnNcbiAgICAgICAgd2hpbGUoIGNvbHMgKiByb3dzIDwgY2VsbHMgKXtcbiAgICAgICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdHJ5IHRvIGFkZCB0byBsYXJnZXIgc2lkZSBmaXJzdCAoYWRkcyBsZXNzIGluIG11bHRpcGxpY2F0aW9uKVxuICAgICAgICAgIGlmKCAobGcgKyAxKSAqIHNtID49IGNlbGxzICl7XG4gICAgICAgICAgICBsYXJnZShsZyArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbWFsbChzbSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgY2VsbFdpZHRoID0gYmIudyAvIGNvbHM7XG4gICAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgICBpZiggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIHcgPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICB2YXIgaCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgICAgIGNlbGxXaWR0aCA9IE1hdGgubWF4KCBjZWxsV2lkdGgsIHcgKTtcbiAgICAgICAgICBjZWxsSGVpZ2h0ID0gTWF0aC5tYXgoIGNlbGxIZWlnaHQsIGggKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgY2VsbFVzZWQgPSB7fTsgLy8gZS5nLiAnYy0wLTInID0+IHRydWVcbiAgICAgIFxuICAgICAgdmFyIHVzZWQgPSBmdW5jdGlvbihyb3csIGNvbCl7XG4gICAgICAgIHJldHVybiBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHZhciB1c2UgPSBmdW5jdGlvbihyb3csIGNvbCl7XG4gICAgICAgIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG4gICAgICB2YXIgcm93ID0gMDtcbiAgICAgIHZhciBjb2wgPSAwO1xuICAgICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgY29sKys7XG4gICAgICAgIGlmKCBjb2wgPj0gY29scyApe1xuICAgICAgICAgIGNvbCA9IDA7XG4gICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuICAgICAgdmFyIGlkMm1hblBvcyA9IHt9O1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcmNQb3MgPSBvcHRpb25zLnBvc2l0aW9uKCBub2RlICk7XG5cbiAgICAgICAgaWYoIHJjUG9zICYmIChyY1Bvcy5yb3cgIT09IHVuZGVmaW5lZCB8fCByY1Bvcy5jb2wgIT09IHVuZGVmaW5lZCkgKXsgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHJvdyBvciBjb2wgZGVmJ2RcbiAgICAgICAgICB2YXIgcG9zID0ge1xuICAgICAgICAgICAgcm93OiByY1Bvcy5yb3csXG4gICAgICAgICAgICBjb2w6IHJjUG9zLmNvbFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiggcG9zLmNvbCA9PT0gdW5kZWZpbmVkICl7IC8vIGZpbmQgdW51c2VkIGNvbFxuICAgICAgICAgICAgcG9zLmNvbCA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlKCB1c2VkKHBvcy5yb3csIHBvcy5jb2wpICl7XG4gICAgICAgICAgICAgIHBvcy5jb2wrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoIHBvcy5yb3cgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICAgIHBvcy5yb3cgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSggdXNlZChwb3Mucm93LCBwb3MuY29sKSApe1xuICAgICAgICAgICAgICBwb3Mucm93Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWQybWFuUG9zWyBub2RlLmlkKCkgXSA9IHBvcztcbiAgICAgICAgICB1c2UoIHBvcy5yb3csIHBvcy5jb2wgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgIGlmKCBlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNGdWxsQXV0b1BhcmVudCgpICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgYSBtYW51YWwgcG9zaXRpb24gc2V0XG4gICAgICAgIHZhciByY1BvcyA9IGlkMm1hblBvc1sgZWxlbWVudC5pZCgpIF07XG4gICAgICAgIGlmKCByY1BvcyApe1xuICAgICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGgvMiArIGJiLngxO1xuICAgICAgICAgIHkgPSByY1Bvcy5yb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodC8yICsgYmIueTE7XG4gICAgICAgIFxuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2Ugc2V0IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgXG4gICAgICAgICAgd2hpbGUoIHVzZWQocm93LCBjb2wpICl7XG4gICAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHggPSBjb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGgvMiArIGJiLngxO1xuICAgICAgICAgIHkgPSByb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodC8yICsgYmIueTE7XG4gICAgICAgICAgdXNlKCByb3csIGNvbCApO1xuICAgICAgICAgIFxuICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgXG4gICAgICB9O1xuXG4gICAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIFxuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdncmlkJywgR3JpZExheW91dCk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIHJlYWR5OiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogZnVuY3Rpb24oKXt9IC8vIG9uIGxheW91dHN0b3BcbiAgfTtcblxuICAvLyBjb25zdHJ1Y3RvclxuICAvLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAgZnVuY3Rpb24gTnVsbExheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7IFxuICB9XG5cbiAgLy8gcnVucyB0aGUgbGF5b3V0XG4gIE51bGxMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIGVsZW1lbnRzIHRvIGNvbnNpZGVyIGluIHRoZSBsYXlvdXRcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcblxuICAgIC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgICB2YXIgY3kgPSBvcHRpb25zLmN5OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIGxheW91dC50cmlnZ2VyKCdsYXlvdXRzdGFydCcpO1xuXG4gICAgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gICAgZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIHRyaWdnZXIgbGF5b3V0cmVhZHkgd2hlbiBlYWNoIG5vZGUgaGFzIGhhZCBpdHMgcG9zaXRpb24gc2V0IGF0IGxlYXN0IG9uY2VcbiAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgIGxheW91dC50cmlnZ2VyKCdsYXlvdXRyZWFkeScpO1xuXG4gICAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICBsYXlvdXQudHJpZ2dlcignbGF5b3V0c3RvcCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gIE51bGxMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIHJlZ2lzdGVyIHRoZSBsYXlvdXRcbiAgJCQoJ2xheW91dCcsICdudWxsJywgTnVsbExheW91dCk7XG5cbn0pKGN5dG9zY2FwZSk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIHBvc2l0aW9uczogdW5kZWZpbmVkLCAvLyBtYXAgb2YgKG5vZGUgaWQpID0+IChwb3NpdGlvbiBvYmopOyBvciBmdW5jdGlvbihub2RlKXsgcmV0dXJuIHNvbVBvczsgfVxuICAgIHpvb206IHVuZGVmaW5lZCwgLy8gdGhlIHpvb20gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICAgIHBhbjogdW5kZWZpbmVkLCAvLyB0aGUgcGFuIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIFByZXNldExheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIFByZXNldExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgICB2YXIgcG9zSXNGbiA9ICQkLmlzLmZuKCBvcHRpb25zLnBvc2l0aW9ucyApO1xuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSl7XG4gICAgICBpZiggb3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYoIHBvc0lzRm4gKXtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucG9zaXRpb25zLmFwcGx5KCBub2RlLCBbIG5vZGUgXSApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcblxuICAgICAgaWYoIHBvcyA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBcbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24oaSwgbm9kZSl7XG4gICAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlKTtcbiAgICAgIFxuICAgICAgaWYoIG5vZGUubG9ja2VkKCkgfHwgcG9zaXRpb24gPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9KTtcbiAgICAgICAgXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ3ByZXNldCcsIFByZXNldExheW91dCk7XG4gIFxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIGZpdCBwYWRkaW5nXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIFJhbmRvbUxheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIFJhbmRvbUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICBcbiAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgfSApO1xuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKCBpLCBub2RlICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSArIE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBiYi53ICksXG4gICAgICAgIHk6IGJiLnkxICsgTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGJiLmggKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgLy8gcmVnaXN0ZXIgdGhlIGxheW91dFxuICAkJChcbiAgICAnbGF5b3V0JywgLy8gd2UncmUgcmVnaXN0ZXJpbmcgYSBsYXlvdXRcbiAgICAncmFuZG9tJywgLy8gdGhlIGxheW91dCBuYW1lXG4gICAgUmFuZG9tTGF5b3V0IC8vIHRoZSBsYXlvdXQgcHJvdG90eXBlXG4gICk7XG4gIFxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBhbmltYXRlOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHNob3cgdGhlIGxheW91dCBhcyBpdCdzIHJ1bm5pbmdcbiAgICBtYXhTaW11bGF0aW9uVGltZTogNDAwMCwgLy8gbWF4IGxlbmd0aCBpbiBtcyB0byBydW4gdGhlIGxheW91dFxuICAgIHVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZzogZmFsc2UsIC8vIHNvIHlvdSBjYW4ndCBkcmFnIG5vZGVzIGR1cmluZyBsYXlvdXRcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBvbiBmaXRcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICByYW5kb206IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHVzZSByYW5kb20gaW5pdGlhbCBwb3NpdGlvbnNcbiAgICBpbmZpbml0ZTogZmFsc2UsIC8vIG92ZXJyaWRlcyBhbGwgb3RoZXIgb3B0aW9ucyBmb3IgYSBmb3JjZXMtYWxsLXRoZS10aW1lIG1vZGVcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuXG4gICAgLy8gc3ByaW5neSBmb3JjZXNcbiAgICBzdGlmZm5lc3M6IDQwMCxcbiAgICByZXB1bHNpb246IDQwMCxcbiAgICBkYW1waW5nOiAwLjVcbiAgfTtcblxuICBmdW5jdGlvbiBTcHJpbmd5TGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgU3ByaW5neUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAkJC51dGlsLnJlcXVpcmUoJ1NwcmluZ3knLCBmdW5jdGlvbihTcHJpbmd5KXtcblxuICAgICAgdmFyIHNpbVVwZGF0aW5nUG9zID0gZmFsc2U7XG5cbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgXG4gICAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcbiAgIFxuICAgICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgICB9ICk7XG4gICAgICBcbiAgICAgIC8vIG1ha2UgYSBuZXcgZ3JhcGhcbiAgICAgIHZhciBncmFwaCA9IG5ldyBTcHJpbmd5LkdyYXBoKCk7XG5cbiAgICAgIC8vIG1ha2Ugc29tZSBub2Rlc1xuICAgICAgbm9kZXMuZWFjaChmdW5jdGlvbihpLCBub2RlKXtcbiAgICAgICAgbm9kZS5zY3JhdGNoKCdzcHJpbmd5Jywge1xuICAgICAgICAgIG1vZGVsOiBncmFwaC5uZXdOb2RlKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG5vZGVcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBjb25uZWN0IHRoZW0gd2l0aCBlZGdlc1xuICAgICAgZWRnZXMuZWFjaChmdW5jdGlvbihpLCBlZGdlKXtcbiAgICAgICAgdmFyIGZkU3JjID0gZWRnZS5zb3VyY2UoKS5zY3JhdGNoKCdzcHJpbmd5JykubW9kZWw7XG4gICAgICAgIHZhciBmZFRndCA9IGVkZ2UudGFyZ2V0KCkuc2NyYXRjaCgnc3ByaW5neScpLm1vZGVsO1xuICAgICAgICBcbiAgICAgICAgZWRnZS5zY3JhdGNoKCdzcHJpbmd5Jywge1xuICAgICAgICAgIG1vZGVsOiBncmFwaC5uZXdFZGdlKGZkU3JjLCBmZFRndCwge1xuICAgICAgICAgICAgZWxlbWVudDogZWRnZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHZhciBzaW0gPSB3aW5kb3cuc2ltID0gbmV3IFNwcmluZ3kuTGF5b3V0LkZvcmNlRGlyZWN0ZWQoZ3JhcGgsIG9wdGlvbnMuc3RpZmZuZXNzLCBvcHRpb25zLnJlcHVsc2lvbiwgb3B0aW9ucy5kYW1waW5nKTtcblxuICAgICAgaWYoIG9wdGlvbnMuaW5maW5pdGUgKXtcbiAgICAgICAgc2ltLm1pbkVuZXJneVRocmVzaG9sZCA9IC1JbmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRCQiA9IHNpbS5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgLy8gdmFyIHRhcmdldEJCID0ge2JvdHRvbWxlZnQ6IG5ldyBTcHJpbmd5LlZlY3RvcigtMiwgLTIpLCB0b3ByaWdodDogbmV3IFNwcmluZ3kuVmVjdG9yKDIsIDIpfTtcbiAgICAgIFxuICAgICAgLy8gY29udmVydCB0by9mcm9tIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgdmFyIHRvU2NyZWVuID0gZnVuY3Rpb24ocCkge1xuICAgICAgICBjdXJyZW50QkIgPSBzaW0uZ2V0Qm91bmRpbmdCb3goKTtcblxuICAgICAgICB2YXIgc2l6ZSA9IGN1cnJlbnRCQi50b3ByaWdodC5zdWJ0cmFjdChjdXJyZW50QkIuYm90dG9tbGVmdCk7XG4gICAgICAgIHZhciBzeCA9IHAuc3VidHJhY3QoY3VycmVudEJCLmJvdHRvbWxlZnQpLmRpdmlkZShzaXplLngpLnggKiBiYi53ICsgYmIueDE7XG4gICAgICAgIHZhciBzeSA9IHAuc3VidHJhY3QoY3VycmVudEJCLmJvdHRvbWxlZnQpLmRpdmlkZShzaXplLnkpLnkgKiBiYi5oICsgYmIueDE7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpbmd5LlZlY3RvcihzeCwgc3kpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGZyb21TY3JlZW4gPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIGN1cnJlbnRCQiA9IHNpbS5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIHZhciBzaXplID0gY3VycmVudEJCLnRvcHJpZ2h0LnN1YnRyYWN0KGN1cnJlbnRCQi5ib3R0b21sZWZ0KTtcbiAgICAgICAgdmFyIHB4ID0gKChzLnggLSBiYi54MSkgLyBiYi53KSAqIHNpemUueCArIGN1cnJlbnRCQi5ib3R0b21sZWZ0Lng7XG4gICAgICAgIHZhciBweSA9ICgocy55IC0gYmIueTEpIC8gYmIuaCkgKiBzaXplLnkgKyBjdXJyZW50QkIuYm90dG9tbGVmdC55O1xuXG4gICAgICAgIHJldHVybiBuZXcgU3ByaW5neS5WZWN0b3IocHgsIHB5KTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHZhciBtb3ZlZE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgXG4gICAgICB2YXIgbnVtTm9kZXMgPSBjeS5ub2RlcygpLnNpemUoKTtcbiAgICAgIHZhciBkcmF3bk5vZGVzID0gMTtcbiAgICAgIHZhciBmZFJlbmRlcmVyID0gbmV3IFNwcmluZ3kuUmVuZGVyZXIoc2ltLFxuICAgICAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgICBpZiggbW92ZWROb2Rlcy5sZW5ndGggPiAwICYmIG9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgICAgICAgc2ltVXBkYXRpbmdQb3MgPSB0cnVlO1xuXG4gICAgICAgICAgICBtb3ZlZE5vZGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuXG4gICAgICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW92ZWROb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcblxuICAgICAgICAgICAgc2ltVXBkYXRpbmdQb3MgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd0VkZ2UoZWRnZSwgcDEsIHAyKSB7XG4gICAgICAgICAgLy8gZHJhdyBhbiBlZGdlXG4gICAgICAgIH0sXG5cbiAgICAgICAgZnVuY3Rpb24gZHJhd05vZGUobm9kZSwgcCkge1xuICAgICAgICAgIHZhciB2ID0gdG9TY3JlZW4ocCk7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBub2RlLmRhdGEuZWxlbWVudDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggIWVsZW1lbnQubG9ja2VkKCkgJiYgIWVsZW1lbnQuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgIGVsZW1lbnQuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogdi54LFxuICAgICAgICAgICAgICAgIHk6IHYueVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBtb3ZlZE5vZGVzLm1lcmdlKGVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3NldExheW91dFBvc2l0aW9uRm9yRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGRyYXduTm9kZXMgPT0gbnVtTm9kZXMgKXtcbiAgICAgICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgICAgIH0gXG4gICAgICAgICAgXG4gICAgICAgICAgZHJhd25Ob2RlcysrO1xuICAgICAgICBcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gc2V0IGluaXRpYWwgbm9kZSBwb2ludHNcbiAgICAgIG5vZGVzLmVhY2goZnVuY3Rpb24oaSwgZWxlKXtcbiAgICAgICAgaWYoICFvcHRpb25zLnJhbmRvbSApe1xuICAgICAgICAgIHNldExheW91dFBvc2l0aW9uRm9yRWxlbWVudChlbGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gdXBkYXRlIG5vZGUgcG9zaXRpb25zIHdoZW4gZHJhZ2dpbmdcbiAgICAgIHZhciBkcmFnSGFuZGxlcjtcbiAgICAgIG5vZGVzLm9uKCdwb3NpdGlvbicsIGRyYWdIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHNpbVVwZGF0aW5nUG9zICl7IHJldHVybjsgfVxuXG4gICAgICAgIHNldExheW91dFBvc2l0aW9uRm9yRWxlbWVudCh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBmdW5jdGlvbiBzZXRMYXlvdXRQb3NpdGlvbkZvckVsZW1lbnQoZWxlbWVudCl7XG4gICAgICAgIHZhciBmZElkID0gZWxlbWVudC5zY3JhdGNoKCdzcHJpbmd5JykubW9kZWwuaWQ7XG4gICAgICAgIHZhciBmZFAgPSBmZFJlbmRlcmVyLmxheW91dC5ub2RlUG9pbnRzW2ZkSWRdLnA7XG4gICAgICAgIHZhciBwb3MgPSBlbGVtZW50LnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBwb3NpdGlvbkluRmQgPSAocG9zLnggIT0gbnVsbCAmJiBwb3MueSAhPSBudWxsKSA/IGZyb21TY3JlZW4oZWxlbWVudC5wb3NpdGlvbigpKSA6IHtcbiAgICAgICAgICB4OiBNYXRoLnJhbmRvbSgpICogNCAtIDIsXG4gICAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIDQgLSAyXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBmZFAueCA9IHBvc2l0aW9uSW5GZC54O1xuICAgICAgICBmZFAueSA9IHBvc2l0aW9uSW5GZC55O1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZ3JhYmJhYmxlTm9kZXMgPSBub2Rlcy5maWx0ZXIoXCI6Z3JhYmJhYmxlXCIpO1xuICAgICAgXG4gICAgICBmdW5jdGlvbiBzdGFydCgpe1xuICAgICAgICAvLyBkaXNhYmxlIGdyYWJiaW5nIGlmIHNvIHNldFxuICAgICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgICBncmFiYmFibGVOb2Rlcy51bmdyYWJpZnkoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZmRSZW5kZXJlci5zdGFydCgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZWxmLnN0b3BTeXN0ZW0gPSBmdW5jdGlvbigpe1xuICAgICAgICBncmFwaC5maWx0ZXJOb2RlcyhmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcmVtb3ZlIGFsbCBub2Rlc1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBvcHRpb25zLnVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZyApe1xuICAgICAgICAgIGdyYWJiYWJsZU5vZGVzLmdyYWJpZnkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG5vZGVzLm9mZignZHJhZyBwb3NpdGlvbicsIGRyYWdIYW5kbGVyKTtcblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICAgIHNlbGYuc3RvcFN5c3RlbSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBzdGFydCgpO1xuICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICl7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBzZWxmLnN0b3AoKTtcbiAgICAgICAgfSwgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSk7XG4gICAgICB9XG5cbiAgICB9KTsgLy8gcmVxdWlyZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgU3ByaW5neUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIHRoaXMuc3RvcFN5c3RlbSAhPSBudWxsICl7XG4gICAgICB0aGlzLnN0b3BTeXN0ZW0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAnc3ByaW5neScsIFNwcmluZ3lMYXlvdXQpO1xuXG4gIFxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgICBcbiAgZnVuY3Rpb24gTnVsbFJlbmRlcmVyKG9wdGlvbnMpe1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgXG4gIE51bGxSZW5kZXJlci5wcm90b3R5cGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oKXtcbiAgfTtcblxuICBOdWxsUmVuZGVyZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gdGhlIG51bGwgcmVuZGVyZXIgZG9lcyBub3RoaW5nXG4gIH07XG4gIFxuICAkJCgncmVuZGVyZXInLCAnbnVsbCcsIE51bGxSZW5kZXJlcik7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUvZGlzdC9jeXRvc2NhcGUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3RcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCBpZiBicm93c2VyIHN1cHBvcnRzIFR5cGVkIEFycmF5cy4gU3VwcG9ydGVkIGJyb3dzZXJzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssXG4gIC8vIENocm9tZSA3KywgU2FmYXJpIDUuMSssIE9wZXJhIDExLjYrLCBpT1MgNC4yKy4gSWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhZGRpbmdcbiAgLy8gcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLCB0aGVuIHRoYXQncyB0aGUgc2FtZSBhcyBubyBgVWludDhBcnJheWAgc3VwcG9ydFxuICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy4gVGhpcyBpcyBhbiBpc3N1ZVxuICAvLyBpbiBGaXJlZm94IDQtMjkuIE5vdyBmaXhlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJlxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nIC8vIENocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBXb3JrYXJvdW5kOiBub2RlJ3MgYmFzZTY0IGltcGxlbWVudGF0aW9uIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBzdHJpbmdzXG4gIC8vIHdoaWxlIGJhc2U2NC1qcyBkb2VzIG5vdC5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JyAmJiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHN1YmplY3QgPSBzdHJpbmd0cmltKHN1YmplY3QpXG4gICAgd2hpbGUgKHN1YmplY3QubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3ViamVjdCA9IHN1YmplY3QgKyAnPSdcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpIC8vIGFzc3VtZSB0aGF0IG9iamVjdCBpcyBhcnJheS1saWtlXG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSlcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdFtpXVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbicgK1xuICAgICAgJ2xpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHRvdGFsTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBfaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyXG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIF91dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gX2FzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kICE9PSB1bmRlZmluZWQpXG4gICAgPyBOdW1iZXIoZW5kKVxuICAgIDogZW5kID0gc2VsZi5sZW5ndGhcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIF91dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gX2FzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBfYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gX2FzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBfaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpKzFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSksICd2YWx1ZSBpcyBub3QgYSBudW1iZXInKVxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuZnVuY3Rpb24gY2xhbXAgKGluZGV4LCBsZW4sIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICBpbmRleCA9IH5+aW5kZXg7ICAvLyBDb2VyY2UgdG8gaW50ZWdlci5cbiAgaWYgKGluZGV4ID49IGxlbikgcmV0dXJuIGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIGluZGV4ICs9IGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGNvZXJjZSAobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aClcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9KShzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKVxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3NcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdFxuICogaXMgbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3RcbiAqIGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQgKHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZzaW50ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlclwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNMRSA/IC0xIDogMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGMsXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApLFxuICAgICAgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzTEUgPyAxIDogLTEsXG4gICAgICBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwO1xuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpO1xuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwO1xuICAgIGUgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKTtcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS07XG4gICAgICBjICo9IDI7XG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrO1xuICAgICAgYyAvPSAyO1xuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDA7XG4gICAgICBlID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gZSArIGVCaWFzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbik7XG4gICAgICBlID0gMDtcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KTtcblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCk7XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4O1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTRcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjJcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjguMic7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XG4gIH07XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuICAvLyBzcGFyc2UgYXJyYXktbGlrZXMgYXMgaWYgdGhleSB3ZXJlIGRlbnNlLlxuICBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XG4gICAgLy8gT3B0aW1pemVkIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIHVzaW5nIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAvLyBpbiB0aGUgbWFpbiBmdW5jdGlvbiB3aWxsIGRlb3B0aW1pemUgdGhlLCBzZWUgIzE5OTEuXG4gICAgZnVuY3Rpb24gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCk7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHZhbHVlIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGtleSA9IF8uZmluZEluZGV4KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gXy5maW5kS2V5KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKGNiKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIHRhcmdldCwgdHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJyAmJiBmcm9tSW5kZXgpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyBmdW5jIDogZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNldCA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBzZXQubGVuZ3RoO1xuICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKDAsIGluZGV4KTtcbiAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gXy5zaHVmZmxlKG9iaikuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbikpO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqKSA/IHBhc3MgOiBmYWlsKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBzdGFydEluZGV4KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdLCBpZHggPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIGxlbmd0aCA9IGlucHV0ICYmIGlucHV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IGNvbXB1dGVkKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHNlZW4sIGNvbXB1dGVkKSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFfLmNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgJ2xlbmd0aCcpLmxlbmd0aCB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IF8ucGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0ICYmIGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5ICYmIGFycmF5Lmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdudW1iZXInKSB7XG4gICAgICBpID0gaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQ7XG4gICAgfSBlbHNlIGlmIChpc1NvcnRlZCAmJiBsZW5ndGgpIHtcbiAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmZpbmRJbmRleChzbGljZS5jYWxsKGFycmF5LCBpKSwgXy5pc05hTik7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgIHZhciBpZHggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgaWYgKHR5cGVvZiBmcm9tID09ICdudW1iZXInKSB7XG4gICAgICBpZHggPSBmcm9tIDwgMCA/IGlkeCArIGZyb20gKyAxIDogTWF0aC5taW4oaWR4LCBmcm9tICsgMSk7XG4gICAgfVxuICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICByZXR1cm4gXy5maW5kTGFzdEluZGV4KHNsaWNlLmNhbGwoYXJyYXksIDAsIGlkeCksIF8uaXNOYU4pO1xuICAgIH1cbiAgICB3aGlsZSAoLS1pZHggPj0gMCkgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgIT0gbnVsbCAmJiBhcnJheS5sZW5ndGg7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZUluZGV4RmluZGVyKDEpO1xuXG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgIGlmICghKF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgYW5kIGluIFNhZmFyaSA4ICgjMTkyOSkuXG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0Jykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIF8ucHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZFxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIGZhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3RbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IGZhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAgICdcXFxcJzogICAgICdcXFxcJyxcbiAgICAnXFxyJzogICAgICdyJyxcbiAgICAnXFxuJzogICAgICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB1bndyYXBwaW5nIHByb3h5IGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XG4gIFxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZVwiKSJdfQ==
