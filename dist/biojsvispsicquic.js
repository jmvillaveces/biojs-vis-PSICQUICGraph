(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
biojsvispsicquic = require('./pGraph.js');
module.exports = biojsvispsicquic;
//Libraries
var psicquic = require('biojs-rest-psicquic');
var cytoscape = require('cytoscape');
var MITab = require('biojs-io-mitab');

//Private members
var _selector = 'body';
var _div = null;

// psicquic vars
var _url = '', _proxy = null, _method = 'query', _params = null, _query='';

var _initSelector = function(selector){
    _div = document.querySelector(selector);
    _div.style.left = 0;
    _div.style.top = 0;
    _div.style.width = '100%';
    _div.style.height = '100%';
    _div.style.position = 'absolute';
};

// Public members
var pGraph = function(){};

pGraph.url = function(_){
    if (!arguments.length)
        return _url;
    _url = _;
    return pGraph;
};

pGraph.proxy = function(_){
    if (!arguments.length)
        return _proxy;
    _proxy = _;
    return pGraph;
};

pGraph.method = function(_){
    if (!arguments.length)
        return _method;
    _method = _;
    return pGraph;
};

pGraph.params = function(_){
    if (!arguments.length)
        return _params;
    _params = _;
    return pGraph;
};

pGraph.query = function(_){
    if (!arguments.length)
        return _query;
    _query = _;
    return pGraph;
};

pGraph.selector = function(_){
    if (!arguments.length)
        return _selector;
    
    _selector = _;
    return pGraph;
};

pGraph.update = function(){
    if(_div === null) _initSelector(_selector);
    
    psicquic.url(_url).params(_params).method(_method).proxy(_proxy).query(_query, function(err, resp, body){
        var parsed = MITab.parse(body);
        console.log(parsed);
    });
};

module.exports = pGraph;
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_2ce66158.js","/")
},{"./pGraph.js":2,"1YiZ5S":18,"biojs-io-mitab":3,"biojs-rest-psicquic":5,"buffer":15,"cytoscape":14}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//Libraries
var psicquic = require('biojs-rest-psicquic');
var cytoscape = require('cytoscape');
var MITab = require('biojs-io-mitab');

//Private members
var _selector = 'body';
var _div = null;

// psicquic vars
var _url = '', _proxy = null, _method = 'query', _params = null, _query='';

var _initSelector = function(selector){
    _div = document.querySelector(selector);
    _div.style.left = 0;
    _div.style.top = 0;
    _div.style.width = '100%';
    _div.style.height = '100%';
    _div.style.position = 'absolute';
};

// Public members
var pGraph = function(){};

pGraph.url = function(_){
    if (!arguments.length)
        return _url;
    _url = _;
    return pGraph;
};

pGraph.proxy = function(_){
    if (!arguments.length)
        return _proxy;
    _proxy = _;
    return pGraph;
};

pGraph.method = function(_){
    if (!arguments.length)
        return _method;
    _method = _;
    return pGraph;
};

pGraph.params = function(_){
    if (!arguments.length)
        return _params;
    _params = _;
    return pGraph;
};

pGraph.query = function(_){
    if (!arguments.length)
        return _query;
    _query = _;
    return pGraph;
};

pGraph.selector = function(_){
    if (!arguments.length)
        return _selector;
    
    _selector = _;
    return pGraph;
};

pGraph.update = function(){
    if(_div === null) _initSelector(_selector);
    
    psicquic.url(_url).params(_params).method(_method).proxy(_proxy).query(_query, function(err, resp, body){
        var parsed = MITab.parse(body);
        console.log(parsed);
    });
};

module.exports = pGraph;
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/pGraph.js","/")
},{"1YiZ5S":18,"biojs-io-mitab":3,"biojs-rest-psicquic":5,"buffer":15,"cytoscape":14}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var _ = require('underscore');

module.exports = MITab = (function() {
     
    var nodes = {}; 
    var links = [];
    var scores = {};
    var textInParenthesis = /\((.*?)\)/;
    var textInQuotes = /\"(.*?)\"/;
    var textInTax = /\:(.*?)\(/;
    
    // Creates a node from identifiers, alternative idenifiers,
    // and taxonomy values
    var _getNode = function(idStr, altIdsStr, taxStr){
        
        var ids = _.map(idStr.split('|'), _mapPub);
        var node = {
            id: ids[0].value,
            ids: ids,
            altIds: _.map(altIdsStr.split('|'), _mapPub),
            taxonomy: _.uniq(_.map(taxStr.split('|'), _mapTaxonomy))
        }
        return node;
    }
    
    // Parses a string and returns an interaction
    var _parse = function(line, i){
        
        if (! _.isString(line)) {
            console.warn('MITab cannot parse line ' + i);
            return {};
        }
        
        var fields = line.split('\t');
        
        if(fields.length < 15) {
            console.warn('MITab cannot parse line ' + i);
            return {};
        }
        
        var nodeA = _getNode(fields[0], fields[2], fields[9]);
        var nodeB = _getNode(fields[1], fields[3], fields[10]);
        
        
        var interaction = {
            source: nodeA.id,
            target: nodeB.id,
            detMethods: _.map(fields[6].split('|'), _mapField),
            firstAuthor: fields[7].split('|'),
            publications: _.map(fields[8].split('|'), _mapPub),
            intTypes: _.map(fields[11].split('|'), _mapField),
            sourceDbs: _.map(fields[12].split('|'), _mapField),
            intIds : _.map(fields[13].split('|'), _mapPub),
            scores: _.map(fields[14].split('|'), _mapScore)
        };
        
        nodes[nodeA.id] = nodeA;
        nodes[nodeB.id] = nodeB;
        
        return interaction;
    }
    
    var _mapScore = function(scoreStr){
        var arr = scoreStr.split(':'), score = {name:arr[0], score:+arr[1]};
        
        _addScore(score);
        return score;
    };
    
    var _mapField = function(fieldStr){
        if(fieldStr.match(textInQuotes) == null || fieldStr.match(textInParenthesis) == null){
            var arr = fieldStr.split(':');
            return {name:arr[0], score:arr[1]};
        }
        return {name:fieldStr.match(textInQuotes)[1], value:fieldStr.match(textInParenthesis)[1]};
    };
    
    var _mapPub = function(pubStr){
        var arr = pubStr.split(':');
        return {name:arr[0], value:arr[1]};
    };
    
    var _mapTaxonomy = function(taxStr){
        if(taxStr != '-'){
            return (taxStr.match(textInTax) == null) ? taxStr.split(':')[1] : taxStr.match(textInTax)[1];
        }
    };
    
    var _addScore = function(score){
        if( !_.isNaN(score.score) && _.isNumber(score.score)){
            if(_.has(scores, score.name)){
                if(scores[score.name].min > score.score) scores[score.name].min = score.score;
                if(scores[score.name].max < score.score) scores[score.name].max = score.score;
            }else{
                scores[score.name] = {name:score.name, min:score.score, max:score.score};
            }
        }
    };
    
    function MITab() {}
    
    MITab.parse = function(text) {
        
        if (! _.isString(text)) {
            throw 'MITab cannot parse ' + typeof text;
            return;
        }
        
        // Initialize variables
        nodes = {}; 
        links = [];
        scores = {};
        
        var lines = text.split('\n');
        
        var interactions = _.reject(_.map(lines, _parse), _.isEmpty);
        var nodeval = _.values(nodes);
        
        return {
            links: interactions,
            nodes: nodeval,
            ids: _.pluck(nodeval, 'id'),
            taxa: _.compact(_.reduce(nodeval, function(memo,n){ return _.union(memo,n.taxonomy)},[])),
            scores: _.values(scores)
        };
    };
    
    return MITab;
})();
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-io-mitab/index.js","/../node_modules/biojs-io-mitab")
},{"1YiZ5S":18,"buffer":15,"underscore":4}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-io-mitab/node_modules/underscore/underscore.js","/../node_modules/biojs-io-mitab/node_modules/underscore")
},{"1YiZ5S":18,"buffer":15}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var xhr = require('nets')

var _url = '', _proxy = null, _method = 'query', _params = null;

//Private members
var _fetch = function(url, callback){
    xhr({
        url: url,
        method: 'GET'
    }, 
    callback)
}

var _eval_params = function(params){
    var str = '';
    if(typeof params === 'string'){
        return params;
    }else if(typeof params === 'object'){
        for(var key in params){
            if (params.hasOwnProperty(key)) str += key+'='+params[key]+'&';
        }
    }
    return str;
}

var _createUrl = function(method, query, params){
    
    var paramsStr = ''; 
    if(params !== null)
        paramsStr = '?'+_eval_params(params);
    
    var url = _url+'/'+method+'/'+query+paramsStr;
    url = url.replace('//'+method, '/'+method)
    
    if(_proxy === null) return url;
    
    return _processProxy(url);
}

var _processProxy = function(url){
    if (typeof _proxy === 'function') return _proxy(url);
    
    if(typeof _proxy === 'string') return _proxy +'?url='+url;
    
    return url;
}

//Public members
var psicquicServer = function(){}
    
psicquicServer.url = function(_){
    if (!arguments.length)
        return _url;
    _url = _;
    return psicquicServer;
};

psicquicServer.proxy = function(_){
    if (!arguments.length)
        return _proxy;
    _proxy = _;
    return psicquicServer;
};

psicquicServer.method = function(_){
    if (!arguments.length)
        return _method;
    _method = _;
    return psicquicServer;
};

psicquicServer.params = function(_){
    if (!arguments.length)
        return _params;
    _params = _;
    return psicquicServer;
};

psicquicServer.query = function(query, callback){
    var url = _createUrl(_method, query, _params);
    _fetch(url, callback);
};

psicquicServer.count = function(query, callback){
    var url = _createUrl(_method, query, {format:'count'});
    _fetch(url, callback);
}

module.exports = psicquicServer;
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/index.js","/../node_modules/biojs-rest-psicquic")
},{"1YiZ5S":18,"buffer":15,"nets":6}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var req = require('request')

module.exports = Nets

function Nets(uri, opts, cb) {
  req(uri, opts, cb)
}
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets")
},{"1YiZ5S":18,"buffer":15,"request":7}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var window = require("global/window")
var once = require("once")
var parseHeaders = require('parse-headers')

var messages = {
    "0": "Internal XMLHttpRequest Error",
    "4": "4xx Client Error",
    "5": "5xx Server Error"
}

var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var key
    var load = options.response ? loadResponse : loadXhr

    if ("json" in options) {
        isJson = true
        headers["Accept"] = "application/json"
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = load
    xhr.onerror = error
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    // hate IE
    xhr.ontimeout = noop
    xhr.open(method, uri, !sync)
                                    //backward compatibility
    if (options.withCredentials || (options.cors && options.withCredentials !== false)) {
        xhr.withCredentials = true
    }

    // Cannot set timeout with sync request
    if (!sync) {
        xhr.timeout = "timeout" in options ? options.timeout : 5000
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr

    function readystatechange() {
        if (xhr.readyState === 4) {
            load()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = null

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === 'text' || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function getStatusCode() {
        return xhr.status === 1223 ? 204 : xhr.status
    }

    // if we're getting a none-ok statusCode, build & return an error
    function errorFromStatusCode(status, body) {
        var error = null
        if (status === 0 || (status >= 400 && status < 600)) {
            var message = (typeof body === "string" ? body : false) ||
                messages[String(status).charAt(0)]
            error = new Error(message)
            error.statusCode = status
        }

        return error
    }

    // will load the data & process the response in a special response object
    function loadResponse() {
        var status = getStatusCode()
        var body = getBody()
        var error = errorFromStatusCode(status, body)
        var response = {
            body: body,
            statusCode: status,
            statusText: xhr.statusText,
            raw: xhr
        }
        if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
            response.headers = parseHeaders(xhr.getAllResponseHeaders())
        } else {
            response.headers = {}
        }

        callback(error, response, response.body)
    }

    // will load the data and add some response properties to the source xhr
    // and then respond with that
    function loadXhr() {
        var status = getStatusCode()
        var error = errorFromStatusCode(status)

        xhr.status = xhr.statusCode = status
        xhr.body = getBody()
        xhr.headers = parseHeaders(xhr.getAllResponseHeaders())

        callback(error, xhr, xhr.body)
    }

    function error(evt) {
        callback(evt, xhr)
    }
}


function noop() {}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr")
},{"1YiZ5S":18,"buffer":15,"global/window":8,"once":9,"parse-headers":13}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
if (typeof window !== "undefined") {
    module.exports = window;
} else if (typeof global !== "undefined") {
    module.exports = global;
} else if (typeof self !== "undefined"){
    module.exports = self;
} else {
    module.exports = {};
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/global/window.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/global")
},{"1YiZ5S":18,"buffer":15}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/once/once.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/once")
},{"1YiZ5S":18,"buffer":15}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/for-each/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/for-each")
},{"1YiZ5S":18,"buffer":15,"is-function":11}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/for-each/node_modules/is-function/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/for-each/node_modules/is-function")
},{"1YiZ5S":18,"buffer":15}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/trim/index.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/node_modules/trim")
},{"1YiZ5S":18,"buffer":15}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var trim = require('trim')
  , forEach = require('for-each')
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')
          , key = trim(row.slice(0, index)).toLowerCase()
          , value = trim(row.slice(index + 1))

        if (typeof(result[key]) === 'undefined') {
          result[key] = value
        } else if (isArray(result[key])) {
          result[key].push(value)
        } else {
          result[key] = [ result[key], value ]
        }
      }
  )

  return result
}
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers/parse-headers.js","/../node_modules/biojs-rest-psicquic/node_modules/nets/node_modules/xhr/node_modules/parse-headers")
},{"1YiZ5S":18,"buffer":15,"for-each":10,"trim":12}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * This file is part of Cytoscape.js 2.3.9.
 * 
 * Cytoscape.js is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 * 
 * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License along with
 * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.
 */
 

// this is put as a global var in the browser
// or it's just a global to this module if commonjs

var cytoscape;

(function(window){ 'use strict';

  // the object iteself is a function that init's an instance of cytoscape

  var $$ = cytoscape = function(){ // jshint ignore:line
    return cytoscape.init.apply(cytoscape, arguments);
  };

  $$.version = '2.3.9';
  
  // allow functional access to cytoscape.js
  // e.g. var cyto = $.cytoscape({ selector: "#foo", ... });
  //      var nodes = cyto.nodes();
  $$.init = function( options ){
    
    // if no options specified, use default
    if( options === undefined ){
      options = {};
    }

    // create instance
    if( $$.is.plainObject( options ) ){
      return new $$.Core( options );
    } 
    
    // allow for registration of extensions
    // e.g. $.cytoscape('renderer', 'svg', SvgRenderer);
    // e.g. $.cytoscape('renderer', 'svg', 'nodeshape', 'ellipse', SvgEllipseNodeShape);
    // e.g. $.cytoscape('core', 'doSomething', function(){ /* doSomething code */ });
    // e.g. $.cytoscape('collection', 'doSomething', function(){ /* doSomething code */ });
    else if( $$.is.string( options ) ) {
      return $$.extension.apply($$.extension, arguments);
    }
  };

  // define the function namespace here, since it has members in many places
  $$.fn = {};

  if( typeof module !== 'undefined' && module.exports ){ // expose as a commonjs module
    module.exports = cytoscape;
  }

  if( typeof define !== 'undefined' && define.amd ){ // expose as an amd/requirejs module
    define('cytoscape', function(){
      return cytoscape;
    });
  }

  // make sure we always register in the window just in case (e.g. w/ derbyjs)
  if( window ){
    window.cytoscape = cytoscape;
  }
  
})( typeof window === 'undefined' ? null : window );

// type testing utility functions

;(function($$, window){ 'use strict';

  $$.is = {
    defined: function(obj){
      return obj != null; // not undefined or null
    },

    string: function(obj){
      return obj != null && typeof obj == typeof '';
    },
    
    fn: function(obj){
      return obj != null && typeof obj === typeof function(){};
    },
    
    array: function(obj){
      return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
    },
    
    plainObject: function(obj){
      return obj != null && typeof obj === typeof {} && !$$.is.array(obj) && obj.constructor === Object;
    },
    
    number: function(obj){
      return obj != null && typeof obj === typeof 1 && !isNaN(obj);
    },

    integer: function( obj ){
      return $$.is.number(obj) && Math.floor(obj) === obj;
    },
    
    color: function(obj){
      return obj != null && typeof obj === typeof '' && $.Color(obj).toString() !== '';
    },
    
    bool: function(obj){
      return obj != null && typeof obj === typeof true;
    },
    
    elementOrCollection: function(obj){
      return $$.is.element(obj) || $$.is.collection(obj);
    },
    
    element: function(obj){
      return obj instanceof $$.Element && obj._private.single;
    },
    
    collection: function(obj){
      return obj instanceof $$.Collection && !obj._private.single;
    },
    
    core: function(obj){
      return obj instanceof $$.Core;
    },

    style: function(obj){
      return obj instanceof $$.Style;
    },

    stylesheet: function(obj){
      return obj instanceof $$.Stylesheet;
    },

    event: function(obj){
      return obj instanceof $$.Event;
    },

    emptyString: function(obj){
      if( !obj ){ // null is empty
        return true; 
      } else if( $$.is.string(obj) ){
        if( obj === '' || obj.match(/^\s+$/) ){
          return true; // empty string is empty
        }
      }
      
      return false; // otherwise, we don't know what we've got
    },
    
    nonemptyString: function(obj){
      if( obj && $$.is.string(obj) && obj !== '' && !obj.match(/^\s+$/) ){
        return true;
      }

      return false;
    },

    domElement: function(obj){
      if( typeof HTMLElement === 'undefined' ){
        return false; // we're not in a browser so it doesn't matter
      } else {
        return obj instanceof HTMLElement;
      }
    },

    boundingBox: function(obj){
      return $$.is.plainObject(obj) && 
        $$.is.number(obj.x1) && $$.is.number(obj.x2) &&
        $$.is.number(obj.y1) && $$.is.number(obj.y2)
      ;
    },

    touch: function(){
      return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
    },

    gecko: function(){
      return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);
    },

    webkit: function(){
      return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);
    },

    chromium: function(){
      return typeof chrome !== 'undefined';
    },

    khtml: function(){
      return navigator.vendor.match(/kde/i); // TODO probably a better way to detect this...
    },

    khtmlEtc: function(){
      return $$.is.khtml() || $$.is.webkit() || $$.is.blink();
    },

    trident: function(){
       return typeof ActiveXObject !== 'undefined' || /*@cc_on!@*/false;
    },

    windows: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Win/i);
    },

    mac: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Mac/i);
    },

    linux: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Linux/i);
    },

    unix: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/X11/i);
    }
  };  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  // utility functions only for internal use

  $$.util = {

    // the jquery extend() function
    // NB: modified to use $$.is etc since we can't use jquery functions
    extend: function() {
      var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

      // Handle a deep copy situation
      if ( typeof target === 'boolean' ) {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
      }

      // Handle case when target is a string or something (possible in deep copy)
      if ( typeof target !== 'object' && !$$.is.fn(target) ) {
        target = {};
      }

      // extend jQuery itself if only one argument is passed
      if ( length === i ) {
        target = this;
        --i;
      }

      for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
          // Extend the base object
          for ( name in options ) {
            src = target[ name ];
            copy = options[ name ];

            // Prevent never-ending loop
            if ( target === copy ) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            if ( deep && copy && ( $$.is.plainObject(copy) || (copyIsArray = $$.is.array(copy)) ) ) {
              if ( copyIsArray ) {
                copyIsArray = false;
                clone = src && $$.is.array(src) ? src : [];

              } else {
                clone = src && $$.is.plainObject(src) ? src : {};
              }

              // Never move original objects, clone them
              target[ name ] = $$.util.extend( deep, clone, copy );

            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
              target[ name ] = copy;
            }
          }
        }
      }

      // Return the modified object
      return target;
    },

    // require that pulls in module from commonjs, amd, or window (falling back until found)
    require: function( name, callback, options ){
      var ret;
      options = $$.util.extend({
        msgIfNotFound: true
      }, options);

      var done = false;
      var fulfil = function( ret ){
        done = true;
        callback( ret );
      };

      var checkWindow = function( next ){
        if( window ){ // detected browser/window env
          ret = window[ name ];
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckWindowDone = function(){
        if( !done ){
          checkCommonJs( onCheckCommonJsDone );
        }
      };

      var checkCommonJs = function( next ){
        if( typeof module !== 'undefined' && module.exports && require ){ // detected commonjs env
          ret = require( name ); // regular require
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckCommonJsDone = function(){
        if( !done ){
          checkAmd( onCheckAmdDone );
        }
      };

      var checkAmd = function( next ){
        if( typeof define !== 'undefined' && define.amd && require ){ // detected amd env w/ defined module
          require([ name ], function( nameImpl ){
            ret = nameImpl;
            
            if( ret !== undefined ){ fulfil(ret); }
            if( next ){ next(); }
          });
        }
      };
      var onCheckAmdDone = function(){
        if( !done && options.msgIfNotFound ){
          $$.util.error('Cytoscape.js tried to pull in dependency `' + name + '` but no module (i.e. CommonJS, AMD, or window) was found');
        }
      };

      // kick off 1st check: window
      checkWindow( onCheckWindowDone );

    },

    // multiple requires in one callback
    requires: function( names, callback ){
      var impls = [];
      var gotImpl = [];

      var checkDone = function(){
        for( var i = 0; i < names.length; i++ ){ // check have all impls
          if( !gotImpl[i] ){ return; }
        }

        // otherwise, all got all impls => done
        callback.apply( callback, impls ); 
      };

      for( var i = 0; i < names.length; i++ ){ (function(){ // w/scope
        var name = names[i];
        var index = i;

        $$.util.require(name, function(impl){
          impls[index] = impl;
          gotImpl[index] = true;

          checkDone();
        });
      })(); }
    },

    // ported lodash throttle function
    throttle: function(func, wait, options) {
      var leading = true,
          trailing = true;

      if (options === false) {
        leading = false;
      } else if ($$.is.plainObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      options = options || {};
      options.leading = leading;
      options.maxWait = wait;
      options.trailing = trailing;

      return $$.util.debounce(func, wait, options);
    },

    now: function(){
      return +new Date();
    },

    // ported lodash debounce function
    debounce: function(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!$$.is.fn(func)) {
        return;
      }
      wait = Math.max(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if ($$.is.plainObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - ($$.util.now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = $$.util.now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = $$.util.now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = $$.util.now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    },

    error: function( msg ){
      if( console ){
        if( console.error ){
          console.error.apply( console, arguments );
        } else if( console.log ){
          console.log.apply( console, arguments );
        } else {
          throw msg;
        }
      } else {
        throw msg;
      }
    },    

    clone: function( obj ){
      var target = {};
      for (var i in obj) {
        if ( obj.hasOwnProperty(i) ) { // TODO is this hasOwnProperty() call necessary for our use?
          target[i] = obj[i];
        }
      }
      return target;
    },

    // gets a shallow copy of the argument
    copy: function( obj ){
      if( obj == null ){
        return obj;
      } if( $$.is.array(obj) ){
        return obj.slice();
      } else if( $$.is.plainObject(obj) ){
        return $$.util.clone( obj );
      } else {
        return obj;
      }
    },
    
    // makes a full bb (x1, y1, x2, y2, w, h) from implicit params
    makeBoundingBox: function( bb ){
      if( bb.x1 != null && bb.y1 != null ){
        if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x2,
            y2: bb.y2,
            w: bb.x2 - bb.x1,
            h: bb.y2 - bb.y1
          };
        } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x1 + bb.w,
            y2: bb.y1 + bb.h,
            w: bb.w,
            h: bb.h
          };
        }
      } 
    },

    // has anything been set in the map
    mapEmpty: function( map ){
      var empty = true;

      if( map != null ){
        for(var i in map){ // jshint ignore:line
          empty = false;
          break;
        }
      }

      return empty;
    },

    // pushes to the array at the end of a map (map may not be built)
    pushMap: function( options ){
      var array = $$.util.getMap(options);

      if( array == null ){ // if empty, put initial array
        $$.util.setMap( $.extend({}, options, {
          value: [ options.value ]
        }) );
      } else {
        array.push( options.value );
      }
    },

    // sets the value in a map (map may not be built)
    setMap: function( options ){
      var obj = options.map;
      var key;
      var keys = options.keys;
      var l = keys.length;

      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to set map with object key');
        }

        if( i < keys.length - 1 ){
          
          // extend the map if necessary
          if( obj[key] == null ){
            obj[key] = {};
          }
          
          obj = obj[key];
        } else {
          // set the value
          obj[key] = options.value;
        }
      }
    },
    
    // gets the value in a map even if it's not built in places
    getMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to get map with object key');
        }

        obj = obj[key];
        
        if( obj == null ){
          return obj;
        }
      }
      
      return obj;
    },

    // deletes the entry in the map
    deleteMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      var keepChildren = options.keepChildren;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to delete map with object key');
        }

        var lastKey = i === options.keys.length - 1;
        if( lastKey ){
          
          if( keepChildren ){ // then only delete child fields not in keepChildren
            for( var child in obj ){
              if( !keepChildren[child] ){
                obj[child] = undefined;
              }
            }
          } else {
            obj[key] = undefined;
          }

        } else {
          obj = obj[key];
        }
      }
    },
    
    capitalize: function(str){
      if( $$.is.emptyString(str) ){
        return str;
      }
      
      return str.charAt(0).toUpperCase() + str.substring(1);
    },

    camel2dash: function( str ){
      var ret = [];

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var chLowerCase = ch.toLowerCase();
        var isUpperCase = ch !== chLowerCase;

        if( isUpperCase ){
          ret.push( '-' );
          ret.push( chLowerCase );
        } else {
          ret.push( ch );
        }
      }

      var noUpperCases = ret.length === str.length;
      if( noUpperCases ){ return str; } // cheaper than .join()

      return ret.join('');
    },

    dash2camel: function( str ){
      var ret = [];
      var nextIsUpper = false;

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var isDash = ch === '-';

        if( isDash ){
          nextIsUpper = true;
        } else {
          if( nextIsUpper ){
            ret.push( ch.toUpperCase() );
          } else {
            ret.push( ch );
          }

          nextIsUpper = false;
        }
      }

      return ret.join('');
    },

    // strip spaces from beginning of string and end of string
    trim: function( str ){
      var first, last;

      // find first non-space char
      for( first = 0; first < str.length && str[first] === ' '; first++ ){}

      // find last non-space char
      for( last = str.length - 1; last > first && str[last] === ' '; last-- ){}

      return str.substring(first, last + 1);
    },

    // get [r, g, b] from #abc or #aabbcc
    hex2tuple: function( hex ){
      if( !(hex.length === 4 || hex.length === 7) || hex[0] !== "#" ){ return; }

      var shortHex = hex.length === 4;
      var r, g, b;
      var base = 16;

      if( shortHex ){
        r = parseInt( hex[1] + hex[1], base );
        g = parseInt( hex[2] + hex[2], base );
        b = parseInt( hex[3] + hex[3], base );
      } else {
        r = parseInt( hex[1] + hex[2], base );
        g = parseInt( hex[3] + hex[4], base );
        b = parseInt( hex[5] + hex[6], base );
      }

      return [r, g, b];
    },

    // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
    hsl2tuple: function( hsl ){
      var ret;
      var h, s, l, a, r, g, b;
      function hue2rgb(p, q, t){
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      }

      var m = new RegExp("^" + $$.util.regex.hsla + "$").exec(hsl);
      if( m ){

        // get hue
        h = parseInt( m[1] ); 
        if( h < 0 ){
          h = ( 360 - (-1*h % 360) ) % 360;
        } else if( h > 360 ){
          h = h % 360;
        }
        h /= 360; // normalise on [0, 1]

        s = parseFloat( m[2] );
        if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
        s = s/100; // normalise on [0, 1]

        l = parseFloat( m[3] );
        if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
        l = l/100; // normalise on [0, 1]

        a = m[4];
        if( a !== undefined ){
          a = parseFloat( a );

          if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
        }

        // now, convert to rgb
        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
        if( s === 0 ){
          r = g = b = Math.round(l * 255); // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );
          g = Math.round( 255 * hue2rgb(p, q, h) );
          b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );
        }

        ret = [r, g, b, a];
      }

      return ret;
    },

    // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
    rgb2tuple: function( rgb ){
      var ret;

      var m = new RegExp("^" + $$.util.regex.rgba + "$").exec(rgb);
      if( m ){
        ret = [];

        var isPct = [];
        for( var i = 1; i <= 3; i++ ){
          var channel = m[i];

          if( channel[ channel.length - 1 ] === "%" ){
            isPct[i] = true;
          }
          channel = parseFloat( channel );

          if( isPct[i] ){
            channel = channel/100 * 255; // normalise to [0, 255]
          }

          if( channel < 0 || channel > 255 ){ return; } // invalid channel value

          ret.push( Math.floor(channel) );
        }

        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
        var allArePct = isPct[1] && isPct[2] && isPct[3];
        if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

        var alpha = m[4];
        if( alpha !== undefined ){
          alpha = parseFloat( alpha );

          if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

          ret.push( alpha );
        }
      }

      return ret;
    },

    colorname2tuple: function( color ){
      return $$.util.colors[ color.toLowerCase() ];
    },

    color2tuple: function( color ){
      return ( $$.is.array(color) ? color : null ) 
        || $$.util.colorname2tuple(color)
        || $$.util.hex2tuple(color)
        || $$.util.rgb2tuple(color)
        || $$.util.hsl2tuple(color);
    },

    tuple2hex: function( tuple ){
      var r = tuple[0];
      var g = tuple[1];
      var b = tuple[2];

      function ch2hex( ch ){
        var hex = ch.toString(16);

        if( hex.length === 1 ){
          hex = '0' + hex;
        }

        return hex;
      }

      return '#' + ch2hex(r) + ch2hex(g) + ch2hex(b);
    },

    colors: {
      // special colour names
      transparent:      [0,0,0,0], // NB alpha === 0

      // regular colours
      aliceblue:        [240,248,255],
      antiquewhite:      [250,235,215],
      aqua:          [0,255,255],
      aquamarine:        [127,255,212],
      azure:          [240,255,255],
      beige:          [245,245,220],
      bisque:          [255,228,196],
      black:          [0,0,0],
      blanchedalmond:      [255,235,205],
      blue:          [0,0,255],
      blueviolet:        [138,43,226],
      brown:          [165,42,42],
      burlywood:        [222,184,135],
      cadetblue:        [95,158,160],
      chartreuse:        [127,255,0],
      chocolate:        [210,105,30],
      coral:          [255,127,80],
      cornflowerblue:      [100,149,237],
      cornsilk:        [255,248,220],
      crimson:        [220,20,60],
      cyan:          [0,255,255],
      darkblue:        [0,0,139],
      darkcyan:        [0,139,139],
      darkgoldenrod:      [184,134,11],
      darkgray:        [169,169,169],
      darkgreen:        [0,100,0],
      darkgrey:        [169,169,169],
      darkkhaki:        [189,183,107],
      darkmagenta:      [139,0,139],
      darkolivegreen:      [85,107,47],
      darkorange:        [255,140,0],
      darkorchid:        [153,50,204],
      darkred:        [139,0,0],
      darksalmon:        [233,150,122],
      darkseagreen:      [143,188,143],
      darkslateblue:      [72,61,139],
      darkslategray:      [47,79,79],
      darkslategrey:      [47,79,79],
      darkturquoise:      [0,206,209],
      darkviolet:        [148,0,211],
      deeppink:        [255,20,147],
      deepskyblue:      [0,191,255],
      dimgray:        [105,105,105],
      dimgrey:        [105,105,105],
      dodgerblue:        [30,144,255],
      firebrick:        [178,34,34],
      floralwhite:      [255,250,240],
      forestgreen:      [34,139,34],
      fuchsia:        [255,0,255],
      gainsboro:        [220,220,220],
      ghostwhite:        [248,248,255],
      gold:          [255,215,0],
      goldenrod:        [218,165,32],
      gray:          [128,128,128],
      grey:          [128,128,128],
      green:          [0,128,0],
      greenyellow:      [173,255,47],
      honeydew:        [240,255,240],
      hotpink:        [255,105,180],
      indianred:        [205,92,92],
      indigo:          [75,0,130],
      ivory:          [255,255,240],
      khaki:          [240,230,140],
      lavender:        [230,230,250],
      lavenderblush:      [255,240,245],
      lawngreen:        [124,252,0],
      lemonchiffon:      [255,250,205],
      lightblue:        [173,216,230],
      lightcoral:        [240,128,128],
      lightcyan:        [224,255,255],
      lightgoldenrodyellow:  [250,250,210],
      lightgray:        [211,211,211],
      lightgreen:        [144,238,144],
      lightgrey:        [211,211,211],
      lightpink:        [255,182,193],
      lightsalmon:      [255,160,122],
      lightseagreen:      [32,178,170],
      lightskyblue:      [135,206,250],
      lightslategray:      [119,136,153],
      lightslategrey:      [119,136,153],
      lightsteelblue:      [176,196,222],
      lightyellow:      [255,255,224],
      lime:          [0,255,0],
      limegreen:        [50,205,50],
      linen:          [250,240,230],
      magenta:        [255,0,255],
      maroon:          [128,0,0],
      mediumaquamarine:    [102,205,170],
      mediumblue:        [0,0,205],
      mediumorchid:      [186,85,211],
      mediumpurple:      [147,112,219],
      mediumseagreen:      [60,179,113],
      mediumslateblue:    [123,104,238],
      mediumspringgreen:    [0,250,154],
      mediumturquoise:    [72,209,204],
      mediumvioletred:    [199,21,133],
      midnightblue:      [25,25,112],
      mintcream:        [245,255,250],
      mistyrose:        [255,228,225],
      moccasin:        [255,228,181],
      navajowhite:      [255,222,173],
      navy:          [0,0,128],
      oldlace:        [253,245,230],
      olive:          [128,128,0],
      olivedrab:        [107,142,35],
      orange:          [255,165,0],
      orangered:        [255,69,0],
      orchid:          [218,112,214],
      palegoldenrod:      [238,232,170],
      palegreen:        [152,251,152],
      paleturquoise:      [175,238,238],
      palevioletred:      [219,112,147],
      papayawhip:        [255,239,213],
      peachpuff:        [255,218,185],
      peru:          [205,133,63],
      pink:          [255,192,203],
      plum:          [221,160,221],
      powderblue:        [176,224,230],
      purple:          [128,0,128],
      red:          [255,0,0],
      rosybrown:        [188,143,143],
      royalblue:        [65,105,225],
      saddlebrown:      [139,69,19],
      salmon:          [250,128,114],
      sandybrown:        [244,164,96],
      seagreen:        [46,139,87],
      seashell:        [255,245,238],
      sienna:          [160,82,45],
      silver:          [192,192,192],
      skyblue:        [135,206,235],
      slateblue:        [106,90,205],
      slategray:        [112,128,144],
      slategrey:        [112,128,144],
      snow:          [255,250,250],
      springgreen:      [0,255,127],
      steelblue:        [70,130,180],
      tan:          [210,180,140],
      teal:          [0,128,128],
      thistle:        [216,191,216],
      tomato:          [255,99,71],
      turquoise:        [64,224,208],
      violet:          [238,130,238],
      wheat:          [245,222,179],
      white:          [255,255,255],
      whitesmoke:        [245,245,245],
      yellow:          [255,255,0],
      yellowgreen:      [154,205,50]
    }
      
  };

  $$.util.regex = {};
  
  $$.util.regex.number = "(?:[-]?\\d*\\.\\d+|[-]?\\d+|[-]?\\d*\\.\\d+[eE]\\d+)";
  
  $$.util.regex.rgba = "rgb[a]?\\(("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.rgbaNoBackRefs = "rgb[a]?\\((?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hsla = "hsl[a]?\\(("+ $$.util.regex.number +")\\s*,\\s*("+ $$.util.regex.number +"[%])\\s*,\\s*("+ $$.util.regex.number +"[%])(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.hslaNoBackRefs = "hsl[a]?\\((?:"+ $$.util.regex.number +")\\s*,\\s*(?:"+ $$.util.regex.number +"[%])\\s*,\\s*(?:"+ $$.util.regex.number +"[%])(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hex3 = "\\#[0-9a-fA-F]{3}";
  $$.util.regex.hex6 = "\\#[0-9a-fA-F]{6}";

  var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||  
        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );

  raf = raf || function(fn){ if(fn){ setTimeout(fn, 1000/60); } };

  $$.util.requestAnimationFrame = function(fn){
    raf( fn );
  };

})( cytoscape, typeof window === 'undefined' ? null : window  );

;(function($$){ 'use strict';
  
  $$.math = {};
  
  $$.math.signum = function(x){
    if( x > 0 ){
      return 1;
    } else if( x < 0 ){
      return -1;
    } else {
      return 0;
    }
  };

  $$.math.distance = function( p1, p2 ){
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt( dx*dx + dy*dy );
  };

  // from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves
  $$.math.qbezierAt = function(p0, p1, p2, t){
    return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;
  };

  $$.math.qbezierPtAt = function(p0, p1, p2, t){
    return {
      x: $$.math.qbezierAt( p0.x, p1.x, p2.x, t ),
      y: $$.math.qbezierAt( p0.y, p1.y, p2.y, t )
    };
  };

  $$.math.boundingBoxesIntersect = function( bb1, bb2 ){
    // case: one bb to right of other
    if( bb1.x1 > bb2.x2 ){ return false; }
    if( bb2.x1 > bb1.x2 ){ return false; }

    // case: one bb to left of other
    if( bb1.x2 < bb2.x1 ){ return false; }
    if( bb2.x2 < bb1.x1 ){ return false; }

    // case: one bb above other
    if( bb1.y2 < bb2.y1 ){ return false; }
    if( bb2.y2 < bb1.y1 ){ return false; }

    // case: one bb below other
    if( bb1.y1 > bb2.y2 ){ return false; }
    if( bb2.y1 > bb1.y2 ){ return false; }

    // otherwise, must have some overlap
    return true;
  };

  $$.math.inBoundingBox = function( bb, x, y ){
    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
  };

  $$.math.pointInBoundingBox = function( bb, pt ){
    return this.inBoundingBox( bb, pt.x, pt.y );
  };

  $$.math.roundRectangleIntersectLine = function(
    x, y, nodeX, nodeY, width, height, padding) {
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    
    // Check intersections with straight line segments
    var straightLineIntersections;
    
    // Top segment, left to right
    {
      var topStartX = nodeX - halfWidth + cornerRadius - padding;
      var topStartY = nodeY - halfHeight - padding;
      var topEndX = nodeX + halfWidth - cornerRadius + padding;
      var topEndY = topStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Right segment, top to bottom
    {
      var rightStartX = nodeX + halfWidth + padding;
      var rightStartY = nodeY - halfHeight + cornerRadius - padding;
      var rightEndX = rightStartX;
      var rightEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Bottom segment, left to right
    {
      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
      var bottomStartY = nodeY + halfHeight + padding;
      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
      var bottomEndY = bottomStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Left segment, top to bottom
    {
      var leftStartX = nodeX - halfWidth - padding;
      var leftStartY = nodeY - halfHeight + cornerRadius - padding;
      var leftEndX = leftStartX;
      var leftEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Check intersections with arc segments
    var arcIntersections;
    
    // Top Left
    {
      var topLeftCenterX = nodeX - halfWidth + cornerRadius;
      var topLeftCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topLeftCenterX, topLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= topLeftCenterX
        && arcIntersections[1] <= topLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Top Right
    {
      var topRightCenterX = nodeX + halfWidth - cornerRadius;
      var topRightCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topRightCenterX, topRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= topRightCenterX
        && arcIntersections[1] <= topRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Right
    {
      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= bottomRightCenterX
        && arcIntersections[1] >= bottomRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Left
    {
      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= bottomLeftCenterX
        && arcIntersections[1] >= bottomLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }

    return []; // if nothing
  };
  
  $$.math.roundRectangleIntersectBox = function(
    boxX1, boxY1, boxX2, boxY2, width, height, centerX, centerY, padding) {
    
    // We have the following shpae
    
    //    _____
    //  _|     |_
    // |         |
    // |_       _|
    //   |_____|
    //
    // With a quarter circle at each corner.
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var hBoxTopLeftX = centerX - width / 2 - padding;
    var hBoxTopLeftY = centerY - height / 2 + cornerRadius - padding;
    var hBoxBottomRightX = centerX + width / 2 + padding;
    var hBoxBottomRightY = centerY + height / 2 - cornerRadius + padding;
    
    var vBoxTopLeftX = centerX - width / 2 + cornerRadius - padding;
    var vBoxTopLeftY = centerY - height / 2 - padding;
    var vBoxBottomRightX = centerX + width / 2 - cornerRadius + padding;
    var vBoxBottomRightY = centerY + height / 2 + padding;
    
    // Check if the box is out of bounds
    var boxMinX = Math.min(boxX1, boxX2);
    var boxMaxX = Math.max(boxX1, boxX2);
    var boxMinY = Math.min(boxY1, boxY2);
    var boxMaxY = Math.max(boxY1, boxY2);
    
    if (boxMaxX < hBoxTopLeftX) {
      return false;
    } else if (boxMinX > hBoxBottomRightX) {
      return false;
    }
    
    if (boxMaxY < vBoxTopLeftY) {
      return false;
    } else if (boxMinY > vBoxBottomRightY) {
      return false;
    }
    
    // Check if an hBox point is in given box
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the hBox
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    // Check if an vBox point is in given box
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the vBox
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    // Lastly, check if one of the ellipses coincide with the box
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    return false;
  };
  
  // @O Approximate collision functions
  $$.math.checkInBoundingCircle = function(
    x, y, farthestPointSqDistance, padding, width, height, centerX, centerY) {
    
    x = (x - centerX) / (width + padding);
    y = (y - centerY) / (height + padding);
    
    return (x * x + y * y) <= farthestPointSqDistance;
  };
  
  $$.math.boxInBezierVicinity = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    // Return values:
    // 0 - curve is not in box
    // 1 - curve may be in box; needs precise check
    // 2 - curve is in box
    
    // midpoint
    var midX = 0.25 * x1 + 0.5 * x2 + 0.25 * x3;
    var midY = 0.25 * y1 + 0.5 * y2 + 0.25 * y3;

    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) { // (x1, y1) in box
      return 1;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) { // (x3, y3) in box
      return 1;
    } else if (midX >= boxMinX && midX <= boxMaxX && midY >= boxMinY && midY <= boxMaxY) { // (midX, midY) in box
      return 1;
    } else if (x2 >= boxMinX && x2 <= boxMaxX && y2 >= boxMinY && y2 <= boxMaxY) { // ctrl pt in box
      return 1;
    }
    
    var curveMinX = Math.min(x1, midX, x3);
    var curveMinY = Math.min(y1, midY, y3);
    var curveMaxX = Math.max(x1, midX, x3);
    var curveMaxY = Math.max(y1, midY, y3);
    
    /*
    console.log(curveMinX + ", " + curveMinY + ", " + curveMaxX 
      + ", " + curveMaxY);
    if (curveMinX == undefined) {
      console.log("undefined curveMinX: " + x1 + ", " + x2 + ", " + x3);
    }
    */
    
    if (curveMinX > boxMaxX
      || curveMaxX < boxMinX
      || curveMinY > boxMaxY
      || curveMaxY < boxMinY) {
      
      return 0;  
    }
    
    return 1;
  };

  $$.math.checkBezierInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {

    function sampleInBox(t){
      var x = $$.math.qbezierAt(x1, x2, x3, t);
      var y = $$.math.qbezierAt(y1, y2, y3, t);

      return x1box <= x && x <= x2box
        && y1box <= y && y <= y2box
      ;
    }

    for( var t = 0; t <= 1; t += 0.25 ){
      if( !sampleInBox(t) ){
        return false;
      }
    }

    return true;
  };
  
  $$.math.checkStraightEdgeInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {

    return x1box <= x1 && x1 <= x2box
      && x1box <= x2 && x2 <= x2box
      && y1box <= y1 && y1 <= y2box
      && y1box <= y2 && y2 <= y2box
    ;
  };

  $$.math.checkStraightEdgeCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {
    
   //console.log(arguments);
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    // Check left + right bounds
    var aX = x2 - x1;
    var bX = x1;
    var yValue;
    
    // Top and bottom
    var aY = y2 - y1;
    var bY = y1;
    var xValue;
    
    if (Math.abs(aX) < 0.0001) {
      return (x1 >= boxMinX && x1 <= boxMaxX
        && Math.min(y1, y2) <= boxMinY
        && Math.max(y1, y2) >= boxMaxY);  
    }
    
    var tLeft = (boxMinX - bX) / aX;
    if (tLeft > 0 && tLeft <= 1) {
      yValue = aY * tLeft + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tRight = (boxMaxX - bX) / aX;
    if (tRight > 0 && tRight <= 1) {
      yValue = aY * tRight + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tTop = (boxMinY - bY) / aY;
    if (tTop > 0 && tTop <= 1) {
      xValue = aX * tTop + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    var tBottom = (boxMaxY - bY) / aY;
    if (tBottom > 0 && tBottom <= 1) {
      xValue = aX * tBottom + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    return false;
  };
  
  $$.math.checkBezierCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) {
      return true;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) {
      return true;
    }
    
    var aX = x1 - 2 * x2 + x3;
    var bX = -2 * x1 + 2 * x2;
    var cX = x1;

    var xIntervals = [];
    
    if (Math.abs(aX) < 0.0001) {
      var leftParam = (boxMinX - x1) / bX;
      var rightParam = (boxMaxX - x1) / bX;
      
      xIntervals.push(leftParam, rightParam);
    } else {
      // Find when x coordinate of the curve crosses the left side of the box
      var discriminantX1 = bX * bX - 4 * aX * (cX - boxMinX);
      var tX1, tX2;
      if (discriminantX1 > 0) {
        var sqrt = Math.sqrt(discriminantX1);
        tX1 = (-bX + sqrt) / (2 * aX);
        tX2 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX1, tX2);
      }
      
      var discriminantX2 = bX * bX - 4 * aX * (cX - boxMaxX);
      var tX3, tX4;
      if (discriminantX2 > 0) {
        var sqrt = Math.sqrt(discriminantX2);
        tX3 = (-bX + sqrt) / (2 * aX);
        tX4 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX3, tX4);
      }
    }
    
    xIntervals.sort(function(a, b) { return a - b; });
    
    var aY = y1 - 2 * y2 + y3;
    var bY = -2 * y1 + 2 * y2;
    var cY = y1;
    
    var yIntervals = [];
    
    if (Math.abs(aY) < 0.0001) {
      var topParam = (boxMinY - y1) / bY;
      var bottomParam = (boxMaxY - y1) / bY;
      
      yIntervals.push(topParam, bottomParam);
    } else {
      var discriminantY1 = bY * bY - 4 * aY * (cY - boxMinY);
      
      var tY1, tY2;
      if (discriminantY1 > 0) {
        var sqrt = Math.sqrt(discriminantY1);
        tY1 = (-bY + sqrt) / (2 * aY);
        tY2 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY1, tY2);
      }
  
      var discriminantY2 = bY * bY - 4 * aY * (cY - boxMaxY);
      
      var tY3, tY4;
      if (discriminantY2 > 0) {
        var sqrt = Math.sqrt(discriminantY2);
        tY3 = (-bY + sqrt) / (2 * aY);
        tY4 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY3, tY4);
      }
    }
        
    yIntervals.sort(function(a, b) { return a - b; });

    for (var index = 0; index < xIntervals.length; index += 2) {
      for (var yIndex = 1; yIndex < yIntervals.length; yIndex += 2) {
        
        // Check if there exists values for the Bezier curve
        // parameter between 0 and 1 where both the curve's
        // x and y coordinates are within the bounds specified by the box
        if (xIntervals[index] < yIntervals[yIndex]
          && yIntervals[yIndex] >= 0.0
          && xIntervals[index] <= 1.0
          && xIntervals[index + 1] > yIntervals[yIndex - 1]
          && yIntervals[yIndex - 1] <= 1.0
          && xIntervals[index + 1] >= 0.0) {
          
          return true;
        }
      }
    }
    
    return false;
  };
  
  $$.math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){
    var t = tolerance;

    var x1 = Math.min(lx1, lx2);
    var x2 = Math.max(lx1, lx2);
    var y1 = Math.min(ly1, ly2);
    var y2 = Math.max(ly1, ly2);

    return x1 - t <= x && x <= x2 + t
      && y1 - t <= y && y <= y2 + t;
  };

  $$.math.inBezierVicinity = function(
    x, y, x1, y1, x2, y2, x3, y3, toleranceSquared) {

    var bb = {
      x1: Math.min( x1, x3, x2 ),
      x2: Math.max( x1, x3, x2 ),
      y1: Math.min( y1, y3, y2 ),
      y2: Math.max( y1, y3, y2 )
    };

    // if outside the rough bounding box for the bezier, then it can't be a hit
    if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
      // console.log('bezier out of rough bb')
      return false;
    } else {
      // console.log('do more expensive check');
      return true;
    }

  };
  
  $$.math.solveCubic = function(a, b, c, d, result) {
    
    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
    // r is the real component, i is the imaginary component

    // An implementation of the Cardano method from the year 1545
    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

    b /= a;
    c /= a;
    d /= a;
    
    var discriminant, q, r, dum1, s, t, term1, r13;

    q = (3.0 * c - (b * b)) / 9.0;
    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
    r /= 54.0;
    
    discriminant = q * q * q + r * r;
    result[1] = 0;
    term1 = (b / 3.0);
    
    if (discriminant > 0) {
      s = r + Math.sqrt(discriminant);
      s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));
      t = r - Math.sqrt(discriminant);
      t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));
      result[0] = -term1 + s + t;
      term1 += (s + t) / 2.0;
      result[4] = result[2] = -term1;
      term1 = Math.sqrt(3.0) * (-t + s) / 2;
      result[3] = term1;
      result[5] = -term1;
      return;
    }
    
    result[5] = result[3] = 0;
    
    if (discriminant === 0) {
      r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));
      result[0] = -term1 + 2.0 * r13;
      result[4] = result[2] = -(r13 + term1);
      return;
    }
    
    q = -q;
    dum1 = q * q * q;
    dum1 = Math.acos(r / Math.sqrt(dum1));
    r13 = 2.0 * Math.sqrt(q);
    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
    
    return;
  };

  $$.math.sqDistanceToQuadraticBezier = function(
    x, y, x1, y1, x2, y2, x3, y3) {
    
    // Find minimum distance by using the minimum of the distance 
    // function between the given point and the curve
    
    // This gives the coefficients of the resulting cubic equation
    // whose roots tell us where a possible minimum is
    // (Coefficients are divided by 4)
    
    var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3
      + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;
    
    var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3
      + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;
    
    var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x
      + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;
      
    var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x
      + y1*y2 - y1*y1 + y1*y - y2*y;
    
    // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);
    
    var roots = [];
    
    // Use the cubic solving algorithm
    this.solveCubic(a, b, c, d, roots);
    
    var zeroThreshold = 0.0000001;
    
    var params = [];
    
    for (var index = 0; index < 6; index += 2) {
      if (Math.abs(roots[index + 1]) < zeroThreshold
          && roots[index] >= 0
          && roots[index] <= 1.0) {
        params.push(roots[index]);
      }
    }
    
    params.push(1.0);
    params.push(0.0);
    
    var minDistanceSquared = -1;
    var closestParam;
    
    var curX, curY, distSquared;
    for (var i = 0; i < params.length; i++) {
      curX = Math.pow(1.0 - params[i], 2.0) * x1
        + 2.0 * (1 - params[i]) * params[i] * x2
        + params[i] * params[i] * x3;
        
      curY = Math.pow(1 - params[i], 2.0) * y1
        + 2 * (1.0 - params[i]) * params[i] * y2
        + params[i] * params[i] * y3;
        
      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
      // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
      if (minDistanceSquared >= 0) {
        if (distSquared < minDistanceSquared) {
          minDistanceSquared = distSquared;
          closestParam = params[i];
        }
      } else {
        minDistanceSquared = distSquared;
        closestParam = params[i];
      }
    }
    
    /*
    debugStats.clickX = x;
    debugStats.clickY = y;
    
    debugStats.closestX = Math.pow(1.0 - closestParam, 2.0) * x1
        + 2.0 * (1.0 - closestParam) * closestParam * x2
        + closestParam * closestParam * x3;
        
    debugStats.closestY = Math.pow(1.0 - closestParam, 2.0) * y1
        + 2.0 * (1.0 - closestParam) * closestParam * y2
        + closestParam * closestParam * y3;
    */
    
    // debug("given: " 
    //   + "( " + x + ", " + y + "), " 
    //   + "( " + x1 + ", " + y1 + "), " 
    //   + "( " + x2 + ", " + y2 + "), "
    //   + "( " + x3 + ", " + y3 + ")");
    
    
    // debug("roots: " + roots);
    // debug("params: " + params);
    // debug("closest param: " + closestParam);
    return minDistanceSquared;
  };
  
  $$.math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {
    var offset = [x - x1, y - y1];
    var line = [x2 - x1, y2 - y1];
    
    var lineSq = line[0] * line[0] + line[1] * line[1];
    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
    
    var dotProduct = offset[0] * line[0] + offset[1] * line[1];
    var adjSq = dotProduct * dotProduct / lineSq;
    
    if (dotProduct < 0) {
      return hypSq;
    }
    
    if (adjSq > lineSq) {
      return (x - x2) * (x - x2) + (y - y2) * (y - y2);
    }
    
    return hypSq - adjSq;
  };

  $$.math.pointInsidePolygon = function(
    x, y, basePoints, centerX, centerY, width, height, direction, padding) {

    //var direction = arguments[6];
    var transformedPoints = new Array(basePoints.length);

    // Gives negative angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
        
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
//    console.log("base: " + basePoints);
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);

      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = this.expandPolygon(
        transformedPoints,
        -padding);
      
      points = this.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    var x1, y1, x2, y2;
    var y3;
    
    // Intersect with vertical line through (x, y)
    var up = 0;
    var down = 0;
    for (var i = 0; i < points.length / 2; i++) {
      
      x1 = points[i * 2];
      y1 = points[i * 2 + 1];
      
      if (i + 1 < points.length / 2) {
        x2 = points[(i + 1) * 2];
        y2 = points[(i + 1) * 2 + 1];
      } else {
        x2 = points[(i + 1 - points.length / 2) * 2];
        y2 = points[(i + 1 - points.length / 2) * 2 + 1];
      }
      
//*      console.log("line from (" + x1 + ", " + y1 + ") to (" + x2 + ", " + y2 + ")");

//&      console.log(x1, x, x2);

      if (x1 == x && x2 == x) {
        
      } else if ((x1 >= x && x >= x2)
        || (x1 <= x && x <= x2)) {
        
        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;
        
        if (y3 > y) {
          up++;
        }
        
        if (y3 < y) {
          down++;
        }
        
//*        console.log(y3, y);
        
      } else {
//*        console.log('22');
        continue;
      }
      
    }
    
//*    console.log("up: " + up + ", down: " + down);
    
    if (up % 2 === 0) {
      return false;
    } else {
      return true;
    }
  };

  $$.math.joinLines = function(lineSet) {
    
    var vertices = new Array(lineSet.length / 2);
    
    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
    
    for (var i = 0; i < lineSet.length / 4; i++) {
      currentLineStartX = lineSet[i * 4];
      currentLineStartY = lineSet[i * 4 + 1];
      currentLineEndX = lineSet[i * 4 + 2];
      currentLineEndY = lineSet[i * 4 + 3];
      
      if (i < lineSet.length / 4 - 1) {
        nextLineStartX = lineSet[(i + 1) * 4];
        nextLineStartY = lineSet[(i + 1) * 4 + 1];
        nextLineEndX = lineSet[(i + 1) * 4 + 2];
        nextLineEndY = lineSet[(i + 1) * 4 + 3];
      } else {
        nextLineStartX = lineSet[0];
        nextLineStartY = lineSet[1];
        nextLineEndX = lineSet[2];
        nextLineEndY = lineSet[3];
      }
      
      var intersection = this.finiteLinesIntersect(
        currentLineStartX, currentLineStartY,
        currentLineEndX, currentLineEndY,
        nextLineStartX, nextLineStartY,
        nextLineEndX, nextLineEndY,
        true);
      
      vertices[i * 2] = intersection[0];
      vertices[i * 2 + 1] = intersection[1];
    }
    
    return vertices;
  };

  $$.math.expandPolygon = function(points, pad) {
    
    var expandedLineSet = new Array(points.length * 2);
    
    var currentPointX, currentPointY, nextPointX, nextPointY;
    
    for (var i = 0; i < points.length / 2; i++) {
      currentPointX = points[i * 2];
      currentPointY = points[i * 2 + 1];
      
      if (i < points.length / 2 - 1) {
        nextPointX = points[(i + 1) * 2];
        nextPointY = points[(i + 1) * 2 + 1];
      } else {
        nextPointX = points[0];
        nextPointY = points[1];
      }
      
      // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
      
      // Assume CCW polygon winding
      
      var offsetX = (nextPointY - currentPointY);
      var offsetY = -(nextPointX - currentPointX);
      
      // Normalize
      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
      var normalizedOffsetX = offsetX / offsetLength;
      var normalizedOffsetY = offsetY / offsetLength;
      
      expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
      expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
    }
    
    return expandedLineSet;
  };

  $$.math.intersectLineEllipse = function(
    x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
    
    var dispX = centerX - x;
    var dispY = centerY - y;
    
    dispX /= ellipseWradius;
    dispY /= ellipseHradius;
    
    var len = Math.sqrt(dispX * dispX + dispY * dispY);
    
    var newLength = len - 1;
    
    if (newLength < 0) {
      return [];
    }
    
    var lenProportion = newLength / len;
    
    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
  };
  
  $$.math.dotProduct = function(
    vec1, vec2) {
    
    if (vec1.length != 2 || vec2.length != 2) {
      throw 'dot product: arguments are not vectors';
    }
    
    return (vec1[0] * vec2[0] + vec1[1] * vec2[1]);
  };
  
  // Returns intersections of increasing distance from line's start point
  $$.math.intersectLineCircle = function(
    x1, y1, x2, y2, centerX, centerY, radius) {
    
    // Calculate d, direction vector of line
    var d = [x2 - x1, y2 - y1]; // Direction vector of line
    var c = [centerX, centerY]; // Center of circle
    var f = [x1 - centerX, y1 - centerY];
    
    var a = d[0] * d[0] + d[1] * d[1];
    var b = 2 * (f[0] * d[0] + f[1] * d[1]);
    var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;
    
    var discriminant = b*b-4*a*c;
    
    if (discriminant < 0) {
      return [];
    }
    
    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
    
    var tMin = Math.min(t1, t2);
    var tMax = Math.max(t1, t2);
    var inRangeParams = [];
    
    if (tMin >= 0 && tMin <= 1) {
      inRangeParams.push(tMin);
    }
    
    if (tMax >= 0 && tMax <= 1) {
      inRangeParams.push(tMax);
    }
    
    if (inRangeParams.length === 0) {
      return [];
    }
    
    var nearIntersectionX = inRangeParams[0] * d[0] + x1;
    var nearIntersectionY = inRangeParams[0] * d[1] + y1;
    
    if (inRangeParams.length > 1) {
    
      if (inRangeParams[0] == inRangeParams[1]) {
        return [nearIntersectionX, nearIntersectionY];
      } else {
        
        var farIntersectionX = inRangeParams[1] * d[0] + x1;
        var farIntersectionY = inRangeParams[1] * d[1] + y1;
      
        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
      }
      
    } else {
      return [nearIntersectionX, nearIntersectionY];
    }
    
  };
  
  $$.math.findCircleNearPoint = function(centerX, centerY, 
    radius, farX, farY) {
    
    var displacementX = farX - centerX;
    var displacementY = farY - centerY;
    var distance = Math.sqrt(displacementX * displacementX 
      + displacementY * displacementY);
    
    var unitDisplacementX = displacementX / distance;
    var unitDisplacementY = displacementY / distance;
    
    return [centerX + unitDisplacementX * radius, 
      centerY + unitDisplacementY * radius];
  };
  
  $$.math.findMaxSqDistanceToOrigin = function(points) {
    var maxSqDistance = 0.000001;
    var sqDistance;
    
    for (var i = 0; i < points.length / 2; i++) {
      
      sqDistance = points[i * 2] * points[i * 2] 
        + points[i * 2 + 1] * points[i * 2 + 1];
      
      if (sqDistance > maxSqDistance) {
        maxSqDistance = sqDistance;
      }
    }
    
    return maxSqDistance;
  };
  
  $$.math.finiteLinesIntersect = function(
    x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
    
    var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    if (u_b !== 0) {
      var ua = ua_t / u_b;
      var ub = ub_t / u_b;
      
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {  
        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        
      } else {
        if (!infiniteLines) {
          return [];
        } else {
          return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        }
      }
    } else {
      if (ua_t === 0 || ub_t === 0) {

        // Parallel, coincident lines. Check if overlap

        // Check endpoint of second line
        if ([x1, x2, x4].sort()[1] === x4) {
          return [x4, y4];
        }
        
        // Check start point of second line
        if ([x1, x2, x3].sort()[1] === x3) {
          return [x3, y3];
        }
        
        // Endpoint of first line
        if ([x3, x4, x2].sort()[1] === x2) {
          return [x2, y2];
        }
        
        return [];
      } else {
      
        // Parallel, non-coincident
        return [];
      }
    }
  };
  
  // (boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
  //      cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
  
  $$.math.boxIntersectEllipse = function(
    x1, y1, x2, y2, padding, width, height, centerX, centerY) {
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    // 4 ortho extreme points
    var west = [centerX - width / 2 - padding, centerY];
    var east = [centerX + width / 2 + padding, centerY];
    var north = [centerX, centerY - height / 2 - padding];
    var south = [centerX, centerY + height / 2 + padding];
    
    // out of bounds: return false
    if (x2 < west[0]) {
      return false;
    }
    
    if (x1 > east[0]) {
      return false;
    }
    
    if (y1 > south[1]) {
      return false;
    }
    
    if (y2 < north[1]) {
      return false;
    }
    
    // 1 of 4 ortho extreme points in box: return true
    if (x1 <= east[0] && east[0] <= x2
        && y1 <= east[1] && east[1] <= y2) {
      return true;
    }
    
    if (x1 <= west[0] && west[0] <= x2
        && y1 <= west[1] && west[1] <= y2) {
      return true;
    }
    
    if (x1 <= north[0] && north[0] <= x2
        && y1 <= north[1] && north[1] <= y2) {
      return true;
    }
    
    if (x1 <= south[0] && south[0] <= x2
        && y1 <= south[1] && south[1] <= y2) {
      return true;
    }
    
    // box corner in ellipse: return true    
    x1 = (x1 - centerX) / (width / 2 + padding);
    x2 = (x2 - centerX) / (width / 2 + padding);
    
    y1 = (y1 - centerY) / (height / 2 + padding);
    y2 = (y2 - centerY) / (height / 2 + padding);
    
    if (x1 * x1 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y2 * y2 <= 1) {
      return true;
    }
    
    if (x1 * x1 + y2 * y2 <= 1) {
      return true;
    }
    
    return false;
  };
  
  $$.math.boxIntersectPolygon = function(
    x1, y1, x2, y2, basePoints, width, height, centerX, centerY, direction, padding) {
    
//    console.log(arguments);
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    var transformedPoints = new Array(basePoints.length);
    
    // Gives negative of angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
    
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);
      
      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    // Assume transformedPoints.length > 0, and check if intersection is possible
    var minTransformedX = transformedPoints[0];
    var maxTransformedX = transformedPoints[0];
    var minTransformedY = transformedPoints[1];
    var maxTransformedY = transformedPoints[1];
    
    for (var i = 1; i < transformedPoints.length / 2; i++) {
      if (transformedPoints[i * 2] > maxTransformedX) {
        maxTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2] < minTransformedX) {
        minTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2 + 1] > maxTransformedY) {
        maxTransformedY = transformedPoints[i * 2 + 1];
      }
      
      if (transformedPoints[i * 2 + 1] < minTransformedY) {
        minTransformedY = transformedPoints[i * 2 + 1];
      }
    }
    
    if (x2 < minTransformedX - padding) {
      return false;
    }
    
    if (x1 > maxTransformedX + padding) {
      return false;
    }
    
    if (y2 < minTransformedY - padding) {
      return false;
    }
    
    if (y1 > maxTransformedY + padding) {
      return false;
    }
    
    // Continue checking with padding-corrected points
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    // Check if a point is in box
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      if (x1 <= transformedPoints[i * 2]
          && transformedPoints[i * 2] <= x2) {
        
        if (y1 <= transformedPoints[i * 2 + 1]
            && transformedPoints[i * 2 + 1] <= y2) {
          
          return true;
        }
      }
    }
    
    
    // Check for intersections with the selection box
    for (var i = 0; i < points.length / 2; i++) {
      
      var currentX = points[i * 2];
      var currentY = points[i * 2 + 1];
      var nextX;
      var nextY;
      
      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2];
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0];
        nextY = points[1];
      }
      
      // Intersection with top of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x2, y1, false).length > 0) {
        return true;
      }
      
      // Intersection with bottom of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y2, x2, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with left side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x1, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with right side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x2, y1, x2, y2, false).length > 0) {
        return true;
      }
    }

    /*
    // Check if box corner in the polygon
    if ($$.math.pointInsidePolygon(
      x1, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x1, y2, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x2, y2, points, 0, 0, 1, 1, 0, direction)) {
       
      return true; 
    } else if ($$.math.pointInsidePolygon(
      x2, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    }
    */
    return false;
  };
  
  $$.math.polygonIntersectLine = function(
    x, y, basePoints, centerX, centerY, width, height, padding) {
    
    var intersections = [];
    var intersection;
    
    var transformedPoints = new Array(basePoints.length);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    // var points = transformedPoints;
    
    var currentX, currentY, nextX, nextY;
    
    for (var i = 0; i < points.length / 2; i++) {
    
      currentX = points[i * 2];
      currentY = points[i * 2 + 1];

      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2]; 
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0]; 
        nextY = points[1];
      }
      
      intersection = this.finiteLinesIntersect(
        x, y, centerX, centerY,
        currentX, currentY,
        nextX, nextY);
      
      if (intersection.length !== 0) {
        intersections.push(intersection[0], intersection[1]);
      }
    }
    
    return intersections;
  };
  
  $$.math.shortenIntersection = function(
    intersection, offset, amount) {
    
    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
    
    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
    
    var lenRatio = (length - amount) / length;
    
    if (lenRatio < 0) {
      lenRatio = 0.00001;
    }

    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
  };

  $$.math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {
    var points = $$.math.generateUnitNgonPoints(sides, rotationRadians);
    points = $$.math.fitPolygonToSquare(points);

    return points;
  };

  $$.math.fitPolygonToSquare = function(points){
    var x, y;
    var sides = points.length/2;
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    for (var i = 0; i < sides; i++) {
      x = points[2 * i];
      y = points[2 * i + 1];

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }
    
    // stretch factors
    var sx = 2 / (maxX - minX);
    var sy = 2 / (maxY - minY);

    for (var i = 0; i < sides; i++){
      x = points[2 * i] = points[2 * i] * sx;
      y = points[2 * i + 1] = points[2 * i + 1] * sy;

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }

    if( minY < -1 ){
      for (var i = 0; i < sides; i++){
        y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);
      }
    }
    
    return points;
  };

  $$.math.generateUnitNgonPoints = function(sides, rotationRadians) {
    
    var increment = 1.0 / sides * 2 * Math.PI;
    var startAngle = sides % 2 === 0 ? 
      Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
//    console.log(nodeShapes['square']);
    startAngle += rotationRadians;
    
    var points = new Array(sides * 2);

    var currentAngle, x, y;
    for (var i = 0; i < sides; i++) {
      currentAngle = i * increment + startAngle;
      
      x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);
      y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);
    }
    
    return points;
  };

  $$.math.getRoundRectangleRadius = function(width, height) {
    
    // Set the default radius, unless half of width or height is smaller than default
    return Math.min(width / 4, height / 4, 8);
  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // registered extensions to cytoscape, indexed by name
  var extensions = {};
  $$.extensions = extensions;
  
  // registered modules for extensions, indexed by name
  var modules = {};
  $$.modules = modules;
  
  function setExtension(type, name, registrant){
    var impl = {};
    impl[name] = registrant;
    
    switch( type ){
    case 'core':
    case 'collection':
      $$.fn[type]( impl );
    }
    
    // fill in missing layout functions in the prototype
    if( type === 'layout' ){
      var layoutProto = registrant.prototype;
      var optLayoutFns = ['stop'];

      for( var i = 0; i < optLayoutFns.length; i++ ){
        var fnName = optLayoutFns[i];

        layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };
      }

      // either .start() or .run() is defined, so autogen the other
      if( layoutProto.start && !layoutProto.run ){
        layoutProto.run = function(){ this.start(); return this; };
      } else if( !layoutProto.start && layoutProto.run ){
        layoutProto.start = function(){ this.run(); return this; };
      }

      layoutProto.on = $$.define.on({ layout: true });
      layoutProto.one = $$.define.on({ layout: true, unbindSelfOnTrigger: true });
      layoutProto.once = $$.define.on({ layout: true, unbindAllBindersOnTrigger: true });
      layoutProto.off = $$.define.off({ layout: true });
      layoutProto.trigger = $$.define.trigger({ layout: true });

      // aliases for those folks who like old stuff:
      layoutProto.bind = layoutProto.on;
      layoutProto.unbind = layoutProto.off;
    }

    return $$.util.setMap({
      map: extensions,
      keys: [ type, name ],
      value: registrant
    });
  }
  
  function getExtension(type, name){
    return $$.util.getMap({
      map: extensions,
      keys: [ type, name ]
    });
  }
  
  function setModule(type, name, moduleType, moduleName, registrant){
    return $$.util.setMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ],
      value: registrant
    });
  }
  
  function getModule(type, name, moduleType, moduleName){
    return $$.util.getMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ]
    });
  }
  
  $$.extension = function(){
    // e.g. $$.extension('renderer', 'svg')
    if( arguments.length == 2 ){
      return getExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', { ... })
    else if( arguments.length == 3 ){
      return setExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if( arguments.length == 4 ){
      return getModule.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
    else if( arguments.length == 5 ){
      return setModule.apply(this, arguments);
    }
    
    else {
      $$.util.error('Invalid extension access syntax');
    }
  
  };
  
})( cytoscape );

;(function($, $$){ 'use strict';
  
  if( !$ ){ return; } // no jquery => don't need this

  var cyReg = function( $ele ){
    var d = $ele[0]._cyreg = $ele[0]._cyreg || {};

    return d;
  };

  // allow calls on a jQuery selector by proxying calls to $.cytoscape
  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
  $.fn.cytoscape = function(opts){
    var $this = $(this);

    // get object
    if( opts === 'get' ){
      return cyReg( $this ).cy;
    }
    
    // bind to ready
    else if( $$.is.fn(opts) ){

      var ready = opts;
      var cy = cyReg( $this ).cy;
      
      if( cy && cy.isReady() ){ // already ready so just trigger now
        cy.trigger('ready', [], ready);

      } else { // not yet ready, so add to readies list
        var data = cyReg( $this );
        var readies = data.readies = data.readies || [];

        readies.push( ready );
      } 
      
    }
    
    // proxy to create instance
    else if( $$.is.plainObject(opts) ){
      return $this.each(function(){
        var options = $.extend({}, opts, {
          container: $(this)[0]
        });
      
        cytoscape(options);
      });
    }
  };
  
  // allow access to the global cytoscape object under jquery for legacy reasons
  $.cytoscape = cytoscape;
  
  // use short alias (cy) if not already defined
  if( $.fn.cy == null && $.cy == null ){
    $.fn.cy = $.fn.cytoscape;
    $.cy = $.cytoscape;
  }
  
})(typeof jQuery !== 'undefined' ? jQuery : null , cytoscape);

;(function($$){ 'use strict';
  
  // shamelessly taken from jQuery
  // https://github.com/jquery/jquery/blob/master/src/event.js

  $$.Event = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof $$.Event) ) {
      return new $$.Event( src, props );
    }

    // Event object
    if ( src && src.type ) {
      this.originalEvent = src;
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

    // Event type
    } else {
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
      // $$.util.extend( this, props );

      // more efficient to manually copy fields we use
      this.type = props.type !== undefined ? props.type : this.type;
      this.cy = props.cy;
      this.cyTarget = props.cyTarget;
      this.cyPosition = props.cyPosition;
      this.cyRenderedPosition = props.cyRenderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
      this.data = props.data;
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || +new Date();
  };

  function returnFalse() {
    return false;
  }
  function returnTrue() {
    return true;
  }

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  $$.Event.prototype = {
    preventDefault: function() {
      this.isDefaultPrevented = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }

      // if preventDefault exists run it on the original event
      if ( e.preventDefault ) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      this.isPropagationStopped = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }
      // if stopPropagation exists run it on the original event
      if ( e.stopPropagation ) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    },
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse
  };
  
  
})( cytoscape );

;(function($$){ 'use strict';

  // use this module to cherry pick functions into your prototype
  // (useful for functions shared between the core and collections, for example)

  // e.g.
  // $$.fn.collection({
  //   foo: $$.define.foo({ /* params... */ })
  // });

  $$.define = {

    // access data field
    data: function( params ){
      var defaults = { 
        field: 'data',
        bindingEvent: 'data',
        allowBinding: false,
        allowSetting: false,
        allowGetting: false,
        settingEvent: 'data',
        settingTriggersEvent: false,
        triggerFnName: 'trigger',
        immutableKeys: {}, // key => true if immutable
        updateStyle: false,
        onSet: function( self ){},
        canSet: function( self ){ return true; }
      };
      params = $$.util.extend({}, defaults, params);

      return function dataImpl( name, value ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var single = selfIsArrayLike ? self[0] : self;

        // .data('foo', ...)
        if( $$.is.string(name) ){ // set or get property

          // .data('foo')
          if( p.allowGetting && value === undefined ){ // get

            var ret;
            if( single ){
              ret = single._private[ p.field ][ name ];
            }
            return ret;
          
          // .data('foo', 'bar')
          } else if( p.allowSetting && value !== undefined ) { // set
            var valid = !p.immutableKeys[name];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ name ] = value;
                }
              }

              // update mappers if asked
              if( p.updateStyle ){ self.updateStyle(); }

              // call onSet callback
              p.onSet( self );

              if( p.settingTriggersEvent ){
                self[ p.triggerFnName ]( p.settingEvent );
              }
            }
          }

        // .data({ 'foo': 'bar' })
        } else if( p.allowSetting && $$.is.plainObject(name) ){ // extend
          var obj = name;
          var k, v;

          for( k in obj ){
            v = obj[ k ];

            var valid = !p.immutableKeys[k];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ k ] = v;
                }
              }
            }
          }
          
          // update mappers if asked
          if( p.updateStyle ){ self.updateStyle(); }

          // call onSet callback
          p.onSet( self );

          if( p.settingTriggersEvent ){
            self[ p.triggerFnName ]( p.settingEvent );
          }
        
        // .data(function(){ ... })
        } else if( p.allowBinding && $$.is.fn(name) ){ // bind to event
          var fn = name;
          self.bind( p.bindingEvent, fn );
        
        // .data()
        } else if( p.allowGetting && name === undefined ){ // get whole object
          var ret;
          if( single ){
            ret = single._private[ p.field ];
          }
          return ret;
        }

        return self; // maintain chainability
      }; // function
    }, // data

    // remove data field
    removeData: function( params ){
      var defaults = { 
        field: 'data',
        event: 'data',
        triggerFnName: 'trigger',
        triggerEvent: false,
        immutableKeys: {} // key => true if immutable
      };
      params = $$.util.extend({}, defaults, params);

      return function removeDataImpl( names ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        
        // .removeData('foo bar')
        if( $$.is.string(names) ){ // then get the list of keys, and delete them
          var keys = names.split(/\s+/);
          var l = keys.length;

          for( var i = 0; i < l; i++ ){ // delete each non-empty key
            var key = keys[i];
            if( $$.is.emptyString(key) ){ continue; }

            var valid = !p.immutableKeys[ key ]; // not valid if immutable
            if( valid ){
              for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
                all[ i_a ]._private[ p.field ][ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }

        // .removeData()
        } else if( names === undefined ){ // then delete all keys

          for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
            var _privateFields = all[ i_a ]._private[ p.field ];
            
            for( var key in _privateFields ){
              var validKeyToDelete = !p.immutableKeys[ key ];

              if( validKeyToDelete ){
                _privateFields[ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }
        }

        return self; // maintain chaining
      }; // function
    }, // removeData

    // event function reusable stuff
    event: {
      regex: /(\w+)(\.\w+)?/, // regex for matching event strings (e.g. "click.namespace")
      optionalTypeRegex: /(\w+)?(\.\w+)?/,
      falseCallback: function(){ return false; }
    },

    // event binding
    on: function( params ){
      var defaults = {
        unbindSelfOnTrigger: false,
        unbindAllBindersOnTrigger: false
      };
      params = $$.util.extend({}, defaults, params);
      
      return function onImpl(events, selector, data, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var p = params;

        if( $$.is.plainObject(selector) ){ // selector is actually data
          callback = data;
          data = selector;
          selector = undefined;
        } else if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          data = undefined;
          selector = undefined;
        }

        if( $$.is.fn(data) || data === false ){ // data is actually callback
          callback = data;
          data = undefined;
        }

        // if there isn't a callback, we can't really do anything
        // (can't speak for mapped events arg version)
        if( !($$.is.fn(callback) || callback === false) && eventsIsString ){
          return self; // maintain chaining
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];
          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          if( !$$.is.fn(callback) ){ continue; }

          evts = evts.split(/\s+/);
          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]

            if( match ){
              var type = match[1];
              var namespace = match[2] ? match[2] : undefined;

              var listener = {
                callback: callback, // callback to run
                data: data, // extra data in eventObj.data
                delegated: selector ? true : false, // whether the evt is delegated
                selector: selector, // the selector to match for delegated events
                selObj: new $$.Selector(selector), // cached selector object to save rebuilding
                type: type, // the event type (e.g. 'click')
                namespace: namespace, // the event namespace (e.g. ".foo")
                unbindSelfOnTrigger: p.unbindSelfOnTrigger,
                unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
                binders: all // who bound together
              };

              for( var j = 0; j < all.length; j++ ){
                all[j]._private.listeners.push( listener );
              }
            }
          } // for events array
        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // on

    off: function offImpl( params ){
      var defaults = {
      };
      params = $$.util.extend({}, defaults, params);
      
      return function(events, selector, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);

        if( arguments.length === 0 ){ // then unbind all

          for( var i = 0; i < all.length; i++ ){
            all[i]._private.listeners = [];
          }

          return self; // maintain chaining
        }

        if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          selector = undefined;
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];

          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          evts = evts.split(/\s+/);
          for( var h = 0; h < evts.length; h++ ){
            var evt = evts[h];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.optionalTypeRegex ); // [type][.namespace]
            if( match ){
              var type = match[1] ? match[1] : undefined;
              var namespace = match[2] ? match[2] : undefined;

              for( var i = 0; i < all.length; i++ ){ //
                var listeners = all[i]._private.listeners;

                for( var j = 0; j < listeners.length; j++ ){
                  var listener = listeners[j];
                  var nsMatches = !namespace || namespace === listener.namespace;
                  var typeMatches = !type || listener.type === type;
                  var cbMatches = !callback || callback === listener.callback;
                  var listenerMatches = nsMatches && typeMatches && cbMatches;

                  // delete listener if it matches
                  if( listenerMatches ){
                    listeners.splice(j, 1);
                    j--;
                  }
                } // for listeners
              } // for all
            } // if match
          } // for events array

        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // off

    trigger: function( params ){
      var defaults = {};
      params = $$.util.extend({}, defaults, params);
      
      return function triggerImpl(events, extraParams, fnToTrigger){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var eventsIsObject = $$.is.plainObject(events);
        var eventsIsEvent = $$.is.event(events);
        var cy = this._private.cy || this;
        var hasCompounds = cy.hasCompoundNodes();

        if( eventsIsString ){ // then make a plain event object for each event name
          var evts = events.split(/\s+/);
          events = [];

          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            events.push( {
              type: type,
              namespace: namespace
            } );
          }
        } else if( eventsIsObject ){ // put in length 1 array
          var eventArgObj = events;

          events = [ eventArgObj ];
        }

        if( extraParams ){
          if( !$$.is.array(extraParams) ){ // make sure extra params are in an array if specified
            extraParams = [ extraParams ];
          }
        } else { // otherwise, we've got nothing
          extraParams = [];
        }

        for( var i = 0; i < events.length; i++ ){ // trigger each event in order
          var evtObj = events[i];
          
          for( var j = 0; j < all.length; j++ ){ // for each
            var triggerer = all[j];
            var listeners = triggerer._private.listeners;
            var triggererIsElement = $$.is.element(triggerer);
            var bubbleUp = triggererIsElement || params.layout;

            // create the event for this element from the event object
            var evt;

            if( eventsIsEvent ){ // then just get the object
              evt = evtObj;
              
              evt.cyTarget = evt.cyTarget || triggerer;
              evt.cy = evt.cy || cy;

            } else { // then we have to make one
              evt = new $$.Event( evtObj, {
                cyTarget: triggerer,
                cy: cy,
                namespace: evtObj.namespace
              } );
            }

            // if a layout was specified, then put it in the typed event
            if( evtObj.layout ){
              evt.layout = evtObj.layout;
            }

            // if triggered by layout, put in event
            if( params.layout ){
              evt.layout = triggerer;
            }

            // create a rendered position based on the passed position
            if( evt.cyPosition ){
              var pos = evt.cyPosition;
              var zoom = cy.zoom();
              var pan = cy.pan();

              evt.cyRenderedPosition = {
                x: pos.x * zoom + pan.x,
                y: pos.y * zoom + pan.y
              };
            }

            if( fnToTrigger ){ // then override the listeners list with just the one we specified
              listeners = [{
                namespace: evt.namespace,
                type: evt.type,
                callback: fnToTrigger
              }];
            }

            for( var k = 0; k < listeners.length; k++ ){ // check each listener
              var lis = listeners[k];
              var nsMatches = !lis.namespace || lis.namespace === evt.namespace;
              var typeMatches = lis.type === evt.type;
              var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && $$.is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive
              var listenerMatches = nsMatches && typeMatches && targetMatches;

              if( listenerMatches ){ // then trigger it
                var args = [ evt ];
                args = args.concat( extraParams ); // add extra params to args list

                if( lis.data ){ // add on data plugged into binding
                  evt.data = lis.data;
                } else { // or clear it in case the event obj is reused
                  evt.data = undefined;
                }

                if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                  listeners.splice(k, 1);
                  k--;
                }

                if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                  var binders = lis.binders;
                  for( var l = 0; l < binders.length; l++ ){
                    var binder = binders[l];
                    if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                    var binderListeners = binder._private.listeners;
                    for( var m = 0; m < binderListeners.length; m++ ){
                      var binderListener = binderListeners[m];

                      if( binderListener === lis ){ // delete listener from list
                        binderListeners.splice(m, 1);
                        m--;
                      }
                    }
                  }
                }

                // run the callback
                var context = lis.delegated ? evt.cyTarget : triggerer;
                var ret = lis.callback.apply( context, args );

                if( ret === false || evt.isPropagationStopped() ){
                  // then don't bubble
                  bubbleUp = false;

                  if( ret === false ){
                    // returning false is a shorthand for stopping propagation and preventing the def. action
                    evt.stopPropagation();
                    evt.preventDefault();
                  }
                }
              } // if listener matches
            } // for each listener

            // bubble up event for elements
            if( bubbleUp ){
              var parent = hasCompounds ? triggerer._private.parent : null;
              var hasParent = parent != null && parent.length !== 0;

              if( hasParent ){ // then bubble up to parent
                parent = parent[0];
                parent.trigger(evt);
              } else { // otherwise, bubble up to the core
                cy.trigger(evt);
              }
            }

          } // for each of all
        } // for each event
        
        return self; // maintain chaining
      }; // function
    }, // trigger


    animated: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animatedImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return false; }

        var ele = all[0];

        if( ele ){
          return ele._private.animation.current.length > 0;
        }
      };
    }, // animated

    clearQueue: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function clearQueueImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          ele._private.animation.queue = [];
        }

        return this;
      };
    }, // clearQueue

    delay: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function delayImpl( time, complete ){
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        this.animate({
          delay: time
        }, {
          duration: time,
          complete: complete
        });

        return this;
      };
    }, // delay

    animate: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animateImpl( properties, params ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;
        var isCore = !selfIsArrayLike;
        var isEles = !isCore;

        if( !cy.styleEnabled() ){ return this; }

        var callTime = +new Date();
        var style = cy.style();
        var q;
        
        if( params === undefined ){
          params = {};
        }

        if( params.duration === undefined ){
          params.duration = 400;
        }
        
        switch( params.duration ){
        case 'slow':
          params.duration = 600;
          break;
        case 'fast':
          params.duration = 200;
          break;
        }
        
        var propertiesEmpty = true;
        if( properties ){ for( var i in properties ){
          propertiesEmpty = false;
          break;
        } }

        if( propertiesEmpty ){
          return this; // nothing to animate
        }

        if( properties.css && isEles ){
          properties.css = style.getValueStyle( properties.css, { array: true } );
        }

        if( properties.renderedPosition && isEles ){
          var rpos = properties.renderedPosition;
          var pan = cy.pan();
          var zoom = cy.zoom();

          properties.position = {
            x: ( rpos.x - pan.x ) /zoom,
            y: ( rpos.y - pan.y ) /zoom
          };
        }

        // override pan w/ panBy if set
        if( properties.panBy && isCore ){
          var panBy = properties.panBy;
          var cyPan = cy.pan();

          properties.pan = {
            x: cyPan.x + panBy.x,
            y: cyPan.y + panBy.y
          };
        }

        // override pan w/ center if set
        var center = properties.center || properties.centre;
        if( center && isCore ){
          var centerPan = cy.getCenterPan( center.eles, properties.zoom );

          if( centerPan ){
            properties.pan = centerPan;
          }
        }

        // override pan & zoom w/ fit if set
        if( properties.fit && isCore ){
          var fit = properties.fit;
          var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

          if( fitVp ){
            properties.pan = fitVp.pan; //{ x: fitVp.pan.x, y: fitVp.pan.y };
            properties.zoom = fitVp.zoom;
          }
        }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
         
          if( ele.animated() && (params.queue === undefined || params.queue) ){
            q = ele._private.animation.queue;
          } else {
            q = ele._private.animation.current;
          }

          q.push({
            properties: properties,
            duration: params.duration,
            params: params,
            callTime: callTime
          });
        }

        if( isEles ){
          cy.addToAnimationPool( this );
        }

        return this; // chaining
      };
    }, // animate

    stop: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function stopImpl( clearQueue, jumpToEnd ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          var anis = ele._private.animation.current;

          for( var j = 0; j < anis.length; j++ ){
            var animation = anis[j];    
            if( jumpToEnd ){
              // next iteration of the animation loop, the animation
              // will go straight to the end and be removed
              animation.duration = 0; 
            }
          }
          
          // clear the queue of future animations
          if( clearQueue ){
            ele._private.animation.queue = [];
          }

          if( !jumpToEnd ){
            ele._private.animation.current = [];
          }
        }
        
        // we have to notify (the animation loop doesn't do it for us on `stop`)
        cy.notify({
          collection: this,
          type: 'draw'
        });
        
        return this;
      };
    } // stop

  }; // define

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.selector = function(map, options){
    for( var name in map ){
      var fn = map[name];
      $$.Selector.prototype[ name ] = fn;
    }
  };

  $$.Selector = function(onlyThisGroup, selector){
    
    if( !(this instanceof $$.Selector) ){
      return new $$.Selector(onlyThisGroup, selector);
    }
  
    if( selector === undefined && onlyThisGroup !== undefined ){
      selector = onlyThisGroup;
      onlyThisGroup = undefined;
    }
    
    var self = this;
    
    self._private = {
      selectorText: null,
      invalid: true
    };
    
    if( !selector || ( $$.is.string(selector) && selector.match(/^\s*$/) ) ){
      
      if( onlyThisGroup == null ){
        // ignore
        self.length = 0;
      } else {
        self[0] = newQuery();
        self[0].group = onlyThisGroup;
        self.length = 1;
      }
              
    } else if( $$.is.element( selector ) ){
      var collection = new $$.Collection(self.cy(), [ selector ]);
      
      self[0] = newQuery();
      self[0].collection = collection;
      self.length = 1;
      
    } else if( $$.is.collection( selector ) ){
      self[0] = newQuery();
      self[0].collection = selector;
      self.length = 1;
      
    } else if( $$.is.fn( selector ) ) {
      self[0] = newQuery();
      self[0].filter = selector;
      self.length = 1;
      
    } else if( $$.is.string( selector ) ){

      // the current subject in the query
      var currentSubject = null;
      
      // storage for parsed queries
      var newQuery = function(){
        return {
          classes: [], 
          colonSelectors: [],
          data: [],
          group: null,
          ids: [],
          meta: [],

          // fake selectors
          collection: null, // a collection to match against
          filter: null, // filter function

          // these are defined in the upward direction rather than down (e.g. child)
          // because we need to go up in Selector.filter()
          parent: null, // parent query obj
          ancestor: null, // ancestor query obj
          subject: null, // defines subject in compound query (subject query obj; points to self if subject)

          // use these only when subject has been defined
          child: null,
          descendant: null
        };
      };

      // tokens in the query language
      var tokens = {
        metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
        comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
        boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
        string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
        number: $$.util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
        meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from $$.Collection)
        separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
        descendant: '\\s+',
        child: '\\s+>\\s+',
        subject: '\\$'
      };
      tokens.variable = '(?:[\\w-]|(?:\\\\'+ tokens.metaChar +'))+'; // a variable name
      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
      tokens.className = tokens.variable; // a class name (follows variable conventions)
      tokens.id = tokens.variable; // an element id (follows variable conventions)

      // when a token like a variable has escaped meta characters, we need to clean the backslashes out
      // so that values get compared properly in Selector.filter()
      var cleanMetaChars = function(str){
        return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){
          return $1;
        });
      };
      
      // add @ variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];
        tokens.comparatorOp += '|@' + op;
      }

      // add ! variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];

        if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !
        if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

        tokens.comparatorOp += '|\\!' + op;
      }

      // NOTE: add new expression syntax here to have it recognised by the parser;
      // - a query contains all adjacent (i.e. no separator in between) expressions;
      // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
      // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
      // - when you add something here, also add to Selector.toString()
      var exprs = {
        group: {
          query: true,
          regex: '(node|edge|\\*)',
          populate: function( group ){
            this.group = group == "*" ? group : group + 's';
          }
        },
        
        state: {
          query: true,
          // NB: if one colon selector is a substring of another from its start, place the longer one first
          // e.g. :foobar|:foo
          regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch)',
          populate: function( state ){
            this.colonSelectors.push( state );
          }
        },
        
        id: {
          query: true,
          regex: '\\#('+ tokens.id +')',
          populate: function( id ){
            this.ids.push( cleanMetaChars(id) );
          }
        },
        
        className: {
          query: true,
          regex: '\\.('+ tokens.className +')',
          populate: function( className ){
            this.classes.push( cleanMetaChars(className) );
          }
        },
        
        dataExists: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( variable ){
            this.data.push({
              field: cleanMetaChars(variable)
            });
          }
        },
        
        dataCompare: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.value +')\\s*\\]',
          populate: function( variable, comparatorOp, value ){ 
            var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

            if( valueIsString ){
              value = value.substring(1, value.length - 1);
            } else {
              value = parseFloat(value);
            }

            this.data.push({
              field: cleanMetaChars(variable),
              operator: comparatorOp,
              value: value
            });
          }
        },
        
        dataBool: {
          query: true,
          regex: '\\[\\s*('+ tokens.boolOp +')\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( boolOp, variable ){
            this.data.push({
              field: cleanMetaChars(variable),
              operator: boolOp
            });
          }
        },
        
        metaCompare: {
          query: true,
          regex: '\\[\\[\\s*('+ tokens.meta +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.number +')\\s*\\]\\]',
          populate: function( meta, comparatorOp, number ){
            this.meta.push({
              field: cleanMetaChars(meta),
              operator: comparatorOp,
              value: parseFloat(number)
            });
          }
        },

        nextQuery: {
          separator: true,
          regex: tokens.separator,
          populate: function(){
            // go on to next query
            self[++i] = newQuery();
            currentSubject = null;
          }
        },

        child: {
          separator: true,
          regex: tokens.child,
          populate: function(){
            // this query is the parent of the following query
            var childQuery = newQuery();
            childQuery.parent = this;
            childQuery.subject = currentSubject;

            // we're now populating the child query with expressions that follow
            self[i] = childQuery;
          }
        },

        descendant: {
          separator: true,
          regex: tokens.descendant,
          populate: function(){
            // this query is the ancestor of the following query
            var descendantQuery = newQuery();
            descendantQuery.ancestor = this;
            descendantQuery.subject = currentSubject;

            // we're now populating the descendant query with expressions that follow
            self[i] = descendantQuery;
          }
        },

        subject: {
          modifier: true,
          regex: tokens.subject,
          populate: function(){
            if( currentSubject != null && this.subject != this ){
              $$.util.error('Redefinition of subject in selector `' + selector + '`');
              return false;
            }

            currentSubject = this;
            this.subject = this;
          }

        }
      };

      var j = 0;
      for( var name in exprs ){
        exprs[j] = exprs[name];
        exprs[j].name = name;

        j++;
      }
      exprs.length = j;

      self._private.selectorText = selector;
      var remaining = selector;
      var i = 0;
      
      // of all the expressions, find the first match in the remaining text
      var consumeExpr = function( expectation ){
        var expr;
        var match;
        var name;
        
        for( var j = 0; j < exprs.length; j++ ){
          var e = exprs[j];
          var n = e.name;

          // ignore this expression if it doesn't meet the expectation function
          if( $$.is.fn( expectation ) && !expectation(n, e) ){ continue; }

          var m = remaining.match(new RegExp( '^' + e.regex ));
          
          if( m != null ){
            match = m;
            expr = e;
            name = n;
            
            var consumed = m[0];
            remaining = remaining.substring( consumed.length );                
            
            break; // we've consumed one expr, so we can return now
          }
        }
        
        return {
          expr: expr,
          match: match,
          name: name
        };
      };
      
      // consume all leading whitespace
      var consumeWhitespace = function(){
        var match = remaining.match(/^\s+/);
        
        if( match ){
          var consumed = match[0];
          remaining = remaining.substring( consumed.length );
        }
      };
      
      self[0] = newQuery(); // get started

      consumeWhitespace(); // get rid of leading whitespace
      for(;;){        
        var check = consumeExpr();
        
        if( check.expr == null ){
          $$.util.error('The selector `'+ selector +'`is invalid');
          return;
        } else {
          var args = [];
          for(var j = 1; j < check.match.length; j++){
            args.push( check.match[j] );
          }
          
          // let the token populate the selector object (i.e. in self[i])
          var ret = check.expr.populate.apply( self[i], args );

          if( ret === false ){ return; } // exit if population failed
        }
        
        // we're done when there's nothing left to parse
        if( remaining.match(/^\s*$/) ){
          break;
        }
      }
      
      self.length = i + 1;

      // adjust references for subject
      for(j = 0; j < self.length; j++){
        var query = self[j];

        if( query.subject != null ){
          // go up the tree until we reach the subject
          for(;;){
            if( query.subject == query ){ break; } // done if subject is self

            if( query.parent != null ){ // swap parent/child reference
              var parent = query.parent;
              var child = query;

              child.parent = null;
              parent.child = child;

              query = parent; // go up the tree
            } else if( query.ancestor != null ){ // swap ancestor/descendant
              var ancestor = query.ancestor;
              var descendant = query;

              descendant.ancestor = null;
              ancestor.descendant = descendant;

              query = ancestor; // go up the tree
            } else {
              $$.util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');
              break;
            }
          } // for

          self[j] = query.subject; // subject should be the root query
        } // if
      } // for

      // make sure for each query that the subject group matches the implicit group if any
      if( onlyThisGroup != null ){
        for(var j = 0; j < self.length; j++){
          if( self[j].group != null && self[j].group != onlyThisGroup ){
            $$.util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');
            return;
          }

          self[j].group = onlyThisGroup; // set to implicit group
        }
      }
      
    } else {
      $$.util.error('A selector must be created from a string; found ' + selector);
      return;
    }

    self._private.invalid = false;
    
  };

  $$.selfn = $$.Selector.prototype;
  
  $$.selfn.size = function(){
    return this.length;
  };
  
  $$.selfn.eq = function(i){
    return this[i];
  };
  
  // get elements from the core and then filter them
  $$.selfn.find = function(){
    // TODO impl if we decide to use a DB for storing elements
  };
  
  var queryMatches = function(query, element){
    // check group
    if( query.group != null && query.group != '*' && query.group != element._private.group ){
      return false;
    }

    var cy = element.cy();
    
    // check colon selectors
    var allColonSelectorsMatch = true;
    for(var k = 0; k < query.colonSelectors.length; k++){
      var sel = query.colonSelectors[k];
      
      switch(sel){
      case ':selected':
        allColonSelectorsMatch = element.selected();
        break;
      case ':unselected':
        allColonSelectorsMatch = !element.selected();
        break;
      case ':selectable':
        allColonSelectorsMatch = element.selectable();
        break;
      case ':unselectable':
        allColonSelectorsMatch = !element.selectable();
        break;
      case ':locked':
        allColonSelectorsMatch = element.locked();
        break;
      case ':unlocked':
        allColonSelectorsMatch = !element.locked();
        break;
      case ':visible':
        allColonSelectorsMatch = element.visible();
        break;
      case ':hidden':
        allColonSelectorsMatch = !element.visible();
        break;
      case ':transparent':
        allColonSelectorsMatch = element.transparent();
        break;
      case ':grabbed':
        allColonSelectorsMatch = element.grabbed();
        break;
      case ':free':
        allColonSelectorsMatch = !element.grabbed();
        break;
      case ':removed':
        allColonSelectorsMatch = element.removed();
        break;
      case ':inside':
        allColonSelectorsMatch = !element.removed();
        break;
      case ':grabbable':
        allColonSelectorsMatch = element.grabbable();
        break;
      case ':ungrabbable':
        allColonSelectorsMatch = !element.grabbable();
        break;
      case ':animated':
        allColonSelectorsMatch = element.animated();
        break;
      case ':unanimated':
        allColonSelectorsMatch = !element.animated();
        break;
      case ':parent':
        allColonSelectorsMatch = element.isNode() && element.children().nonempty();
        break;
      case ':child':
      case ':nonorphan':
        allColonSelectorsMatch = element.isNode() && element.parent().nonempty();
        break;
      case ':orphan':
        allColonSelectorsMatch = element.isNode() && element.parent().empty();
        break;
      case ':loop':
        allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');
        break;
      case ':simple':
        allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');
        break;
      case ':active':
        allColonSelectorsMatch = element.active();
        break;
      case ':inactive':
        allColonSelectorsMatch = !element.active();
        break;
      case ':touch':
        allColonSelectorsMatch = $$.is.touch();
        break;
      }
      
      if( !allColonSelectorsMatch ) break;
    }
    if( !allColonSelectorsMatch ) return false;
    
    // check id
    var allIdsMatch = true;
    for(var k = 0; k < query.ids.length; k++){
      var id = query.ids[k];
      var actualId = element._private.data.id;
      
      allIdsMatch = allIdsMatch && (id == actualId);
      
      if( !allIdsMatch ) break;
    }
    if( !allIdsMatch ) return false;
    
    // check classes
    var allClassesMatch = true;
    for(var k = 0; k < query.classes.length; k++){
      var cls = query.classes[k];
      
      allClassesMatch = allClassesMatch && element.hasClass(cls);
      
      if( !allClassesMatch ) break;
    }
    if( !allClassesMatch ) return false;
    
    // generic checking for data/metadata
    var operandsMatch = function(params){
      var allDataMatches = true;
      for(var k = 0; k < query[params.name].length; k++){
        var data = query[params.name][k];
        var operator = data.operator;
        var value = data.value;
        var field = data.field;
        var matches;
        
        if( operator != null && value != null ){
          
          var fieldVal = params.fieldValue(field);
          var fieldStr = !$$.is.string(fieldVal) && !$$.is.number(fieldVal) ? '' : '' + fieldVal;
          var valStr = '' + value;
          
          var caseInsensitive = false;
          if( operator.indexOf('@') >= 0 ){
            fieldStr = fieldStr.toLowerCase();
            valStr = valStr.toLowerCase();
            
            operator = operator.replace('@', '');
            caseInsensitive = true;
          }

          var notExpr = false;
          var handledNotExpr = false;
          if( operator.indexOf('!') >= 0 ){
            operator = operator.replace('!', '');
            notExpr = true;
          }
          
          // if we're doing a case insensitive comparison, then we're using a STRING comparison
          // even if we're comparing numbers
          if( caseInsensitive ){
            value = valStr.toLowerCase();
            fieldVal = fieldStr.toLowerCase();
          }

          switch(operator){
          case '*=':
            matches = fieldStr.search(valStr) >= 0;
            break;
          case '$=':
            matches = new RegExp(valStr + '$').exec(fieldStr) != null;
            break;
          case '^=':
            matches = new RegExp('^' + valStr).exec(fieldStr) != null;
            break;
          case '=':
            matches = fieldVal === value;
            break;
          case '!=':
            matches = fieldVal !== value;
            break;
          case '>':
            matches = !notExpr ? fieldVal > value : fieldVal <= value;
            handledNotExpr = true;
            break;
          case '>=':
            matches = !notExpr ? fieldVal >= value : fieldVal < value;
            handledNotExpr = true;
            break;
          case '<':
            matches = !notExpr ? fieldVal < value : fieldVal >= value;
            handledNotExpr = true;
            break;
          case '<=':
            matches = !notExpr ? fieldVal <= value : fieldVal > value;
            handledNotExpr = true;
            break;
          default:
            matches = false;
            break;
            
          }
        } else if( operator != null ){
          switch(operator){
          case '?':
            matches = params.fieldTruthy(field);
            break;
          case '!':
            matches = !params.fieldTruthy(field);
            break;
          case '^':
            matches = params.fieldUndefined(field);
            break;
          }
        } else {   
          matches = !params.fieldUndefined(field);
        }

        if( notExpr && !handledNotExpr ){
          matches = !matches;
          handledNotExpr = true;
        }
        
        if( !matches ){
          allDataMatches = false;
          break;
        }
      } // for
      
      return allDataMatches;
    }; // operandsMatch
    
    // check data matches
    var allDataMatches = operandsMatch({
      name: 'data',
      fieldValue: function(field){
        return element._private.data[field];
      },
      fieldRef: function(field){
        return 'element._private.data.' + field;
      },
      fieldUndefined: function(field){
        return element._private.data[field] === undefined;
      },
      fieldTruthy: function(field){
        if( element._private.data[field] ){
          return true;
        }
        return false;
      }
    });
    
    if( !allDataMatches ){
      return false;
    }
    
    // check metadata matches
    var allMetaMatches = operandsMatch({
      name: 'meta',
      fieldValue: function(field){
        return element[field]();
      },
      fieldRef: function(field){
        return 'element.' + field + '()';
      },
      fieldUndefined: function(field){
        return element[field]() == null;
      },
      fieldTruthy: function(field){
        if( element[field]() ){
          return true;
        }
        return false;
      }
    });
    
    if( !allMetaMatches ){
      return false;
    }
    
    // check collection
    if( query.collection != null ){
      var matchesAny = query.collection._private.ids[ element.id() ] != null;
      
      if( !matchesAny ){
        return false;
      }
    }
    
    // check filter function
    if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){
      return false;
    }
    

    // check parent/child relations
    var confirmRelations = function( query, elements ){
      if( query != null ){
        var matches = false;

        if( !cy.hasCompoundNodes() ){
          return false;
        }

        elements = elements(); // make elements functional so we save cycles if query == null

        // query must match for at least one element (may be recursive)
        for(var i = 0; i < elements.length; i++){
          if( queryMatches( query, elements[i] ) ){
            matches = true;
            break;
          }
        }

        return matches;
      } else {
        return true;
      }
    };

    if (! confirmRelations(query.parent, function(){
      return element.parent();
    }) ){ return false; }

    if (! confirmRelations(query.ancestor, function(){
      return element.parents();
    }) ){ return false; }

    if (! confirmRelations(query.child, function(){
      return element.children();
    }) ){ return false; }

    if (! confirmRelations(query.descendant, function(){
      return element.descendants();
    }) ){ return false; }

    // we've reached the end, so we've matched everything for this query
    return true;
  }; // queryMatches

  // filter an existing collection
  $$.selfn.filter = function(collection){
    var self = this;
    var cy = collection.cy();
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return new $$.Collection( cy );
    }
  
    var selectorFunction = function(i, element){
      for(var j = 0; j < self.length; j++){
        var query = self[j];
        
        if( queryMatches(query, element) ){
          return true;
        }
      }
      
      return false;
    };
    
    if( self._private.selectorText == null ){
      selectorFunction = function(){ return true; };
    }
    
    var filteredCollection = collection.filter( selectorFunction );
    
    return filteredCollection;
  }; // filter

  // does selector match a single element?
  $$.selfn.matches = function(ele){
    var self = this;
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return false;
    }
  
    for(var j = 0; j < self.length; j++){
      var query = self[j];
      
      if( queryMatches(query, ele) ){
        return true;
      }
    }
    
    return false;
  }; // filter
  
  // ith query to string
  $$.selfn.toString = $$.selfn.selector = function(){
    
    var str = '';
    
    var clean = function(obj, isValue){
      if( $$.is.string(obj) ){
        return isValue ? '"' + obj + '"' : obj;
      } 
      return '';
    };
    
    var queryToString = function(query){
      var str = '';

      if( query.subject === query ){
        str += '$';
      }

      var group = clean(query.group);
      str += group.substring(0, group.length - 1);
      
      for(var j = 0; j < query.data.length; j++){
        var data = query.data[j];
        
        if( data.value ){
          str += '[' + data.field + clean(data.operator) + clean(data.value, true) + ']';
        } else {
          str += '[' + clean(data.operator) + data.field + ']';
        }
      }

      for(var j = 0; j < query.meta.length; j++){
        var meta = query.meta[j];
        str += '[[' + meta.field + clean(meta.operator) + clean(meta.value, true) + ']]';
      }
      
      for(var j = 0; j < query.colonSelectors.length; j++){
        var sel = query.colonSelectors[i];
        str += sel;
      }
      
      for(var j = 0; j < query.ids.length; j++){
        var sel = '#' + query.ids[i];
        str += sel;
      }
      
      for(var j = 0; j < query.classes.length; j++){
        var sel = '.' + query.classes[i];
        str += sel;
      }

      if( query.parent != null ){
        str = queryToString( query.parent ) + ' > ' + str; 
      }

      if( query.ancestor != null ){
        str = queryToString( query.ancestor ) + ' ' + str; 
      }

      if( query.child != null ){
        str += ' > ' + queryToString( query.child ); 
      }

      if( query.descendant != null ){
        str += ' ' + queryToString( query.descendant ); 
      }

      return str;
    };

    for(var i = 0; i < this.length; i++){
      var query = this[i];
      
      str += queryToString( query );
      
      if( this.length > 1 && i < this.length - 1 ){
        str += ', ';
      }
    }
    
    return str;
  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.Style = function( cy ){

    if( !(this instanceof $$.Style) ){
      return new $$.Style(cy);
    }

    if( !$$.is.core(cy) ){
      $$.util.error('A style must have a core reference');
      return;
    }

    this._private = {
      cy: cy,
      coreStyle: {},
      newStyle: true
    };
    
    this.length = 0;

    this.addDefaultStylesheet();
  };

  // nice-to-have aliases
  $$.style = $$.Style;
  $$.styfn = $$.Style.prototype;

  // define functions in the Style prototype
  $$.fn.style = function( fnMap, options ){
    for( var fnName in fnMap ){
      var fn = fnMap[ fnName ];
      $$.Style.prototype = fn;
    }
  };

  (function(){
    var number = $$.util.regex.number;
    var rgba = $$.util.regex.rgbaNoBackRefs;
    var hsla = $$.util.regex.hslaNoBackRefs;
    var hex3 = $$.util.regex.hex3;
    var hex6 = $$.util.regex.hex6;
    var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
    var mapData = function( prefix ){ return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\s*\\,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\)$'; };

    // each visual style property has a type and needs to be validated according to it
    $$.style.types = {
      time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
      percent: { number: true, min: 0, max: 100, units: '%' },
      zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
      nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
      nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
      position: { enums: ['parent', 'origin'] },
      autoSize: { number: true, min: 0, enums: ['auto'] },
      number: { number: true },
      size: { number: true, min: 0 },
      bgSize: { number: true, min: 0, allowPercent: true },
      bgPos: { number: true, allowPercent: true },
      bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },
      bgFit: { enums: ['none', 'contain', 'cover'] },
      bgClip: { enums: ['none', 'node'] },
      color: { color: true },
      lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
      borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
      curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack'] },
      fontFamily: { regex: '^([\\w- ]+(?:\\s*,\\s*[\\w- ]+)*)$' },
      fontVariant: { enums: ['small-caps', 'normal'] },
      fontStyle: { enums: ['italic', 'normal', 'oblique'] },
      fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
      textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
      textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
      nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star'] },
      arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'square', 'circle', 'diamond', 'none'] },
      arrowFill: { enums: ['filled', 'hollow'] },
      display: { enums: ['element', 'none'] },
      visibility: { enums: ['hidden', 'visible'] },
      valign: { enums: ['top', 'center', 'bottom'] },
      halign: { enums: ['left', 'center', 'right'] },
      text: { string: true },
      data: { mapping: true, regex: data('data') },
      layoutData: { mapping: true, regex: data('layoutData') },
      mapData: { mapping: true, regex: mapData('mapData') },
      mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
      url: { regex: '^url\\s*\\(\\s*([^\\s]+)\\s*\\s*\\)|none|(.+)$' },
      propList: { propList: true },
      angle: { number: true, units: 'deg|rad' }
    };

    // define visual style properties
    var t = $$.style.types;
    var props = $$.style.properties = [
      // labels
      { name: 'text-valign', type: t.valign },
      { name: 'text-halign', type: t.halign },
      { name: 'color', type: t.color },
      { name: 'content', type: t.text },
      { name: 'text-outline-color', type: t.color },
      { name: 'text-outline-width', type: t.size },
      { name: 'text-outline-opacity', type: t.zeroOneNumber },
      { name: 'text-opacity', type: t.zeroOneNumber },
      // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
      { name: 'text-transform', type: t.textTransform },
      // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes
      { name: 'font-family', type: t.fontFamily },
      { name: 'font-style', type: t.fontStyle },
      // { name: 'font-variant', type: t.fontVariant }, // not useful
      { name: 'font-weight', type: t.fontWeight },
      { name: 'font-size', type: t.size },
      { name: 'min-zoomed-font-size', type: t.size },

      // visibility
      { name: 'display', type: t.display },
      { name: 'visibility', type: t.visibility },
      { name: 'opacity', type: t.zeroOneNumber },
      { name: 'z-index', type: t.nonNegativeInt },

      // overlays
      { name: 'overlay-padding', type: t.size },
      { name: 'overlay-color', type: t.color },
      { name: 'overlay-opacity', type: t.zeroOneNumber },

      // transition anis
      { name: 'transition-property', type: t.propList },
      { name: 'transition-duration', type: t.time },
      { name: 'transition-delay', type: t.time },

      // node body
      { name: 'height', type: t.autoSize },
      { name: 'width', type: t.autoSize },
      { name: 'shape', type: t.nodeShape },
      { name: 'background-color', type: t.color },
      { name: 'background-opacity', type: t.zeroOneNumber },
      { name: 'background-blacken', type: t.nOneOneNumber },

      // node border
      { name: 'border-color', type: t.color },
      { name: 'border-opacity', type: t.zeroOneNumber },
      { name: 'border-width', type: t.size },
      { name: 'border-style', type: t.borderStyle },
      
      // node background images
      { name: 'background-image', type: t.url },
      { name: 'background-image-opacity', type: t.zeroOneNumber },
      { name: 'background-position-x', type: t.bgPos },
      { name: 'background-position-y', type: t.bgPos },
      { name: 'background-repeat', type: t.bgRepeat },
      { name: 'background-fit', type: t.bgFit },
      { name: 'background-clip', type: t.bgClip },

      // compound props
      { name: 'padding-left', type: t.size },
      { name: 'padding-right', type: t.size },
      { name: 'padding-top', type: t.size },
      { name: 'padding-bottom', type: t.size },
      { name: 'position', type: t.position },

      // edge line
      { name: 'line-style', type: t.lineStyle },
      { name: 'line-color', type: t.color },
      { name: 'control-point-step-size', type: t.size },
      { name: 'control-point-distance', type: t.number },
      { name: 'control-point-weight', type: t.zeroOneNumber },
      { name: 'curve-style', type: t.curveStyle },
      { name: 'haystack-radius', type: t.zeroOneNumber },

      // edge arrows
      { name: 'source-arrow-shape', type: t.arrowShape },
      { name: 'target-arrow-shape', type: t.arrowShape },
      { name: 'mid-source-arrow-shape', type: t.arrowShape },
      { name: 'mid-target-arrow-shape', type: t.arrowShape },
      { name: 'source-arrow-color', type: t.color },
      { name: 'target-arrow-color', type: t.color },
      { name: 'mid-source-arrow-color', type: t.color },
      { name: 'mid-target-arrow-color', type: t.color },
      { name: 'source-arrow-fill', type: t.arrowFill },
      { name: 'target-arrow-fill', type: t.arrowFill },
      { name: 'mid-source-arrow-fill', type: t.arrowFill },
      { name: 'mid-target-arrow-fill', type: t.arrowFill },

      // these are just for the core
      { name: 'selection-box-color', type: t.color },
      { name: 'selection-box-opacity', type: t.zeroOneNumber },
      { name: 'selection-box-border-color', type: t.color },
      { name: 'selection-box-border-width', type: t.size },
      { name: 'active-bg-color', type: t.color },
      { name: 'active-bg-opacity', type: t.zeroOneNumber },
      { name: 'active-bg-size', type: t.size },
      { name: 'outside-texture-bg-color', type: t.color },
      { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
    ];

    // pie backgrounds for nodes
    $$.style.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
    props.push({ name: 'pie-size', type: t.bgSize });
    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){
      props.push({ name: 'pie-'+i+'-background-color', type: t.color });
      props.push({ name: 'pie-'+i+'-background-size', type: t.percent });
      props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });
    }

    // allow access of properties by name ( e.g. $$.style.properties.height )
    for( var i = 0; i < props.length; i++ ){
      var prop = props[i];
      
      props[ prop.name ] = prop; // allow lookup by name
    }
  })();

  // adds the default stylesheet to the current style
  $$.styfn.addDefaultStylesheet = function(){
    // to be nice, we build font related style properties from the core container
    // so that cytoscape matches the style of its container by default
    // 
    // unfortunately, this doesn't seem work consistently and can grab the default stylesheet values
    // instead of the developer's values so let's just make it explicit for the dev for now
    //
    // delaying the read of these val's is not an opt'n: that would delay init'l load time
    var fontFamily = 'Helvetica' || this.containerPropertyAsString('font-family') || 'sans-serif';
    var fontStyle = 'normal' || this.containerPropertyAsString('font-style') || 'normal';
    // var fontVariant = 'normal' || this.containerPropertyAsString('font-variant') || 'normal';
    var fontWeight = 'normal' || this.containerPropertyAsString('font-weight') || 'normal';
    var color = '#000' || this.containerPropertyAsString('color') || '#000';
    var textTransform = 'none' || this.containerPropertyAsString('text-transform') || 'none';
    var fontSize = 16 || this.containerPropertyAsString('font-size') || 16;

    // fill the style with the default stylesheet
    this
      .selector('node, edge') // common properties
        .css({
          'text-valign': 'top',
          'text-halign': 'center',
          'color': color,
          'text-outline-color': '#000',
          'text-outline-width': 0,
          'text-outline-opacity': 1,
          'text-opacity': 1,
          'text-decoration': 'none',
          'text-transform': textTransform,
          'font-family': fontFamily,
          'font-style': fontStyle,
          // 'font-variant': fontVariant,
          'font-weight': fontWeight,
          'font-size': fontSize,
          'min-zoomed-font-size': 0,
          'visibility': 'visible',
          'display': 'element',
          'opacity': 1,
          'z-index': 0,
          'content': '',
          'overlay-opacity': 0,
          'overlay-color': '#000',
          'overlay-padding': 10,
          'transition-property': 'none',
          'transition-duration': 0,
          'transition-delay': 0,

          // node props
          'background-blacken': 0,
          'background-color': '#888',
          'background-opacity': 1,
          'background-image': 'none',
          'background-image-opacity': 1,
          'background-position-x': '50%',
          'background-position-y': '50%',
          'background-repeat': 'no-repeat',
          'background-fit': 'none',
          'background-clip': 'node',
          'border-color': '#000',
          'border-opacity': 1,
          'border-width': 0,
          'border-style': 'solid',
          'height': 30,
          'width': 30,
          'shape': 'ellipse',

          // compound props
          'padding-top': 0,
          'padding-bottom': 0,
          'padding-left': 0,
          'padding-right': 0,
          'position': 'origin',
          

          // node pie bg
          'pie-size': '100%',
          'pie-1-background-color': 'black',
          'pie-2-background-color': 'black',
          'pie-3-background-color': 'black',
          'pie-4-background-color': 'black',
          'pie-5-background-color': 'black',
          'pie-6-background-color': 'black',
          'pie-7-background-color': 'black',
          'pie-8-background-color': 'black',
          'pie-9-background-color': 'black',
          'pie-10-background-color': 'black',
          'pie-11-background-color': 'black',
          'pie-12-background-color': 'black',
          'pie-13-background-color': 'black',
          'pie-14-background-color': 'black',
          'pie-15-background-color': 'black',
          'pie-16-background-color': 'black',
          'pie-1-background-size': '0%',
          'pie-2-background-size': '0%',
          'pie-3-background-size': '0%',
          'pie-4-background-size': '0%',
          'pie-5-background-size': '0%',
          'pie-6-background-size': '0%',
          'pie-7-background-size': '0%',
          'pie-8-background-size': '0%',
          'pie-9-background-size': '0%',
          'pie-10-background-size': '0%',
          'pie-11-background-size': '0%',
          'pie-12-background-size': '0%',
          'pie-13-background-size': '0%',
          'pie-14-background-size': '0%',
          'pie-15-background-size': '0%',
          'pie-16-background-size': '0%',
          'pie-1-background-opacity': 1,
          'pie-2-background-opacity': 1,
          'pie-3-background-opacity': 1,
          'pie-4-background-opacity': 1,
          'pie-5-background-opacity': 1,
          'pie-6-background-opacity': 1,
          'pie-7-background-opacity': 1,
          'pie-8-background-opacity': 1,
          'pie-9-background-opacity': 1,
          'pie-10-background-opacity': 1,
          'pie-11-background-opacity': 1,
          'pie-12-background-opacity': 1,
          'pie-13-background-opacity': 1,
          'pie-14-background-opacity': 1,
          'pie-15-background-opacity': 1,
          'pie-16-background-opacity': 1,

          // edge props
          'source-arrow-shape': 'none',
          'mid-source-arrow-shape': 'none',
          'target-arrow-shape': 'none',
          'mid-target-arrow-shape': 'none',
          'source-arrow-color': '#ddd',
          'mid-source-arrow-color': '#ddd',
          'target-arrow-color': '#ddd',
          'mid-target-arrow-color': '#ddd',
          'source-arrow-fill': 'filled',
          'mid-source-arrow-fill': 'filled',
          'target-arrow-fill': 'filled',
          'mid-target-arrow-fill': 'filled',
          'line-style': 'solid',
          'line-color': '#ddd',
          'control-point-step-size': 40,
          'control-point-weight': 0.5,
          'curve-style': 'bezier',
          'haystack-radius': 0.8
        })
      .selector('$node > node') // compound (parent) node properties
        .css({
          'width': 'auto',
          'height': 'auto',
          'shape': 'rectangle',
          'background-opacity': 0.5,
          'padding-top': 10,
          'padding-right': 10,
          'padding-left': 10,
          'padding-bottom': 10
        })
      .selector('edge') // just edge properties
        .css({
          'width': 1
        })
      .selector(':active')
        .css({
          'overlay-color': 'black',
          'overlay-padding': 10,
          'overlay-opacity': 0.25
        })
      .selector('core') // just core properties
        .css({
          'selection-box-color': '#ddd',
          'selection-box-opacity': 0.65,
          'selection-box-border-color': '#aaa',
          'selection-box-border-width': 1,
          'active-bg-color': 'black',
          'active-bg-opacity': 0.15,
          'active-bg-size': $$.is.touch() ? 40 : 15,
          'outside-texture-bg-color': '#000',
          'outside-texture-bg-opacity': 0.125
        })
    ;

    this.defaultLength = this.length;
  };

  // remove all contexts
  $$.styfn.clear = function(){
    for( var i = 0; i < this.length; i++ ){
      this[i] = undefined;
    }
    this.length = 0;
    this._private.newStyle = true;

    return this; // chaining
  };

  $$.styfn.resetToDefault = function(){
    this.clear();
    this.addDefaultStylesheet();

    return this;
  };

  // builds a style object for the 'core' selector
  $$.styfn.core = function(){
    return this._private.coreStyle;
  };

  // parse a property; return null on invalid; return parsed property otherwise
  // fields :
  // - name : the name of the property
  // - value : the parsed, native-typed value of the property
  // - strValue : a string value that represents the property value in valid css
  // - bypass : true iff the property is a bypass property
  $$.styfn.parse = function( name, value, propIsBypass, propIsFlat ){
    
    name = $$.util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')
    var property = $$.style.properties[ name ];
    var passedValue = value;
    
    if( !property ){ return null; } // return null on property of unknown name
    if( value === undefined || value === null ){ return null; } // can't assign null

    var valueIsString = $$.is.string(value);
    if( valueIsString ){ // trim the value to make parsing easier
      value = $$.util.trim( value );
    }

    var type = property.type;
    if( !type ){ return null; } // no type, no luck

    // check if bypass is null or empty string (i.e. indication to delete bypass property)
    if( propIsBypass && (value === '' || value === null) ){
      return {
        name: name,
        value: value,
        bypass: true,
        deleteBypass: true
      };
    }

    // check if value is mapped
    var data, mapData, layoutData, mapLayoutData;
    if( !valueIsString || propIsFlat ){
      // then don't bother to do the expensive regex checks

    } else if(
      ( data = new RegExp( $$.style.types.data.regex ).exec( value ) ) ||
      ( layoutData = new RegExp( $$.style.types.layoutData.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass
      
      var isLayout = layoutData !== undefined;
      data = data || layoutData;

      return {
        name: name,
        value: data,
        strValue: '' + value,
        mapped: isLayout ? $$.style.types.layoutData : $$.style.types.data,
        field: data[1],
        bypass: propIsBypass,
        hasPie: name.match(/pie-(\d+)-background-size/)
      };

    } else if(
      ( mapData = new RegExp( $$.style.types.mapData.regex ).exec( value ) ) ||
      ( mapLayoutData = new RegExp( $$.style.types.mapLayoutData.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass

      var isLayout = mapLayoutData !== undefined;
      mapData = mapData || mapLayoutData;

      // we can map only if the type is a colour or a number
      if( !(type.color || type.number) ){ return false; }

      var valueMin = this.parse( name, mapData[4]); // parse to validate
      if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

      var valueMax = this.parse( name, mapData[5]); // parse to validate
      if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

      // check if valueMin and valueMax are the same
      if( valueMin.value === valueMax.value ){
        return false; // can't make much of a mapper without a range
      
      } else if( type.color ){
        var c1 = valueMin.value;
        var c2 = valueMax.value;
        
        var same = c1[0] === c2[0] // red
          && c1[1] === c2[1] // green
          && c1[2] === c2[2] // blue
          && ( // optional alpha
            c1[3] === c2[3] // same alpha outright
            || (
              (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
              &&
              (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
            )
          )
        ;

        if( same ){ return false; } // can't make a mapper without a range
      }

      return {
        name: name,
        value: mapData,
        strValue: '' + value,
        mapped: isLayout ? $$.style.types.mapLayoutData : $$.style.types.mapData,
        field: mapData[1],
        fieldMin: parseFloat( mapData[2] ), // min & max are numeric
        fieldMax: parseFloat( mapData[3] ),
        valueMin: valueMin.value,
        valueMax: valueMax.value,
        bypass: propIsBypass,
        hasPie: name.match(/pie-(\d+)-background-size/)
      };
    }

    // check the type and return the appropriate object
    if( type.number ){ 
      var units;
      var implicitUnits = 'px'; // not set => px

      if( type.units ){ // use specified units if set
        units = type.units;
      }

      if( type.implicitUnits ){
        implicitUnits = type.implicitUnits;
      }

      if( !type.unitless ){
        if( valueIsString ){
          var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
          if( units ){ unitsRegex = units; } // only allow explicit units if so set 
          var match = value.match( '^(' + $$.util.regex.number + ')(' + unitsRegex + ')?' + '$' );
          
          if( match ){
            value = match[1];
            units = match[2] || implicitUnits;
          }
          
        } else if( !units || type.implicitUnits ) {
          units = implicitUnits; // implicitly px if unspecified
        }
      }

      value = parseFloat( value );

      // if not a number and enums not allowed, then the value is invalid
      if( isNaN(value) && type.enums === undefined ){
        return null;
      }

      // check if this number type also accepts special keywords in place of numbers
      // (i.e. `left`, `auto`, etc)
      if( isNaN(value) && type.enums !== undefined ){
        value = passedValue;

        for( var i = 0; i < type.enums.length; i++ ){
          var en = type.enums[i];

          if( en === value ){
            return {
              name: name,
              value: value,
              strValue: '' + value,
              bypass: propIsBypass
            };
          }
        }

        return null; // failed on enum after failing on number
      }

      // check if value must be an integer
      if( type.integer && !$$.is.integer(value) ){
        return null;
      }

      // check value is within range
      if( (type.min !== undefined && value < type.min) 
      || (type.max !== undefined && value > type.max)
      ){
        return null;
      }

      var ret = {
        name: name,
        value: value,
        strValue: '' + value + (units ? units : ''),
        units: units,
        bypass: propIsBypass,
        hasPie: name.match(/pie-(\d+)-background-size/) && value != null && value !== 0 && value !== ''
      };

      // normalise value in pixels
      if( type.unitless || (units !== 'px' && units !== 'em') ){
        // then pxValue does not apply
      } else {
        ret.pxValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
      }

      // normalise value in ms
      if( units === 'ms' || units === 's' ){
        ret.msValue = units === 'ms' ? value : 1000 * value;
      }

      return ret;

    } else if( type.propList ) {

      var props = [];
      var propsStr = '' + value;      
 
      if( propsStr === 'none' ){
        // leave empty

      } else { // go over each prop

        var propsSplit = propsStr.split(',');
        for( var i = 0; i < propsSplit.length; i++ ){
          var propName = $$.util.trim( propsSplit[i] );

          if( $$.style.properties[propName] ){
            props.push( propName );
          }
        }

        if( props.length === 0 ){ return null; }

      }

      return {
        name: name,
        value: props,
        strValue: props.length === 0 ? 'none' : props.join(', '),
        bypass: propIsBypass
      };

    } else if( type.color ){
      var tuple = $$.util.color2tuple( value );

      if( !tuple ){ return null; }

      return {
        name: name,
        value: tuple,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else if( type.enums ){
      for( var i = 0; i < type.enums.length; i++ ){
        var en = type.enums[i];

        if( en === value ){
          return {
            name: name,
            value: value,
            strValue: '' + value,
            bypass: propIsBypass
          };
        }
      }

      return null;

    } else if( type.regex ){
      var regex = new RegExp( type.regex ); // make a regex from the type
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      } else { // regex doesn't match
        return null; // didn't match the regex so the value is bogus
      }

    } else if( type.string ){
      // just return
      return {
        name: name,
        value: value,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else {
      return null; // not a type we can handle
    }

  };

  // create a new context from the specified selector string and switch to that context
  $$.styfn.selector = function( selectorStr ){
    // 'core' is a special case and does not need a selector
    var selector = selectorStr === 'core' ? null : new $$.Selector( selectorStr );

    var i = this.length++; // new context means new index
    this[i] = {
      selector: selector,
      properties: [],
      mappedProperties: [],
      index: i
    };

    return this; // chaining
  };

  // add one or many css rules to the current context
  $$.styfn.css = function(){
    var args = arguments;

    switch( args.length ){
    case 1:
      var map = args[0];

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          this.cssRule( prop.name, mapVal );
        }
      }

      break;

    case 2:
      this.cssRule( args[0], args[1] );
      break;

    default:
      break; // do nothing if args are invalid
    }

    return this; // chaining
  };

  // add a single css rule to the current context
  $$.styfn.cssRule = function( name, value ){ 
    // name-value pair
    var property = this.parse( name, value );

    // add property to current context if valid
    if( property ){
      var i = this.length - 1;
      this[i].properties.push( property );
      this[i].properties[ property.name ] = property; // allow access by name as well

      if( property.hasPie ){
        this._private.hasPie = true;
      }

      if( property.mapped ){
        this[i].mappedProperties.push( property );
      }

      // add to core style if necessary
      var currentSelectorIsCore = !this[i].selector;
      if( currentSelectorIsCore ){
        this._private.coreStyle[ property.name ] = property;
      }
    }

    return this; // chaining
  };

})( cytoscape );
;(function($$){ 'use strict';

  // (potentially expensive calculation)
  // apply the style to the element based on
  // - its bypass
  // - what selectors match it
  $$.styfn.apply = function( eles ){
    var self = this;

    if( self._private.newStyle ){ // clear style caches
      this._private.contextStyles = {};
      this._private.propDiffs = {};
    }

    for( var ie = 0; ie < eles.length; ie++ ){
      var ele = eles[ie];
      var cxtMeta = self.getContextMeta( ele );
      var cxtStyle = self.getContextStyle( cxtMeta );
      var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

      self.updateTransitions( ele, app.diffProps );
      self.updateStyleHints( ele );

    } // for elements

    self._private.newStyle = false;
  };

  $$.styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
    var self = this;
    var cache = self._private.propDiffs = self._private.propDiffs || {};
    var dualCxtKey = oldCxtKey + '-' + newCxtKey;
    var cachedVal = cache[dualCxtKey];

    if( cachedVal ){
      return cachedVal;
    }

    var diffProps = [];
    var addedProp = {};

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var oldHasCxt = oldCxtKey[i] === 't';
      var newHasCxt = newCxtKey[i] === 't';
      var cxtHasDiffed = oldHasCxt !== newHasCxt;
      var cxtHasMappedProps = cxt.mappedProperties.length > 0;

      if( cxtHasDiffed || cxtHasMappedProps ){
        var props;

        if( cxtHasDiffed && cxtHasMappedProps ){
          props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
        } else if( cxtHasDiffed ){
          props = cxt.properties; // need to check them all
        } else if( cxtHasMappedProps ){
          props = cxt.mappedProperties; // only need to check mapped
        }

        for( var j = 0; j < props.length; j++ ){
          var prop = props[j];
          var name = prop.name;

          // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
          // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
          // is cached)
          var laterCxtOverrides = false; 
          for( var k = i + 1; k < self.length; k++ ){
            var laterCxt = self[k];
            var hasLaterCxt = newCxtKey[k] === 't';

            if( !hasLaterCxt ){ continue; } // can't override unless the context is active

            laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

            if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
          }

          if( !addedProp[name] && !laterCxtOverrides ){
            addedProp[name] = true;
            diffProps.push( name );
          }
        } // for props
      } // if

    } // for contexts

    cache[ dualCxtKey ] = diffProps;
    return diffProps;
  };

  $$.styfn.getContextMeta = function( ele ){
    var self = this;
    var cxtKey = '';
    var diffProps;
    var prevKey = ele._private.styleCxtKey || '';

    if( self._private.newStyle ){
      prevKey = ''; // since we need to apply all style if a fresh stylesheet
    }

    // get the cxt key
    for( var i = 0; i < self.length; i++ ){
      var context = self[i];
      var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

      if( contextSelectorMatches ){
        cxtKey += 't';
      } else {
        cxtKey += 'f';
      }
    } // for context

    diffProps = self.getPropertiesDiff( prevKey, cxtKey );

    ele._private.styleCxtKey = cxtKey;

    return {
      key: cxtKey,
      diffPropNames: diffProps
    };
  };

  // gets a computed ele style object based on matched contexts
  $$.styfn.getContextStyle = function( cxtMeta ){
    var cxtKey = cxtMeta.key;
    var self = this;
    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

    // if already computed style, returned cached copy
    if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }

    var style = {
      _private: {
        key: cxtKey
      }
    };

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var hasCxt = cxtKey[i] === 't';

      if( !hasCxt ){ continue; }

      for( var j = 0; j < cxt.properties.length; j++ ){
        var prop = cxt.properties[j];
        var styProp = style[ prop.name ] = prop;

        styProp.context = cxt;
      }
    }

    cxtStyles[cxtKey] = style;
    return style;
  };

  $$.styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
    var self = this;
    var diffProps = cxtMeta.diffPropNames;
    var retDiffProps = {};

    for( var i = 0; i < diffProps.length; i++ ){
      var diffPropName = diffProps[i];
      var cxtProp = cxtStyle[ diffPropName ];
      var eleProp = ele._private.style[ diffPropName ];

      // save cycles when the context prop doesn't need to be applied
      if( !cxtProp || eleProp === cxtProp ){ continue; }

      var retDiffProp = retDiffProps[ diffPropName ] = {
        prev: eleProp
      };

      self.applyParsedProperty( ele, cxtProp );

      retDiffProp.next = ele._private.style[ diffPropName ];

      if( retDiffProp.next && retDiffProp.next.bypass ){
        retDiffProp.next = retDiffProp.next.bypassed;
      }
    }

    return {
      diffProps: retDiffProps
    };
  };

  $$.styfn.updateStyleHints = function(ele){
    var _p = ele._private;
    var self = this;
    var style = _p.style;

    // set whether has pie or not; for greater efficiency
    var hasPie = false;
    if( _p.group === 'nodes' && self._private.hasPie ){
      for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
        var size = _p.style['pie-' + i + '-background-size'].value;

        if( size > 0 ){
          hasPie = true;
          break;
        }
      }
    }

    _p.hasPie = hasPie;

    var transform = style['text-transform'].strValue;
    var content = style['content'].strValue;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;
    var valign = style['text-valign'].strValue;
    var halign = style['text-valign'].strValue;
    var oWidth = style['text-outline-width'].pxValue;
    _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth;
    _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;

    var width = style['width'].pxValue;
    var height = style['height'].pxValue;
    var borderW = style['border-width'].pxValue;
    _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;

    if( ele._private.group === 'edges' ){
      var cpss = style['control-point-step-size'].pxValue;
      var cpd = style['control-point-distance'] ? style['control-point-distance'].pxValue : undefined;
      var cpw = style['control-point-weight'].value;
      var curve = style['curve-style'].strValue;
      
      _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ curve;
    }

    _p.styleKey = Date.now(); // probably safe to use applied time and much faster
    // for( var i = 0; i < $$.style.properties.length; i++ ){
    //   var prop = $$.style.properties[i];
    //   var eleProp = _p.style[ prop.name ];
    //   var val = eleProp && eleProp.strValue ? eleProp.strValue : 'undefined';

    //   _p.styleKey += '$' + val;
    // }
  };

  // apply a property to the style (for internal use)
  // returns whether application was successful
  //
  // now, this function flattens the property, and here's how:
  //
  // for parsedProp:{ bypass: true, deleteBypass: true }
  // no property is generated, instead the bypass property in the
  // element's style is replaced by what's pointed to by the `bypassed`
  // field in the bypass property (i.e. restoring the property the
  // bypass was overriding)
  //
  // for parsedProp:{ mapped: truthy }
  // the generated flattenedProp:{ mapping: prop }
  // 
  // for parsedProp:{ bypass: true }
  // the generated flattenedProp:{ bypassed: parsedProp } 
  $$.styfn.applyParsedProperty = function( ele, parsedProp ){
    var prop = parsedProp;
    var style = ele._private.style;
    var fieldVal, flatProp;
    var type = $$.style.properties[ prop.name ].type;
    var propIsBypass = prop.bypass;
    var origProp = style[ prop.name ];
    var origPropIsBypass = origProp && origProp.bypass;

    // can't apply auto to width or height unless it's a parent node
    if( (parsedProp.name === 'height' || parsedProp.name === 'width') && parsedProp.value === 'auto' && ele.isNode() && !ele.isParent() ){
      return false;
    }

    // check if we need to delete the current bypass
    if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete
      var currentProp = style[ prop.name ];

      // can only delete if the current prop is a bypass and it points to the property it was overriding
      if( !currentProp ){
        return true; // property is already not defined
      } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original
        
        // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
        style[ prop.name ] = currentProp.bypassed;
        return true;
      
      } else {
        return false; // we're unsuccessful deleting the bypass
      }
    }

    var printMappingErr = function(){
      $$.util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');
    };

    // put the property in the style objects
    switch( prop.mapped ){ // flatten the property if mapped
    case $$.style.types.mapData:
    case $$.style.types.mapLayoutData:
      
      var isLayout = prop.mapped === $$.style.types.mapLayoutData;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal = isLayout ? ele._private.layoutData : ele._private.data;
      for( var i = 0; i < fields.length && fieldVal; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      }

      var percent;
      if( !$$.is.number(fieldVal) ){ // then keep the mapping but assume 0% for now
        percent = 0;
      } else {
        percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
      }

      // make sure to bound percent value
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( type.color ){
        var r1 = prop.valueMin[0];
        var r2 = prop.valueMax[0];
        var g1 = prop.valueMin[1];
        var g2 = prop.valueMax[1];
        var b1 = prop.valueMin[2];
        var b2 = prop.valueMax[2];
        var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
        var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

        var clr = [
          Math.round( r1 + (r2 - r1)*percent ),
          Math.round( g1 + (g2 - g1)*percent ),
          Math.round( b1 + (b2 - b1)*percent ),
          Math.round( a1 + (a2 - a1)*percent )
        ];

        flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
          bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
          name: prop.name,
          value: clr,
          strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
        };
      
      } else if( type.number ){
        var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
        flatProp = this.parse( prop.name, calcValue, prop.bypass, true );
      
      } else {
        return false; // can only map to colours and numbers
      }

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );
      } 

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    // direct mapping  
    case $$.style.types.data: 
    case $$.style.types.layoutData: 

      var isLayout = prop.mapped === $$.style.types.layoutData;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal = isLayout ? ele._private.layoutData : ele._private.data;
      for( var i = 0; i < fields.length && fieldVal; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      }

      flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        var flatPropVal = origProp ? origProp.strValue : '';

        flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );
      }

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want
      break;

    case undefined:
      break; // just set the property

    default: 
      return false; // not a valid mapping
    }

    // if the property is a bypass property, then link the resultant property to the original one
    if( propIsBypass ){
      if( origPropIsBypass ){ // then this bypass overrides the existing one
        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
      } else { // then link the orig prop to the new bypass
        prop.bypassed = origProp;
      }

      style[ prop.name ] = prop; // and set
    
    } else { // prop is not bypass
      if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
        origProp.bypassed = prop;
      } else { // then just replace the old prop with the new one
        style[ prop.name ] = prop; 
      }
    }

    return true;
  };

  // updates the visual style for all elements (useful for manual style modification after init)
  $$.styfn.update = function(){
    var cy = this._private.cy;
    var eles = cy.elements();

    eles.updateStyle();
  };

  // just update the functional properties (i.e. mappings) in the elements'
  // styles (less expensive than recalculation)
  $$.styfn.updateMappers = function( eles ){
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;

      for( var j = 0; j < $$.style.properties.length; j++ ){ // for each prop
        var prop = $$.style.properties[j];
        var propInStyle = style[ prop.name ];

        if( propInStyle && propInStyle.mapping ){
          var mapping = propInStyle.mapping;
          this.applyParsedProperty( ele, mapping ); // reapply the mapping property
        }
      }

      this.updateStyleHints( ele );
    }
  };

  // diffProps : { name => { prev, next } }
  $$.styfn.updateTransitions = function( ele, diffProps, isBypass ){
    var self = this;
    var style = ele._private.style;

    var props = style['transition-property'].value;
    var duration = style['transition-duration'].msValue;
    var delay = style['transition-delay'].msValue;
    var css = {};

    if( props.length > 0 && duration > 0 ){

      // build up the style to animate towards
      var anyPrev = false;
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        var styProp = style[ prop ];
        var diffProp = diffProps[ prop ];

        if( !diffProp ){ continue; }

        var prevProp = diffProp.prev;
        var fromProp = prevProp;
        var toProp = diffProp.next != null ? diffProp.next : styProp;
        var diff = false;

        if( !fromProp ){ continue; } 

        // consider px values
        if( $$.is.number( fromProp.pxValue ) && $$.is.number( toProp.pxValue ) ){
          diff = fromProp.pxValue !== toProp.pxValue;

        // consider numerical values
        } else if( $$.is.number( fromProp.value ) && $$.is.number( toProp.value ) ){
          diff = fromProp.value !== toProp.value;

        // consider colour values
        } else if( $$.is.array( fromProp.value ) && $$.is.array( toProp.value ) ){
          diff = fromProp.value[0] !== toProp.value[0]
            || fromProp.value[1] !== toProp.value[1]
            || fromProp.value[2] !== toProp.value[2]
          ;
        }

        // the previous value is good for an animation only if it's different
        if( diff ){
          css[ prop ] = toProp.strValue; // to val
          this.applyBypass(ele, prop, fromProp.strValue); // from val
          anyPrev = true;
        }
        
      } // end if props allow ani

      // can't transition if there's nothing previous to transition from
      if( !anyPrev ){ return; }
      
      ele._private.transitioning = true;

      ele.stop();

      if( delay > 0 ){
        ele.delay( delay );
      }

      ele.animate({
        css: css
      }, {
        duration: duration,
        queue: false,
        complete: function(){ 
          if( !isBypass ){
            self.removeBypasses( ele, props );
          }

          ele._private.transitioning = false;
        }
      });

    } else if( ele._private.transitioning ){
      ele.stop();

      this.removeBypasses( ele, props );

      ele._private.transitioning = false;
    }
  }; 

})( cytoscape );
;(function($$){ 'use strict';

  // bypasses are applied to an existing style on an element, and just tacked on temporarily
  // returns true iff application was successful for at least 1 specified property
  $$.styfn.applyBypass = function( eles, name, value, updateTransitions ){
    var props = [];
    var isBypass = true;
    
    // put all the properties (can specify one or many) in an array after parsing them
    if( name === "*" || name === "**" ){ // apply to all property names

      if( value !== undefined ){
        for( var i = 0; i < $$.style.properties.length; i++ ){
          var prop = $$.style.properties[i];
          var name = prop.name;

          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }

    } else if( $$.is.string(name) ){ // then parse the single property
      var parsedProp = this.parse(name, value, true);

      if( parsedProp ){
        props.push( parsedProp );
      }
    } else if( $$.is.plainObject(name) ){ // then parse each property
      var specifiedProps = name;
      updateTransitions = value;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = specifiedProps[ name ];

        if( value === undefined ){ // try camel case name too
          value = specifiedProps[ $$.util.dash2camel(name) ];
        }

        if( value !== undefined ){
          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }
    } else { // can't do anything without well defined properties
      return false;
    }

    // we've failed if there are no valid properties
    if( props.length === 0 ){ return false; }

    // now, apply the bypass properties on the elements
    var ret = false; // return true if at least one succesful bypass applied
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;
      var diffProps = {};
      var diffProp;

      for( var j = 0; j < props.length; j++ ){ // for each prop
        var prop = props[j];

        if( updateTransitions ){
          var prevProp = style[ prop.name ];
          diffProp = diffProps[ prop.name ] = { prev: prevProp };
        }

        ret = this.applyParsedProperty( ele, prop ) || ret;

        if( updateTransitions ){
          diffProp.next = style[ prop.name ];
        }

      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles

    return ret;
  };

  // only useful in specific cases like animation
  $$.styfn.overrideBypass = function( eles, name, value ){
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var prop = ele._private.style[ $$.util.camel2dash(name) ];

      if( !prop.bypass ){ // need a bypass if one doesn't exist
        this.applyBypass( ele, name, value );
        continue;
      }

      prop.value = value;
      prop.pxValue = value;
    }
  };

  $$.styfn.removeAllBypasses = function( eles, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

  $$.styfn.removeBypasses = function( eles, props, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < props.length; i++ ){
        var name = props[i];
        var prop = $$.style.properties[ name ];
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

})( cytoscape );
;(function($$, window){ 'use strict';

  // gets what an em size corresponds to in pixels relative to a dom element
  $$.styfn.getEmSizeInPixels = function(){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      var pxAsStr = window.getComputedStyle(domElement).getPropertyValue('font-size');
      var px = parseFloat( pxAsStr );
      return px;
    } else {
      return 1; // in case we're running outside of the browser
    }
  };

  // gets css property from the core container
  $$.styfn.containerCss = function( propName ){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      return window.getComputedStyle(domElement).getPropertyValue( propName );
    }
  };

  $$.styfn.containerProperty = function( propName ){
    var propStr = this.containerCss( propName );
    var prop = this.parse( propName, propStr );
    return prop;
  };

  $$.styfn.containerPropertyAsString = function( propName ){
    var prop = this.containerProperty( propName );

    if( prop ){
      return prop.strValue;
    }
  };

})( cytoscape, typeof window === 'undefined' ? null : window );
;(function($$){ 'use strict';

  // gets the rendered style for an element
  $$.styfn.getRenderedStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;
      var cy = this._private.cy;
      var zoom = cy.zoom();

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          var val = styleProp.unitless ? styleProp.strValue : (styleProp.pxValue * zoom) + 'px';
          rstyle[ prop.name ] = val;
          rstyle[ $$.util.dash2camel(prop.name) ] = val;
        }
      }

      return rstyle;
    }
  };

  // gets the raw style for an element
  $$.styfn.getRawStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          rstyle[ prop.name ] = styleProp.strValue;
          rstyle[ $$.util.dash2camel(prop.name) ] = styleProp.strValue;
        }
      }

      return rstyle;
    }
  };

  // gets the value style for an element (useful for things like animations)
  $$.styfn.getValueStyle = function( ele, opts ){
    opts = opts || {};

    var rstyle = opts.array ? [] : {}; 
    var style;

    if( $$.is.element(ele) ){
      style = ele._private.style;    
    } else {
      style = ele; // just passed the style itself
    }

    if( style ){
      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ] || style[ $$.util.dash2camel(prop.name) ];

        if( styleProp !== undefined && !$$.is.plainObject( styleProp ) ){ // then make a prop of it
          styleProp = this.parse(prop.name, styleProp);
        }

        if( styleProp ){
          if( opts.array ){
            rstyle.push( styleProp );
          } else {
            rstyle[ prop.name ] = styleProp;
            rstyle[ $$.util.dash2camel(prop.name) ] = styleProp;
          }
        }
      }
    }

    return rstyle;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromJson = function( style, json ){
    for( var i = 0; i < json.length; i++ ){
      var context = json[i];
      var selector = context.selector;
      var props = context.css;

      style.selector(selector); // apply selector

      for( var name in props ){
        var value = props[name];

        style.css( name, value ); // apply property
      }
    }

    return style;
  };

  // static function
  $$.style.fromJson = function( cy, json ){
    var style = new $$.Style(cy);

    $$.style.applyFromJson( style, json );

    return style;
  };

  // accessible cy.style() function
  $$.styfn.fromJson = function( json ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromJson( style, json );

    return style;
  };

  // get json from cy.style() api
  $$.styfn.json = function(){
    var json = [];

    for( var i = this.defaultLength; i < this.length; i++ ){
      var cxt = this[i];
      var selector = cxt.selector;
      var props = cxt.properties;
      var css = {};

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        css[ prop.name ] = prop.strValue;
      }

      json.push({
        selector: !selector ? 'core' : selector.toString(),
        css: css
      });
    }

    return json;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromString = function( style, string ){
    var remaining = '' + string;
    var selAndBlockStr;
    var blockRem;
    var propAndValStr;

    // remove comments from the style string
    remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

    function removeSelAndBlockFromRemaining(){
      // remove the parsed selector and block from the remaining text to parse
      if( remaining.length > selAndBlockStr.length ){
        remaining = remaining.substr( selAndBlockStr.length );
      } else {
        remaining = '';
      }
    }

    function removePropAndValFromRem(){
      // remove the parsed property and value from the remaining block text to parse
      if( blockRem.length > propAndValStr.length ){
        blockRem = blockRem.substr( propAndValStr.length );
      } else {
        blockRem = '';
      }
    }

    while(true){
      var nothingLeftToParse = remaining.match(/^\s*$/);
      if( nothingLeftToParse ){ break; }

      var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

      if( !selAndBlock ){
        $$.util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
        break;
      }

      selAndBlockStr = selAndBlock[0];

      // parse the selector
      var selectorStr = selAndBlock[1];
      var selector = new $$.Selector( selectorStr );
      if( selector._private.invalid && selectorStr !== 'core' ){
        $$.util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

        // skip this selector and block
        removeSelAndBlockFromRemaining();
        continue; 
      }

      // parse the block of properties and values
      var blockStr = selAndBlock[2];
      var invalidBlock = false;
      blockRem = blockStr;
      var props = [];

      while(true){
        var nothingLeftToParse = blockRem.match(/^\s*$/);
        if( nothingLeftToParse ){ break; }

        var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

        if( !propAndVal ){
          $$.util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
          invalidBlock = true;
          break;
        }

        propAndValStr = propAndVal[0];
        var propStr = propAndVal[1];
        var valStr = propAndVal[2];

        var prop = $$.style.properties[ propStr ];
        if( !prop ){
          $$.util.error('Skipping property: Invalid property name in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        var parsedProp = style.parse( propStr, valStr );

        if( !parsedProp ){
          $$.util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        props.push({
          name: propStr,
          val: valStr
        });
        removePropAndValFromRem();
      }

      if( invalidBlock ){
        removeSelAndBlockFromRemaining();
        break;
      }

      // put the parsed block in the style
      style.selector( selectorStr );
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        style.css( prop.name, prop.val );
      }

      removeSelAndBlockFromRemaining();
    }

    return style;
  };

  $$.style.fromString = function( cy, string ){
    var style = new $$.Style(cy);
    
    $$.style.applyFromString( style, string );

    return style;
  };

  $$.styfn.fromString = function( string ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromString( style, string );

    return style;
  };

})( cytoscape );

;(function($$){ 'use strict';

  // a dummy stylesheet object that doesn't need a reference to the core
  // (useful for init)
  $$.stylesheet = $$.Stylesheet = function(){
    if( !(this instanceof $$.Stylesheet) ){
      return new $$.Stylesheet();
    }

    this.length = 0;
  };

  // just store the selector to be parsed later
  $$.Stylesheet.prototype.selector = function( selector ){
    var i = this.length++;

    this[i] = {
      selector: selector,
      properties: []
    };

    return this; // chaining
  };

  // just store the property to be parsed later
  $$.Stylesheet.prototype.css = function( name, value ){
    var i = this.length - 1;

    if( $$.is.string(name) ){
      this[i].properties.push({
        name: name,
        value: value
      });
    } else if( $$.is.plainObject(name) ){
      var map = name;

      for( var j = 0; j < $$.style.properties.length; j++ ){
        var prop = $$.style.properties[j];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){ // also try camel case name
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          var name = prop.name;
          var value = mapVal;

          this[i].properties.push({
            name: name,
            value: value
          });
        }
      }
    }

    return this; // chaining
  };

  // generate a real style object from the dummy stylesheet
  $$.Stylesheet.prototype.generateStyle = function( cy ){
    var style = new $$.Style(cy);

    for( var i = 0; i < this.length; i++ ){
      var context = this[i];
      var selector = context.selector;
      var props = context.properties;

      style.selector(selector); // apply selector

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];

        style.css( prop.name, prop.value ); // apply property
      }
    }

    return style;
  };

})( cytoscape );
;(function($$, window){ 'use strict';

  var isTouch = $$.is.touch();

  var defaults = {
  };
  
  var origDefaults = $$.util.copy( defaults );

  $$.defaults = function( opts ){
    defaults = $$.util.extend({}, origDefaults, opts);
  };

  $$.fn.core = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Core.prototype[ name ] = fn;
    }
  };
  
  $$.Core = function( opts ){
    if( !(this instanceof $$.Core) ){
      return new $$.Core(opts);
    }
    var cy = this;

    opts = $$.util.extend({}, defaults, opts);

    var container = opts.container;
    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
    reg = reg || {};

    if( reg && reg.cy ){ 
      if( container ){
        while( container.firstChild ){ // clean the container
          container.removeChild( container.firstChild );
        }
      }
      
      reg.cy.notify({ type: 'destroy' }); // destroy the renderer

      reg = {}; // old instance => replace reg completely
    }

    var readies = reg.readies = reg.readies || [];
    
    if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
    reg.cy = cy;

    var head = window !== undefined && container !== undefined && !opts.headless;
    var options = opts;
    options.layout = $$.util.extend( { name: head ? 'grid' : 'null' }, options.layout );
    options.renderer = $$.util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );
    
    var defVal = function( def, val, altVal ){
      if( val !== undefined ){
        return val;
      } else if( altVal !== undefined ){
        return altVal;
      } else {
        return def;
      }
    };

    var _p = this._private = {
      container: options.container, // html dom ele container
      ready: false, // whether ready has been triggered
      initrender: false, // has initrender has been triggered
      options: options, // cached options
      elements: [], // array of elements
      id2index: {}, // element id => index in elements array
      listeners: [], // list of listeners
      aniEles: $$.Collection(this), // elements being animated
      scratch: {}, // scratch object for core
      layout: null,
      renderer: null,
      notificationsEnabled: true, // whether notifications are sent to the renderer
      minZoom: 1e-50,
      maxZoom: 1e50,
      zoomingEnabled: defVal(true, options.zoomingEnabled),
      userZoomingEnabled: defVal(true, options.userZoomingEnabled),
      panningEnabled: defVal(true, options.panningEnabled),
      userPanningEnabled: defVal(true, options.userPanningEnabled),
      boxSelectionEnabled: defVal(false, options.boxSelectionEnabled),
      autolock: defVal(false, options.autolock, options.autolockNodes),
      autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
      autounselectify: defVal(false, options.autounselectify),
      styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
      zoom: $$.is.number(options.zoom) ? options.zoom : 1,
      pan: {
        x: $$.is.plainObject(options.pan) && $$.is.number(options.pan.x) ? options.pan.x : 0,
        y: $$.is.plainObject(options.pan) && $$.is.number(options.pan.y) ? options.pan.y : 0
      },
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      hasCompoundNodes: false,
      deferredExecQueue: []
    };

    // set selection type
    var selType = options.selectionType;
    if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
      // then set default

      if( isTouch ){
        _p.selectionType = 'additive';
      } else {
        _p.selectionType = 'single';
      }
    } else {
      _p.selectionType = selType;
    }

    // init zoom bounds
    if( $$.is.number(options.minZoom) && $$.is.number(options.maxZoom) && options.minZoom < options.maxZoom ){
      _p.minZoom = options.minZoom;
      _p.maxZoom = options.maxZoom;
    } else if( $$.is.number(options.minZoom) && options.maxZoom === undefined ){
      _p.minZoom = options.minZoom;
    } else if( $$.is.number(options.maxZoom) && options.minZoom === undefined ){
      _p.maxZoom = options.maxZoom;
    }

    // init style
    if( _p.styleEnabled ){
      this.setStyle( options.style );
    }

    // create the renderer
    cy.initRenderer( $$.util.extend({
      hideEdgesOnViewport: options.hideEdgesOnViewport,
      hideLabelsOnViewport: options.hideLabelsOnViewport,
      textureOnViewport: options.textureOnViewport,
      wheelSensitivity: $$.is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
      motionBlur: options.motionBlur,
      pixelRatio: $$.is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : (options.pixelRatio === 'auto' ? undefined : 1),
      tapThreshold: defVal( $$.is.touch() ? 8 : 4, $$.is.touch() ? options.touchTapThreshold : options.desktopTapThreshold )
    }, options.renderer) );

    // trigger the passed function for the `initrender` event
    if( options.initrender ){
      cy.on('initrender', options.initrender);
      cy.on('initrender', function(){
        cy._private.initrender = true;
      });
    }

    // initial load
    cy.load(options.elements, function(){ // onready
      cy.startAnimationLoop();
      cy._private.ready = true;

      // if a ready callback is specified as an option, the bind it
      if( $$.is.fn( options.ready ) ){
        cy.on('ready', options.ready);
      }

      // bind all the ready handlers registered before creating this instance
      for( var i = 0; i < readies.length; i++ ){
        var fn = readies[i];
        cy.on('ready', fn);
      }
      if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc
      
      cy.trigger('ready');
    }, options.done);
  };

  $$.corefn = $$.Core.prototype; // short alias
  

  $$.fn.core({
    isReady: function(){
      return this._private.ready;
    },

    ready: function( fn ){
      if( this.isReady() ){
        this.trigger('ready', [], fn); // just calls fn as though triggered via ready event
      } else {
        this.on('ready', fn);
      }
    },

    initrender: function(){
      return this._private.initrender;
    },

    destroy: function(){
      this.notify({ type: 'destroy' }); // destroy the renderer

      var domEle = this.container();
      var parEle = domEle.parentNode;
      if( parEle ){
        parEle.removeChild( domEle );
      }

      return this;
    },

    getElementById: function( id ){
      var index = this._private.id2index[ id ];
      if( index !== undefined ){
        return this._private.elements[ index ];
      }

      // worst case, return an empty collection
      return new $$.Collection( this );
    },

    selectionType: function(){
      return this._private.selectionType;
    },

    hasCompoundNodes: function(){
      return this._private.hasCompoundNodes;
    },

    styleEnabled: function(){
      return this._private.styleEnabled;
    },

    addToPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var alreadyInPool = index !== undefined;

        if( !alreadyInPool ){
          index = elements.length;
          elements.push( ele );
          id2index[ id ] = index;
          ele._private.index = index;
        }
      }

      return this; // chaining
    },

    removeFromPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var inPool = index !== undefined;

        if( inPool ){
          this._private.id2index[ id ] = undefined;
          elements.splice(index, 1);

          // adjust the index of all elements past this index
          for( var j = index; j < elements.length; j++ ){
            var jid = elements[j]._private.data.id;
            id2index[ jid ]--;
          }
        }
      }
    },

    container: function(){
      return this._private.container;
    },

    options: function(){
      return $$.util.copy( this._private.options );
    },
    
    json: function(params){
      var json = {};
      var cy = this;
      
      json.elements = {};
      cy.elements().each(function(i, ele){
        var group = ele.group();
        
        if( !json.elements[group] ){
          json.elements[group] = [];
        }
        
        json.elements[group].push( ele.json() );
      });

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = cy._private.pan;
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.layout = cy._private.options.layout;
      json.renderer = cy._private.options.renderer;
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;
      
      return json;
    },

    // defer execution until not busy and guarantee relative execution order of deferred functions
    defer: function( fn ){
      var cy = this;
      var _p = cy._private;
      var q = _p.deferredExecQueue;

      q.push( fn );

      if( !_p.deferredTimeout ){
        _p.deferredTimeout = setTimeout(function(){
          while( q.length > 0 ){
            ( q.shift() )();
          }

          _p.deferredTimeout = null;
        }, 0);
      }
    }
    
  });  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

(function($$, window){ 'use strict';

  function ready(f) {
    var fn = ( document && (document.readyState === 'interactive' || document.readyState === 'complete') )  ? f : ready;

    setTimeout(fn, 9, f);
  }

  $$.fn.core({
    add: function(opts){
      
      var elements;
      var cy = this;
      
      // add the elements
      if( $$.is.elementOrCollection(opts) ){
        var eles = opts;

        if( eles._private.cy === cy ){ // same instance => just restore
          elements = eles.restore();

        } else { // otherwise, copy from json
          var jsons = [];

          for( var i = 0; i < eles.length; i++ ){
            var ele = eles[i];
            jsons.push( ele.json() );
          }

          elements = new $$.Collection( cy, jsons );
        }
      }
      
      // specify an array of options
      else if( $$.is.array(opts) ){
        var jsons = opts;

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify via opts.nodes and opts.edges
      else if( $$.is.plainObject(opts) && ($$.is.array(opts.nodes) || $$.is.array(opts.edges)) ){
        var elesByGroup = opts;
        var jsons = [];

        var grs = ['nodes', 'edges'];
        for( var i = 0, il = grs.length; i < il; i++ ){
          var group = grs[i];
          var elesArray = elesByGroup[group];

          if( $$.is.array(elesArray) ){

            for( var j = 0, jl = elesArray.length; j < jl; j++ ){
              var json = elesArray[j];
              json.group = group;

              jsons.push( json );
            }
          } 
        }

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify options for one element
      else {
        var json = opts;
        elements = (new $$.Element( cy, json )).collection();
      }
      
      return elements;
    },
    
    remove: function(collection){
      if( $$.is.elementOrCollection(collection) ){
        collection = collection;
      } else if( $$.is.string(collection) ){
        var selector = collection;
        collection = this.$( selector );
      }
      
      return collection.remove();
    },
    
    load: function(elements, onload, ondone){
      var cy = this;
      
      // remove old elements
      var oldEles = cy.elements();
      if( oldEles.length > 0 ){
        oldEles.remove();
      }

      cy.notifications(false);
      
      if( elements != null ){
        if( $$.is.plainObject(elements) || $$.is.array(elements) ){
          cy.add( elements );
        } 
      }
      
      function callback(){        
        cy.one('layoutready', function(e){
          cy.notifications(true);
          cy.trigger(e); // we missed this event by turning notifications off, so pass it on

          cy.notify({
            type: 'load',
            collection: cy.elements()
          });

          cy.one('load', onload);
          cy.trigger('load');
        }).one('layoutstop', function(){
          cy.one('done', ondone);
          cy.trigger('done');
        });
        
        var layoutOpts = $$.util.extend({}, cy._private.options.layout);
        layoutOpts.eles = cy.$();

        cy.layout( layoutOpts );

      }

      if( window ){
        ready( callback );
      } else {
        callback();
      }

      return this;
    }
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  $$.fn.core({
    
    // pull in animation functions
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop(),

    addToAnimationPool: function( eles ){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used
      
      cy._private.aniEles.merge( eles );
    },

    startAnimationLoop: function(){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used

      // don't execute the animation loop in headless environments
      if( !window ){
        return;
      }
      
      function globalAnimationStep(){
        $$.util.requestAnimationFrame(function(now){
          handleElements(now);
          globalAnimationStep();
        });
      }
      
      globalAnimationStep(); // first call
      
      function handleElements(now){
        now = +new Date();

        var eles = cy._private.aniEles;
        var doneEles = [];

        function handleElement( ele, isCore ){
          var current = ele._private.animation.current;
          var queue = ele._private.animation.queue;
          var ranAnis = false;
          
          // if nothing currently animating, get something from the queue
          if( current.length === 0 ){
            var next = queue.length > 0 ? queue.shift() : null;
            
            if( next ){
              next.callTime = now; // was queued, so update call time
              current.push( next );
            }
          }
          
          // step and remove if done
          var completes = [];
          for(var i = current.length - 1; i >= 0; i--){
            var ani = current[i];

            // start if need be
            if( !ani.started ){ startAnimation( ele, ani ); }
            
            step( ele, ani, now, isCore );

            if( ani.done ){
              completes.push( ani );
              
              // remove current[i]
              current.splice(i, 1);
            }

            ranAnis = true;
          }
          
          // call complete callbacks
          for( var i = 0; i < completes.length; i++ ){
            var ani = completes[i];
            var complete = ani.params.complete;

            if( $$.is.fn(complete) ){
              complete.apply( ele, [ now ] );
            }
          }

          if( !isCore && current.length === 0 && queue.length === 0 ){
            doneEles.push( ele );
          }

          return ranAnis;
        } // handleElements

        // handle all eles
        for( var e = 0; e < eles.length; e++ ){
          var ele = eles[e];
          
          handleElement( ele );
        } // each element

        var ranCoreAni = handleElement( cy, true );
        
        // notify renderer
        if( eles.length > 0 || ranCoreAni ){
          var toNotify;

          if( eles.length > 0 ){
            var updatedEles = eles.updateCompoundBounds();
            toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;
          }

          cy.notify({
            type: 'draw',
            collection: toNotify
          });
        }

        // remove elements from list of currently animating if its queues are empty
        eles.unmerge( doneEles );

      } // handleElements
      
      function startAnimation( self, ani ){
        var isCore = $$.is.core( self );
        var isEles = !isCore;
        var ele = self;
        var style = cy._private.style;

        if( isEles ){
          var pos = ele._private.position;
          var startPosition = {
            x: pos.x,
            y: pos.y
          };
          var startStyle = style.getValueStyle( ele );
        }

        if( isCore ){
          var pan = cy._private.pan;
          var startPan = {
            x: pan.x,
            y: pan.y
          };

          var startZoom = cy._private.zoom;
        }

        ani.started = true;
        ani.startTime = Date.now();
        ani.startPosition = startPosition;
        ani.startStyle = startStyle;
        ani.startPan = startPan;
        ani.startZoom = startZoom;
      }

      function step( self, animation, now, isCore ){
        var style = cy._private.style;
        var properties = animation.properties;
        var params = animation.params;
        var startTime = animation.startTime;
        var percent;
        var isEles = !isCore;
        
        if( animation.duration === 0 ){
          percent = 1;
        } else {
          percent = Math.min(1, (now - startTime)/animation.duration);
        }

        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }
        
        if( properties.delay == null ){ // then update

          var startPos = animation.startPosition;
          var endPos = properties.position;
          var pos = self._private.position;
          if( endPos && isEles ){
            if( valid( startPos.x, endPos.x ) ){
              pos.x = ease( startPos.x, endPos.x, percent );
            }

            if( valid( startPos.y, endPos.y ) ){
              pos.y = ease( startPos.y, endPos.y, percent );
            }
          }

          var startPan = animation.startPan;
          var endPan = properties.pan;
          var pan = self._private.pan;
          var animatingPan = endPan != null && isCore;
          if( animatingPan ){
            if( valid( startPan.x, endPan.x ) ){
              pan.x = ease( startPan.x, endPan.x, percent );
            }

            if( valid( startPan.y, endPan.y ) ){
              pan.y = ease( startPan.y, endPan.y, percent );
            }

            self.trigger('pan');
          }

          var startZoom = animation.startZoom;
          var endZoom = properties.zoom;
          var animatingZoom = endZoom != null && isCore;
          if( animatingZoom ){
            if( valid( startZoom, endZoom ) ){
              self._private.zoom = ease( startZoom, endZoom, percent );
            }

            self.trigger('zoom');
          }

          if( animatingPan || animatingZoom ){
            self.trigger('viewport');
          }

          if( properties.css && isEles ){
            var props = properties.css;

            for( var i = 0; i < props.length; i++ ){
              var name = props[i].name;
              var prop = props[i];
              var end = prop;

              var start = animation.startStyle[ name ];
              var easedVal = ease( start, end, percent );
              
              style.overrideBypass( self, name, easedVal );
            } // for props
          } // if 

        }
        
        if( $$.is.fn(params.step) ){
          params.step.apply( self, [ now ] );
        }
        
        if( percent >= 1 ){
          animation.done = true;
        }
        
        return percent;
      }
      
      function valid(start, end){
        if( start == null || end == null ){
          return false;
        }
        
        if( $$.is.number(start) && $$.is.number(end) ){
          return true;
        } else if( (start) && (end) ){
          return true;
        }
        
        return false;
      }
      
      function ease(startProp, endProp, percent){
        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }

        var start, end;

        if( startProp.pxValue != null || startProp.value != null ){
          start = startProp.pxValue != null ? startProp.pxValue : startProp.value;
        } else {
          start = startProp;
        }

        if( endProp.pxValue != null || endProp.value != null ){
          end = endProp.pxValue != null ? endProp.pxValue : endProp.value;
        } else {
          end = endProp;
        }

        if( $$.is.number(start) && $$.is.number(end) ){
          return start + (end - start) * percent;

        } else if( $$.is.number(start[0]) && $$.is.number(end[0]) ){ // then assume a colour
          var c1 = start;
          var c2 = end;

          var ch = function(ch1, ch2){
            var diff = ch2 - ch1;
            var min = ch1;
            return Math.round( percent * diff + min );
          };
          
          var r = ch( c1[0], c2[0] );
          var g = ch( c1[1], c2[1] );
          var b = ch( c1[2], c2[2] );
          
          return [r, g, b];
        }
        
        return undefined;
      }
      
    }
    
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );


  
    
;(function($$){ 'use strict';
  
  $$.fn.core({
    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      triggerEvent: false
    })
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.core({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger() // .trigger( events [, extraParams] )
  });

  // aliases for those folks who like old stuff:
  $$.corefn.bind = $$.corefn.on;
  $$.corefn.unbind = $$.corefn.off;

})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    png: function( options ){
      var renderer = this._private.renderer;
      options = options || {};

      return renderer.png( options );      
    }
    
  });
  
})( cytoscape );
;(function($$){ 'use strict';
  
  $$.fn.core({
    
    layout: function( params ){
      var layout = this._private.prevLayout = ( params == null ? this._private.prevLayout : this.initLayout( params ) );

      layout.run();

      return this; // chaining
    },

    makeLayout: function( params ){
      return this.initLayout( params );
    },
    
    initLayout: function( options ){
      if( options == null ){
        $$.util.error('Layout options must be specified to make a layout');
        return;
      }
      
      if( options.name == null ){
        $$.util.error('A `name` must be specified to make a layout');
        return;
      }
      
      var name = options.name;
      var LayoutProto = $$.extension('layout', name);
      
      if( LayoutProto == null ){
        $$.util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
        return;
      }

      options.eles = options.eles != null ? options.eles : this.$();

      if( $$.is.string( options.eles ) ){
        options.eles = this.$( options.eles );
      }
      
      var layout = new LayoutProto( $$.util.extend({}, options, {
        cy: this
      }) );

      // make sure layout has _private for use w/ std apis like .on()
      if( !$$.is.plainObject(layout._private) ){
        layout._private = {};
      }

      layout._private.cy = this;
      layout._private.listeners = [];
      
      return layout;
    }
    
  });
  
})( cytoscape );
(function($$){ 'use strict';
  
  $$.fn.core({
    notify: function( params ){
      if( this._private.batchingNotify ){
        var bEles = this._private.batchNotifyEles;
        var bTypes = this._private.batchNotifyTypes;

        if( params.collection ){ for( var i = 0; i < params.collection.length; i++ ){
          var ele = params.collection[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        } }

        if( !bTypes.ids[ params.type ] ){
          bTypes.push( params.type );
        }

        return; // notifications are disabled during batching
      }

      if( !this._private.notificationsEnabled ){ return; } // exit on disabled

      var renderer = this.renderer();
      
      renderer.notify(params);
    },
    
    notifications: function( bool ){
      var p = this._private;
      
      if( bool === undefined ){
        return p.notificationsEnabled;
      } else {
        p.notificationsEnabled = bool ? true : false;
      }
    },
    
    noNotifications: function( callback ){
      this.notifications(false);
      callback();
      this.notifications(true);
    },

    startBatch: function(){
      var _p = this._private;

      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = [];
      _p.batchNotifyEles = [];
      _p.batchNotifyTypes = [];

      _p.batchStyleEles.ids = {};
      _p.batchNotifyEles.ids = {};
      _p.batchNotifyTypes.ids = {};

      return this;
    },

    endBatch: function(){
      var _p = this._private;

      // update style for dirty eles
      _p.batchingStyle = false;
      new $$.Collection(this, _p.batchStyleEles).updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify({
        type: _p.batchNotifyTypes,
        collection: _p.batchNotifyEles
      });

      return this;
    },

    batch: function( callback ){
      this.startBatch();
      callback();
      this.endBatch();

      return this;
    },

    // for backwards compatibility
    batchData: function( map ){
      var cy = this;

      return this.batch(function(){
        for( var id in map ){
          var data = map[id];
          var ele = cy.getElementById( id );
          
          ele.data( data );
        }
      });
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    renderTo: function( context, zoom, pan, pxRatio ){
      var r = this._private.renderer;

      r.renderTo( context, zoom, pan, pxRatio );
      return this;
    },

    renderer: function(){
      return this._private.renderer;
    },

    forceRender: function(){
      this.notify({
        type: 'draw'
      });

      return this;
    },

    resize: function(){
      this.notify({
        type: 'resize'
      });

      this.trigger('resize');

      return this;
    },
    
    initRenderer: function( options ){
      var cy = this;

      var RendererProto = $$.extension('renderer', options.name);
      if( RendererProto == null ){
        $$.util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
        return;
      }
      
      this._private.renderer = new RendererProto(
        $$.util.extend({}, options, {
          cy: cy,
          style: cy._private.style
        })
      );
       
    }
    
  });  
  
})( cytoscape );
;(function($$){ 'use strict';
  
  $$.fn.core({

    // get a collection
    // - empty collection on no args
    // - collection of elements in the graph on selector arg
    // - guarantee a returned collection when elements or collection specified
    collection: function( eles ){

      if( $$.is.string( eles ) ){
        return this.$( eles );

      } else if( $$.is.elementOrCollection( eles ) ){
        return eles.collection();

      } else if( $$.is.array( eles ) ){
        return new $$.Collection( this, eles );
      }

      return new $$.Collection( this );
    },
    
    nodes: function( selector ){
      var nodes = this.$(function(){
        return this.isNode();
      });

      if( selector ){
        return nodes.filter( selector );
      } 

      return nodes;
    },
    
    edges: function( selector ){
      var edges = this.$(function(){
        return this.isEdge();
      });

      if( selector ){
        return edges.filter( selector );
      }

      return edges;
    },
      
    // search the graph like jQuery
    $: function( selector ){
      var eles = new $$.Collection( this, this._private.elements );

      if( selector ){
        return eles.filter( selector );
      }

      return eles;
    }
    
  });  

  // aliases
  $$.corefn.elements = $$.corefn.filter = $$.corefn.$;  
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    style: function( newStyle ){
      if( newStyle ){
        var s = this.setStyle( newStyle );

        s.update();
      }

      return this._private.style;
    },

    setStyle: function( style ){
      var _p = this._private;

      if( $$.is.stylesheet(style) ){
        _p.style = style.generateStyle(this);
      
      } else if( $$.is.array(style) ) {
        _p.style = $$.style.fromJson(this, style);
      
      } else if( $$.is.string(style) ){
        _p.style = $$.style.fromString(this, style);
      
      } else {
        _p.style = new $$.Style( this );
      }

      return _p.style;
    }
  });
  
})( cytoscape );


;(function($$){ 'use strict';
  
  $$.fn.core({

    autolock: function(bool){
      if( bool !== undefined ){
        this._private.autolock = bool ? true : false;
      } else {
        return this._private.autolock;
      }
      
      return this; // chaining
    },

    autoungrabify: function(bool){
      if( bool !== undefined ){
        this._private.autoungrabify = bool ? true : false;
      } else {
        return this._private.autoungrabify;
      }
      
      return this; // chaining
    },

    autounselectify: function(bool){
      if( bool !== undefined ){
        this._private.autounselectify = bool ? true : false;
      } else {
        return this._private.autounselectify;
      }
      
      return this; // chaining
    },

    panningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.panningEnabled = bool ? true : false;
      } else {
        return this._private.panningEnabled;
      }
      
      return this; // chaining
    },

    userPanningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userPanningEnabled = bool ? true : false;
      } else {
        return this._private.userPanningEnabled;
      }
      
      return this; // chaining
    },
    
    zoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.zoomingEnabled = bool ? true : false;
      } else {
        return this._private.zoomingEnabled;
      }
      
      return this; // chaining
    },

    userZoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userZoomingEnabled = bool ? true : false;
      } else {
        return this._private.userZoomingEnabled;
      }
      
      return this; // chaining
    },

    boxSelectionEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.boxSelectionEnabled = bool ? true : false;
      } else {
        return this._private.boxSelectionEnabled;
      }
      
      return this; // chaining
    },
    
    pan: function(){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      switch( args.length ){
      case 0: // .pan()
        return pan;

      case 1: 

        if( $$.is.string( args[0] ) ){ // .pan('x')
          dim = args[0];
          return pan[ dim ];

        } else if( $$.is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })
          if( !this._private.panningEnabled ){
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x = x;
          }

          if( $$.is.number(y) ){
            pan.y = y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .pan('x', 100)
        if( !this._private.panningEnabled ){
          return this;
        }

        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] = val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    panBy: function(params){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      if( !this._private.panningEnabled ){
        return this;
      }

      switch( args.length ){
      case 1: 

        if( $$.is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x += x;
          }

          if( $$.is.number(y) ){
            pan.y += y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .panBy('x', 100)
        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] += val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    fit: function( elements, padding ){
      var viewportState = this.getFitViewport( elements, padding );

      if( viewportState ){
        var _p = this._private;
        _p.zoom = viewportState.zoom;
        _p.pan = viewportState.pan;

        this.trigger('pan zoom viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getFitViewport: function( elements, padding ){
      if( $$.is.number(elements) && padding === undefined ){ // elements is optional
        padding = elements;
        elements = undefined;
      }

      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return;
      }

      var bb;

      if( $$.is.string(elements) ){
        var sel = elements;
        elements = this.$( sel );

      } else if( $$.is.boundingBox(elements) ){ // assume bb
        var bbe = elements;
        bb = {
          x1: bbe.x1,
          y1: bbe.y1,
          x2: bbe.x2,
          y2: bbe.y2
        };

        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;

      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      bb = bb || elements.boundingBox();

      var w = this.width();
      var h = this.height();
      var zoom;
      padding = $$.is.number(padding) ? padding : 0;

      if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){
        zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );

        // crop zoom
        zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
        zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

        var pan = { // now pan to middle
          x: (w - zoom*( bb.x1 + bb.x2 ))/2,
          y: (h - zoom*( bb.y1 + bb.y2 ))/2
        };

        return {
          zoom: zoom, 
          pan: pan
        };
      }

      return;
    },
    
    minZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.minZoom;
      } else if( $$.is.number(zoom) ){
        this._private.minZoom = zoom;
      }

      return this;
    },

    maxZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.maxZoom;
      } else if( $$.is.number(zoom) ){
        this._private.maxZoom = zoom;
      }

      return this;
    },

    zoom: function( params ){
      var pos; // in rendered px
      var zoom;

      if( params === undefined ){ // then get the zoom
        return this._private.zoom;

      } else if( $$.is.number(params) ){ // then set the zoom
        zoom = params;

      } else if( $$.is.plainObject(params) ){ // then zoom about a point
        zoom = params.level;

        if( params.position ){
          var p = params.position;
          var pan = this._private.pan;
          var z = this._private.zoom;

          pos = { // convert to rendered px
            x: p.x * z + pan.x,
            y: p.y * z + pan.y
          };
        } else if( params.renderedPosition ){
          pos = params.renderedPosition;
        }

        if( pos && !this._private.panningEnabled ){
          return this; // panning disabled
        }
      }

      if( !this._private.zoomingEnabled ){
        return this; // zooming disabled
      }

      if( !$$.is.number(zoom) || ( pos && (!$$.is.number(pos.x) || !$$.is.number(pos.y)) ) ){
        return this; // can't zoom with invalid params
      }

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      if( pos ){ // set zoom about position
        var pan1 = this._private.pan;
        var zoom1 = this._private.zoom;
        var zoom2 = zoom;
        
        var pan2 = {
          x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,
          y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y
        };

        this._private.zoom = zoom;
        this._private.pan = pan2;

        var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
        this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );
      
      } else { // just set the zoom
        this._private.zoom = zoom;
        this.trigger('zoom viewport');
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },

    viewport: function( opts ){ 
      var _p = this._private;
      var zoomDefd = true;
      var panDefd = true;
      var events = []; // to trigger
      var zoomFailed = false;
      var panFailed = false;

      if( !opts ){ return this; }
      if( !$$.is.number(opts.zoom) ){ zoomDefd = false; }
      if( !$$.is.plainObject(opts.pan) ){ panDefd = false; }
      if( !zoomDefd && !panDefd ){ return this; }

      if( zoomDefd ){
        var z = opts.zoom;

        if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
          zoomFailed = true;

        } else {
          _p.zoom = z;

          events.push('zoom');
        }
      }

      if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
        var p = opts.pan;

        if( $$.is.number(p.x) ){
          _p.pan.x = p.x;
          panFailed = false;
        }

        if( $$.is.number(p.y) ){
          _p.pan.y = p.y;
          panFailed = false;
        }

        if( !panFailed ){
          events.push('pan');
        }
      }

      if( events.length > 0 ){
        events.push('viewport');
        this.trigger( events.join(' ') );

        this.notify({
          type: 'viewport'
        });
      }

      return this; // chaining
    },
    
    center: function( elements ){
      var pan = this.getCenterPan( elements );

      if( pan ){
        this._private.pan = pan;

        this.trigger('pan viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getCenterPan: function( elements, zoom ){
      if( !this._private.panningEnabled ){
        return;
      }

      if( $$.is.string(elements) ){
        var selector = elements;
        elements = this.elements( selector );
      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      var bb = elements.boundingBox();
      var w = this.width();
      var h = this.height();
      zoom = zoom === undefined ? this._private.zoom : zoom;

      var pan = { // middle
        x: (w - zoom*( bb.x1 + bb.x2 ))/2,
        y: (h - zoom*( bb.y1 + bb.y2 ))/2
      };
      
      return pan;
    },
    
    reset: function(){
      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return this;
      }

      this.viewport({
        pan: { x: 0, y: 0 },
        zoom: 1
      });
      
      return this; // chaining
    },

    width: function(){
      var container = this._private.container;

      if( container ){
        return container.clientWidth;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    height: function(){
      var container = this._private.container;

      if( container ){
        return container.clientHeight;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    extent: function(){
      var pan = this._private.pan;
      var zoom = this._private.zoom;
      var rb = this.renderedExtent();

      var b = {
        x1: ( rb.x1 - pan.x )/zoom,
        x2: ( rb.x2 - pan.x )/zoom,
        y1: ( rb.y1 - pan.y )/zoom,
        y2: ( rb.y2 - pan.y )/zoom,
      };

      b.w = b.x2 - b.x1;
      b.h = b.y2 - b.y1;

      return b;
    },

    renderedExtent: function(){
      var width = this.width();
      var height = this.height();

      return {
        x1: 0,
        y1: 0,
        x2: width,
        y2: height,
        w: width,
        h: height
      };
    }
  });

  // aliases
  $$.corefn.centre = $$.corefn.center;

  // backwards compatibility
  $$.corefn.autolockNodes = $$.corefn.autolock;
  $$.corefn.autoungrabifyNodes = $$.corefn.autoungrabify;

})( cytoscape );

;(function($$){ 'use strict';
  
  // Use this interface to define functions for collections/elements.
  // This interface is good, because it forces you to think in terms
  // of the collections case (more than 1 element), so we don't need
  // notification blocking nonsense everywhere.
  //
  // Other collection-*.js files depend on this being defined first.
  // It's a trade off: It simplifies the code for Collection and 
  // Element integration so much that it's worth it to create the
  // JS dependency.
  //
  // Having this integration guarantees that we can call any
  // collection function on an element and vice versa.

  // e.g. $$.fn.collection({ someFunc: function(){ /* ... */ } })
  $$.fn.collection = $$.fn.eles = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];

      $$.Collection.prototype[ name ] = fn;
    }
  };
  
  // factory for generating edge ids when no id is specified for a new element
  var idFactory = {
    prefix: {
      nodes: 'n',
      edges: 'e'
    },
    id: {
      nodes: 0,
      edges: 0
    },
    generate: function(cy, element, tryThisId){
      var json = $$.is.element( element ) ? element._private : element;
      var group = json.group;
      var id = tryThisId != null ? tryThisId : this.prefix[group] + this.id[group];
      
      if( cy.getElementById(id).empty() ){
        this.id[group]++; // we've used the current id, so move it up
      } else { // otherwise keep trying successive unused ids
        while( !cy.getElementById(id).empty() ){
          id = this.prefix[group] + ( ++this.id[group] );
        }
      }
      
      return id;
    }
  };
  
  // Element
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a node or an edge
  $$.Element = function(cy, params, restore){
    if( !(this instanceof $$.Element) ){
      return new $$.Element(cy, params, restore);
    }

    var self = this;
    restore = (restore === undefined || restore ? true : false);
    
    if( cy === undefined || params === undefined || !$$.is.core(cy) ){
      $$.util.error('An element must have a core reference and parameters set');
      return;
    }
    
    // validate group
    if( params.group !== 'nodes' && params.group !== 'edges' ){
      $$.util.error('An element must be of type `nodes` or `edges`; you specified `' + params.group + '`');
      return;
    }
    
    // make the element array-like, just like a collection
    this.length = 1;
    this[0] = this;
    
    // NOTE: when something is added here, add also to ele.json()
    this._private = {
      cy: cy,
      single: true, // indicates this is an element
      data: params.data || {}, // data object
      layoutData: {}, // place for layouts to put calculated stats etc for mappers
      position: params.position || {}, // (x, y) position pair
      autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
      autoHeight: undefined, 
      listeners: [], // array of bound listeners
      group: params.group, // string; 'nodes' or 'edges'
      style: {}, // properties as set by the style
      rstyle: {}, // properties for style sent from the renderer to the core
      styleCxts: [], // applied style contexts from the styler
      removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
      selected: params.selected ? true : false, // whether it's selected
      selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
      locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
      grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
      grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
      active: false, // whether the element is active from user interaction
      classes: {}, // map ( className => true )
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      rscratch: {}, // object in which the renderer can store information
      scratch: {}, // scratch objects
      edges: [], // array of connected edges
      children: [] // array of children
    };
    
    // renderedPosition overrides if specified
    if( params.renderedPosition ){
      var rpos = params.renderedPosition;
      var pan = cy.pan();
      var zoom = cy.zoom();

      this._private.position = {
        x: (rpos.x - pan.x)/zoom,
        y: (rpos.y - pan.y)/zoom
      };
    }
    
    if( $$.is.string(params.classes) ){
      var classes = params.classes.split(/\s+/);
      for( var i = 0, l = classes.length; i < l; i++ ){
        var cls = classes[i];
        if( !cls || cls === '' ){ continue; }

        self._private.classes[cls] = true;
      }
    }

    if( params.css ){
      cy.style().applyBypass( this, params.css );
    }
    
    if( restore === undefined || restore ){
      this.restore();
    }
    
  };

  
  // Collection
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a set of nodes, edges, or both together
  $$.Collection = function(cy, elements, options){
    if( !(this instanceof $$.Collection) ){
      return new $$.Collection(cy, elements);
    }

    if( cy === undefined || !$$.is.core(cy) ){
      $$.util.error('A collection must have a reference to the core');
      return;
    }
    
    var ids = {};
    var indexes = {};
    var createdElements = false;
    
    if( !elements ){
      elements = [];
    } else if( elements.length > 0 && $$.is.plainObject( elements[0] ) && !$$.is.element( elements[0] ) ){
      createdElements = true;

      // make elements from json and restore all at once later
      var eles = [];
      var elesIds = {};

      for( var i = 0, l = elements.length; i < l; i++ ){
        var json = elements[i];

        if( json.data == null ){
          json.data = {};
        }
        
        var data = json.data;

        // make sure newly created elements have valid ids
        if( data.id == null ){
          data.id = idFactory.generate( cy, json );
        } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){
          continue; // can't create element if prior id already exists
        }

        var ele = new $$.Element( cy, json, false );
        eles.push( ele );
        elesIds[ data.id ] = true;
      }

      elements = eles;
    }
    
    this.length = 0;

    for( var i = 0, l = elements.length; i < l; i++ ){
      var element = elements[i];
      if( !element ){  continue; }
      
      var id = element._private.data.id;
      
      if( !options || (options.unique && !ids[ id ] ) ){
        ids[ id ] = element;
        indexes[ id ] = this.length;

        this[ this.length ] = element;
        this.length++;
      }
    }
    
    this._private = {
      cy: cy,
      ids: ids,
      indexes: indexes
    };

    // restore the elements if we created them from json
    if( createdElements ){
      this.restore();
    }
  };
  
  
  // Functions
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // keep the prototypes in sync (an element has the same functions as a collection)
  // and use $$.elefn and $$.elesfn as shorthands to the prototypes
  $$.elefn = $$.elesfn = $$.Element.prototype = $$.Collection.prototype;

  $$.elesfn.cy = function(){
    return this._private.cy;
  };
  
  $$.elesfn.element = function(){
    return this[0];
  };
  
  $$.elesfn.collection = function(){
    if( $$.is.collection(this) ){
      return this;
    } else { // an element
      return new $$.Collection( this._private.cy, [this] );
    }
  };

  $$.elesfn.unique = function(){
    return new $$.Collection( this._private.cy, this, { unique: true } );
  };

  $$.elesfn.getElementById = function( id ){
    var cy = this._private.cy;
    var ele = this._private.ids[ id ];

    return ele ? ele : $$.Collection(cy); // get ele or empty collection
  };

  $$.elesfn.json = function(){
    var ele = this.element();
    if( ele == null ){ return undefined; }

    var p = ele._private;
    
    var json = $$.util.copy({
      data: p.data,
      position: p.position,
      group: p.group,
      bypass: p.bypass,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbed: p.grabbed,
      grabbable: p.grabbable,
      classes: ''
    });
    
    var classes = [];
    for( var cls in p.classes ){
      if( p.classes[cls] ){
        classes.push(cls);
      }
    }
    
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[i];
      json.classes += cls + ( i < classes.length - 1 ? ' ' : '' );
    }
    
    return json;
  };

  $$.elesfn.jsons = function(){
    var jsons = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();

      jsons.push( json );
    }

    return jsons;
  };

  $$.elesfn.clone = function(){
    var cy = this.cy();
    var elesArr = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();
      var clone = new $$.Element(cy, json, false); // NB no restore

      elesArr.push( clone );
    }

    return new $$.Collection( cy, elesArr );
  };

  $$.elesfn.restore = function( notifyRenderer ){
    var self = this;
    var restored = [];
    var cy = self.cy();
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }

    // create arrays of nodes and edges, since we need to
    // restore the nodes first
    var elements = [];
    var nodes = [], edges = [];
    var numNodes = 0;
    var numEdges = 0;
    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];
      
      // keep nodes first in the array and edges after
      if( ele.isNode() ){ // put to front of array if node
        nodes.push( ele );
        numNodes++;
      } else { // put to end of array if edge
        edges.push( ele );
        numEdges++;
      }
    }

    elements = nodes.concat( edges );

    // now, restore each element
    for( var i = 0, l = elements.length; i < l; i++ ){
      var ele = elements[i];

      if( !ele.removed() ){
        // don't need to do anything
        continue;
      }
      
      var _private = ele._private;
      var data = _private.data;
      
      // set id and validate
      if( data.id === undefined ){
        data.id = idFactory.generate( cy, ele );
      } else if( $$.is.emptyString(data.id) || !$$.is.string(data.id) ){
        $$.util.error('Can not create element with invalid string ID `' + data.id + '`');
        
        // can't create element if it has empty string as id or non-string id
        continue;
      } else if( cy.getElementById( data.id ).length !== 0 ){
        $$.util.error('Can not create second element with ID `' + data.id + '`');
        
        // can't create element if one already has that id
        continue;
      }

      var id = data.id; // id is finalised, now let's keep a ref
      
      if( ele.isEdge() ){ // extra checks for edges
        
        var edge = ele;
        var fields = ['source', 'target'];
        var fieldsLength = fields.length;
        var badSourceOrTarget = false;
        for(var j = 0; j < fieldsLength; j++){
          
          var field = fields[j];
          var val = data[field];
          
          if( val == null || val === '' ){
            // can't create if source or target is not defined properly
            $$.util.error('Can not create edge `' + id + '` with unspecified ' + field);
            badSourceOrTarget = true;
          } else if( cy.getElementById(val).empty() ){ 
            // can't create edge if one of its nodes doesn't exist
            $$.util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
            badSourceOrTarget = true;
          }
        }

        if( badSourceOrTarget ){ continue; } // can't create this
        
        var src = cy.getElementById( data.source );
        var tgt = cy.getElementById( data.target );

        src._private.edges.push( edge );
        tgt._private.edges.push( edge );

        edge._private.source = src;
        edge._private.target = tgt;

      } // if is edge
       
      // create mock ids map for element so it can be used like collections
      _private.ids = {};
      _private.ids[ id ] = ele;

      _private.removed = false;
      cy.addToPool( ele );
      
      restored.push( ele );
    } // for each element

    // do compound node sanity checks
    for( var i = 0; i < numNodes; i++ ){ // each node 
      var node = elements[i];
      var data = node._private.data;

      var parentId = node._private.data.parent;
      var specifiedParent = parentId != null;

      if( specifiedParent ){
        var parent = cy.getElementById( parentId );

        if( parent.empty() ){
          // non-existant parent; just remove it
          data.parent = undefined;
        } else {
          var selfAsParent = false;
          var ancestor = parent;
          while( !ancestor.empty() ){
            if( node.same(ancestor) ){
              // mark self as parent and remove from data
              selfAsParent = true;
              data.parent = undefined; // remove parent reference

              // exit or we loop forever
              break;
            }

            ancestor = ancestor.parent();
          }

          if( !selfAsParent ){
            // connect with children
            parent[0]._private.children.push( node );
            node._private.parent = parent[0];

            // let the core know we have a compound graph
            cy._private.hasCompoundNodes = true;
          }
        } // else
      } // if specified parent
    } // for each node
    
    restored = new $$.Collection( cy, restored );
    if( restored.length > 0 ){

      var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
      toUpdateStyle.updateStyle( notifyRenderer );

      if( notifyRenderer ){
        restored.rtrigger('add');
      } else {
        restored.trigger('add');
      }
    }
    
    return self; // chainability
  };
  
  $$.elesfn.removed = function(){
    var ele = this[0];
    return ele && ele._private.removed;
  };

  $$.elesfn.inside = function(){
    var ele = this[0];
    return ele && !ele._private.removed;
  };

  $$.elesfn.remove = function( notifyRenderer ){
    var self = this;
    var removed = [];
    var elesToRemove = [];
    var elesToRemoveIds = {};
    var cy = self._private.cy;
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }
    
    // add connected edges
    function addConnectedEdges(node){
      var edges = node._private.edges; 
      for( var i = 0; i < edges.length; i++ ){
        add( edges[i] );
      }
    }
    

    // add descendant nodes
    function addChildren(node){
      var children = node._private.children;
      
      for( var i = 0; i < children.length; i++ ){
        add( children[i] );
      }
    }

    function add( ele ){
      var alreadyAdded =  elesToRemoveIds[ ele.id() ];
      if( alreadyAdded ){
        return;
      } else {
        elesToRemoveIds[ ele.id() ] = true;
      }

      if( ele.isNode() ){
        elesToRemove.push( ele ); // nodes are removed last

        addConnectedEdges( ele );
        addChildren( ele );
      } else {
        elesToRemove.unshift( ele ); // edges are removed first
      }
    }

    // make the list of elements to remove
    // (may be removing more than specified due to connected edges etc)

    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];

      add( ele );
    }
    
    function removeEdgeRef(node, edge){
      var connectedEdges = node._private.edges;
      for( var j = 0; j < connectedEdges.length; j++ ){
        var connectedEdge = connectedEdges[j];
        
        if( edge === connectedEdge ){
          connectedEdges.splice( j, 1 );
          break;
        }
      }
    }

    function removeChildRef(parent, ele){
      ele = ele[0];
      parent = parent[0];
      var children = parent._private.children;

      for( var j = 0; j < children.length; j++ ){
        if( children[j][0] === ele[0] ){
          children.splice(j, 1);
          break;
        }
      }
    }

    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];

      // mark as removed
      ele._private.removed = true;

      // remove from core pool
      cy.removeFromPool( ele );

      // add to list of removed elements
      removed.push( ele );

      if( ele.isEdge() ){ // remove references to this edge in its connected nodes
        var src = ele.source()[0];
        var tgt = ele.target()[0];

        removeEdgeRef( src, ele );
        removeEdgeRef( tgt, ele );

      } else { // remove reference to parent 
        var parent = ele.parent();

        if( parent.length !== 0 ){
          removeChildRef(parent, ele);
        }
      }
    }

    // check to see if we have a compound graph or not
    var elesStillInside = cy._private.elements;
    cy._private.hasCompoundNodes = false;
    for( var i = 0; i < elesStillInside.length; i++ ){
      var ele = elesStillInside[i];

      if( ele.isParent() ){
        cy._private.hasCompoundNodes = true;
        break;
      }
    }

    var removedElements = new $$.Collection( this.cy(), removed );
    if( removedElements.size() > 0 ){
      // must manually notify since trigger won't do this automatically once removed
      
      if( notifyRenderer ){
        this.cy().notify({
          type: 'remove',
          collection: removedElements
        });
      }
      
      removedElements.trigger('remove');
    }

    // check for empty remaining parent nodes
    var checkedParentId = {};
    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];
      var isNode = ele._private.group === 'nodes';
      var parentId = ele._private.data.parent;

      if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){
        checkedParentId[ parentId ] = true;
        var parent = cy.getElementById( parentId );

        if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){
          parent.updateStyle();
        }
      }
    }

    return this;
  };

  $$.elesfn.move = function( struct ){
    var cy = this._private.cy;

    if( struct.source !== undefined || struct.target !== undefined ){
      var srcId = struct.source;
      var tgtId = struct.target;
      var srcExists = cy.getElementById( srcId ).length > 0;
      var tgtExists = cy.getElementById( tgtId ).length > 0;

      if( srcExists || tgtExists ){
        var jsons = this.jsons();

        this.remove();

        for( var i = 0; i < jsons.length; i++ ){
          var json = jsons[i];

          if( json.group === 'edges' ){
            if( srcExists ){ json.data.source = srcId; }
            if( tgtExists ){ json.data.target = tgtId; }
          }
        }

        return cy.add( jsons );
      }
 
    } else if( struct.parent !== undefined ){ // move node to new parent
      var parentId = struct.parent;
      var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;
    
      if( parentExists ){
        var jsons = this.jsons();
        var descs = this.descendants();
        var descsEtc = descs.merge( descs.add(this).connectedEdges() );

        this.remove(); // NB: also removes descendants and their connected edges

        for( var i = 0; i < this.length; i++ ){
          var json = jsons[i];

          if( json.group === 'nodes' ){
            json.data.parent = parentId === null ? undefined : parentId;
          }
        }
      }

      return cy.add( jsons ).merge( descsEtc.restore() );
    }

    return this; // if nothing done
  };
  
})( cytoscape );


;(function($$){ 'use strict';

  // search, spanning trees, etc
  $$.fn.eles({

    // std functional ele first callback style
    stdBreadthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.breadthFirstSearch( options );
    },

    // do a breadth first search from the nodes in the collection
    // from pseudocode on wikipedia
    breadthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }

      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var Q = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var V = {};
      var j = 0;
      var found;
      var nodes = this.nodes();
      var edges = this.edges();

      // enqueue v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          Q.unshift( v[i] );
          V[ v[i].id() ] = true; 

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( Q.length !== 0 ){
        var v = Q.shift();
        var depth = id2depth[ v.id() ];
        var prevEdge = connectedBy[ v.id() ];
        var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
        var ret;

        if( std ){
          ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
        } else {
          ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
        }

        if( ret === true ){
          found = v;
          break;
        }

        if( ret === false ){
          break;
        }

        var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
        for( var i = 0; i < vwEdges.length; i++ ){
          var e = vwEdges[i];
          var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

          if( w.length !== 0 && !V[ w.id() ] ){
            w = w[0];

            Q.push( w );
            V[ w.id() ] = true;

            id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

            connectedNodes.push( w );
            connectedBy[ w.id() ] = e;
          }
        }
        
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // std functional ele first callback style
    stdDepthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.depthFirstSearch( options );
    },

    // do a depth first search on the nodes in the collection
    // from pseudocode on wikipedia (iterative impl)
    depthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }
      
      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var S = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var discovered = {};
      var j = 0;
      var found;
      var edges = this.edges();
      var nodes = this.nodes();

      // push v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          S.push( v[i] );

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( S.length !== 0 ){
        var v = S.pop();

        if( !discovered[ v.id() ] ){
          discovered[ v.id() ] = true;

          var depth = id2depth[ v.id() ];
          var prevEdge = connectedBy[ v.id() ];
          var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
          var ret;

          if( std ){
            ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
          } else {
            ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
          }

          if( ret === true ){
            found = v;
            break;
          }

          if( ret === false ){
            break;
          }

          var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
          
          for( var i = 0; i < vwEdges.length; i++ ){
            var e = vwEdges[i];
            var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

            if( w.length !== 0 && !discovered[ w.id() ] ){
              w = w[0];

              S.push( w );

              id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

              connectedNodes.push( w );
              connectedBy[ w.id() ] = e;
            }
          }
        }
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
    // implemented from pseudocode from wikipedia
    kruskal: function( weightFn ){
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      function findSet(ele){
        for( var i = 0; i < forest.length; i++ ){
          var eles = forest[i];

          if( eles.anySame(ele) ){
            return {
              eles: eles,
              index: i
            };
          }
        }
      }

      var A = new $$.Collection(this._private.cy, []);
      var forest = [];
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        forest.push( nodes[i].collection() );
      }

      var edges = this.edges();
      var S = edges.toArray().sort(function(a, b){
        var weightA = weightFn.call(a, a);
        var weightB = weightFn.call(b, b);

        return weightA - weightB;
      });

      for(var i = 0; i < S.length; i++){
        var edge = S[i];
        var u = edge.source()[0];
        var v = edge.target()[0];
        var setU = findSet(u);
        var setV = findSet(v);

        if( setU.index !== setV.index ){
          A = A.add( edge );

          // combine forests for u and v
          forest[ setU.index ] = setU.eles.add( setV.eles );
          forest.splice( setV.index, 1 );
        }
      }

      return nodes.add( A );

    },

    dijkstra: function( root, weightFn, directed ){
      var options;
      if( $$.is.plainObject(root) && !$$.is.elementOrCollection(root) ){
        options = root;
        root = options.root;
        weightFn = options.weight;
        directed = options.directed;
      }

      var cy = this._private.cy;
      directed = !$$.is.fn(weightFn) ? weightFn : directed;
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      var source = $$.is.string(root) ? this.filter(root).eq(0) : root.eq(0);
      var dist = {};
      var prev = {};
      var knownDist = {};

      var edges = this.edges().filter(function(){ return !this.isLoop(); });
      var nodes = this.nodes();
      var Q = [];

      for( var i = 0; i < nodes.length; i++ ){
        dist[ nodes[i].id() ] = nodes[i].same( source ) ? 0 : Infinity;
        Q.push( nodes[i] );
      }

      var valueFn = function(node) {
        return dist[ node.id() ];
      };
      
      Q = new $$.Collection(cy, Q);
    
      var heap = $$.Minheap(cy, Q, valueFn);
    
      var distBetween = function(u, v){
        var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);
        var smallestDistance = Infinity;
        var smallestEdge;

        for( var i = 0; i < uvs.length; i++ ){
          var edge = uvs[i];
          var weight = weightFn.apply( edge, [edge] );

          if( weight < smallestDistance || !smallestEdge ){
            smallestDistance = weight;
            smallestEdge = edge;
          }
        }

        return {
          edge: smallestEdge,
          dist: smallestDistance
        };
      };

      while(heap.size() > 0){
        var smallestEl = heap.pop(),
        smalletsDist = smallestEl.value,
        uid = smallestEl.id,
        u = cy.getElementById(uid);
    
        knownDist[uid] = smalletsDist;
      
        if( smalletsDist === Math.Infinite ){
          break;
        }

        var neighbors = u.neighborhood().intersect(nodes);
        for( var i = 0; i < neighbors.length; i++ ){
          var v = neighbors[i];
          var vid = v.id();
          var vDist = distBetween(u, v);

          var alt = smalletsDist + vDist.dist;

          if( alt < heap.getValueById(vid) ){
            heap.edit(vid, alt);
            prev[ vid ] = {
              node: u,
              edge: vDist.edge
            };
          }
        } // for 
      } // while

      return {
        distanceTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node).eq(0) : node.eq(0);

          return knownDist[ target.id() ];
        },

        pathTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node).eq(0) : node.eq(0);
          var S = [];
          var u = target;

          if( target.length > 0 ){
            S.unshift( target );

            while( prev[ u.id() ] ){
              var p = prev[ u.id() ];

              S.unshift( p.edge );
              S.unshift( p.node );

              u = p.node;
            }
          }

          return new $$.Collection( cy, S );
        }
      };
    }  
  });

  // nice, short mathemathical alias
  $$.elesfn.bfs = $$.elesfn.breadthFirstSearch;
  $$.elesfn.dfs = $$.elesfn.depthFirstSearch;
  $$.elesfn.stdBfs = $$.elesfn.stdBreadthFirstSearch;
  $$.elesfn.stdDfs = $$.elesfn.stdDepthFirstSearch;
  
})( cytoscape );
;(function($$) { 
  'use strict';

  // Additional graph analysis algorithms
  $$.fn.eles({

    // Implemented from pseudocode from wikipedia

    // options => options object
    //   root // starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   heuristic: function( node ){} // specifies heuristic value for `node`/`this`
    //   directed // default false
    //   goal // target node (either element or selector string). Mandatory.

    // retObj => returned object by function
    //   found : true/false // whether a path from root to goal has been found
    //   distance // Distance for the shortest path from root to goal
    //   path // Array of ids of nodes in shortest path
    aStar: function(options) {
      options = options || {};

      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };

      // Reconstructs the path from Start to End, acumulating the result in pathAcum
      var reconstructPath = function(start, end, cameFromMap, pathAcum) {
        // Base case
        if (start == end) {
          pathAcum.push( cy.getElementById(end) );
          return pathAcum;
        }
        
        if (end in cameFromMap) {
          // We know which node is before the last one
          var previous = cameFromMap[end];
          var previousEdge = cameFromEdge[end];

          pathAcum.push( cy.getElementById(end) );
          pathAcum.push( cy.getElementById(previousEdge) );


          return reconstructPath(start, 
                       previous, 
                       cameFromMap, 
                       pathAcum);
        }

        // We should not reach here!
        return undefined;       
      };

      // Returns the index of the element in openSet which has minimum fScore
      var findMin = function(openSet, fScore) {
        if (openSet.length === 0) {
          // Should never be the case
          return undefined;
        }
        var minPos = 0;
        var tempScore = fScore[openSet[0]];
        for (var i = 1; i < openSet.length; i++) {
          var s = fScore[openSet[i]];
          if (s < tempScore) {
            tempScore = s;
            minPos = i;
          }
        }
        return minPos;
      };

      // Parse options
      // debug - optional
      if (options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }

      logDebug("Starting aStar..."); 
      var cy = this._private.cy;

      // root - mandatory!
      if (options != null && options.root != null) {        
        var source = $$.is.string(options.root) ? 
          // use it as a selector, e.g. "#rootID
          this.filter(options.root)[0] : 
          options.root[0];
        logDebug("Source node: %s", source.id()); 
      } else {
        return undefined;
      }
      
      // goal - mandatory!
      if (options.goal != null) {       
        var target = $$.is.string(options.goal) ? 
          // use it as a selector, e.g. "#goalID
          this.filter(options.goal)[0] : 
          options.goal[0];
        logDebug("Target node: %s", target.id()); 
      } else {
        return undefined;
      }

      // Heuristic function - optional
      if (options.heuristic != null && $$.is.fn(options.heuristic)) {       
        var heuristic = options.heuristic;
      } else {
        var heuristic = function(){ return 0; }; // use constant if unspecified
        // $$.util.error("Missing required parameter (heuristic)! Aborting.");
        // return;
      }

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var closedSet = [];
      var openSet = [source.id()];
      var cameFrom = {};
      var cameFromEdge = {};
      var gScore = {};
      var fScore = {};

      gScore[source.id()] = 0;
      fScore[source.id()] = heuristic(source);
      
      var edges = this.edges().not(':loop');
      var nodes = this.nodes();

      // Counter
      var steps = 0;

      // Main loop 
      while (openSet.length > 0) {
        var minPos = findMin(openSet, fScore);
        var cMin = this.filter("#" + openSet[minPos])[0];
        steps++;

        logDebug("\nStep: %s", steps);
        logDebug("Processing node: %s, fScore = %s", cMin.id(), fScore[cMin.id()]);
        
        // If we've found our goal, then we are done
        if (cMin.id() == target.id()) {
          logDebug("Found goal node!");
          var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);
          rPath.reverse();
          logDebug("Path: %s", rPath);
          return {
            found : true,
            distance : gScore[cMin.id()],
            path : new $$.Collection(cy, rPath),
            steps : steps
          };          
        }
        
        // Add cMin to processed nodes
        closedSet.push(cMin.id());
        // Remove cMin from boundary nodes
        openSet.splice(minPos, 1);
        logDebug("Added node to closedSet, removed from openSet.");
        logDebug("Processing neighbors...");

        // Update scores for neighbors of cMin
        // Take into account if graph is directed or not
        var vwEdges = cMin.connectedEdges(directed ? '[source = "' + cMin.id() + '"]' 
                         : undefined).intersect(edges);         
        for (var i = 0; i < vwEdges.length; i++) {
          var e = vwEdges[i];
          var w = e.connectedNodes('[id != "' + cMin.id() + '"]').intersect(nodes);

          logDebug("   processing neighbor: %s", w.id());
          // if node is in closedSet, ignore it
          if (closedSet.indexOf(w.id()) != -1) {
            logDebug("   already in closedSet, ignoring it.");
            continue;
          }
          
          // New tentative score for node w
          var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);
          logDebug("   tentative gScore: %d", tempScore);

          // Update gScore for node w if:
          //   w not present in openSet
          // OR
          //   tentative gScore is less than previous value

          // w not in openSet
          if (openSet.indexOf(w.id()) == -1) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            openSet.push(w.id()); // Add node to openSet
            cameFrom[w.id()] = cMin.id();
            cameFromEdge[w.id()] = e.id();
            logDebug("   not in openSet, adding it. ");
            logDebug("   fScore(%s) = %s", w.id(), tempScore);
            continue;
          }
          // w already in openSet, but with greater gScore
          if (tempScore < gScore[w.id()]) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            cameFrom[w.id()] = cMin.id();
            logDebug("   better score, replacing gScore. ");
            logDebug("   fScore(%s) = %s", w.id(), tempScore);
          }

        } // End of neighbors update

      } // End of main loop

      // If we've reached here, then we've not reached our goal
      logDebug("Reached end of computation without finding our goal");
      return {
        found : false,
        distance : undefined,
        path : undefined,
        steps : steps
      };
    }, // aStar()


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(fromId, toId) // Returns the shortest path from node with ID "fromID" to node with ID "toId", as an array of node IDs
    //   distanceTo: function(fromId, toId) // Returns the distance of the shortest path from node with ID "fromID" to node with ID "toId"
    floydWarshall: function(options) {
      options = options || {};

      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };

      // Parse options
      // debug - optional
      if (options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }
      logDebug("Starting floydWarshall..."); 

      var cy = this._private.cy;

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var edges = this.edges().not(':loop');
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initialize distance matrix
      var dist = [];
      for (var i = 0; i < numNodes; i++) {
        var newRow = new Array(numNodes);
        for (var j = 0; j < numNodes; j++) {
          if (i == j) {
            newRow[j] = 0;
          } else {
            newRow[j] = Infinity;
          }
        }
        dist.push(newRow);
      }           

      // Initialize matrix used for path reconstruction
      // Initialize distance matrix
      var next = [];
      var edgeNext = [];

      var initMatrix = function(next){
        for (var i = 0; i < numNodes; i++) {
          var newRow = new Array(numNodes);
          for (var j = 0; j < numNodes; j++) {
            newRow[j] = undefined;
          }
          next.push(newRow);
        }
      };

      initMatrix(next);
      initMatrix(edgeNext);
      
      // Process edges
      for (var i = 0; i < edges.length ; i++) {     
        var sourceIndex = id2position[edges[i].source().id()];
        var targetIndex = id2position[edges[i].target().id()];    
        var weight = weightFn.apply(edges[i], [edges[i]]);
        
        // Check if already process another edge between same 2 nodes
        if (dist[sourceIndex][targetIndex] > weight) {
          dist[sourceIndex][targetIndex] = weight;
          next[sourceIndex][targetIndex] = targetIndex;
          edgeNext[sourceIndex][targetIndex] = edges[i];
        }
      }

      // If undirected graph, process 'reversed' edges
      if (!directed) {
        for (var i = 0; i < edges.length ; i++) {     
          var sourceIndex = id2position[edges[i].target().id()];    
          var targetIndex = id2position[edges[i].source().id()];
          var weight = weightFn.apply(edges[i], [edges[i]]);
          
          // Check if already process another edge between same 2 nodes
          if (dist[sourceIndex][targetIndex] > weight) {
            dist[sourceIndex][targetIndex] = weight;
            next[sourceIndex][targetIndex] = targetIndex;
            edgeNext[sourceIndex][targetIndex] = edges[i];
          }
        }
      }

      // Main loop
      for (var k = 0; k < numNodes; k++) {
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {            
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
              dist[i][j] = dist[i][k] + dist[k][j];
              next[i][j] = next[i][k];
            }
          }
        }
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }

      var res = {
        distance: function(from, to) {
          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return dist[id2position[fromId]][id2position[toId]];
        },

        path: function(from, to) {
          var reconstructPathAux = function(from, to, next, position2id, edgeNext) {
            if (from === to) {
              return cy.getElementById( position2id[from] );
            }
            if (next[from][to] === undefined) {
              return undefined;
            }

            var path = [ cy.getElementById(position2id[from]) ];
            var prev = from;
            while (from !== to) {
              prev = from;
              from = next[from][to];

              var edge = edgeNext[prev][from];
              path.push( edge );

              path.push( cy.getElementById(position2id[from]) );
            }
            return path;
          };

          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          
          var pathArr = reconstructPathAux(id2position[fromId], 
                        id2position[toId], 
                        next,
                        position2id,
                        edgeNext);

          return new $$.Collection( cy, pathArr );
        },
      };

      return res;

    }, // floydWarshall


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   root: starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(toId) // Returns the shortest path from root node to node with ID "toId", as an array of node IDs
    //   distanceTo: function(toId) // Returns the distance of the shortest path from root node to node with ID "toId"
    //   hasNegativeWeightCycle: true/false (if true, pathTo and distanceTo will be undefined)
    bellmanFord: function(options) {
      options = options || {};

      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };

      // Parse options
      // debug - optional
      if (options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }
      logDebug("Starting bellmanFord..."); 

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // root - mandatory!
      if (options.root != null) {       
        if ($$.is.string(options.root)) {
          // use it as a selector, e.g. "#rootID
          var source = this.filter(options.root)[0];
        } else {
          var source = options.root[0];
        }
        logDebug("Source node: %s", source.id()); 
      } else {
        $$.util.error("options.root required");
        return undefined;
      }

      var cy = this._private.cy;
      var edges = this.edges().not(':loop');
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initializations
      var cost = [];
      var predecessor = [];
      var predEdge = [];
      
      for (var i = 0; i < numNodes; i++) {
        if (nodes[i].id() === source.id()) {
          cost[i] = 0;
        } else {
          cost[i] = Infinity;
        } 
        predecessor[i] = undefined;
      }
      
      // Edges relaxation      
      var flag = false;
      for (var i = 1; i < numNodes; i++) {
        flag = false;
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          var temp = cost[sourceIndex] + weight;
          if (temp < cost[targetIndex]) {
            cost[targetIndex] = temp;
            predecessor[targetIndex] = sourceIndex;
            predEdge[targetIndex] = edges[e];
            flag = true;
          }

          // If undirected graph, we need to take into account the 'reverse' edge
          if (!directed) {
            var temp = cost[targetIndex] + weight;
            if (temp < cost[sourceIndex]) {
              cost[sourceIndex] = temp;
              predecessor[sourceIndex] = targetIndex;
              predEdge[sourceIndex] = edges[e];
              flag = true;
            }
          }
        }

        if (!flag) {
          break;
        }
      }      
            
      if (flag) {
        // Check for negative weight cycles
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          if (cost[sourceIndex] + weight < cost[targetIndex]) {
            $$.util.error("Error: graph contains a negative weigth cycle!"); 
            return { pathTo: undefined,
                 distanceTo: undefined,
                 hasNegativeWeightCycle: true};
          }
        }     
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }
      
      
      var res = {       
        distanceTo : function(to) {
          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return cost[id2position[toId]];
        }, 

        pathTo : function(to) {

          var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
            for(;;){
              // Add toId to path
              acumPath.push( cy.getElementById(position2id[toPos]) );
              acumPath.push( predEdge[toPos] );

              if (fromPos === toPos) {
                // reached starting node
                return acumPath;
              }

              // If no path exists, discart acumulated path and return undefined
              var predPos = predecessor[toPos];
              if (typeof predPos === "undefined") {
                return undefined;
              }

              toPos = predPos;
            }

          };

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          var path = [];

          // This returns a reversed path 
          var res =  reconstructPathAux(predecessor, 
                        id2position[source.id()],
                        id2position[toId], 
                        position2id, 
                        path,
                        predEdge);

          // Get it in the correct order and return it
          if (res != null) {
            res.reverse();
          }

          return new $$.Collection(cy, res);                       
        }, 

        hasNegativeWeightCycle: false
      };

      return res;

    }, // bellmanFord


    // Computes the minimum cut of an undirected graph
    // Returns the correct answer with high probability
    // options => options object
    // 
    // retObj => returned object by function
    //   cut : list of IDs of edges in the cut,
    //   partition1: list of IDs of nodes in one partition
    //   partition2: list of IDs of nodes in the other partition
    kargerStein: function(options) {
      options = options || {};
      
      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };

      // Function which colapses 2 (meta) nodes into one
      // Updates the remaining edge lists
      // Receives as a paramater the edge which causes the collapse
      var colapse = function(edgeIndex, nodeMap, remainingEdges) {
        var edgeInfo = remainingEdges[edgeIndex];
        var sourceIn = edgeInfo[1];
        var targetIn = edgeInfo[2];
        var partition1 = nodeMap[sourceIn];
        var partition2 = nodeMap[targetIn];

        // Delete all edges between partition1 and partition2
        var newEdges = remainingEdges.filter(function(edge) {
          if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
            return false;
          }
          if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
            return false;
          }
          return true;
        });
        
        // All edges pointing to partition2 should now point to partition1
        for (var i = 0; i < newEdges.length; i++) {
          var edge = newEdges[i];
          if (edge[1] === partition2) { // Check source
            newEdges[i] = edge.slice(0);
            newEdges[i][1] = partition1;
          } else if (edge[2] === partition2) { // Check target
            newEdges[i] = edge.slice(0);
            newEdges[i][2] = partition1;
          }
        } 
        
        // Move all nodes from partition2 to partition1
        for (var i = 0; i < nodeMap.length; i++) {
          if (nodeMap[i] === partition2) {
            nodeMap[i] = partition1;
          }
        }
        
        return newEdges;
      };


      // Contracts a graph until we reach a certain number of meta nodes
      var contractUntil = function(metaNodeMap, 
                     remainingEdges,
                     size, 
                     sizeLimit) {
        // Stop condition
        if (size <= sizeLimit) {
          return remainingEdges;
        }
        
        // Choose an edge randomly
        var edgeIndex = Math.floor((Math.random() * remainingEdges.length));

        // Colapse graph based on edge
        var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);
        
        return contractUntil(metaNodeMap, 
                   newEdges, 
                   size - 1, 
                   sizeLimit);        
      };


      // Parse options
      // debug - optional
      if (options != null && options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }
      logDebug("Starting kargerStein..."); 

      var cy = this._private.cy;
      var edges = this.edges().not(':loop');
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;
      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
      var stopSize = Math.floor(numNodes / Math.sqrt(2));

      if (numNodes < 2) {
        $$.util.error("At least 2 nodes are required for KargerSteing algorithm!"); 
        return undefined;
      }

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Now store edge destination as indexes
      // Format for each edge (edge index, source node index, target node index)
      var edgeIndexes = [];
      for (var i = 0; i < numEdges; i++) {
        var e = edges[i];
        edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
      }

      // We will store the best cut found here
      var minCutSize = Infinity;
      var minCut;     

      // Initial meta node partition
      var originalMetaNode = [];
      for (var i = 0; i < numNodes; i++) {
        originalMetaNode.push(i);
      }

      // Main loop
      for (var iter = 0; iter <= numIter; iter++) {
        // Create new meta node partition
        var metaNodeMap = originalMetaNode.slice(0);

        // Contract until stop point (stopSize nodes)
        var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);
        
        // Create a copy of the colapsed nodes state
        var metaNodeMap2 = metaNodeMap.slice(0);

        // Run 2 iterations starting in the stop state
        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
        var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

        // Is any of the 2 results the best cut so far?
        if (res1.length <= res2.length && res1.length < minCutSize) {
          minCutSize = res1.length;
          minCut = [res1, metaNodeMap];
        } else if (res2.length <= res1.length && res2.length < minCutSize) {
          minCutSize = res2.length;
          minCut = [res2, metaNodeMap2];
        }
      } // end of main loop

      
      // Construct result
      var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });
      var partition1 = [];
      var partition2 = [];

      // traverse metaNodeMap for best cut
      var witnessNodePartition = minCut[1][0];
      for (var i = 0; i < minCut[1].length; i++) { 
        var partitionId = minCut[1][i]; 
        if (partitionId === witnessNodePartition) {
          partition1.push(nodes[i]);
        } else {
          partition2.push(nodes[i]);
        }       
      }
      
      var ret = {
        cut: new $$.Collection(cy, resEdges),
        partition1: new $$.Collection(cy, partition1),
        partition2: new $$.Collection(cy, partition2)
      };
      
      return ret;
    },


    // 
    // options => options object
    //   dampingFactor: optional
    //   precision: optional
    //   iterations : optional
    // retObj => returned object by function
    //  rank : function that returns the pageRank of a given node (object or selector string)
    pageRank: function(options) {
      options = options || {};
      
      var normalizeVector = function(vector) {
        var length = vector.length;

        // First, get sum of all elements
        var total = 0; 
        for (var i = 0; i < length; i++) {
          total += vector[i];
        }

        // Now, divide each by the sum of all elements
        for (var i = 0; i < length; i++) {
          vector[i] = vector[i] / total;
        }
      };
      
      var logDebug = function() {
        if (debug) {
          console.log.apply(console, arguments);
        }
      };
      
      // Parse options
      // debug - optional
      if (options != null && 
        options.debug != null) {
        var debug = options.debug;
      } else {
        var debug = false;
      }
      logDebug("Starting pageRank..."); 

      // dampingFactor - optional
      if (options != null && 
        options.dampingfactor != null) {
        var dampingFactor = options.dampingFactor;
      } else {
        var dampingFactor = 0.8; // Default damping factor
      }

      // desired precision - optional
      if (options != null && 
        options.precision != null) {
        var epsilon = options.precision;
      } else {
        var epsilon = 0.000001; // Default precision
      }

      // Max number of iterations - optional
      if (options != null && 
        options.iterations != null) {
        var numIter = options.iterations;
      } else {
        var numIter = 200; // Default number of iterations
      }

      // Weight function - optional
      if (options != null && 
        options.weight != null && 
        $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;}; 
      }

      var cy = this._private.cy;
      var edges = this.edges().not(':loop');
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Construct transposed adjacency matrix
      // First lets have a zeroed matrix of the right size
      // We'll also keep track of the sum of each column
      var matrix = [];
      var columnSum = [];
      var additionalProb = (1 - dampingFactor) / numNodes;

      // Create null matric
      for (var i = 0; i < numNodes; i++) { 
        var newRow = [];
        for (var j = 0; j < numNodes; j++) {
          newRow.push(0.0);
        }
        matrix.push(newRow);
        columnSum.push(0.0);
      }

      // Now, process edges
      for (var i = 0; i < numEdges; i++) {
        var edge = edges[i];
        var s = id2position[edge.source().id()];
        var t = id2position[edge.target().id()];
        var w = weightFn.apply(edge, [edge]);
        
        // Update matrix
        matrix[t][s] += w;

        // Update column sum
        columnSum[s] += w; 
      }

      // Add additional probability based on damping factor
      // Also, take into account columns that have sum = 0
      var p = 1.0 / numNodes + additionalProb; // Shorthand
      // Traverse matrix, column by column
      for (var j = 0; j < numNodes; j++) { 
        if (columnSum[j] === 0) {
          // No 'links' out from node jth, assume equal probability for each possible node
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = p;
          }
        } else {
          // Node jth has outgoing link, compute normalized probabilities
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
          }         
        }
      }

      // Compute dominant eigenvector using power method
      var eigenvector = [];
      var nullVector = [];
      var previous;

      // Start with a vector of all 1's
      // Also, initialize a null vector which will be used as shorthand
      for (var i = 0; i < numNodes; i++) {
        eigenvector.push(1.0);
        nullVector.push(0.0);
      }
            
      for (var iter = 0; iter < numIter; iter++) {
        // New array with all 0's
        var temp = nullVector.slice(0);
        
        // Multiply matrix with previous result
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {        
            temp[i] += matrix[i][j] * eigenvector[j];
          }
        }

        normalizeVector(temp);
        previous = eigenvector;
        eigenvector = temp;

        var diff = 0;
        // Compute difference (squared module) of both vectors
        for (var i = 0; i < numNodes; i++) {
          diff += Math.pow(previous[i] - eigenvector[i], 2);
        }
        
        // If difference is less than the desired threshold, stop iterating
        if (diff < epsilon) {
          logDebug("Stoped at iteration %s", iter);
          break;
        }
      }
            
      logDebug("Result:\n" + eigenvector);

      // Construct result
      var res = {
        rank : function(node) {
          if ($$.is.string(node)) {
            // is a selector string
            var nodeId = (cy.filter(node)[0]).id();
          } else {
            // is a node object
            var nodeId = node.id();
          }
          return eigenvector[id2position[nodeId]];
        }
      };


      return res;
    } // pageRank

  }); // $$.fn.eles


}) (cytoscape);
;(function( $$ ){ 'use strict';

  $$.fn.eles({
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop()
  });
  
})( cytoscape );  

;(function( $$ ){ 'use strict';
  
  $$.fn.eles({
    classes: function(opts){
      var eles = this;
      var changed = [];
      var fn;

      if( $$.is.fn(opts) ){
        fn = opts;

      } else if( !$$.is.plainObject(opts) ){
        return this; // needs opts or fn
      } 

      for(var i = 0; i < eles.length; i++){
        var ele = eles[i];
        var eleChanged = false;

        opts = fn ? fn.apply(ele, [i, ele]) : opts;

        // add classes
        if( opts.add ){ for( var j = 0; j < opts.add.length; j++ ){
          var cls = opts.add[j];
          var hasClass = ele._private.classes[cls];

          ele._private.classes[cls] = true;

          if( !hasClass && !eleChanged ){
            changed.push( ele );
            eleChanged = true;
          }
        } }

        // remove classes
        if( opts.remove ){ for( var j = 0; j < opts.remove.length; j++ ){
          var cls = opts.remove[j];
          var hasClass = ele._private.classes[cls];

          ele._private.classes[cls] = false;

          if( hasClass && !eleChanged ){
            changed.push( ele );
            eleChanged = true;
          }
        } }

        // toggle classes
        if( opts.toggle ){ for( var j = 0; j < opts.toggle.length; j++ ){
          var cls = opts.toggle[j];
          var hasClass = ele._private.classes[cls];

          ele._private.classes[cls] = !hasClass;

          if( !eleChanged ){
            changed.push( ele );
            eleChanged = true;
          }
        } }
      }

      if( changed.length > 0 ){
        new $$.Collection( this.cy(), changed )
          .updateStyle()
          .trigger('class')
        ;
      }

      return this;
    },

    addClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];
      
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[i];
        if( $$.is.emptyString(cls) ){ continue; }
        
        for( var j = 0; j < self.length; j++ ){
          var ele = self[j];
          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = true;

          if( !hasClass ){ // if didn't already have, add to list of changed
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    hasClass: function(className){
      var ele = this[0];
      return ( ele != null && ele._private.classes[className] ) ? true : false;
    },

    toggleClass: function(classesStr, toggle){
      var classes = classesStr.split(/\s+/);
      var self = this;
      var changed = []; // eles who had classes changed
      
      for( var i = 0, il = self.length; i < il; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];

          if( $$.is.emptyString(cls) ){ continue; }
          
          var hasClass = ele._private.classes[cls];
          var shouldAdd = toggle || (toggle === undefined && !hasClass);

          if( shouldAdd ){
            ele._private.classes[cls] = true;

            if( !hasClass ){ changed.push(ele); }
          } else { // then remove
            ele._private.classes[cls] = false;

            if( hasClass ){ changed.push(ele); }
          }

        } // for j classes
      } // for i eles
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    removeClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];

      for( var i = 0; i < self.length; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];
          if( !cls || cls === '' ){ continue; }

          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = undefined;

          if( hasClass ){ // then we changed its set of classes
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(self._private.cy, changed).updateStyle();
      }

      self.trigger('class');
      return self;
    },

    flashClass: function(classes, duration){
      var self = this;

      if( duration == null ){
        duration = 250;
      } else if( duration === 0 ){
        return self; // nothing to do really
      }

      self.addClass( classes );
      setTimeout(function(){
        self.removeClass( classes );
      }, duration);

      return self;
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    allAre: function( selector ){
      return this.filter(selector).length === this.length;
    },

    is: function( selector ){
      return this.filter(selector).length > 0;
    },

    some: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = fn.apply( thisArg, [ this[i], i, this ] );

        if( ret ){
          return true;
        }
      }

      return false;
    },

    every: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = fn.apply( thisArg, [ this[i], i, this ] );

        if( !ret ){
          return false;
        }
      }

      return true;
    },

    same: function( collection ){
      collection = this.cy().collection( collection );

      // cheap extra check
      if( this.length !== collection.length ){
        return false;
      }

      return this.intersect( collection ).length === this.length;
    },

    anySame: function( collection ){
      collection = this.cy().collection( collection );

      return this.intersect( collection ).length > 0;
    },

    allAreNeighbors: function( collection ){
      collection = this.cy().collection( collection );

      return this.neighborhood().intersect( collection ).length === collection.length;
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  // Compound functions
  /////////////////////

  $$.fn.eles({
    parent: function( selector ){
      var parents = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parent = cy.getElementById( ele._private.data.parent );

        if( parent.size() > 0 ){
          parents.push( parent );
        }
      }
      
      return new $$.Collection( cy, parents, { unique: true } ).filter( selector );
    },

    parents: function( selector ){
      var parents = [];

      var eles = this.parent();
      while( eles.nonempty() ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];
          parents.push( ele );
        }

        eles = eles.parent();
      }

      return new $$.Collection( this.cy(), parents, { unique: true } ).filter( selector );
    },

    commonAncestors: function( selector ){
      var ancestors;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parents = ele.parents();
        
        ancestors = ancestors || parents;

        ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
      }

      return ancestors.filter( selector );
    },

    orphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().empty();
      }).filter( selector );
    },

    nonorphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().nonempty();
      }).filter( selector );
    },

    children: function( selector ){
      var children = [];

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        children = children.concat( ele._private.children );
      }

      return new $$.Collection( this.cy(), children, { unique: true } ).filter( selector );
    },

    siblings: function( selector ){
      return this.parent().children().not( this ).filter( selector );
    },

    isParent: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.children.length !== 0;
      }
    },

    isChild: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.parent !== undefined && ele.parent().length !== 0;
      }
    },

    descendants: function( selector ){
      var elements = [];

      function add( eles ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          elements.push( ele );

          if( ele.children().nonempty() ){
            add( ele.children() );
          }
        }
      }

      add( this.children() );

      return new $$.Collection( this.cy(), elements, { unique: true } ).filter( selector );
    }
  });

  // aliases
  $$.elesfn.ancestors = $$.elesfn.parents;
  
})( cytoscape );
;(function($$){ 'use strict';
  
  var borderWidthMultiplier = 2 * 0.5;
  var borderWidthAdjustment = 0;

  $$.fn.eles({

    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      triggerEvent: false
    }),

    rscratch: $$.define.data({
      field: 'rscratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeRscratch: $$.define.removeData({
      field: 'rscratch',
      triggerEvent: false
    }),

    id: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.id;
      }
    },

    position: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: true,
      triggerFnName: 'rtrigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        var updatedEles = eles.updateCompoundBounds();
        updatedEles.rtrigger('position');
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    // position but no notification to renderer
    silentPosition: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: false,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        eles.updateCompoundBounds();
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    positions: function( pos, silent ){
      if( $$.is.plainObject(pos) ){
        this.position(pos);
        
      } else if( $$.is.fn(pos) ){
        var fn = pos;
        
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          var pos = fn.apply(ele, [i, ele]);

          if( pos && !ele.locked() ){
            var elePos = ele._private.position;
            elePos.x = pos.x;
            elePos.y = pos.y;
          }
        }

        var updatedEles = this.updateCompoundBounds();
        var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;

        if( silent ){
          toTrigger.trigger('position');
        } else {
          toTrigger.rtrigger('position');
        }
      }

      return this; // chaining
    },

    silentPositions: function( pos ){
      return this.positions( pos, true );
    },

    updateCompoundBounds: function(){
      var cy = this.cy();

      if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled

      var updated = [];

      function update( parent ){
        var children = parent.children();
        var style = parent._private.style;
        var bb = children.boundingBox({ includeLabels: false, includeEdges: false });
        var padding = {
          top: style['padding-top'].pxValue,
          bottom: style['padding-bottom'].pxValue,
          left: style['padding-left'].pxValue,
          right: style['padding-right'].pxValue
        };
        var pos = parent._private.position;
        var didUpdate = false;

        if( style['width'].value === 'auto' ){
          parent._private.autoWidth = bb.w + padding.left + padding.right;
          pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;
          didUpdate = true;
        }

        if( style['height'].value === 'auto' ){
          parent._private.autoHeight = bb.h + padding.top + padding.bottom;
          pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;
          didUpdate = true;
        }

        if( didUpdate ){
          updated.push( parent );
        }
      }

      // go up, level by level
      var eles = this.parent();
      while( eles.nonempty() ){

        // update each parent node in this level
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          update( ele );
        }

        // next level
        eles = eles.parent();
      }

      // return changed
      return new $$.Collection( cy, updated );
    },

    // get/set the rendered (i.e. on screen) positon of the element
    renderedPosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();
      var rpos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = rpos !== undefined || ( val !== undefined && $$.is.string(dim) );

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = ( val - pan[dim] )/zoom;
            } else if( rpos !== undefined ){ // set whole position
              ele._private.position = {
                x: ( rpos.x - pan.x ) /zoom,
                y: ( rpos.y - pan.y ) /zoom
              };
            }
          }

          this.rtrigger('position');
        } else { // getting
          var pos = ele._private.position;
          rpos = {
            x: pos.x * zoom + pan.x,
            y: pos.y * zoom + pan.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return rpos;
          } else { // then return the specified dimension
            return rpos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // get/set the position relative to the parent
    parentPosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var ppos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = ppos !== undefined || ( val !== undefined && $$.is.string(dim) );
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];
            var parent = hasCompoundNodes ? ele.parent() : null;
            var hasParent = parent && parent.length > 0;
            var relativeToParent = hasParent;

            if( hasParent ){
              parent = parent[0];
            }

            var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = val + origin[dim];
            } else if( ppos !== undefined ){ // set whole position
              ele._private.position = {
                x: ppos.x + origin.x,
                y: ppos.y + origin.y,
              };
            }
          }

          this.rtrigger('position');

        } else { // getting
          var pos = ele._private.position;
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          ppos = {
            x: pos.x - origin.x,
            y: pos.y - origin.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return ppos;
          } else { // then return the specified dimension
            return ppos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // convenience function to get a numerical value for the width of the node/edge
    width: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var w = ele._private.style.width;
          return w.strValue === 'auto' ? ele._private.autoWidth : w.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerWidth: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var style = ele._private.style;
          var width = style.width.strValue === 'auto' ? ele._private.autoWidth : style.width.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;

          return width + border;
        } else {
          return 1;
        }
      }
    },

    renderedWidth: function(){
      var ele = this[0];

      if( ele ){
        var width = ele.width();
        return width * this.cy().zoom();
      }
    },

    renderedOuterWidth: function(){
      var ele = this[0];

      if( ele ){
        var owidth = ele.outerWidth();
        return owidth * this.cy().zoom();
      }
    },

    // convenience function to get a numerical value for the height of the node
    height: function(){ 
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var h = ele._private.style.height;
          return h.strValue === 'auto' ? ele._private.autoHeight : h.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerHeight: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var style = ele._private.style;
          var height = style.height.strValue === 'auto' ? ele._private.autoHeight : style.height.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;
        } else {
          return 1;
        }

        return height + border;
      }
    },

    renderedHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var height = ele.height();
        return height * this.cy().zoom();
      }
    },

    renderedOuterHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var oheight = ele.outerHeight();
        return oheight * this.cy().zoom();
      }
    },

    renderedBoundingBox: function( options ){
      var bb = this.boundingBox( options );
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();

      var x1 = bb.x1 * zoom + pan.x;
      var x2 = bb.x2 * zoom + pan.x;
      var y1 = bb.y1 * zoom + pan.y;
      var y2 = bb.y2 * zoom + pan.y;

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    },

    // get the bounding box of the elements (in raw model position)
    boundingBox: function( options ){
      var eles = this;
      var cy = eles._private.cy;
      var cy_p = cy._private;
      var styleEnabled = cy_p.styleEnabled;

      options = options || {};

      var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;
      var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;
      var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;

      // recalculate projections etc
      if( styleEnabled ){
        cy_p.renderer.recalculateRenderedStyle( this );
      }

      var x1 = Infinity;
      var x2 = -Infinity;
      var y1 = Infinity;
      var y2 = -Infinity;

      // find bounds of elements
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var _p = ele._private;
        var display = styleEnabled ? _p.style['display'].value : 'element';
        var isNode = _p.group === 'nodes';
        var ex1, ex2, ey1, ey2, x, y;
        var includedEle = false;

        if( display === 'none' ){ continue; } // then ele doesn't take up space      

        if( isNode && includeNodes ){
          includedEle = true;

          var pos = _p.position;
          x = pos.x;
          y = pos.y;
          var w = ele.outerWidth();
          var halfW = w/2;
          var h = ele.outerHeight();
          var halfH = h/2;

          // handle node dimensions
          /////////////////////////

          ex1 = x - halfW;
          ex2 = x + halfW;
          ey1 = y - halfH;
          ey2 = y + halfH;

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

        } else if( ele.isEdge() && includeEdges ){ 
          includedEle = true;

          var n1pos = ele._private.source._private.position;
          var n2pos = ele._private.target._private.position;

          // handle edge dimensions (rough box estimate)
          //////////////////////////////////////////////

          var rstyle = ele._private.rstyle || {};

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;

          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

          // handle points along edge (sanity check)
          //////////////////////////////////////////

          if( styleEnabled ){
            var bpts = rstyle.bezierPts || [];

            var w = ele._private.style['width'].pxValue;
            var wHalf = w/2;

            for( var j = 0; j < bpts.length; j++ ){
              var bpt = bpts[j];

              ex1 = bpt.x - wHalf;
              ex2 = bpt.x + wHalf;
              ey1 = bpt.y - wHalf;
              ey2 = bpt.y + wHalf;

              x1 = ex1 < x1 ? ex1 : x1;
              x2 = ex2 > x2 ? ex2 : x2;
              y1 = ey1 < y1 ? ey1 : y1;
              y2 = ey2 > y2 ? ey2 : y2;
            }
          }

        } // edges

        // handle label dimensions
        //////////////////////////

        if( styleEnabled ){

          var style = ele._private.style;
          var rstyle = ele._private.rstyle;
          var label = style['content'].strValue;
          var fontSize = style['font-size'];
          var halign = style['text-halign'];
          var valign = style['text-valign'];
          var labelWidth = rstyle.labelWidth;
          var labelHeight = rstyle.labelHeight;
          var labelX = rstyle.labelX;
          var labelY = rstyle.labelY;

          if( includedEle && includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){
            var lh = labelHeight;
            var lw = labelWidth;
            var lx1, lx2, ly1, ly2;

            if( ele.isEdge() ){
              lx1 = labelX - lw/2;
              lx2 = labelX + lw/2;
              ly1 = labelY - lh/2;
              ly2 = labelY + lh/2;
            } else {
              switch( halign.value ){
                case 'left':
                  lx1 = labelX - lw;
                  lx2 = labelX;
                  break;

                case 'center':
                  lx1 = labelX - lw/2;
                  lx2 = labelX + lw/2;
                  break;

                case 'right':
                  lx1 = labelX;
                  lx2 = labelX + lw;
                  break;
              }

              switch( valign.value ){
                case 'top':
                  ly1 = labelY - lh;
                  ly2 = labelY;
                  break;

                case 'center':
                  ly1 = labelY - lh/2;
                  ly2 = labelY + lh/2;
                  break;

                case 'bottom':
                  ly1 = labelY;
                  ly2 = labelY + lh;
                  break;
              }
            }

            x1 = lx1 < x1 ? lx1 : x1;
            x2 = lx2 > x2 ? lx2 : x2;
            y1 = ly1 < y1 ? ly1 : y1;
            y2 = ly2 > y2 ? ly2 : y2;
          }
        } // style enabled
      } // for

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    }
  }); 

  // in case some users want to be explicit
  $$.elesfn.modelPosition = $$.elesfn.position;
  $$.elesfn.modelPositions = $$.elesfn.positions;
  
})( cytoscape );

;(function( $$ ){ 'use strict';
  
  // Regular degree functions (works on single element)
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeFunction(callback){
    return function( includeLoops ){
      var self = this;

      if( includeLoops === undefined ){
        includeLoops = true;
      }
      
      if( self.length === 0 ){ return; }

      if( self.isNode() && !self.removed() ){
        var degree = 0;
        var node = self[0];
        var connectedEdges = node._private.edges;

        for( var i = 0; i < connectedEdges.length; i++ ){
          var edge = connectedEdges[i];

          if( !includeLoops && edge.isLoop() ){
            continue;
          }

          degree += callback( node, edge );
        }
        
        return degree;
      } else {
        return;
      }
    };
  }
  
  $$.fn.eles({
    degree: defineDegreeFunction(function(node, edge){
      if( edge.source().same( edge.target() ) ){
        return 2;
      } else {
        return 1;
      }
    }),

    indegree: defineDegreeFunction(function(node, edge){
      if( edge.target().same(node) ){
        return 1;
      } else {
        return 0;
      }
    }),

    outdegree: defineDegreeFunction(function(node, edge){
      if( edge.source().same(node) ){
        return 1;
      } else {
        return 0;
      }
    })
  });
  
  
  // Collection degree stats
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeBoundsFunction(degreeFn, callback){
    return function( includeLoops ){
      var ret;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        var ele = nodes[i];
        var degree = ele[degreeFn]( includeLoops );
        if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){
          ret = degree;
        }
      }
      
      return ret;
    };
  }
  
  $$.fn.eles({
    minDegree: defineDegreeBoundsFunction('degree', function(degree, min){
      return degree < min;
    }),

    maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){
      return degree > max;
    }),

    minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){
      return degree < min;
    }),

    maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){
      return degree > max;
    }),

    minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){
      return degree < min;
    }),

    maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){
      return degree > max;
    })
  });
  
  $$.fn.eles({
    totalDegree: function( includeLoops ){
      var total = 0;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        total += nodes[i].degree( includeLoops );
      }

      return total;
    }
  });
  
})( cytoscape );

  
;(function($$){ 'use strict';
  
  // Functions for binding & triggering events
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger(), // .trigger( events [, extraParams] )

    rtrigger: function(event, extraParams){ // for internal use only
      if( this.length === 0 ){ return; } // empty collections don't need to notify anything

      // notify renderer
      this.cy().notify({
        type: event,
        collection: this
      });
      
      this.trigger(event, extraParams);
      return this;
    }
  });

  // aliases for those folks who like old stuff:
  $$.elesfn.bind = $$.elesfn.on;
  $$.elesfn.unbind = $$.elesfn.off;
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    nodes: function( selector ){
      return this.filter(function(i, element){
        return element.isNode();
      }).filter(selector);
    },

    edges: function( selector ){
      return this.filter(function(i, element){
        return element.isEdge();
      }).filter(selector);
    },

    filter: function( filter ){
      var cy = this._private.cy;
      
      if( $$.is.fn(filter) ){
        var elements = [];

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( filter.apply(ele, [i, ele]) ){
            elements.push(ele);
          }
        }
        
        return new $$.Collection(cy, elements);
      
      } else if( $$.is.string(filter) || $$.is.elementOrCollection(filter) ){
        return new $$.Selector(filter).filter(this);
      
      } else if( filter === undefined ){
        return this;
      }

      return new $$.Collection( cy ); // if not handled by above, give 'em an empty collection
    },

    not: function( toRemove ){
      var cy = this._private.cy;

      if( !toRemove ){
        return this;
      } else {
      
        if( $$.is.string( toRemove ) ){
          toRemove = this.filter( toRemove );
        }
        
        var elements = [];
        
        for( var i = 0; i < this.length; i++ ){
          var element = this[i];

          var remove = toRemove._private.ids[ element.id() ];
          if( !remove ){
            elements.push( element );
          }
        }
        
        return new $$.Collection( cy, elements );
      }
      
    },

    intersect: function( other ){
      var cy = this._private.cy;
      
      // if a selector is specified, then filter by it instead
      if( $$.is.string(other) ){
        var selector = other;
        return this.filter( selector );
      }
      
      var elements = [];
      var col1 = this;
      var col2 = other;
      var col1Smaller = this.length < other.length;
      // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
      var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
      var col = col1Smaller ? col1 : col2;
      
      for( var i = 0; i < col.length; i++ ){
        var id = col[i]._private.data.id;
        var ele = ids2[ id ];

        if( ele ){
          elements.push( ele );
        }
      }
      
      return new $$.Collection( cy, elements );
    },

    add: function( toAdd ){
      var cy = this._private.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }
      
      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        elements.push( this[i] );
      }

      for( var i = 0; i < toAdd.length; i++ ){

        var add = !this._private.ids[ toAdd[i].id() ];
        if( add ){
          elements.push( toAdd[i] );
        }
      }
      
      return new $$.Collection(cy, elements);
    },

    // in place merge on calling collection
    merge: function( toAdd ){
      var _p = this._private;
      var cy = _p.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }

      for( var i = 0; i < toAdd.length; i++ ){
        var toAddEle = toAdd[i];
        var id = toAddEle.id();
        var add = !_p.ids[ id ];

        if( add ){
          var index = this.length++;

          this[ index ] = toAddEle;
          _p.ids[ id ] = toAddEle;
          _p.indexes[ id ] = index;
        }
      }
      
      return this; // chaining
    },

    // remove single ele in place in calling collection
    unmergeOne: function( ele ){
      ele = ele[0];

      var _p = this._private;
      var id = ele.id();
      var i = _p.indexes[ id ];

      if( i == null ){
        return this; // no need to remove
      }

      // remove ele
      this[i] = undefined;
      _p.ids[ id ] = undefined;
      _p.indexes[ id ] = undefined;

      var unmergedLastEle = i === this.length - 1;

      // replace empty spot with last ele in collection
      if( this.length > 1 && !unmergedLastEle ){
        var lastEleI = this.length - 1;
        var lastEle = this[ lastEleI ];

        this[ lastEleI ] = undefined;
        this[i] = lastEle;
        _p.indexes[ lastEle.id() ] = i;
      }

      // the collection is now 1 ele smaller
      this.length--;

      return this;
    },

    // remove eles in place on calling collection
    unmerge: function( toRemove ){
      var cy = this._private.cy;    
      
      if( !toRemove ){
        return this;
      }

      if( $$.is.string(toRemove) ){
        var selector = toRemove;
        toRemove = cy.elements(selector);
      }

      for( var i = 0; i < toRemove.length; i++ ){
        this.unmergeOne( toRemove[i] );
      }
      
      return this; // chaining
    },

    map: function( mapFn, thisArg ){
      var arr = [];
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var ret = mapFn.apply( thisArg, [ele, i, eles] );

        arr.push( ret );
      }

      return arr;
    },

    stdFilter: function( fn, thisArg ){
      var filterEles = [];
      var eles = this;
      var cy = this._private.cy;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var include = fn.apply( thisArg, [ele, i, eles] );

        if( include ){
          filterEles.push( ele );
        }
      }

      return new $$.Collection( cy, filterEles );
    },

    max: function( valFn, thisArg ){
      var max = -Infinity;
      var maxEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = valFn.apply( thisArg, [ ele, i, eles ] );

        if( val > max ){
          max = val;
          maxEle = ele;
        }
      }

      return {
        value: max,
        ele: maxEle
      };
    },

    min: function( valFn, thisArg ){
      var min = Infinity;
      var minEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = valFn.apply( thisArg, [ ele, i, eles ] );

        if( val < min ){
          min = val;
          minEle = ele;
        }
      }

      return {
        value: min,
        ele: minEle
      };
    }
  });
  
})( cytoscape );
;(function($$){ 'use strict';

  $$.fn.eles({
    isNode: function(){
      return this.group() === 'nodes';
    },

    isEdge: function(){
      return this.group() === 'edges';
    },

    isLoop: function(){
      return this.isEdge() && this.source().id() === this.target().id();
    },

    isSimple: function(){
      return this.isEdge() && this.source().id() !== this.target().id();
    },

    group: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.group;
      }
    }
  });

  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for iterating over collections
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    each: function(fn){
      if( $$.is.fn(fn) ){
        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = fn.apply( ele, [ i, ele ] );

          if( ret === false ){ break; } // exit each early on return false
        }
      }
      return this;
    },

    forEach: function(fn, thisArg){
      if( $$.is.fn(fn) ){

        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = fn.apply( thisArg, [ ele, i, this ] );

          if( ret === false ){ break; } // exit each early on return false
        }
      }

      return this;
    },

    toArray: function(){
      var array = [];
      
      for(var i = 0; i < this.length; i++){
        array.push( this[i] );
      }
      
      return array;
    },

    slice: function(start, end){
      var array = [];
      var thisSize = this.length;
      
      if( end == null ){
        end = thisSize;
      }

      if( start == null ){
        start = 0;
      }
      
      if( start < 0 ){
        start = thisSize + start;
      }

      if( end < 0 ){
        end = thisSize + end;
      }
      
      for(var i = start; i >= 0 && i < end && i < thisSize; i++){
        array.push( this[i] );
      }
      
      return new $$.Collection(this.cy(), array);
    },

    size: function(){
      return this.length;
    },

    eq: function(i){
      return this[i] || new $$.Collection( this.cy() );
    },

    first: function(){
      return this[0] || new $$.Collection( this.cy() );
    },

    last: function(){
      return this[ this.length - 1 ] || new $$.Collection( this.cy() );
    },

    empty: function(){
      return this.length === 0;
    },

    nonempty: function(){
      return !this.empty();
    },

    sort: function( sortFn ){
      if( !$$.is.fn( sortFn ) ){
        return this;
      }

      var cy = this.cy();      
      var sorted = this.toArray().sort( sortFn );

      return new $$.Collection(cy, sorted);
    },

    sortByZIndex: function(){
      return this.sort( $$.Collection.zIndexSort );
    },

    zDepth: function(){
      var ele = this[0];
      if( !ele ){ return undefined; }

      var _p = ele._private;
      var group = _p.group;

      if( group === 'nodes' ){
        return _p.data.parent ? ele.parents().size() : 0;
      } else {
        var src = _p.source;
        var tgt = _p.target;
        var srcDepth = src._private.data.parent ? src.parents().size() : 0;
        var tgtDepth = tgt._private.data.parent ? tgt.parents().size() : 0;

        return Math.max( srcDepth - 1, tgtDepth - 1, 0 ) + 0.5; // depth of deepest parent and just a bit above
      }
    }
  });

  $$.Collection.zIndexSort = function(a, b){
    var cy = a.cy();
    var a_p = a._private;
    var b_p = b._private;
    var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;
    var depthA = 0;
    var depthB = 0;
    var hasCompoundNodes = cy.hasCompoundNodes();
    var aIsNode = a_p.group === 'nodes';
    var aIsEdge = a_p.group === 'edges';
    var bIsNode = b_p.group === 'nodes';
    var bIsEdge = b_p.group === 'edges';

    // no need to calculate element depth if there is no compound node
    if( hasCompoundNodes ){
      depthA = a.zDepth();
      depthB = b.zDepth();
    }

    var depthDiff = depthA - depthB;
    var sameDepth = depthDiff === 0;

    if( sameDepth ){
      
      if( aIsNode && bIsEdge ){
        return 1; // 'a' is a node, it should be drawn later       
      
      } else if( aIsEdge && bIsNode ){
        return -1; // 'a' is an edge, it should be drawn first

      } else { // both nodes or both edges
        if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)
          return a_p.index - b_p.index;
        } else {
          return zDiff;
        }
      }
    
    // elements on different level
    } else {
      return depthDiff; // deeper element should be drawn later
    }

  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for layouts on nodes
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({

    // using standard layout options, apply position function (w/ or w/o animation)
    layoutPositions: function( layout, options, fn ){
      var nodes = this.nodes();
      var cy = this.cy();

      layout.trigger({ type: 'layoutstart', layout: layout });

      if( options.animate ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var lastNode = i === nodes.length - 1;

          var newPos = fn.call( node, i, node );
          var pos = node.position();

          if( !$$.is.number(pos.x) || !$$.is.number(pos.y) ){
            node.silentPosition({ x: 0, y: 0 });
          }

          node.animate({
            position: newPos
          }, {
            duration: options.animationDuration,
            step: !lastNode ? undefined : function(){
              if( options.fit ){
                cy.fit( options.padding );
              } 
            },
            complete: !lastNode ? undefined : function(){
              if( options.zoom != null ){
                cy.zoom( options.zoom );
              }

              if( options.pan ){
                cy.pan( options.pan );
              } 

              if( options.fit ){
                cy.fit( options.padding );
              } 
              
              layout.one('layoutstop', options.stop);
              layout.trigger({ type: 'layoutstop', layout: layout });
            }
          });
        }

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      } else {
        nodes.positions( fn );

        if( options.fit ){
          cy.fit( options.padding );
        }

        if( options.zoom != null ){
          cy.zoom( options.zoom );
        }

        if( options.pan ){
          cy.pan( options.pan );
        } 

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
        
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }

      return this; // chaining
    },

    layout: function( options ){
      var cy = this.cy();

      cy.layout( $$.util.extend({}, options, {
        eles: this
      }) );

      return this;
    },

    makeLayout: function( options ){
      var cy = this.cy();

      return cy.makeLayout( $$.util.extend({}, options, {
        eles: this
      }) );
    }

  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    // fully updates (recalculates) the style for the elements
    updateStyle: function( notifyRenderer ){
      var cy = this._private.cy;

      if( !cy.styleEnabled() ){ return this; }

      if( cy._private.batchingStyle ){
        var bEles = cy._private.batchStyleEles;

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        }

        return this; // chaining and exit early when batching
      }

      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      style.apply( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
    updateMappers: function( notifyRenderer ){
      var cy = this._private.cy;
      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      if( !cy.styleEnabled() ){ return this; }

      style.updateMappers( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // get the specified css property as a rendered value (i.e. on-screen value)
    // or get the whole rendered style if no property specified (NB doesn't allow setting)
    renderedCss: function( property ){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return this; }

      var ele = this[0];

      if( ele ){
        var renstyle = ele.cy().style().getRenderedStyle( ele );

        if( property === undefined ){
          return renstyle;
        } else {
          return renstyle[ property ];
        }
      }
    },

    // read the calculated css style of the element or override the style (via a bypass)
    css: function( name, value ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();

      if( $$.is.plainObject(name) ){ // then extend the bypass
        var props = name;
        style.applyBypass( this, props, updateTransitions );

        var updatedCompounds = this.updateCompoundBounds();
        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
        toNotify.rtrigger('style'); // let the renderer know we've updated style

      } else if( $$.is.string(name) ){
  
        if( value === undefined ){ // then get the property from the style
          var ele = this[0];

          if( ele ){
            return ele._private.style[ name ].strValue;
          } else { // empty collection => can't get any value
            return;
          }

        } else { // then set the bypass with the property value
          style.applyBypass( this, name, value, updateTransitions );

          var updatedCompounds = this.updateCompoundBounds();
          var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
          toNotify.rtrigger('style'); // let the renderer know we've updated style
        }

      } else if( name === undefined ){
        var ele = this[0];

        if( ele ){
          return style.getRawStyle( ele );
        } else { // empty collection => can't get any value
          return;
        }
      }

      return this; // chaining
    },

    removeCss: function( names ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();
      var eles = this;

      if( names === undefined ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeAllBypasses( ele, updateTransitions );
        }
      } else {
        names = names.split(/\s+/);

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeBypasses( ele, names, updateTransitions );
        }
      }

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
      toNotify.rtrigger('style'); // let the renderer know we've updated style

      return this; // chaining
    },

    show: function(){
      this.css('display', 'element');
      return this; // chaining
    },

    hide: function(){
      this.css('display', 'none');
      return this; // chaining
    },

    visible: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return true; }

      var ele = this[0];
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele ){
        var style = ele._private.style;

        if(
          style['visibility'].value !== 'visible'
          || style['display'].value !== 'element'
        ){
          return false;
        }
        
        if( ele._private.group === 'nodes' ){
          if( !hasCompoundNodes ){ return true; }

          var parents = ele._private.data.parent ? ele.parents() : null;

          if( parents ){
            for( var i = 0; i < parents.length; i++ ){
              var parent = parents[i];
              var pStyle = parent._private.style;
              var pVis = pStyle['visibility'].value;
              var pDis = pStyle['display'].value;

              if( pVis !== 'visible' || pDis !== 'element' ){
                return false;
              }
            }
          }

          return true;
        } else {
          var src = ele._private.source;
          var tgt = ele._private.target;

          return src.visible() && tgt.visible();
        }

      }
    },

    hidden: function(){
      var ele = this[0];

      if( ele ){
        return !ele.visible();
      }
    },

    effectiveOpacity: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return 1; }

      var hasCompoundNodes = cy.hasCompoundNodes();
      var ele = this[0];

      if( ele ){
        var _p = ele._private;
        var parentOpacity = _p.style.opacity.value;

        if( !hasCompoundNodes ){ return parentOpacity; }

        var parents = !_p.data.parent ? null : ele.parents();
        
        if( parents ){
          for( var i = 0; i < parents.length; i++ ){
            var parent = parents[i];
            var opacity = parent._private.style.opacity.value;

            parentOpacity = opacity * parentOpacity;
          }
        }

        return parentOpacity;
      }
    },

    transparent: function(){
      var ele = this[0];
      var hasCompoundNodes = ele.cy().hasCompoundNodes();

      if( ele ){
        if( !hasCompoundNodes ){
          return ele._private.style.opacity.value === 0;
        } else {
          return ele.effectiveOpacity() === 0;
        }
      }
    },

    isFullAutoParent: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];

      if( ele ){
        var autoW = ele._private.style['width'].value === 'auto';
        var autoH = ele._private.style['height'].value === 'auto';

        return ele.isParent() && autoW && autoH;
      }
    }

  });


  $$.elesfn.style = $$.elesfn.css;
  $$.elesfn.renderedStyle = $$.elesfn.renderedCss;
  $$.elesfn.removeStyle = $$.elesfn.removeCss;
  
})( cytoscape );
;(function($$){ 'use strict';
  
  // Collection functions that toggle a boolean value
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  
  function defineSwitchFunction(params){
    return function(){
      var args = arguments;
      
      // e.g. cy.nodes().select( data, handler )
      if( args.length === 2 ){
        var data = args[0];
        var handler = args[1];
        this.bind( params.event, data, handler );
      } 
      
      // e.g. cy.nodes().select( handler )
      else if( args.length === 1 ){
        var handler = args[0];
        this.bind( params.event, handler );
      }
      
      // e.g. cy.nodes().select()
      else if( args.length === 0 ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];
          var able = !params.ableField || ele._private[params.ableField];

          if( params.overrideAble ){
            var overrideAble = params.overrideAble(ele);

            if( overrideAble !== undefined ){
              able = overrideAble;

              if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
            }
          }

          if( able ){
            ele._private[params.field] = params.value;
          }
        }
        this.updateStyle(); // change of state => possible change of style
        this.trigger( params.event );
      }

      return this;
    };
  }
  
  function defineSwitchSet( params ){
    $$.elesfn[ params.field ] = function(){
      var ele = this[0];

      if( ele ){
        if( params.overrideField ){
          var val = params.overrideField(ele);

          if( val !== undefined ){
            return val;
          }
        }

        return ele._private[ params.field ];
      }
    };
    
    $$.elesfn[ params.on ] = defineSwitchFunction({
      event: params.on,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: true
    });

    $$.elesfn[ params.off ] = defineSwitchFunction({
      event: params.off,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: false
    });
  }
  
  defineSwitchSet({
    field: 'locked',
    overrideField: function(ele){
      return ele.cy().autolock() ? true : undefined;
    },
    on: 'lock',
    off: 'unlock'
  });
  
  defineSwitchSet({
    field: 'grabbable',
    overrideField: function(ele){
      return ele.cy().autoungrabify() ? false : undefined;
    },
    on: 'grabify',
    off: 'ungrabify'
  });
  
  defineSwitchSet({
    field: 'selected',
    ableField: 'selectable',
    overrideAble: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'select',
    off: 'unselect'
  });
  
  defineSwitchSet({
    field: 'selectable',
    overrideField: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'selectify',
    off: 'unselectify'
  });
  
  $$.elesfn.grabbed = function(){
    var ele = this[0];
    if( ele ){
      return ele._private.grabbed;
    }
  };

  defineSwitchSet({
    field: 'active',
    on: 'activate',
    off: 'unactivate'
  });

  $$.elesfn.inactive = function(){
    var ele = this[0];
    if( ele ){
      return !ele._private.active;
    }
  };
  
})( cytoscape );

;(function($$){ 'use strict';

  // DAG functions
  //////////////////////////

  $$.fn.eles({
    // get the root nodes in the DAG
    roots: function( selector ){
      var eles = this;
      var roots = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingIn = ele.connectedEdges(function(){
          return this.data('target') === ele.id() && this.data('source') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingIn ){
          roots.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, roots, { unique: true } ).filter( selector );
    },

    // get the leaf nodes in the DAG
    leaves: function( selector ){
      var eles = this;
      var leaves = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingOut = ele.connectedEdges(function(){
          return this.data('source') === ele.id() && this.data('target') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingOut ){
          leaves.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, leaves, { unique: true } ).filter( selector );
    },

    // normally called children in graph theory
    // these nodes =edges=> outgoing nodes
    outgoers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( srcId === eleId && tgtId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.target()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG descendants
    successors: function( selector ){
      var eles = this;
      var sEles = [];
      var sElesIds = {};

      for(;;){
        var outgoers = eles.outgoers();

        if( outgoers.length === 0 ){ break; } // done if no outgoers left

        var newOutgoers = false;
        for( var i = 0; i < outgoers.length; i++ ){
          var outgoer = outgoers[i];
          var outgoerId = outgoer.id();

          if( !sElesIds[ outgoerId ] ){
            sElesIds[ outgoerId ] = true;
            sEles.push( outgoer );
            newOutgoers = true;
          }
        }

        if( !newOutgoers ){ break; } // done if touched all outgoers already

        eles = outgoers;
      }

      return new $$.Collection( this._private.cy, sEles, { unique: true } ).filter( selector );
    },

    // normally called parents in graph theory
    // these nodes <=edges= incoming nodes
    incomers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( tgtId === eleId && srcId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.source()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG ancestors
    predecessors: function( selector ){
      var eles = this;
      var pEles = [];
      var pElesIds = {};

      for(;;){
        var incomers = eles.incomers();

        if( incomers.length === 0 ){ break; } // done if no incomers left

        var newIncomers = false;
        for( var i = 0; i < incomers.length; i++ ){
          var incomer = incomers[i];
          var incomerId = incomer.id();

          if( !pElesIds[ incomerId ] ){
            pElesIds[ incomerId ] = true;
            pEles.push( incomer );
            newIncomers = true;
          }
        }

        if( !newIncomers ){ break; } // done if touched all incomers already

        eles = incomers;
      }

      return new $$.Collection( this._private.cy, pEles, { unique: true } ).filter( selector );
    }
  });


  // Neighbourhood functions
  //////////////////////////

  $$.fn.eles({
    neighborhood: function(selector){
      var elements = [];
      var cy = this._private.cy;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){ // for all nodes
        var node = nodes[i];
        var connectedEdges = node.connectedEdges();

        // for each connected edge, add the edge and the other node
        for( var j = 0; j < connectedEdges.length; j++ ){
          var edge = connectedEdges[j];
          var otherNode = edge.connectedNodes().not(node);

          // need check in case of loop
          if( otherNode.length > 0 ){
            elements.push( otherNode[0] ); // add node 1 hop away
          }
          
          // add connected edge
          elements.push( edge[0] );
        }

      }
      
      return ( new $$.Collection( cy, elements, { unique: true } ) ).filter( selector );
    },

    closedNeighborhood: function(selector){
      return this.neighborhood().add( this ).filter( selector );
    },

    openNeighborhood: function(selector){
      return this.neighborhood( selector );
    }
  });  


  // Edge functions
  /////////////////

  $$.fn.eles({
    source: function( selector ){
      var ele = this[0];
      var src;

      if( ele ){
        src = ele._private.source;
      }

      return src && selector ? src.filter( selector ) : src;
    },

    target: function( selector ){
      var ele = this[0];
      var tgt;

      if( ele ){
        tgt = ele._private.target;
      }

      return tgt && selector ? tgt.filter( selector ) : tgt;
    },

    sources: defineSourceFunction({
      attr: 'source'
    }),

    targets: defineSourceFunction({
      attr: 'target'
    })
  });
  
  function defineSourceFunction( params ){
    return function( selector ){
      var sources = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var src = ele._private[ params.attr ];

        if( src ){
          sources.push( src );
        }
      }
      
      return new $$.Collection( cy, sources, { unique: true } ).filter( selector );
    };
  }

  $$.fn.eles({
    edgesWith: defineEdgesWithFunction(),

    edgesTo: defineEdgesWithFunction({
      thisIs: 'source'
    })
  });
  
  function defineEdgesWithFunction( params ){
    
    return function(otherNodes){
      var elements = [];
      var cy = this._private.cy;
      var p = params || {};

      // get elements if a selector is specified
      if( $$.is.string(otherNodes) ){
        otherNodes = cy.$( otherNodes );
      }
      
      var edges = otherNodes.connectedEdges();
      var thisIds = this._private.ids;
      
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];
        var foundId;
        var edgeData = edge._private.data;

        if( p.thisIs ){
          var idToFind = edgeData[ p.thisIs ];
          foundId = thisIds[ idToFind ];
        } else {
          foundId = thisIds[ edgeData.source ] || thisIds[ edgeData.target ];
        }
        
        if( foundId ){
          elements.push( edge );
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } );
    };
  }
  
  $$.fn.eles({
    connectedEdges: function( selector ){
      var retEles = [];
      var cy = this._private.cy;
      
      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var node = eles[i];
        if( !node.isNode() ){ continue; }

        var edges = node._private.edges;

        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];          
          retEles.push( edge );
        }
      }
      
      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    connectedNodes: function( selector ){
      var retEles = [];
      var cy = this._private.cy;

      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var edge = eles[i];
        if( !edge.isEdge() ){ continue; }

        retEles.push( edge.source()[0] );
        retEles.push( edge.target()[0] );
      }

      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    parallelEdges: defineParallelEdgesFunction(),

    codirectedEdges: defineParallelEdgesFunction({
      codirected: true
    })
  });
  
  function defineParallelEdgesFunction(params){
    var defaults = {
      codirected: false
    };
    params = $$.util.extend({}, defaults, params);
    
    return function( selector ){
      var cy = this._private.cy;
      var elements = [];
      var edges = this.edges();
      var p = params;

      // look at all the edges in the collection
      for( var i = 0; i < edges.length; i++ ){
        var edge1 = edges[i];
        var src1 = edge1.source()[0];
        var srcid1 = src1.id();
        var tgt1 = edge1.target()[0];
        var tgtid1 = tgt1.id();
        var srcEdges1 = src1._private.edges;

        // look at edges connected to the src node of this edge
        for( var j = 0; j < srcEdges1.length; j++ ){
          var edge2 = srcEdges1[j];
          var edge2data = edge2._private.data;
          var tgtid2 = edge2data.target;
          var srcid2 = edge2data.source;

          var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
          var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;
          
          if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
            elements.push( edge2 );
          }
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } ).filter( selector );
    };
  
  }

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    fit: function(){},
    center: function(){}

  });
  
})( cytoscape );
;(function ($$) {
  "use strict";

  /*  Min and Max heap predefaults */
  
  $$.Minheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.minHeapComparator, valueFn);
  };

  $$.Maxheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.maxHeapComparator, valueFn);
  };
  
  $$.Heap = function (cy, eles, comparator, valueFn) {
    if (typeof comparator === "undefined" || typeof eles === "undefined") {
      return;
    }
    
    if (typeof valueFn === "undefined") {
      valueFn = $$.Heap.idFn;
    }

    var sourceHeap = [],
      pointers = {},
      elements = [],
      i = 0,
      id,
      heap,
      elesLen;

    eles = this.getArgumentAsCollection(eles, cy);
    elesLen = eles.length;

    for (i = 0; i < elesLen; i += 1) {
      sourceHeap.push(valueFn.call(cy, eles[i], i, eles));

      id = eles[i].id();
      
      if (pointers.hasOwnProperty(id)) {
        throw "ERROR: Multiple items with the same id found: " + id;
      }
      
      pointers[id] = i;
      elements.push(id);
    }

    this._private = {
      cy: cy,
      heap: sourceHeap,
      pointers: pointers,
      elements: elements,
      comparator: comparator,
      extractor: valueFn,
      length: elesLen
    };

    for (i = Math.floor(elesLen / 2); i >= 0; i -= 1) {
      heap = this.heapify(i);
    }

    return heap;
  };

  /* static methods */
  $$.Heap.idFn = function (node) {
    return node.id();
  };

  $$.Heap.minHeapComparator = function (a, b) {
    return a >= b;
  };

  $$.Heap.maxHeapComparator = function (a, b) {
    return a <= b;
  };

  $$.fn.heap = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Heap.prototype[ name ] = fn;
    }
  };

  $$.heapfn = $$.Heap.prototype; // short alias

  /* object methods */
  $$.heapfn.size = function () {
    return this._private.length;
  };

  $$.heapfn.getArgumentAsCollection = function (eles, cy) {
    var result;
    if(typeof cy === "undefined") {
      cy = this._private.cy;
    }

    if ($$.is.elementOrCollection(eles)) {
      result = eles;

    } else {
      var resultArray = [],
        sourceEles = [].concat.apply([], [eles]);

      for (var i = 0; i < sourceEles.length; i++) {
        var id = sourceEles[i],
          ele = cy.getElementById(id);

        if(ele.length > 0) {
          resultArray.push(ele);
        }
      }

      result = new $$.Collection(cy, resultArray);
    }

    return result;
  };

  $$.heapfn.isHeap = function () {
    var array = this._private.heap,
      arrlen = array.length,
      i,
      left,
      right,
      lCheck,
      rCheck,
      comparator = this._private.comparator;

    for (i = 0; i < arrlen; i += 1) {
      left = 2 * i + 1;
      right = left + 1;
      lCheck = left < arrlen ? comparator(array[left], array[i]) : true;
      rCheck = right < arrlen ? comparator(array[right], array[i]) : true;

      if (!lCheck || !rCheck) {
        return false;
      }
    }

    return true;
  };

  $$.heapfn.heapSwap = function (i, j) {
    var heap = this._private.heap,
      pointers = this._private.pointers,
      elements = this._private.elements,
      swapValue = heap[i],
      swapElems = elements[i],
      idI = elements[i],
      idJ = elements[j];

    heap[i] = heap[j];
    elements[i] = elements[j];

    pointers[idI] = j;
    pointers[idJ] = i;

    heap[j] = swapValue;
    elements[j] = swapElems;
  };

  $$.heapfn.heapify = function (i, rootToLeaf) {
    var treeLen = 0,
      condHeap = false,
      array,
      current,
      left,
      right,
      best,
      comparator,
      parent;
    
    if (typeof rootToLeaf === "undefined") {
      rootToLeaf = true;
    }

    array = this._private.heap;
    treeLen = array.length;
    comparator = this._private.comparator;
    current = i;

    while (!condHeap) {

      if (rootToLeaf) {
        left = 2 * current + 1;
        right = left + 1;
        best = current;
        
        if (left < treeLen && !comparator(array[left], array[best])) {
          best = left;
        }
        
        if (right < treeLen && !comparator(array[right], array[best])) {
          best = right;
        }
        
        condHeap = best === current;
        
        if (!condHeap) {
          this.heapSwap(best, current);
          current = best;
        }

      } else {
        parent = Math.floor((current - 1) / 2);
        best = current;
        condHeap = parent < 0 || comparator(array[best], array[parent]);

        if (!condHeap) {
          this.heapSwap(best, parent);
          current = parent;
        }
      }

    } // while
  };

  /* collectionOrElement */
  $$.heapfn.insert = function (eles) {
    var elements = this.getArgumentAsCollection(eles),
      elsize = elements.length,
      element,
      elindex,
      elvalue,
      elid,
      i;

    for (i = 0; i < elsize; i += 1) {
      element = elements[i];
      elindex = this._private.heap.length;
      elvalue = this._private.extractor(element);
      elid = element.id();

      if (this._private.pointers.hasOwnProperty(elid)) {
        throw "ERROR: Multiple items with the same id found: " + elid;
      }

      this._private.heap.push(elvalue);
      this._private.elements.push(elid);
      this._private.pointers[elid] = elindex;
      this.heapify(elindex, false);
    }

    this._private.length = this._private.heap.length;
  };

  $$.heapfn.getValueById = function (elementId) {
    if (this._private.pointers.hasOwnProperty(elementId)) {
      var elementIndex = this._private.pointers[elementId];

      return this._private.heap[elementIndex];
    }
  };
  
  $$.heapfn.contains = function (eles) {
    var elements = this.getArgumentAsCollection(eles);

    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id();

      if(!this._private.pointers.hasOwnProperty(elementId)) {
        return false;
      }
    }

    return true;
  };
  
  $$.heapfn.top = function () {
    if (this._private.length > 0) {

      return {
        value: this._private.heap[0],
        id: this._private.elements[0]
      };

    }
  };

  $$.heapfn.pop = function () {
    if (this._private.length > 0) {
      var top = this.top(),
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      this.heapSwap(0, lastIndex);

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.heapify(0);
      return top;
    }
  };

  $$.heapfn.findDirectionHeapify = function (index) {
    var parent = Math.floor((index - 1) / 2),
      array = this._private.heap,
      condHeap = parent < 0 || this._private.comparator(array[index], array[parent]);

    this.heapify(index, condHeap);
  };

  /* edit is a new value or function */
  // only values in heap are updated. elements themselves are not!
  $$.heapfn.edit = function (eles, edit) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        elementValue = this._private.heap[elementIndex];
      
      if ($$.is.number(edit)) {
        this._private.heap[elementIndex] = edit;
        
      } else if ($$.is.fn(edit)) {
        this._private.heap[elementIndex] = edit.call(this._private.cy, elementValue, elementIndex);
      }

      this.findDirectionHeapify(elementIndex);
    }
  };

  $$.heapfn.delete = function (eles) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      if (elementIndex !== lastIndex) {
        this.heapSwap(elementIndex, lastIndex);
      }

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.findDirectionHeapify(elementIndex);
    }

    return removeValue;
  };

})(cytoscape);
/*
  The canvas renderer was written by Yue Dong.

  Modifications tracked on Github.
*/

(function($$) { 'use strict';

  function CanvasRenderer(options) {
    
    CanvasRenderer.CANVAS_LAYERS = 5;
    CanvasRenderer.SELECT_BOX = 0;
    CanvasRenderer.DRAG = 2;
    CanvasRenderer.NODE = 4;
    CanvasRenderer.TEXTURE_BUFFER = 0;
    CanvasRenderer.BUFFER_COUNT = 2;

    this.options = options;

    this.data = {
        
      select: [undefined, undefined, undefined, undefined, 0], // Coordinates for selection box, plus enabled flag 
      renderer: this, cy: options.cy, container: options.cy.container(),
      
      canvases: new Array(CanvasRenderer.CANVAS_LAYERS),
      contexts: new Array(CanvasRenderer.CANVAS_LAYERS),
      canvasNeedsRedraw: new Array(CanvasRenderer.CANVAS_LAYERS),
      
      bufferCanvases: new Array(CanvasRenderer.BUFFER_COUNT),
      bufferContexts: new Array(CanvasRenderer.CANVAS_LAYERS)

    };
    
    //--Pointer-related data
    this.hoverData = {down: null, last: null, 
        downTime: null, triggerMode: null, 
        dragging: false, 
        initialPan: [null, null], capture: false};
    
    this.timeoutData = {panTimeout: null};
    
    this.dragData = {possibleDragElements: []};
    
    this.touchData = {start: null, capture: false,
        // These 3 fields related to tap, taphold events
        startPosition: [null, null, null, null, null, null],
        singleTouchStartTime: null,
        singleTouchMoved: true,
        
        
        now: [null, null, null, null, null, null], 
        earlier: [null, null, null, null, null, null] };
    //--
    
    //--Wheel-related data 
    this.zoomData = {freeToZoom: false, lastPointerX: null};
    //--
    
    this.redraws = 0;
    this.showFps = options.showFps;

    this.bindings = [];
    
    this.data.canvasContainer = document.createElement('div');
    var containerStyle = this.data.canvasContainer.style;
    containerStyle.position = 'absolute';
    containerStyle.zIndex = '0';
    containerStyle.overflow = 'hidden';

    this.data.container.appendChild( this.data.canvasContainer );

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {
      this.data.canvases[i] = document.createElement('canvas');
      this.data.contexts[i] = this.data.canvases[i].getContext('2d');
      this.data.canvases[i].style.position = 'absolute';
      this.data.canvases[i].setAttribute('data-id', 'layer' + i);
      this.data.canvases[i].style.zIndex = String(CanvasRenderer.CANVAS_LAYERS - i);
      this.data.canvasContainer.appendChild(this.data.canvases[i]);
      
      this.data.canvasNeedsRedraw[i] = false;
    }
    this.data.topCanvas = this.data.canvases[0];

    this.data.canvases[CanvasRenderer.NODE].setAttribute('data-id', 'layer' + CanvasRenderer.NODE + '-node');
    this.data.canvases[CanvasRenderer.SELECT_BOX].setAttribute('data-id', 'layer' + CanvasRenderer.SELECT_BOX + '-selectbox');
    this.data.canvases[CanvasRenderer.DRAG].setAttribute('data-id', 'layer' + CanvasRenderer.DRAG + '-drag');
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      this.data.bufferCanvases[i] = document.createElement('canvas');
      this.data.bufferContexts[i] = this.data.bufferCanvases[i].getContext('2d');
      this.data.bufferCanvases[i].style.position = 'absolute';
      this.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
      this.data.bufferCanvases[i].style.zIndex = String(-i - 1);
      this.data.bufferCanvases[i].style.visibility = 'hidden';
      //this.data.canvasContainer.appendChild(this.data.bufferCanvases[i]);
    }

    this.hideEdgesOnViewport = options.hideEdgesOnViewport;
    this.hideLabelsOnViewport = options.hideLabelsOnViewport;
    this.textureOnViewport = options.textureOnViewport;
    this.wheelSensitivity = options.wheelSensitivity;
    this.motionBlurEnabled = options.motionBlur === undefined ? true : options.motionBlur; // on by default
    this.forcedPixelRatio = options.pixelRatio;
    this.motionBlur = true; // for initial kick off
    this.tapThreshold = options.tapThreshold;
    this.tapThreshold2 = options.tapThreshold * options.tapThreshold;
    this.tapholdDuration = 500;

    this.load();
  }

  CanvasRenderer.panOrBoxSelectDelay = 400;
  CanvasRenderer.isTouch = $$.is.touch();

  // whether to use Path2D caching for drawing
  var pathsImpld = typeof Path2D !== 'undefined';
  CanvasRenderer.usePaths = function(){
    return pathsImpld;
  };

  CanvasRenderer.prototype.notify = function(params) {
    var types;

    if( $$.is.array( params.type ) ){
      types = params.type;

    } else {
      types = [ params.type ];
    }

    for( var i = 0; i < types.length; i++ ){
      var type = types[i];

      switch( type ){
        case 'destroy':
          this.destroy();
          return;

        case 'add':
        case 'remove':
        case 'load':
          this.updateNodesCache();
          this.updateEdgesCache();
          break;

        case 'viewport':
          this.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          break;

        case 'style':
          this.updateCachedZSortedEles();
          break;
      }

      if( type === 'load' || type === 'resize' ){
        this.invalidateContainerClientCoordsCache();
        this.matchCanvasSize(this.data.container);
      }
    } // for
    
    this.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
    this.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

    this.redraw();
  };

  CanvasRenderer.prototype.destroy = function(){
    this.destroyed = true;

    for( var i = 0; i < this.bindings.length; i++ ){
      var binding = this.bindings[i];
      var b = binding;

      b.target.removeEventListener(b.event, b.handler, b.useCapture);
    }

    if( this.removeObserver ){
      this.removeObserver.disconnect();
    }

    if( this.labelCalcDiv ){
      document.body.removeChild(this.labelCalcDiv);
    }
  };

  

  // copy the math functions into the renderer prototype
  // unfortunately these functions are used interspersed t/o the code
  // and this makes sure things work just in case a ref was missed in refactoring
  // TODO remove this eventually
  for( var fnName in $$.math ){
    CanvasRenderer.prototype[ fnName ] = $$.math[ fnName ];
  }
  
  
  $$('renderer', 'canvas', CanvasRenderer);
  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var rendFunc = CanvasRenderer.prototype;
  var arrowShapes = CanvasRenderer.arrowShapes = {};

  CanvasRenderer.arrowShapeHeight = 0.3;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function(x, y, centerX, centerY, width, height, direction, padding){
    var x1 = centerX - width/2;
    var x2 = centerX + width/2;
    var y1 = centerY - height/2;
    var y2 = centerY + height/2;

    return (x1 <= x && x <= x2) && (y1 <= y && y <= y2);
  };

  var transform = function(x, y, size, angle, translation){
    angle = -angle; // b/c of notation used in arrow draw fn

    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
    
    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;
    
    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  arrowShapes['arrow'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['arrow']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['arrow']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }

    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['triangle'] = arrowShapes['arrow'];
  
  arrowShapes['triangle-backcurve'] = {
    _ctrlPt: [ 0, -0.15 ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['triangle']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['triangle']._points;
      var firstPt;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo(pt.x, pt.y);
      }

      var ctrlPt = this._ctrlPt;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      context.quadraticCurveTo( ctrlPtTrans.x, ctrlPtTrans.y, firstPt.x, firstPt.y );
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  

  arrowShapes['triangle-tee'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    _pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var triPts = arrowShapes['triangle-tee']._points;
      var teePts = arrowShapes['triangle-tee']._pointsTee;
      
      var inside = $$.math.pointInsidePolygon(x, y, teePts, centerX, centerY, width, height, direction, padding) 
        || $$.math.pointInsidePolygon(x, y, triPts, centerX, centerY, width, height, direction, padding);

      return inside;
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var triPts = arrowShapes['triangle-tee']._points;
      for (var i = 0; i < triPts.length / 2; i++){
        var pt = transform( triPts[ i * 2 ],  triPts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }

      var teePts = arrowShapes['triangle-tee']._pointsTee;
      var firstTeePt = transform( teePts[0], teePts[1], size, angle, translation );
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for (var i = 0; i < teePts.length / 2; i++){
        var pt = transform( teePts[ i * 2 ],  teePts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['half-triangle-overshot'] = {
    _points: [
      0, -0.25,
      -0.5, -0.25,
      0.5, 0.25
    ],
    
    leavePathOpen: true,
    matchEdgeWidth: true,

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = this._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = this._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['none'] = {
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    roughCollide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    draw: function(context) {
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return 0;
    }
  };
  
  arrowShapes['circle'] = {
    _baseRadius: 0.15,
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      // Transform x, y to get non-rotated ellipse
      
      if (width != height) {                  
        var aspectRatio = (height + padding) / (width + padding);
        y /= aspectRatio;
        centerY /= aspectRatio;
        
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      } else {
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      }
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      context.arc(translation.x, translation.y, arrowShapes['circle']._baseRadius * size, 0, Math.PI * 2, false);
    },
    
    spacing: function(edge) {
      return rendFunc.getArrowWidth(edge._private.style['width'].pxValue)
        * arrowShapes['circle']._baseRadius;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  
  arrowShapes['inhibitor'] = {
    _points: [
      -0.25, 0,
      -0.25, -0.1,
      0.25, -0.1,
      0.25, 0
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['inhibitor']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['inhibitor']._points;
      
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 1;
    },
    
    gap: function(edge) {
      return 1;
    }
  };

  arrowShapes['tee'] = arrowShapes['inhibitor'];

  arrowShapes['square'] = {
    _points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['square']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['square']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },

    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['diamond'] = {
    _points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['diamond']._points;
          
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },

    roughCollide: bbCollide,

    draw: function(context, size, angle, translation) {
      var points = arrowShapes['diamond']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue;
    }
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  CanvasRenderer.prototype.getCachedNodes = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedNodes == null) {
      data.cache.cachedNodes = cy.nodes();
    }
    
    return data.cache.cachedNodes;
  };
  
  CanvasRenderer.prototype.updateNodesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedNodes = cy.nodes();
  };
  
  CanvasRenderer.prototype.getCachedEdges = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedEdges == null) {
      data.cache.cachedEdges = cy.edges();
    }
    
    return data.cache.cachedEdges;
  };
  
  CanvasRenderer.prototype.updateEdgesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedEdges = cy.edges();
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // Project mouse
  CanvasRenderer.prototype.projectIntoViewport = function(clientX, clientY) {
    var offsets = this.findContainerClientCoords();
    var offsetLeft = offsets[0];
    var offsetTop = offsets[1];
    
    var x = clientX - offsetLeft; 
    var y = clientY - offsetTop;
    
    x -= this.data.cy.pan().x; y -= this.data.cy.pan().y; x /= this.data.cy.zoom(); y /= this.data.cy.zoom();
    return [x, y];
  };

  CanvasRenderer.prototype.findContainerClientCoords = function() {
    var container = this.data.container;

    var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();

    return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];
  };

  CanvasRenderer.prototype.invalidateContainerClientCoordsCache = function(){
    this.containerBB = null;
  };

  // Find nearest element
  CanvasRenderer.prototype.findNearestElement = function(x, y, visibleElementsOnly){
    var self = this;
    var eles = this.getCachedZSortedEles();
    var near = [];
    var isTouch = CanvasRenderer.isTouch;
    var zoom = this.data.cy.zoom();
    var hasCompounds = this.data.cy.hasCompoundNodes();
    var edgeThreshold = (isTouch ? 256 : 32) / zoom;
    var nodeThreshold = (isTouch ? 16 : 0) /  zoom;

    function checkNode(node){
      var width = node.outerWidth();
      var height = node.outerHeight();
      var hw = width/2;
      var hh = height/2;
      var pos = node._private.position;

      if(
        pos.x - hw <= x && x <= pos.x + hw // bb check x
          &&
        pos.y - hh <= y && y <= pos.y + hh // bb check y
      ){
        var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );

        // exit early if invisible edge and must be visible
        if( visibleElementsOnly && !visible ){
          return;
        }

        var shape = CanvasRenderer.nodeShapes[ self.getNodeShape(node) ];
        var borderWO = node._private.style['border-width'].pxValue / 2;

        if(
          shape.checkPoint(x, y, borderWO, width + nodeThreshold, height + nodeThreshold, pos.x, pos.y)
        ){
            near.push( node );
        }

      }
    }

    function checkEdge(edge){
      var rs = edge._private.rscratch;
      var style = edge._private.style;
      var width = style['width'].pxValue;
      var widthSq = width * width;
      var width2 = width * 2;
      var src = edge._private.source;
      var tgt = edge._private.target;
      var inEdgeBB = false;

      // exit early if invisible edge and must be visible
      var passedVisibilityCheck;
      var passesVisibilityCheck = function(){
        if( passedVisibilityCheck !== undefined ){
          return passedVisibilityCheck;
        }

        if( !visibleElementsOnly ){
          passedVisibilityCheck = true;
          return true;
        }

        var visible = edge.visible() && !edge.transparent();
        if( visible ){
          passedVisibilityCheck = true;
          return true;
        }

        passedVisibilityCheck = false;
        return false;
      };

      if (rs.edgeType === 'self') {
        if(
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY) )
            )
              ||
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY) )
            )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'haystack') {
        var radius = style['haystack-radius'].value;
        var halfRadius = radius/2; // b/c have to half width/height

        var tgtPos = tgt._private.position;
        var tgtW = tgt.width();
        var tgtH = tgt.height();
        var srcPos = src._private.position;
        var srcW = src.width();
        var srcH = src.height();

        var startX = srcPos.x + rs.source.x * srcW * halfRadius;
        var startY = srcPos.y + rs.source.y * srcH * halfRadius;
        var endX = tgtPos.x + rs.target.x * tgtW * halfRadius;
        var endY = tgtPos.y + rs.target.y * tgtH * halfRadius;

        if( 
          (inEdgeBB = $$.math.inLineVicinity(x, y, startX, startY, endX, endY, width2))
            && passesVisibilityCheck() &&
          widthSq + edgeThreshold > $$.math.sqDistanceToFiniteLine( x, y, startX, startY, endX, endY )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'straight') {
        if(
          (inEdgeBB = $$.math.inLineVicinity(x, y, rs.startX, rs.startY, rs.endX, rs.endY, width2))
            && passesVisibilityCheck() &&
          widthSq + edgeThreshold > $$.math.sqDistanceToFiniteLine(x, y, rs.startX, rs.startY, rs.endX, rs.endY)
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'bezier') {
        if(
          (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY, widthSq))
            && passesVisibilityCheck() &&
          (widthSq + edgeThreshold > $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY))
        ){
          near.push( edge );
        }
      }
      
      if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){
        var srcShape = CanvasRenderer.arrowShapes[ style['source-arrow-shape'].value ];
        var tgtShape = CanvasRenderer.arrowShapes[ style['target-arrow-shape'].value ];

        var src = src || edge._private.source;
        var tgt = tgt || edge._private.target;

        var tgtPos = tgt._private.position;
        var srcPos = src._private.position;

        var srcArW = self.getArrowWidth( style['width'].pxValue );
        var srcArH = self.getArrowHeight( style['width'].pxValue );

        var tgtArW = srcArW;
        var tgtArH = srcArH;

        if(
          (
            srcShape.roughCollide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], 0)
              && 
            srcShape.collide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], 0)
          )
            ||
          (
            tgtShape.roughCollide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], 0)
              &&
            tgtShape.collide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], 0)
          )
        ){
          near.push( edge );
        }
      }

      // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
      if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){
        checkNode( src );
        checkNode( tgt );
      }
    }

    for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
      var ele = eles[i];

      if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early

      if( ele._private.group === 'nodes' ){ 
        checkNode( eles[i] );

      } else  { // then edge
        checkEdge( eles[i] );
      }

    }
  
    
    if( near.length > 0 ){
      return near[ near.length - 1 ];
    } else {
      return null;
    }
  }; 

  // 'Give me everything from this box'
  CanvasRenderer.prototype.getAllInBox = function(x1, y1, x2, y2) {
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var box = [];
    
    var x1c = Math.min(x1, x2);
    var x2c = Math.max(x1, x2);
    var y1c = Math.min(y1, y2);
    var y2c = Math.max(y1, y2); 

    x1 = x1c; 
    x2 = x2c; 
    y1 = y1c; 
    y2 = y2c; 

    var heur;
    
    for ( var i = 0; i < nodes.length; i++ ){
      var pos = nodes[i]._private.position;
      var nShape = this.getNodeShape(nodes[i]);
      var w = this.getNodeWidth(nodes[i]);
      var h = this.getNodeHeight(nodes[i]);
      var border = nodes[i]._private.style['border-width'].pxValue / 2;
      var shapeObj = CanvasRenderer.nodeShapes[ nShape ];

      if ( shapeObj.intersectBox(x1, y1, x2, y2, w, h, pos.x, pos.y, border) ){
        box.push(nodes[i]);
      }
    }
    
    for ( var i = 0; i < edges.length; i++ ){
      var rs = edges[i]._private.rscratch;

      if (edges[i]._private.rscratch.edgeType == 'self') {
        if ((heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2ax, rs.cp2ay,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2ax, rs.cp2ay,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
                ||
          (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2cx, rs.cp2cy,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2cx, rs.cp2cy,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
          )
        { box.push(edges[i]); }
      }
      
      if (rs.edgeType == 'bezier' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2x, rs.cp2y,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2x, rs.cp2y,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }
    
      if (rs.edgeType == 'straight' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.startX * 0.5 + rs.endX * 0.5, 
            rs.startY * 0.5 + rs.endY * 0.5, 
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              && /* console.log('test', heur) == undefined && */
            (heur == 2 || (heur == 1 && $$.math.checkStraightEdgeInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }


      if (rs.edgeType == 'haystack'){
        var tgt = edges[i].target()[0];
        var tgtPos = tgt.position();
        var src = edges[i].source()[0];
        var srcPos = src.position();

        var startX = srcPos.x + rs.source.x;
        var startY = srcPos.y + rs.source.y;
        var endX = tgtPos.x + rs.target.x;
        var endY = tgtPos.y + rs.target.y;

        var startInBox = (x1 <= startX && startX <= x2) && (y1 <= startY && startY <= y2);
        var endInBox = (x1 <= endX && endX <= x2) && (y1 <= endY && endY <= y2);

        if( startInBox && endInBox ){
          box.push( edges[i] );
        }
      }
      
    }
    
    return box;
  };


  /**
   * Returns the width of the given node. If the width is set to auto,
   * returns the value of the autoWidth field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CanvasRenderer.prototype.getNodeWidth = function(node)
  {
    return node.width();
  };

  /**
   * Returns the height of the given node. If the height is set to auto,
   * returns the value of the autoHeight field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CanvasRenderer.prototype.getNodeHeight = function(node)
  {
    return node.height();
  };

  /**
   * Returns the shape of the given node. If the height or width of the given node
   * is set to auto, the node is considered to be a compound.
   *
   * @param node          a node
   * @return {String}     shape of the node
   */
  CanvasRenderer.prototype.getNodeShape = function(node)
  {
    // TODO only allow rectangle for a compound node?
//    if (node._private.style['width'].value == 'auto' ||
//        node._private.style['height'].value == 'auto')
//    {
//      return 'rectangle';
//    }

    var shape = node._private.style['shape'].value;

    if( node.isParent() ){
      if( shape === 'rectangle' || shape === 'roundrectangle' ){
        return shape;
      } else {
        return 'rectangle';
      }
    }

    return shape;
  };


  CanvasRenderer.prototype.getNodePadding = function(node)
  {
    var left = node._private.style['padding-left'].pxValue;
    var right = node._private.style['padding-right'].pxValue;
    var top = node._private.style['padding-top'].pxValue;
    var bottom = node._private.style['padding-bottom'].pxValue;

    if (isNaN(left))
    {
      left = 0;
    }

    if (isNaN(right))
    {
      right = 0;
    }

    if (isNaN(top))
    {
      top = 0;
    }

    if (isNaN(bottom))
    {
      bottom = 0;
    }

    return {left : left,
      right : right,
      top : top,
      bottom : bottom};
  };

  CanvasRenderer.prototype.zOrderSort = $$.Collection.zIndexSort;

  CanvasRenderer.prototype.updateCachedZSortedEles = function(){
    this.getCachedZSortedEles( true );
  };

  CanvasRenderer.prototype.getCachedZSortedEles = function( forceRecalc ){
    var lastNodes = this.lastZOrderCachedNodes;
    var lastEdges = this.lastZOrderCachedEdges;
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var eles = [];

    if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){ 
      //console.time('cachezorder')
      
      for( var i = 0; i < nodes.length; i++ ){
        if( nodes[i].visible() && !nodes[i].transparent() ){
          eles.push( nodes[i] );
        }
      }

      for( var i = 0; i < edges.length; i++ ){
        if( edges[i].visible() && !edges[i].transparent() ){
          eles.push( edges[i] );
        }
      }

      eles.sort( this.zOrderSort );
      this.cachedZSortedEles = eles;
      //console.log('make cache')

      //console.timeEnd('cachezorder')
    } else {
      eles = this.cachedZSortedEles;
      //console.log('read cache')
    }

    this.lastZOrderCachedNodes = nodes;
    this.lastZOrderCachedEdges = edges;

    return eles;
  };

  CanvasRenderer.prototype.projectBezier = function(edge){
    var qbezierAt = $$.math.qbezierAt;
    var rs = edge._private.rscratch;
    var bpts = edge._private.rstyle.bezierPts = [];

    function pushBezierPts(pts){
      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )
      });

      var mid = {
        x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )
      };

      bpts.push( mid );

      if( rs.edgeType === 'self' ){
        rs.midX = rs.selfEdgeMidX;
        rs.midY = rs.selfEdgeMidY;
      } else {
        rs.midX = mid.x;
        rs.midY = mid.y;
      }

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )
      });
    }

    if( rs.edgeType === 'self' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY] );
      pushBezierPts( [rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY] );
    } else if( rs.edgeType === 'bezier' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY] );
    }
  };

  CanvasRenderer.prototype.recalculateNodeLabelProjection = function( node ){
    var content = node._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;
    var nodeWidth = node.outerWidth();
    var nodeHeight = node.outerHeight();
    var nodePos = node._private.position;
    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;
    var rstyle = node._private.rstyle;

    switch( textHalign ){
      case 'left':
        textX = nodePos.x - nodeWidth / 2;
        break;

      case 'right':
        textX = nodePos.x + nodeWidth / 2;
        break;

      default: // e.g. center
        textX = nodePos.x;
    }

    switch( textValign ){
      case 'top':
        textY = nodePos.y - nodeHeight / 2;
        break;

      case 'bottom':
        textY = nodePos.y + nodeHeight / 2;
        break;

      default: // e.g. middle
        textY = nodePos.y;
    }
  
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( node );
  };

  CanvasRenderer.prototype.recalculateEdgeLabelProjection = function( edge ){
    var content = edge._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;  
    var edgeCenterX, edgeCenterY;
    var rs = edge._private.rscratch;
    var rstyle = edge._private.rstyle;
    
    if (rs.edgeType == 'self') {
      edgeCenterX = rs.selfEdgeMidX;
      edgeCenterY = rs.selfEdgeMidY;
    } else if (rs.edgeType == 'straight') {
      edgeCenterX = (rs.startX + rs.endX) / 2;
      edgeCenterY = (rs.startY + rs.endY) / 2;
    } else if (rs.edgeType == 'bezier') {
      edgeCenterX = $$.math.qbezierAt( rs.startX, rs.cp2x, rs.endX, 0.5 );
      edgeCenterY = $$.math.qbezierAt( rs.startY, rs.cp2y, rs.endY, 0.5 );
    } else if (rs.edgeType == 'haystack') {
      var srcPos = edge._private.source._private.position;
      var tgtPos = edge._private.target._private.position;

      edgeCenterX = (srcPos.x + rs.source.x + tgtPos.x + rs.target.x)/2;
      edgeCenterY = (srcPos.y + rs.source.y + tgtPos.y + rs.target.y)/2;
    }
    
    textX = edgeCenterX;
    textY = edgeCenterY;

    // add center point to style so bounding box calculations can use it
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( edge );
  };

  CanvasRenderer.prototype.applyLabelDimensions = function( ele ){
    var rs = ele._private.rscratch;
    var rstyle = ele._private.rstyle;

    var text = this.getLabelText( ele );
    var labelDims = this.calculateLabelDimensions( ele, text );
 
    rstyle.labelWidth = labelDims.width;
    rs.labelWidth = labelDims.width;
 
    rstyle.labelHeight = labelDims.height;
    rs.labelHeight = labelDims.height;
  };

  CanvasRenderer.prototype.getLabelText = function( ele ){
    var style = ele._private.style;
    var text = ele._private.style['content'].strValue;
    var textTransform = style['text-transform'].value;
    
    if (textTransform == 'none') {
    } else if (textTransform == 'uppercase') {
      text = text.toUpperCase();
    } else if (textTransform == 'lowercase') {
      text = text.toLowerCase();
    }

    return text;
  };

  CanvasRenderer.prototype.calculateLabelDimensions = function( ele, text ){
    var r = this;
    var style = ele._private.style;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;

    var cacheKey = ele._private.labelKey;
    var cache = r.labelDimCache || (r.labelDimCache = {});

    if( cache[cacheKey] ){
      return cache[cacheKey];
    }

    var div = this.labelCalcDiv;

    if( !div ){
      div = this.labelCalcDiv = document.createElement('div');
      document.body.appendChild( div );
    }

    var ds = div.style;

    // from ele style
    ds.fontFamily = family;
    ds.fontStyle = fStyle;
    ds.fontSize = size;
    // ds.fontVariant = variant;
    ds.fontWeight = weight;

    // forced style
    ds.position = 'absolute';
    ds.left = '-9999px';
    ds.top = '-9999px';
    ds.zIndex = '-1';
    ds.visibility = 'hidden';
    ds.pointerEvents = 'none';
    ds.padding = '0';
    ds.lineHeight = '1';

    // put label content in div
    div.textContent = text;

    cache[cacheKey] = {
      width: div.clientWidth,
      height: div.clientHeight
    };

    return cache[cacheKey];
  };  

  CanvasRenderer.prototype.recalculateRenderedStyle = function( eles ){
    var edges = [];
    var nodes = [];
    var handledEdge = {};

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var _p = ele._private;
      var rs = _p.rscratch;
      var rstyle = _p.rstyle;
      var id = _p.data.id;
      var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;
      var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;
      var styleSame = bbStyleSame && labelStyleSame;

      if( ele._private.group === 'nodes' ){
        var pos = _p.position;
        var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;

        if( !posSame || !styleSame ){
          nodes.push( ele );
        }

        rstyle.nodeX = pos.x;
        rstyle.nodeY = pos.y;
      } else { // edges

        var srcPos = ele._private.source._private.position;
        var tgtPos = ele._private.target._private.position;
        var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;
        var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;
        var positionsSame = srcSame && tgtSame;

        if( !positionsSame || !styleSame ){
          var curveType = _p.style['curve-style'].value;

          if( curveType === 'bezier' ){
            if( !handledEdge[ id ] ){
              edges.push( ele );
              handledEdge[ id ] = true;

              var parallelEdges = ele.parallelEdges();
              for( var i = 0; i < parallelEdges.length; i++ ){
                var pEdge = parallelEdges[i];
                var pId = pEdge._private.data.id;

                if( !handledEdge[ pId ] ){
                  edges.push( pEdge );
                  handledEdge[ pId ] = true;
                }
                
              }
            }
          } else {
            edges.push( ele );
          }
        } // if positions diff

        // update rstyle positions
        rstyle.srcX = srcPos.x;
        rstyle.srcY = srcPos.y;
        rstyle.tgtX = tgtPos.x;
        rstyle.tgtY = tgtPos.y;

      } // if edges

      rs.boundingBoxKey = _p.boundingBoxKey;
      rs.labelKey = _p.labelKey;
    }

    this.recalculateEdgeProjections( edges );
    this.recalculateLabelProjections( nodes, edges );
  };

  CanvasRenderer.prototype.recalculateLabelProjections = function( nodes, edges ){
    for( var i = 0; i < nodes.length; i++ ){
      this.recalculateNodeLabelProjection( nodes[i] );
    }

    for( var i = 0; i < edges.length; i++ ){
      this.recalculateEdgeLabelProjection( edges[i] );
    }
  };

  CanvasRenderer.prototype.recalculateEdgeProjections = function( edges ){
    this.findEdgeControlPoints( edges );
  };


  // Find edge control points
  CanvasRenderer.prototype.findEdgeControlPoints = function(edges) {
    if( !edges || edges.length === 0 ){ return; }

    var hashTable = {};
    var pairIds = [];
    var haystackEdges = [];

    // create a table of edge (src, tgt) => list of edges between them
    var pairId;
    for (var i = 0; i < edges.length; i++){
      var edge = edges[i];
      var style = edge._private.style;
      var edgeIsUnbundled = style['curve-style'].value === 'unbundled-bezier';

      // ignore edges who are not to be displayed
      // they shouldn't take up space
      if( style.display.value === 'none' ){
        continue;
      }

      if( style['curve-style'].value === 'haystack' ){
        haystackEdges.push( edge );
        continue;
      }

      var srcId = edge._private.data.source;
      var tgtId = edge._private.data.target;

      pairId = srcId > tgtId ?
        tgtId + '-' + srcId :
        srcId + '-' + tgtId ;

      if( edgeIsUnbundled ){
        pairId = 'unbundled' + edge._private.data.id;
      }

      if (hashTable[pairId] == null) {
        hashTable[pairId] = [];
        pairIds.push( pairId );
      }
      
      hashTable[pairId].push( edge );

      if( edgeIsUnbundled ){
        hashTable[pairId].hasUnbundled = true;
      }
    }

    var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape, srcBorder, tgtBorder;
    var vectorNormInverse;
    var badBezier;
    
    // for each pair (src, tgt), create the ctrl pts
    // Nested for loop is OK; total number of iterations for both loops = edgeCount  
    for (var p = 0; p < pairIds.length; p++) {
      pairId = pairIds[p];
      var pairEdges = hashTable[pairId];
    
      // for each pair id, the edges should be sorted by index
      pairEdges.sort(function(edge1, edge2){
        return edge1._private.index - edge2._private.index;
      });

      src = pairEdges[0]._private.source;
      tgt = pairEdges[0]._private.target;

      // make sure src/tgt distinction is consistent
      // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)
      if( src._private.data.id > tgt._private.data.id ){
        var temp = src;
        src = tgt;
        tgt = temp;
      }

      srcPos = src._private.position;
      tgtPos = tgt._private.position;

      srcW = this.getNodeWidth(src);
      srcH = this.getNodeHeight(src);

      tgtW = this.getNodeWidth(tgt);
      tgtH = this.getNodeHeight(tgt);

      srcShape = CanvasRenderer.nodeShapes[ this.getNodeShape(src) ];
      tgtShape = CanvasRenderer.nodeShapes[ this.getNodeShape(tgt) ];

      srcBorder = src._private.style['border-width'].pxValue;
      tgtBorder = tgt._private.style['border-width'].pxValue;

      badBezier = false;
      

      if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){

        // pt outside src shape to calc distance/displacement from src to tgt
        var srcOutside = srcShape.intersectLine(
          srcPos.x,
          srcPos.y,
          srcW,
          srcH,
          tgtPos.x,
          tgtPos.y,
          srcBorder / 2
        );

        // pt outside tgt shape to calc distance/displacement from src to tgt
        var tgtOutside = tgtShape.intersectLine(
          tgtPos.x,
          tgtPos.y,
          tgtW,
          tgtH,
          srcPos.x,
          srcPos.y,
          tgtBorder / 2
        );

        var midptSrcPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };

        var dy = ( tgtOutside[1] - srcOutside[1] );
        var dx = ( tgtOutside[0] - srcOutside[0] );
        var l = Math.sqrt( dx*dx + dy*dy );

        var vector = {
          x: dx,
          y: dy
        };
        
        var vectorNorm = {
          x: vector.x/l,
          y: vector.y/l
        };
        vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        };

        // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw
        if( 
          tgtShape.checkPoint( srcOutside[0], srcOutside[1], tgtBorder/2, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||
          srcShape.checkPoint( tgtOutside[0], tgtOutside[1], srcBorder/2, srcW, srcH, srcPos.x, srcPos.y ) 
        ){
          vectorNormInverse = {};
          badBezier = true;
        }
        
      }
      
      var edge;
      var rs;
      
      for (var i = 0; i < pairEdges.length; i++) {
        edge = pairEdges[i];
        rs = edge._private.rscratch;
        
        var edgeIndex1 = rs.lastEdgeIndex;
        var edgeIndex2 = i;

        var numEdges1 = rs.lastNumEdges;
        var numEdges2 = pairEdges.length;

        var eStyle = edge._private.style;
        var stepSize = eStyle['control-point-step-size'].pxValue;
        var stepDist = eStyle['control-point-distance'] !== undefined ? eStyle['control-point-distance'].pxValue : undefined;
        var stepWeight = eStyle['control-point-weight'].value;
        var edgeIsUnbundled = eStyle['curve-style'].value === 'unbundled-bezier';

        var srcX1 = rs.lastSrcCtlPtX;
        var srcX2 = srcPos.x;
        var srcY1 = rs.lastSrcCtlPtY;
        var srcY2 = srcPos.y;
        var srcW1 = rs.lastSrcCtlPtW;
        var srcW2 = src.outerWidth();
        var srcH1 = rs.lastSrcCtlPtH;
        var srcH2 = src.outerHeight();

        var tgtX1 = rs.lastTgtCtlPtX;
        var tgtX2 = tgtPos.x;
        var tgtY1 = rs.lastTgtCtlPtY;
        var tgtY2 = tgtPos.y;
        var tgtW1 = rs.lastTgtCtlPtW;
        var tgtW2 = tgt.outerWidth();
        var tgtH1 = rs.lastTgtCtlPtH;
        var tgtH2 = tgt.outerHeight();

        var width1 = rs.lastW;
        var width2 = eStyle['control-point-step-size'].pxValue;

        if( badBezier ){
          rs.badBezier = true;
        } else {
          rs.badBezier = false;
        }

        if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
        &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
        &&  width1 === width2
        &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
          // console.log('edge ctrl pt cache HIT')
          continue; // then the control points haven't changed and we can skip calculating them
        } else {
          rs.lastSrcCtlPtX = srcX2;
          rs.lastSrcCtlPtY = srcY2;
          rs.lastSrcCtlPtW = srcW2;
          rs.lastSrcCtlPtH = srcH2;
          rs.lastTgtCtlPtX = tgtX2;
          rs.lastTgtCtlPtY = tgtY2;
          rs.lastTgtCtlPtW = tgtW2;
          rs.lastTgtCtlPtH = tgtH2;
          rs.lastEdgeIndex = edgeIndex2;
          rs.lastNumEdges = numEdges2;
          rs.lastWidth = width2;
          // console.log('edge ctrl pt cache MISS')
        }

        // Self-edge
        if ( src === tgt ) {
            
          rs.edgeType = 'self';
          
          var j = i;
          var loopDist = stepSize;

          if( edgeIsUnbundled ){
            j = 0;
            loopDist = stepDist;
          }

          // New -- fix for large nodes
          rs.cp2ax = srcPos.x;
          rs.cp2ay = srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1);
          
          rs.cp2cx = src._private.position.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1);
          rs.cp2cy = srcPos.y;
          
          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;
          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;
          
        // Straight edge
        } else if (pairEdges.length % 2 === 1
          && i === Math.floor(pairEdges.length / 2)
          && !edgeIsUnbundled ) {
          
          rs.edgeType = 'straight';
          
        // Bezier edge
        } else {
          var normStepDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manStepDist;
          var sign = $$.math.signum( normStepDist );

          if( edgeIsUnbundled ){
            manStepDist = stepDist;
          } else {
            manStepDist = stepDist !== undefined ? sign * stepDist : undefined; 
          }

          var distanceFromMidpoint = manStepDist !== undefined ? manStepDist : normStepDist;
          
          var w1 = (1 - stepWeight);
          var w2 = stepWeight;

          var swappedDirection = edge._private.source !== src;
          if( swappedDirection ){
            w1 = stepWeight;
            w2 = (1 - stepWeight);
          }

          var adjustedMidpt = {
            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
          };

          rs.edgeType = 'bezier';
          
          rs.cp2x = adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint;
          rs.cp2y = adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint;
          
          // console.log(edge, midPointX, displacementX, distanceFromMidpoint);
        }

        // find endpts for edge
        this.findEndpoints( edge );

        var badStart = !$$.is.number( rs.startX ) || !$$.is.number( rs.startY );
        var badAStart = !$$.is.number( rs.arrowStartX ) || !$$.is.number( rs.arrowStartY );
        var badEnd = !$$.is.number( rs.endX ) || !$$.is.number( rs.endY );
        var badAEnd = !$$.is.number( rs.arrowEndX ) || !$$.is.number( rs.arrowEndY );

        var minCpADistFactor = 3;
        var arrowW = this.getArrowWidth( edge._private.style['width'].pxValue ) * CanvasRenderer.arrowShapeHeight;
        var minCpADist = minCpADistFactor * arrowW;
        var startACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        if( rs.edgeType === 'bezier' ){
          var overlapping = false;

          if( badStart || badAStart || closeStartACp ){
            overlapping = true;

            // project control point along line from src centre to outside the src shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - srcPos.x,
              y: rs.cp2y - srcPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var srcCtrlPtIntn = srcShape.intersectLine(
              srcPos.x,
              srcPos.y,
              srcW,
              srcH,
              cpProj.x,
              cpProj.y,
              srcBorder / 2
            );

            if( closeStartACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - startACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - startACpDist);
            } else {
              rs.cp2x = srcCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = srcCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if( badEnd || badAEnd || closeEndACp ){
            overlapping = true;

            // project control point along line from tgt centre to outside the tgt shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - tgtPos.x,
              y: rs.cp2y - tgtPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var tgtCtrlPtIntn = tgtShape.intersectLine(
              tgtPos.x,
              tgtPos.y,
              tgtW,
              tgtH,
              cpProj.x,
              cpProj.y,
              tgtBorder / 2
            );

            if( closeEndACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - endACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - endACpDist);
            } else {
              rs.cp2x = tgtCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
            }
            
          }

          if( overlapping ){
            // recalc endpts
            this.findEndpoints( edge );
          }
        } else if( rs.edgeType === 'straight' ){
          rs.midX = ( srcX2 + tgtX2 )/2;
          rs.midY = ( srcY2 + tgtY2 )/2;
        }

        // project the edge into rstyle
        this.projectBezier( edge );

      }
    }
      
    for( var i = 0; i < haystackEdges.length; i++ ){
      var edge = haystackEdges[i];
      var rscratch = edge._private.rscratch;

      if( !rscratch.haystack ){
        var angle = Math.random() * 2 * Math.PI;

        rscratch.source = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };

        var angle = Math.random() * 2 * Math.PI;

        rscratch.target = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };
      }  

      // always override as haystack in case set to different type previously
      rscratch.edgeType = 'haystack';
      rscratch.haystack = true;
    }

    return hashTable;
  };

  CanvasRenderer.prototype.findEndpoints = function(edge) {
    var intersect;

    var source = edge.source()[0];
    var target = edge.target()[0];
    
    var tgtArShape = edge._private.style['target-arrow-shape'].value;
    var srcArShape = edge._private.style['source-arrow-shape'].value;

    var tgtBorderW = target._private.style['border-width'].pxValue;
    var srcBorderW = source._private.style['border-width'].pxValue;

    var rs = edge._private.rscratch;
    
    if (edge._private.rscratch.edgeType == 'self') {
      
      var cp = [rs.cp2cx, rs.cp2cy];
      
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0],
        cp[1], 
        tgtBorderW / 2
      );
      
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      var cp = [rs.cp2ax, rs.cp2ay];

      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));
      
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];


      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
    } else if (rs.edgeType == 'straight') {
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        source.position().x,
        source.position().y,
        tgtBorderW / 2);
        
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
  //      return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      var arrowEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));

      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        target.position().x,
        target.position().y,
        srcBorderW / 2);
      
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
  //      return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      /*
      console.log("1: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));

      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
            
    } else if (rs.edgeType == 'bezier') {
      // if( window.badArrow) debugger;
      var cp = [rs.cp2x, rs.cp2y];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        tgtBorderW / 2
      );
      
      /*
      console.log("2: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge)
      );
      var edgeStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge)
      );
    
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
      // if( isNaN(rs.startX) || isNaN(rs.startY) ){
      //   debugger;
      // }

    } else if (rs.isArcEdge) {
      return;
    }
  };

  // Find adjacent edges
  CanvasRenderer.prototype.findEdges = function(nodeSet) {
    
    var edges = this.getCachedEdges();
    
    var hashTable = {};
    var adjacentEdges = [];
    
    for (var i = 0; i < nodeSet.length; i++) {
      hashTable[nodeSet[i]._private.data.id] = nodeSet[i];
    }
    
    for (var i = 0; i < edges.length; i++) {
      if (hashTable[edges[i]._private.data.source]
        || hashTable[edges[i]._private.data.target]) {
        
        adjacentEdges.push(edges[i]);
      }
    }
    
    return adjacentEdges;
  };

  CanvasRenderer.prototype.getArrowWidth = CanvasRenderer.prototype.getArrowHeight = function(edgeWidth) {
    var cache = this.arrowWidthCache = this.arrowWidthCache || {};

    var cachedVal = cache[edgeWidth];
    if( cachedVal ){
      return cachedVal;
    }

    cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);
    cache[edgeWidth] = cachedVal;

    return cachedVal;
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

// Draw edge
  CanvasRenderer.prototype.drawEdge = function(context, edge, drawOverlayInstead) {
    var rs = edge._private.rscratch;
    var usePaths = CanvasRenderer.usePaths();

    // if bezier ctrl pts can not be calculated, then die
    if( rs.badBezier || ( (rs.edgeType === 'bezier' || rs.edgeType === 'straight') && isNaN(rs.startX)) ){ // extra isNaN() for safari 7.1 b/c it mangles ctrlpt calcs
      return;
    }

    var style = edge._private.style;
    
    // Edge line width
    if (style['width'].pxValue <= 0) {
      return;
    }

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    // Edge color & opacity
    if( drawOverlayInstead ){

      if( overlayOpacity === 0 ){ // exit early if no overlay
        return;
      }

      this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
      context.lineCap = 'round';

      if( edge._private.rscratch.edgeType == 'self' && !usePaths ){
        context.lineCap = 'butt';
      }

    } else {
      var lineColor = style['line-color'].value;

      this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);
      
      context.lineCap = 'butt'; 
    }
    
    var startNode, endNode, source, target;
    source = startNode = edge._private.source;
    target = endNode = edge._private.target;

    var targetPos = target._private.position;
    var targetW = target.width();
    var targetH = target.height();
    var sourcePos = source._private.position;
    var sourceW = source.width();
    var sourceH = source.height();


    var edgeWidth = style['width'].pxValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
    var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;
    context.lineWidth = edgeWidth;
    
    if( rs.edgeType !== 'haystack' ){
      //this.findEndpoints(edge);
    }
    
    if( rs.edgeType === 'haystack' ){
      var radius = style['haystack-radius'].value;
      var halfRadius = radius/2; // b/c have to half width/height

      this.drawStyledEdge(
        edge, 
        context, 
        rs.haystackPts = [
          rs.source.x * sourceW * halfRadius + sourcePos.x,
          rs.source.y * sourceH * halfRadius + sourcePos.y,
          rs.target.x * targetW * halfRadius + targetPos.x,
          rs.target.y * targetH * halfRadius + targetPos.y
        ],
        lineStyle,
        edgeWidth
      );
    } else if (rs.edgeType === 'self') {
      
      var details = edge._private.rscratch;
      var points = [details.startX, details.startY, details.cp2ax,
        details.cp2ay, details.selfEdgeMidX, details.selfEdgeMidY,
        details.selfEdgeMidX, details.selfEdgeMidY,
        details.cp2cx, details.cp2cy, details.endX, details.endY];

      var details = edge._private.rscratch;
      this.drawStyledEdge(edge, context, points, lineStyle, edgeWidth);
      
    } else if (rs.edgeType === 'straight') {
      
      var nodeDirectionX = endNode._private.position.x - startNode._private.position.x;
      var nodeDirectionY = endNode._private.position.y - startNode._private.position.y;
      
      var edgeDirectionX = rs.endX - rs.startX;
      var edgeDirectionY = rs.endY - rs.startY;
      
      if (nodeDirectionX * edgeDirectionX
        + nodeDirectionY * edgeDirectionY < 0) {
        
        rs.straightEdgeTooShort = true;  
      } else {
        
        var details = rs;
        this.drawStyledEdge(edge, context, [details.startX, details.startY,
                                      details.endX, details.endY],
                                      lineStyle,
                                      edgeWidth);
        
        rs.straightEdgeTooShort = false;  
      }  
    } else {
      
      var details = rs;
      
      this.drawStyledEdge(edge, context, [details.startX, details.startY,
        details.cp2x, details.cp2y, details.endX, details.endY],
        lineStyle,
        edgeWidth);
      
    }
    
    if( rs.edgeType === 'haystack' ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    } else if ( rs.noArrowPlacement !== true && rs.startX !== undefined ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    }

  };
  
  
  CanvasRenderer.prototype.drawStyledEdge = function(
      edge, context, pts, type, width) {

    // 3 points given -> assume Bezier
    // 2 -> assume straight
    
    var rs = edge._private.rscratch;
    var canvasCxt = context;
    var path;
    var pathCacheHit = false;
    var usePaths = CanvasRenderer.usePaths();


    if( usePaths ){

      var pathCacheKey = pts;
      var keyLengthMatches = rs.pathCacheKey && pathCacheKey.length === rs.pathCacheKey.length;
      var keyMatches = keyLengthMatches;

      for( var i = 0; keyMatches && i < pathCacheKey.length; i++ ){
        if( rs.pathCacheKey[i] !== pathCacheKey[i] ){
          keyMatches = false;
        }
      }

      if( keyMatches ){
        path = context = rs.pathCache;
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.pathCacheKey = pathCacheKey;
        rs.pathCache = path;
      }

    }

    if( canvasCxt.setLineDash ){ // for very outofdate browsers
      switch( type ){
        case 'dotted':
          canvasCxt.setLineDash([ 1, 1 ]);
          break;

        case 'dashed':
          canvasCxt.setLineDash([ 6, 3 ]);
          break;

        case 'solid':
          canvasCxt.setLineDash([ ]);
          break;
      }
    }

    if( !pathCacheHit ){
      if( context.beginPath ){ context.beginPath(); }
      context.moveTo(pts[0], pts[1]);
      
      if (pts.length === 3 * 2) { // bezier
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
      } else if( pts.length === 3 * 2 * 2 ){ // double bezier loop
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
        context.quadraticCurveTo(pts[8], pts[9], pts[10], pts[11]);
      } else { // line
        context.lineTo(pts[2], pts[3]);
      }
    }

    context = canvasCxt;
    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }
  
    // reset any line dashes
    if( context.setLineDash ){ // for very outofdate browsers
      context.setLineDash([ ]);
    }

  };

  CanvasRenderer.prototype.drawArrowheads = function(context, edge, drawOverlayInstead) {
    if( drawOverlayInstead ){ return; } // don't do anything for overlays 

    var rs = edge._private.rscratch;
    var self = this;
    var isHaystack = rs.edgeType === 'haystack';

    // Displacement gives direction for arrowhead orientation
    var dispX, dispY;
    var startX, startY, endX, endY;

    var srcPos = edge.source().position();
    var tgtPos = edge.target().position();

    if( isHaystack ){
      startX = rs.haystackPts[0];
      startY = rs.haystackPts[1];
      endX = rs.haystackPts[2];
      endY = rs.haystackPts[3];
    } else {
      startX = rs.arrowStartX;
      startY = rs.arrowStartY;
      endX = rs.arrowEndX;
      endY = rs.arrowEndY;
    }

    var style = edge._private.style;
    
    function drawArrowhead( prefix, x, y, dispX, dispY ){
      var arrowShape = style[prefix + '-arrow-shape'].value;

      if( arrowShape === 'none' ){
        return;
      }

      var gco = context.globalCompositeOperation;

      context.globalCompositeOperation = 'destination-out';
      
      self.fillStyle(context, 255, 255, 255, 1);


      var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';
      var arrowFill = style[prefix + '-arrow-fill'].value;

      if( arrowShape === 'half-triangle-overshot' ){
        arrowFill = 'hollow';
        arrowClearFill = 'hollow';
      }

      self.drawArrowShape( edge, prefix, context, 
        arrowClearFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
        x, y, dispX, dispY
      );

      context.globalCompositeOperation = gco;

      var color = style[prefix + '-arrow-color'].value;
      self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);

      self.drawArrowShape( edge, prefix, context, 
        arrowFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
        x, y, dispX, dispY
      );
    }

    dispX = startX - srcPos.x;
    dispY = startY - srcPos.y;

    if( !isHaystack && !isNaN(startX) && !isNaN(startY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'source', startX, startY, dispX, dispY );

    } else {
      // window.badArrow = true;
      // debugger;
    }
    
    var midX = rs.midX;
    var midY = rs.midY;

    if( isHaystack ){
      midX = ( startX + endX )/2;
      midY = ( startY + endY )/2;
    }

    dispX = startX - endX;
    dispY = startY - endY;

    if( rs.edgeType === 'self' ){
      dispX = 1;
      dispY = -1;
    }

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-target', midX, midY, dispX, dispY );
    }

    dispX *= -1;
    dispY *= -1;

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-source', midX, midY, dispX, dispY );
    }
    
    dispX = endX - tgtPos.x;
    dispY = endY - tgtPos.y;
    
    if( !isHaystack && !isNaN(endX) && !isNaN(endY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'target', endX, endY, dispX, dispY );
    }
  };
  
  // Draw arrowshape
  CanvasRenderer.prototype.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, dispX, dispY) {
    var usePaths = CanvasRenderer.usePaths();
    var rs = edge._private.rscratch;
    var pathCacheHit = false;
    var path;
    var canvasContext = context;
    var translation = { x: x, y: y };

    // Negative of the angle
    var angle = Math.asin(dispY / (Math.sqrt(dispX * dispX + dispY * dispY)));
  
    if (dispX < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = - (Math.PI / 2 + angle);
    }
    
    var size = this.getArrowWidth( edgeWidth );
    var shapeImpl = CanvasRenderer.arrowShapes[shape];

    // context.translate(x, y);

    if( usePaths ){
      var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
      rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
      rs.arrowPathCache = rs.arrowPathCache || {};

      var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
      if( alreadyCached ){
        path = context = rs.arrowPathCache[arrowType];
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.arrowPathCacheKey[arrowType] = pathCacheKey;
        rs.arrowPathCache[arrowType] = path;
      }
    }

    if( context.beginPath ){ context.beginPath(); }

    if( !pathCacheHit ){
      shapeImpl.draw(context, size, angle, translation);
    }
    
    if( !shapeImpl.leavePathOpen && context.closePath ){
      context.closePath();
    }

    context = canvasContext;

    if( fill === 'filled' || fill === 'both' ){
      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }
    }

    if( fill === 'hollow' || fill === 'both' ){
      context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
      context.lineJoin = 'miter';

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }
      
    }

    // context.translate(-x, -y);
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  CanvasRenderer.prototype.getCachedImage = function(url, onLoad) {
    var r = this;
    var imageCache = r.imageCache = r.imageCache || {};

    if( imageCache[url] && imageCache[url].image ){
      return imageCache[url].image;
    }
    
    var cache = imageCache[url] = imageCache[url] || {};

    var image = cache.image = new Image();
    image.addEventListener('load', onLoad);
    image.src = url;
    
    return image;
  };
    
  CanvasRenderer.prototype.drawInscribedImage = function(context, img, node) {
    var r = this;
    var nodeX = node._private.position.x;
    var nodeY = node._private.position.y;
    var style = node._private.style;
    var fit = style['background-fit'].value;
    var xPos = style['background-position-x'];
    var yPos = style['background-position-y'];
    var repeat = style['background-repeat'].value;
    var nodeW = node.width();
    var nodeH = node.height();
    var rs = node._private.rscratch;
    var clip = style['background-clip'].value;
    var shouldClip = clip === 'node';
    var imgOpacity = style['background-image-opacity'].value;
    
    var w = img.width;
    var h = img.height;

    if( w === 0 || h === 0 ){
      return; // no point in drawing empty image (and chrome is broken in this case)
    }

    if( fit === 'contain' ){
      var scale = Math.min( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;

    } else if( fit === 'cover' ){
      var scale = Math.max( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;
    }

    var x = (nodeX - nodeW/2); // left
    if( xPos.units === '%' ){
      x += (nodeW - w) * xPos.value/100;
    } else {
      x += xPos.pxValue;
    }

    var y = (nodeY - nodeH/2); // top
    if( yPos.units === '%' ){
      y += (nodeH - h) * yPos.value/100;
    } else {
      y += yPos.pxValue;
    }

    if( rs.pathCache ){
      x -= nodeX;
      y -= nodeY;

      nodeX = 0;
      nodeY = 0;
    }

    var gAlpha = context.globalAlpha;

    context.globalAlpha = imgOpacity;

    if( repeat === 'no-repeat' ){

      if( shouldClip ){
        context.save();

        if( rs.pathCache ){
          context.clip( rs.pathCache );
        } else {
          CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
            context,
            nodeX, nodeY, 
            nodeW, nodeH);

          context.clip();
        }
      }

      context.drawImage( img, 0, 0, img.width, img.height, x, y, w, h );

      if( shouldClip ){
        context.restore();
      }
    } else {
      var pattern = context.createPattern( img, repeat );
      context.fillStyle = pattern;

      CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
          context,
          nodeX, nodeY, 
          nodeW, nodeH);

        context.translate(x, y);
        context.fill();
        context.translate(-x, -y);
    }

    context.globalAlpha = gAlpha;
    
  };

  
})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // Draw edge text
  CanvasRenderer.prototype.drawEdgeText = function(context, edge) {
    var text = edge._private.style['content'].strValue;

    if( !text || text.match(/^\s+$/) ){
      return;
    }

    if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching

    var computedSize = edge._private.style['font-size'].pxValue * edge.cy().zoom();
    var minSize = edge._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }
  
    // Calculate text draw position
    
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    // this.recalculateEdgeLabelProjection( edge );
    
    var rs = edge._private.rscratch;
    this.drawText(context, edge, rs.labelX, rs.labelY);
  };

  // Draw node text
  CanvasRenderer.prototype.drawNodeText = function(context, node) {
    var text = node._private.style['content'].strValue;

    if ( !text || text.match(/^\s+$/) ) {
      return;
    }

    var computedSize = node._private.style['font-size'].pxValue * node.cy().zoom();
    var minSize = node._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }
      
    // this.recalculateNodeLabelProjection( node );

    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;

    switch( textHalign ){
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default: // e.g. center
        context.textAlign = 'center';
    }

    switch( textValign ){
      case 'top':
        context.textBaseline = 'bottom';
        break;

      case 'bottom':
        context.textBaseline = 'top';
        break;

      default: // e.g. center
        context.textBaseline = 'middle';
    }

    this.drawText(context, node, rs.labelX, rs.labelY);
  };
  
  CanvasRenderer.prototype.getFontCache = function(context){
    var cache;

    this.fontCaches = this.fontCaches || [];

    for( var i = 0; i < this.fontCaches.length; i++ ){
      cache = this.fontCaches[i];

      if( cache.context === context ){
        return cache;
      }
    }

    cache = {
      context: context
    };
    this.fontCaches.push(cache);

    return cache;
  };

  // set up canvas context with font
  // returns transformed text string
  CanvasRenderer.prototype.setupTextStyle = function( context, element ){
    // Font style
    var parentOpacity = element.effectiveOpacity();
    var style = element._private.style;
    var labelStyle = style['font-style'].strValue;
    var labelSize = style['font-size'].pxValue + 'px';
    var labelFamily = style['font-family'].strValue;
    var labelWeight = style['font-weight'].strValue;
    var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;
    var outlineOpacity = style['text-outline-opacity'].value * opacity;
    var color = style['color'].value;
    var outlineColor = style['text-outline-color'].value;

    var fontCacheKey = element._private.fontKey;
    var cache = this.getFontCache(context);

    if( cache.key !== fontCacheKey ){
      context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

      cache.key = fontCacheKey;
    }

    var text = String(style['content'].value);
    var textTransform = style['text-transform'].value;
    
    if (textTransform == 'none') {
    } else if (textTransform == 'uppercase') {
      text = text.toUpperCase();
    } else if (textTransform == 'lowercase') {
      text = text.toLowerCase();
    }
    
    // Calculate text draw position based on text alignment
    
    // so text outlines aren't jagged
    context.lineJoin = 'round';

    this.fillStyle(context, color[0], color[1], color[2], opacity);
    
    this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);

    return text;
  };

  // Draw text
  CanvasRenderer.prototype.drawText = function(context, element, textX, textY) {
    var style = element._private.style;
    var parentOpacity = element.effectiveOpacity();
    if( parentOpacity === 0 ){ return; }

    var text = this.setupTextStyle( context, element );
    
    if ( text != null && !isNaN(textX) && !isNaN(textY) ) {
     
      var lineWidth = 2  * style['text-outline-width'].value; // *2 b/c the stroke is drawn centred on the middle
      if (lineWidth > 0) {
        context.lineWidth = lineWidth;
        context.strokeText(text, textX, textY);
      }

      context.fillText(text, textX, textY);
    }
  };

  
})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // Draw node
  CanvasRenderer.prototype.drawNode = function(context, node, drawOverlayInstead) {

    var r = this;
    var nodeWidth, nodeHeight;
    var style = node._private.style;
    var rs = node._private.rscratch;
    
    var usePaths = CanvasRenderer.usePaths();
    var canvasContext = context;
    var path;
    var pathCacheHit = false;

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw
      return;
    }

    var parentOpacity = node.effectiveOpacity();
    if( parentOpacity === 0 ){ return; }

    nodeWidth = this.getNodeWidth(node);
    nodeHeight = this.getNodeHeight(node);
    
    context.lineWidth = style['border-width'].pxValue;

    if( drawOverlayInstead === undefined || !drawOverlayInstead ){

      // Node color & opacity

      var bgColor = style['background-color'].value;
      var borderColor = style['border-color'].value;
      var borderStyle = style['border-style'].value;

      this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * style['opacity'].value * parentOpacity);
      
      this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * style['opacity'].value * parentOpacity);

      context.lineJoin = 'miter'; // so borders are square with the node shape

      if( context.setLineDash ){ // for very outofdate browsers
        switch( borderStyle ){
          case 'dotted':
            context.setLineDash([ 1, 1 ]);
            break;

          case 'dashed':
            context.setLineDash([ 4, 2 ]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([ ]);
            break;
        }
      }

      //var image = this.getCachedImage('url');
      
      var url = style['background-image'].value[2] ||
        style['background-image'].value[1];
      
      var styleShape = style['shape'].strValue;

      var pos = node._private.position;

      if( usePaths ){
        var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;

        context.translate( pos.x, pos.y );

        if( rs.pathCacheKey === pathCacheKey ){
          path = context = rs.pathCache;
          pathCacheHit = true;
        } else {
          path = context = new Path2D();
          rs.pathCacheKey = pathCacheKey;
          rs.pathCache = path;
        }
      }

      if( !pathCacheHit ){

        var npos = pos;

        if( usePaths ){
          npos = {
            x: 0,
            y: 0
          };
        }

        CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
              context,
              npos.x,
              npos.y,
              nodeWidth,
              nodeHeight);
      }

      context = canvasContext;

      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }

      if (url !== undefined) {
        
        // get image, and if not loaded then ask to redraw when later loaded
        var image = this.getCachedImage(url, function(){
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
          
          r.redraw();
        });
        
        if( image.complete ){
          this.drawInscribedImage(context, image, node);
        }
        
      } 
      
      var darkness = style['background-blacken'].value;
      var borderWidth = style['border-width'].pxValue;

      if( this.hasPie(node) ){
        this.drawPie(context, node);

        // redraw path for blacken and border
        if( darkness !== 0 || borderWidth !== 0 ){

          if( !usePaths ){
            CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
                context,
                pos.x,
                pos.y,
                nodeWidth,
                nodeHeight);
          }
        }
      }

      if( darkness > 0 ){
        this.fillStyle(context, 0, 0, 0, darkness);

        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
        
      } else if( darkness < 0 ){
        this.fillStyle(context, 255, 255, 255, -darkness);
        
        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
      }

      // Border width, draw border
      if (borderWidth > 0) {

        if( usePaths ){
          context.stroke( path );
        } else {
          context.stroke();
        }

        if( borderStyle === 'double' ){
          context.lineWidth = style['border-width'].pxValue/3;

          var gco = context.globalCompositeOperation;
          context.globalCompositeOperation = 'destination-out';

          if( usePaths ){
            context.stroke( path );
          } else {
            context.stroke();
          }

          context.globalCompositeOperation = gco;
        }

      }

      if( usePaths ){
        context.translate( -pos.x, -pos.y );
      }

      // reset in case we changed the border style
      if( context.setLineDash ){ // for very outofdate browsers
        context.setLineDash([ ]);
      }

    // draw the overlay
    } else {

      if( overlayOpacity > 0 ){
        this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

        CanvasRenderer.nodeShapes['roundrectangle'].drawPath(
          context,
          node._private.position.x,
          node._private.position.y,
          nodeWidth + overlayPadding * 2,
          nodeHeight + overlayPadding * 2
        );

        context.fill();
      }
    }

  };

  // does the node have at least one pie piece?
  CanvasRenderer.prototype.hasPie = function(node){
    node = node[0]; // ensure ele ref
    
    return node._private.hasPie;
  };

  CanvasRenderer.prototype.drawPie = function(context, node){
    node = node[0]; // ensure ele ref

    var pieSize = node._private.style['pie-size'];
    var nodeW = this.getNodeWidth( node );
    var nodeH = this.getNodeHeight( node );
    var x = node._private.position.x;
    var y = node._private.position.y;
    var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
    var usePaths = CanvasRenderer.usePaths();

    if( usePaths ){
      x = 0;
      y = 0;
    }

    if( pieSize.units === '%' ){
      radius = radius * pieSize.value / 100;
    } else if( pieSize.pxValue !== undefined ){
      radius = pieSize.pxValue / 2;
    }

    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
      var size = node._private.style['pie-' + i + '-background-size'].value;
      var color = node._private.style['pie-' + i + '-background-color'].value;
      var opacity = node._private.style['pie-' + i + '-background-opacity'].value;
      var percent = size / 100; // map integer range [0, 100] to [0, 1]
      var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
      var angleDelta = 2 * Math.PI * percent;
      var angleEnd = angleStart + angleDelta;

      // ignore if
      // - zero size
      // - we're already beyond the full circle
      // - adding the current slice would go beyond the full circle
      if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
        continue;
      }

      context.beginPath();
      context.moveTo(x, y);
      context.arc( x, y, radius, angleStart, angleEnd );
      context.closePath();

      this.fillStyle(context, color[0], color[1], color[2], opacity);

      context.fill();

      lastPercent += percent;
    }

  };

  
})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // var isFirefox = typeof InstallTrigger !== 'undefined';

  CanvasRenderer.prototype.getPixelRatio = function(){ 
    var context = this.data.contexts[0];

    if( this.forcedPixelRatio != null ){
      return this.forcedPixelRatio;
    }

    var backingStore = context.backingStorePixelRatio ||
      context.webkitBackingStorePixelRatio ||
      context.mozBackingStorePixelRatio ||
      context.msBackingStorePixelRatio ||
      context.oBackingStorePixelRatio ||
      context.backingStorePixelRatio || 1;

    //console.log(window.devicePixelRatio, backingStore);

    // if( isFirefox ){ // because ff can't scale canvas properly
    //   return 1;
    // }

    return (window.devicePixelRatio || 1) / backingStore;
  };

  CanvasRenderer.prototype.paintCache = function(context){
    var caches = this.paintCaches = this.paintCaches || [];
    var needToCreateCache = true;
    var cache;

    for(var i = 0; i < caches.length; i++ ){
      cache = caches[i];

      if( cache.context === context ){
        needToCreateCache = false;
        break;
      }
    }

    if( needToCreateCache ){
      cache = {
        context: context
      };
      caches.push( cache );
    }

    return cache;
  };

  CanvasRenderer.prototype.fillStyle = function(context, r, g, b, a){
    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.fillStyle !== fillStyle ){
    //   context.fillStyle = cache.fillStyle = fillStyle;
    // }
  };

  CanvasRenderer.prototype.strokeStyle = function(context, r, g, b, a){
    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.strokeStyle !== strokeStyle ){
    //   context.strokeStyle = cache.strokeStyle = strokeStyle;
    // }
  };

  // Resize canvas
  CanvasRenderer.prototype.matchCanvasSize = function(container) {
    var data = this.data;
    var width = container.clientWidth;
    var height = container.clientHeight;
    var pixelRatio = this.getPixelRatio();
    var canvasWidth = width * pixelRatio;
    var canvasHeight = height * pixelRatio;
    var canvas;

    if( canvasWidth === this.canvasWidth && canvasHeight === this.canvasHeight ){
      return; // save cycles if same
    }

    this.fontCaches = null; // resizing resets the style

    var canvasContainer = data.canvasContainer;
    canvasContainer.style.width = width + 'px';
    canvasContainer.style.height = height + 'px';

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {

      canvas = data.canvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      
      canvas = data.bufferCanvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }

    this.textureMult = 1;
    if( pixelRatio <= 1 ){
      canvas = data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

      this.textureMult = 2;
      canvas.width = canvasWidth * this.textureMult;
      canvas.height = canvasHeight * this.textureMult;
    }

    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;

  };

  CanvasRenderer.prototype.renderTo = function( cxt, zoom, pan, pxRatio ){
    this.redraw({
      forcedContext: cxt,
      forcedZoom: zoom,
      forcedPan: pan,
      drawAllLayers: true,
      forcedPxRatio: pxRatio
    });
  };

  CanvasRenderer.prototype.timeToRender = function(){
    return this.redrawTotalTime / this.redrawCount;
  };

  CanvasRenderer.minRedrawLimit = 1000/60; // people can't see much better than 60fps
  CanvasRenderer.maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth
  CanvasRenderer.motionBlurDelay = 100;

  // Redraw frame
  CanvasRenderer.prototype.redraw = function( options ) {
    options = options || {};

    // console.log('redraw');

    var forcedContext = options.forcedContext;
    var drawAllLayers = options.drawAllLayers;
    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
    var forcedZoom = options.forcedZoom;
    var forcedPan = options.forcedPan;
    var r = this;
    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
    var cy = r.data.cy; var data = r.data; 
    var needDraw = data.canvasNeedsRedraw;
    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled;

    if( motionBlur && r.motionBlurTimeout ){
      clearTimeout( r.motionBlurTimeout );
    }

    if( !forcedContext && this.redrawTimeout ){
      clearTimeout( this.redrawTimeout );
    }
    this.redrawTimeout = null;

    if( this.averageRedrawTime === undefined ){ this.averageRedrawTime = 0; }

    var minRedrawLimit = CanvasRenderer.minRedrawLimit; 
    var maxRedrawLimit = CanvasRenderer.maxRedrawLimit;

    var redrawLimit = this.averageRedrawTime; // estimate the ideal redraw limit based on how fast we can draw
    redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;
    redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;

    //console.log('--\nideal: %i; effective: %i', this.averageRedrawTime, redrawLimit);

    if( this.lastDrawTime === undefined ){ this.lastDrawTime = 0; }

    var nowTime = +new Date();
    var timeElapsed = nowTime - this.lastDrawTime;
    var callAfterLimit = timeElapsed >= redrawLimit;

    if( !forcedContext ){
      if( !callAfterLimit || this.currentlyDrawing ){
        // console.log('-- skip');

        // we have new things to draw but we're busy, so try again when possibly free
        this.redrawTimeout = setTimeout(function(){
          r.redraw();
        }, redrawLimit);
        return;
      }

      this.lastDrawTime = nowTime;
      this.currentlyDrawing = true;
    }


    var startTime = +new Date();

    //console.log('-- redraw --')


    function drawToContext(){ 
      // startTime = +new Date();
      // console.profile('draw' + startTime)
      var edges = r.getCachedEdges();
      var coreStyle = cy.style()._private.coreStyle;
      
      var zoom = cy.zoom();
      var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
      var pan = cy.pan();
      var effectivePan = {
        x: pan.x,
        y: pan.y
      };

      if( forcedPan ){
        effectivePan = forcedPan;
      }

      // apply pixel ratio

      effectiveZoom *= pixelRatio;
      effectivePan.x *= pixelRatio;
      effectivePan.y *= pixelRatio;
      
      var eles = {
        drag: {
          nodes: [],
          edges: [],
          eles: []
        },
        nondrag: {
          nodes: [],
          edges: [],
          eles: []
        }
      };

      function setContextTransform(context, clear){
        context.setTransform(1, 0, 0, 1, 0, 0);

        if( clear === 'motionBlur' ){
          var gco = context.globalCompositeOperation;

          context.globalCompositeOperation = 'destination-out';
          r.fillStyle( context, 255, 255, 255, 0.666 );
          context.fillRect(0, 0, r.canvasWidth, r.canvasHeight);

          context.globalCompositeOperation = gco;
        } else if( !forcedContext && (clear === undefined || clear) ){
          context.clearRect(0, 0, r.canvasWidth, r.canvasHeight);
        }
        
        if( !drawAllLayers ){
          context.translate(effectivePan.x, effectivePan.y);
          context.scale(effectiveZoom, effectiveZoom);
        }
        if( forcedPan ){
          context.translate(forcedPan.x, forcedPan.y);
        } 
        if( forcedZoom ){
          context.scale(forcedZoom, forcedZoom);
        }
      }

      var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);

      if( textureDraw ){

        var bb;

        if( !r.textureCache ){
          r.textureCache = {};

          bb = r.textureCache.bb = cy.elements().boundingBox();

          r.textureCache.texture = r.data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

          var cxt = r.data.bufferContexts[ CanvasRenderer.TEXTURE_BUFFER ];

          cxt.setTransform(1, 0, 0, 1, 0, 0);
          cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
          
          r.redraw({
            forcedContext: cxt,
            drawOnlyNodeLayer: true,
            forcedPxRatio: pixelRatio * r.textureMult
          });

          var vp = r.textureCache.viewport = {
            zoom: cy.zoom(),
            pan: cy.pan(),
            width: r.canvasWidth,
            height: r.canvasHeight
          };

          vp.mpan = {
            x: (0 - vp.pan.x)/vp.zoom,
            y: (0 - vp.pan.y)/vp.zoom
          };
        }

        needDraw[CanvasRenderer.DRAG] = false;
        needDraw[CanvasRenderer.NODE] = false;

        var context = data.contexts[CanvasRenderer.NODE];

        var texture = r.textureCache.texture;
        var vp = r.textureCache.viewport;
        bb = r.textureCache.bb;

        context.setTransform(1, 0, 0, 1, 0, 0);
        context.clearRect(0, 0, vp.width, vp.height);

        var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
        var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
        r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
        context.fillRect( 0, 0, vp.width, vp.height );

        var zoom = cy.zoom();
        
        setContextTransform( context, false );

        context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );
        context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );

      } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
        r.textureCache = null;
      }

      var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
      var hideEdges = r.hideEdgesOnViewport && vpManip;
      var hideLabels = r.hideLabelsOnViewport && vpManip;

      if (needDraw[CanvasRenderer.DRAG] || needDraw[CanvasRenderer.NODE] || drawAllLayers || drawOnlyNodeLayer) {
        //NB : VERY EXPENSIVE

        if( hideEdges ){ 
        } else {
          r.findEdgeControlPoints(edges);
        }

        var zEles = r.getCachedZSortedEles();
        var extent = cy.extent();

        for (var i = 0; i < zEles.length; i++) {
          var ele = zEles[i];
          var list;
          var bb = forcedContext ? null : ele.boundingBox();
          var insideExtent = forcedContext ? true : $$.math.boundingBoxesIntersect( extent, bb );

          if( !insideExtent ){ continue; } // no need to render

          if ( ele._private.rscratch.inDragLayer ) {
            list = eles.drag;
          } else {
            list = eles.nondrag;
          }

          list.eles.push( ele );
        }

      }
      
      
      function drawElements( list, context ){
        var eles = list.eles;

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          if( ele.isNode() ){
            r.drawNode(context, ele);

            if( !hideLabels ){
              r.drawNodeText(context, ele);
            }

            r.drawNode(context, ele, true);
          } else if( !hideEdges ) {
            r.drawEdge(context, ele);

            if( !hideLabels ){
              r.drawEdgeText(context, ele);
            }

            r.drawEdge(context, ele, true);
          }
          
          
        }

      }

      var nodeLayerNeedsMotionClear = needDraw[CanvasRenderer.DRAG] && !needDraw[CanvasRenderer.NODE] && motionBlur && !r.clearedNodeLayerForMotionBlur;
      if( nodeLayerNeedsMotionClear ){ r.clearedNodeLayerForMotionBlur = true; }

      if( needDraw[CanvasRenderer.NODE] || drawAllLayers || drawOnlyNodeLayer || nodeLayerNeedsMotionClear ){
        // console.log('redrawing node layer');
        
        var context = forcedContext || data.contexts[CanvasRenderer.NODE];

        setContextTransform( context, motionBlur && !nodeLayerNeedsMotionClear ? 'motionBlur' : undefined );
        drawElements(eles.nondrag, context);
        
        if( !drawAllLayers ){
          needDraw[CanvasRenderer.NODE] = false; 
        }
      }
      
      if ( !drawOnlyNodeLayer && (needDraw[CanvasRenderer.DRAG] || drawAllLayers) ) {
        
        var context = forcedContext || data.contexts[CanvasRenderer.DRAG];
        
        setContextTransform( context, motionBlur ? 'motionBlur' : undefined );
        drawElements(eles.drag, context);
        
        if( !drawAllLayers ){
          needDraw[CanvasRenderer.DRAG] = false;
        }
      }
      
      if( r.showFps || (!drawOnlyNodeLayer && (needDraw[CanvasRenderer.SELECT_BOX] && !drawAllLayers)) ) {
        // console.log('redrawing selection box');
        
        var context = forcedContext || data.contexts[CanvasRenderer.SELECT_BOX];

        setContextTransform( context );

        if( data.select[4] == 1 && r.hoverData.selecting ){
          var zoom = data.cy.zoom();
          var borderWidth = coreStyle['selection-box-border-width'].value / zoom;
          
          context.lineWidth = borderWidth;
          context.fillStyle = "rgba(" 
            + coreStyle['selection-box-color'].value[0] + ","
            + coreStyle['selection-box-color'].value[1] + ","
            + coreStyle['selection-box-color'].value[2] + ","
            + coreStyle['selection-box-opacity'].value + ")";
          
          context.fillRect(
            data.select[0],
            data.select[1],
            data.select[2] - data.select[0],
            data.select[3] - data.select[1]);
          
          if (borderWidth > 0) {
            context.strokeStyle = "rgba(" 
              + coreStyle['selection-box-border-color'].value[0] + ","
              + coreStyle['selection-box-border-color'].value[1] + ","
              + coreStyle['selection-box-border-color'].value[2] + ","
              + coreStyle['selection-box-opacity'].value + ")";
            
            context.strokeRect(
              data.select[0],
              data.select[1],
              data.select[2] - data.select[0],
              data.select[3] - data.select[1]);
          }
        }

        if( data.bgActivePosistion && !r.hoverData.selecting ){
          var zoom = data.cy.zoom();
          var pos = data.bgActivePosistion;

          context.fillStyle = "rgba(" 
            + coreStyle['active-bg-color'].value[0] + ","
            + coreStyle['active-bg-color'].value[1] + ","
            + coreStyle['active-bg-color'].value[2] + ","
            + coreStyle['active-bg-opacity'].value + ")";

          context.beginPath();
          context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pxValue / zoom, 0, 2 * Math.PI); 
          context.fill();
        }
        
        var timeToRender = r.averageRedrawTime;
        if( r.showFps && timeToRender ){
          timeToRender = Math.round( timeToRender );
          var fps = Math.round(1000/timeToRender);

          context.setTransform(1, 0, 0, 1, 0, 0);

          //context.font = '20px helvetica';
          context.fillStyle = 'rgba(255, 0, 0, 0.75)';
          context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
          context.lineWidth = 1;
          context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

          var maxFps = 60;
          context.strokeRect(0, 30, 250, 20);
          context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);
        }

        if( !drawAllLayers ){
          needDraw[CanvasRenderer.SELECT_BOX] = false; 
        }
      }


      var endTime = +new Date();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      r.redrawTotalTime += endTime - startTime;
      r.lastRedrawTime = endTime - startTime;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime/2 + (endTime - startTime)/2;
      //console.log('actual: %i, average: %i', endTime - startTime, this.averageRedrawTime);

      r.currentlyDrawing = false;

      // console.profileEnd('draw' + startTime)

      if( r.clearingMotionBlur ){
        r.clearingMotionBlur = false;
        r.motionBlurCleared = true;
        r.motionBlur = true;
      }

      if( motionBlur ){ 
        r.motionBlurTimeout = setTimeout(function(){
          r.motionBlurTimeout = null;
          // console.log('motion blur clear');

          r.clearedNodeLayerForMotionBlur = false;
          r.motionBlur = false;
          r.clearingMotionBlur = true;

          needDraw[CanvasRenderer.NODE] = true; 
          needDraw[CanvasRenderer.DRAG] = true; 

          r.redraw();
        }, CanvasRenderer.motionBlurDelay);
      }
    } // draw to context

    if( !forcedContext ){
      $$.util.requestAnimationFrame(drawToContext); // makes direct renders to screen a bit more responsive
    } else {
      drawToContext();
    }

    if( !forcedContext && !r.initrender ){
      r.initrender = true;
      cy.trigger('initrender');
    }
    
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  // @O Polygon drawing
  CanvasRenderer.prototype.drawPolygonPath = function(
    context, x, y, width, height, points) {

    var halfW = width / 2;
    var halfH = height / 2;

    if( context.beginPath ){ context.beginPath(); }

    context.moveTo( x + halfW * points[0], y + halfH * points[1] );

    for (var i = 1; i < points.length / 2; i++) {
      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );
    }
    
    context.closePath();
  };
  
  CanvasRenderer.prototype.drawPolygon = function(
    context, x, y, width, height, points) {

    // Draw path
    this.drawPolygonPath(context, x, y, width, height, points);
    
    // Fill path
    context.fill();
  };
  
  // Round rectangle drawing
  CanvasRenderer.prototype.drawRoundRectanglePath = function(
    context, x, y, width, height, radius) {
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
    
    if( context.beginPath ){ context.beginPath(); }
    
    // Start at top middle
    context.moveTo(x, y - halfHeight);
    // Arc from middle top to right side
    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
    // Arc from right side to bottom
    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
    // Arc from bottom to left side
    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
    // Arc from left side to topBorder
    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
    // Join line
    context.lineTo(x, y - halfHeight);
    
    
    context.closePath();
  };
  
  CanvasRenderer.prototype.drawRoundRectangle = function(
    context, x, y, width, height, radius) {
    
    this.drawRoundRectanglePath(context, x, y, width, height, radius);
    
    context.fill();
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  CanvasRenderer.prototype.createBuffer = function(w, h) {
    var buffer = document.createElement('canvas');
    buffer.width = w;
    buffer.height = h;
    
    return [buffer, buffer.getContext('2d')];
  };

  CanvasRenderer.prototype.bufferCanvasImage = function( options ){
    var data = this.data;
    var cy = data.cy;
    var bb = cy.elements().boundingBox();
    var width = options.full ? Math.ceil(bb.w) : this.data.container.clientWidth;
    var height = options.full ? Math.ceil(bb.h) : this.data.container.clientHeight;
    var scale = 1;

    if( options.scale !== undefined ){
      width *= options.scale;
      height *= options.scale;

      scale = options.scale;
    }

    var buffCanvas = document.createElement('canvas');

    buffCanvas.width = width;
    buffCanvas.height = height;

    buffCanvas.style.width = width + 'px';
    buffCanvas.style.height = height + 'px';

    var buffCxt = buffCanvas.getContext('2d');

    // Rasterize the layers, but only if container has nonzero size
    if (width > 0 && height > 0) {

      buffCxt.clearRect( 0, 0, width, height );

      if( options.bg ){
        buffCxt.fillStyle = options.bg;
        buffCxt.rect( 0, 0, width, height );
        buffCxt.fill();
      }

      buffCxt.globalCompositeOperation = 'source-over';

      if( options.full ){ // draw the full bounds of the graph
        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: scale,
          forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },
          forcedPxRatio: 1
        });
      } else { // draw the current view
        var cyPan = cy.pan();
        var pan = {
          x: cyPan.x * scale,
          y: cyPan.y * scale
        };
        var zoom = cy.zoom() * scale;

        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: zoom,
          forcedPan: pan,
          forcedPxRatio: 1
        });
      }
    }

    return buffCanvas;
  }; 

  CanvasRenderer.prototype.png = function( options ){
    return this.bufferCanvasImage( options ).toDataURL('image/png');
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');

  CanvasRenderer.prototype.registerBinding = function(target, event, handler, useCapture){
    this.bindings.push({
      target: target,
      event: event,
      handler: handler,
      useCapture: useCapture
    });

    target.addEventListener(event, handler, useCapture);
  };

  CanvasRenderer.prototype.nodeIsDraggable = function(node) {
    if (node._private.style['opacity'].value !== 0
      && node._private.style['visibility'].value == 'visible'
      && node._private.style['display'].value == 'element'
      && !node.locked()
      && node.grabbable() ) {

      return true;
    }
    
    return false;
  };

  CanvasRenderer.prototype.load = function() {
    var r = this;

    var getDragListIds = function(opts){
      var listHasId;

      if( opts.addToList && r.data.cy.hasCompoundNodes() ){ // only needed for compound graphs
        if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
          opts.addToList.hasId = {};

          for( var i = 0; i < opts.addToList.length; i++ ){
            var ele = opts.addToList[i];

            opts.addToList.hasId[ ele.id() ] = true;
          }
        }

        listHasId = opts.addToList.hasId;
      }

      return listHasId || {};
    };

    // helper function to determine which child nodes and inner edges
    // of a compound node to be dragged as well as the grabbed and selected nodes
    var addDescendantsToDrag = function(node, opts){
      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      var listHasId = getDragListIds( opts );

      var innerNodes = node.descendants();

      // TODO do not drag hidden children & children of hidden children?
      for( var i = 0; i < innerNodes.size(); i++ ){
        var iNode = innerNodes[i];
        var _p = iNode._private;

        if( opts.inDragLayer ){
          _p.rscratch.inDragLayer = true;
        }

        if( opts.addToList && !listHasId[ iNode.id() ] ){
          opts.addToList.push( iNode );
          listHasId[ iNode.id() ] = true;

          _p.grabbed = true; 
        }

        var edges = _p.edges;
        for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){
          edges[j]._private.rscratch.inDragLayer = true;
        }
      }
    };

    // adds the given nodes, and its edges to the drag layer
    var addNodeToDrag = function(node, opts){

      var _p = node._private;
      var listHasId = getDragListIds( opts );

      if( opts.inDragLayer ){
        _p.rscratch.inDragLayer = true;
      }

      if( opts.addToList && !listHasId[ node.id() ] ){
        opts.addToList.push( node );
        listHasId[ node.id() ] = true;

        _p.grabbed = true; 
      }

      var edges = _p.edges;
      for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){
        edges[i]._private.rscratch.inDragLayer = true;
      }

      addDescendantsToDrag( node, opts ); // always add to drag

      // also add nodes and edges related to the topmost ancestor
      updateAncestorsInDragLayer( node, {
        inDragLayer: true
      } );
    };

    // helper function to determine which ancestor nodes and edges should go
    // to the drag layer (or should be removed from drag layer).
    var updateAncestorsInDragLayer = function(node, opts) {
      // find top-level parent
      var parent = node;

      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      while( parent.parent().nonempty() ){
        parent = parent.parent()[0];
      }

      // no parent node: no nodes to add to the drag layer
      if( parent == node ){
        return;
      }

      var nodes = parent
        .descendants()
        .add( parent )
        .not( node )
        .not( node.descendants() )
      ;

      var edges = nodes.connectedEdges();

      var listHasId = getDragListIds( opts );

      for( var i = 0; i < nodes.size(); i++ ){
        if( opts.inDragLayer !== undefined ){
          nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;
        }

        if( opts.addToList && !listHasId[ nodes[i].id() ] ){
          opts.addToList.push( nodes[i] );
          listHasId[ nodes[i].id() ] = true;

          nodes[i]._private.grabbed = true;
        }
      }

      for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {
        edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;
      }
    };

    if( typeof MutationObserver !== 'undefined' ){
      r.removeObserver = new MutationObserver(function( mutns ){
        for( var i = 0; i < mutns.length; i++ ){
          var mutn = mutns[i];
          var rNodes = mutn.removedNodes;

          if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
            var rNode = rNodes[j];

            if( rNode === r.data.container ){
              r.destroy();
              break;
            }
          } }
        }
      });

      r.removeObserver.observe( r.data.container.parentNode, { childList: true } );
    } else {
      r.registerBinding(r.data.container, 'DOMNodeRemoved', function(e){
        r.destroy();
      });
    }



    // auto resize
    r.registerBinding(window, 'resize', $$.util.debounce( function(e) {
      r.invalidateContainerClientCoordsCache();

      r.matchCanvasSize(r.data.container);
      r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
      r.redraw();
    }, 100 ) );

    var invalCtnrBBOnScroll = function(domEle){
      r.registerBinding(domEle, 'scroll', function(e){
        r.invalidateContainerClientCoordsCache();
      } );
    };

    var bbCtnr = r.data.cy.container();

    for( ;; ){
      
      invalCtnrBBOnScroll( bbCtnr );

      if( bbCtnr.parentNode ){
        bbCtnr = bbCtnr.parentNode;
      } else {
        break;
      }
      
    }

    // stop right click menu from appearing on cy
    r.registerBinding(r.data.container, 'contextmenu', function(e){
      e.preventDefault();
    });

    var inBoxSelection = function(){
      return r.data.select[4] !== 0;
    };

    // Primary key
    r.registerBinding(r.data.container, 'mousedown', function(e) { 
      e.preventDefault();
      r.hoverData.capture = true;
      r.hoverData.which = e.which;
      
      var cy = r.data.cy; 
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true);
      var draggedElements = r.dragData.possibleDragElements;

      r.hoverData.mdownPos = pos;

      var checkForTaphold = function(){
        r.hoverData.tapholdCancelled = false;

        clearTimeout( r.hoverData.tapholdTimeout );

        r.hoverData.tapholdTimeout = setTimeout(function(){

          if( r.hoverData.tapholdCancelled ){
            return;
          } else {
            var ele = r.hoverData.down;

            if( ele ){
              ele.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            } else {
              cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            }
          }

        }, r.tapholdDuration);
      };

      // Right click button
      if( e.which == 3 ){

        r.hoverData.cxtStarted = true;

        var cxtEvt = new $$.Event(e, {
          type: 'cxttapstart', 
          cyPosition: { x: pos[0], y: pos[1] } 
        });

        if( near ){
          near.activate();
          near.trigger( cxtEvt );

          r.hoverData.down = near;
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.downTime = (new Date()).getTime();
        r.hoverData.cxtDragged = false;

      // Primary button
      } else if (e.which == 1) {
        
        if( near ){
          near.activate();
        }

        // Element dragging
        {
          // If something is under the cursor and it is draggable, prepare to grab it
          if (near != null) {

            if( r.nodeIsDraggable(near) ){

              var grabEvent = new $$.Event(e, {
                type: 'grab',
                cyPosition: { x: pos[0], y: pos[1] }
              });

              if ( near.isNode() && !near.selected() ){

                draggedElements = r.dragData.possibleDragElements = [];
                addNodeToDrag( near, { addToList: draggedElements } );

                near.trigger(grabEvent);

              } else if ( near.isNode() && near.selected() ){
                draggedElements = r.dragData.possibleDragElements = [  ];

                var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });

                for( var i = 0; i < selectedNodes.length; i++ ){

                  // Only add this selected node to drag if it is draggable, eg. has nonzero opacity
                  if( r.nodeIsDraggable( selectedNodes[i] ) ){
                    addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );
                  }
                }

                near.trigger( grabEvent );
              }

              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
              r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

            }
            
            near
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
            
          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }
          
          r.hoverData.down = near;
          r.hoverData.downTime = (new Date()).getTime();

        }
      
        // Selection box
        if ( near == null || near.isEdge() ) {
          select[4] = 1;
          var timeUntilActive = Math.max( 0, CanvasRenderer.panOrBoxSelectDelay - (+new Date() - r.hoverData.downTime) );

          clearTimeout( r.bgActiveTimeout );

          if( cy.boxSelectionEnabled() || ( near && near.isEdge() ) ){
            r.bgActiveTimeout = setTimeout(function(){
              if( near ){
                near.unactivate();
              }

              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };

              checkForTaphold();

              r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
      
              r.redraw();
            }, timeUntilActive);
          } else {
            r.data.bgActivePosistion = {
              x: pos[0],
              y: pos[1]
            };

            checkForTaphold();

            r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
    
            r.redraw();
          }
          
        }
      
      } 
      
      // Initialize selection box coordinates
      select[0] = select[2] = pos[0];
      select[1] = select[3] = pos[1];
      
    }, false);
    
    r.registerBinding(window, 'mousemove', $$.util.throttle( function(e) {
      var preventDefault = false;
      var capture = r.hoverData.capture;

      // save cycles if mouse events aren't to be captured
      if ( !capture ){
        var containerPageCoords = r.findContainerClientCoords();

        if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth
          && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight
        ) {
          // inside container bounds so OK
        } else {
          return;
        }

        var cyContainer = r.data.container;
        var target = e.target;
        var tParent = target.parentNode;
        var containerIsTarget = false;

        while( tParent ){
          if( tParent === cyContainer ){
            containerIsTarget = true;
            break;
          }

          tParent = tParent.parentNode;
        }

        if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us
      }

      var cy = r.data.cy;
      var zoom = cy.zoom();
      var pan = cy.pan();
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      
      var near = null;
      if( !r.hoverData.draggingEles ){
        near = r.findNearestElement(pos[0], pos[1], true);
      }
      var last = r.hoverData.last;
      var down = r.hoverData.down;
      
      var disp = [pos[0] - select[2], pos[1] - select[3]];

      var draggedElements = r.dragData.possibleDragElements;

      var dx = select[2] - select[0];
      var dx2 = dx * dx;
      var dy = select[3] - select[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      r.hoverData.tapholdCancelled = true;

      var updateDragDelta = function(){
        var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

        if( dragDelta.length === 0 ){
          dragDelta.push(0);
          dragDelta.push(0);
        } else {
          dragDelta[0] += disp[0];
          dragDelta[1] += disp[1];
        }
      };
      

      preventDefault = true;

      // Mousemove event
      {
        if (near != null) {
          near
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;
          
        } else if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;
        }

      }

      // trigger context drag if rmouse down
      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.cxtDragged = true;

        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

          if( r.hoverData.cxtOver ){
            r.hoverData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragout ' + r.hoverData.cxtOver.id());
          }

          r.hoverData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragover ' + near.id());
          }

        }

      // Check if we are drag panning the entire graph
      } else if (r.hoverData.dragging) {
        preventDefault = true;

        if( cy.panningEnabled() && cy.userPanningEnabled() ){
          var deltaP;

          if( r.hoverData.justStartedPan ){
            var mdPos = r.hoverData.mdownPos;

            deltaP = {
              x: ( pos[0] - mdPos[0] ) * zoom,
              y: ( pos[1] - mdPos[1] ) * zoom
            };

            r.hoverData.justStartedPan = false;

          } else {
            deltaP = {
              x: disp[0] * zoom,
              y: disp[1] * zoom
            };

          }

          cy.panBy( deltaP );
          
        }
        
        // Needs reproject due to pan changing viewport
        pos = r.projectIntoViewport(e.clientX, e.clientY);

      // Checks primary button down & out of time & mouse not moved much
      } else if(
          select[4] == 1 && (down == null || down.isEdge())
          && ( !cy.boxSelectionEnabled() || (+new Date() - r.hoverData.downTime >= CanvasRenderer.panOrBoxSelectDelay) )
          //&& (Math.abs(select[3] - select[1]) + Math.abs(select[2] - select[0]) < 4)
          && !r.hoverData.selecting
          && rdist2 >= r.tapThreshold2
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){
        r.hoverData.dragging = true;
        r.hoverData.selecting = false;
        r.hoverData.justStartedPan = true;
        select[4] = 0;

      } else {
        // deactivate bg on box selection
        if (cy.boxSelectionEnabled() && Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]){
          clearTimeout( r.bgActiveTimeout );
          r.data.bgActivePosistion = undefined;
          r.hoverData.selecting = true;

          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          r.redraw();
        }
        
        if( down && down.isEdge() && down.active() ){ down.unactivate(); }

        if (near != last) {
          
          if (last) {
            last.trigger( new $$.Event(e, {
              type: 'mouseout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) ); 

            last.trigger( new $$.Event(e, {
              type: 'tapdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) ); 
          }
          
          if (near) {
            near.trigger( new $$.Event(e, {
              type: 'mouseover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) ); 

            near.trigger( new $$.Event(e, {
              type: 'tapdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) ); 
          }
          
          r.hoverData.last = near;
        }

        if( down && down.isNode() && r.nodeIsDraggable(down) ){

          if( rdist2 >= r.tapThreshold2 ){ // then drag

            var justStartedDrag = !r.dragData.didDrag;

            if( justStartedDrag ) {
              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            for( var i = 0; i < draggedElements.length; i++ ){
              var dEle = draggedElements[i];

              // now, add the elements to the drag layer if not done already
              if( !r.hoverData.draggingEles ){ 
                addNodeToDrag( dEle, { inDragLayer: true } );
              }

              // Locked nodes not draggable, as well as non-visible nodes
              if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){
                var dPos = dEle._private.position;

                toTrigger.push( dEle );
                
                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];

                  if( justStartedDrag ){
                    var dragDelta = r.hoverData.dragDelta;

                    if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }

              }
            }

            r.hoverData.draggingEles = true;
            
            var tcol = (new $$.Collection(cy, toTrigger));

            tcol.updateCompoundBounds();
            tcol.trigger('position drag');
            
            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
            r.redraw();

          } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
            updateDragDelta();
          }
        }

        // prevent the dragging from triggering text selection on the page
        preventDefault = true;
      }
      
      select[2] = pos[0]; select[3] = pos[1];
      
      if( preventDefault ){ 
        if(e.stopPropagation) e.stopPropagation();
          if(e.preventDefault) e.preventDefault();
          return false;
        }
    }, 1000/30, { trailing: true }), false);
    
    r.registerBinding(window, 'mouseup', function(e) {
      // console.log('--\nmouseup', e)

      var capture = r.hoverData.capture;
      if (!capture) { return; }
      r.hoverData.capture = false;
    
      var cy = r.data.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true); 
      var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
      var shiftDown = e.shiftKey;
      
      if( r.data.bgActivePosistion ){
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
        r.redraw();
      }

      r.data.bgActivePosistion = undefined; // not active bg now
      clearTimeout( r.bgActiveTimeout );

      r.hoverData.cxtStarted = false;
      r.hoverData.draggingEles = false;
      r.hoverData.selecting = false;

      if( down ){
        down.unactivate();
      }

      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( !r.hoverData.cxtDragged ){
          var cxtTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: pos[0], y: pos[1] }
          });

          if( down ){
            down.trigger( cxtTap );
          } else {
            cy.trigger( cxtTap );
          }
        }

        r.hoverData.cxtDragged = false;
        r.hoverData.which = null;

      // if not right mouse
      } else {

        // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
        if ( (down == null) // not mousedown on node
          && !r.dragData.didDrag // didn't move the node around
          && !(Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]) // not box selection
          && !r.hoverData.dragging // not panning
        ) {

          cy.$(function(){
            return this.selected();
          }).unselect();
          
          if (draggedElements.length > 0) {
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
          }
          
          r.dragData.possibleDragElements = draggedElements = [];
        }
      
        
        // Mouseup event
        {
          // console.log('trigger mouseup et al');

          if (near != null) {
            near
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }
        }
        
        // Click event
        {
          // console.log('trigger click et al');

          if (Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) === 0) {
            if (near != null) {
              near
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            } else if (near == null) {
              cy
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            }
          }
        }

        // Single selection
        if (near == down && !r.dragData.didDrag) {
          if (near != null && near._private.selectable) {
            
            // console.log('single selection')

            if( r.hoverData.dragging ){
              // if panning, don't change selection state
            } else if( cy.selectionType() === 'additive' || shiftDown ){
              if( near.selected() ){
                near.unselect();
              } else {
                near.select();
              }
            } else {
              if( !shiftDown ){
                cy.$(':selected').not( near ).unselect();
                near.select();
              }               
            }
            
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
            
          }
      
        } 
        
        if ( cy.boxSelectionEnabled() &&  Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4] ) {         
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

          if( box.length > 0 ) { 
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          }

          for( var i = 0; i < box.length; i++ ){ 
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'additive' ){
            newlySelCol.select();
          } else {
            if( !shiftDown ){
              cy.$(':selected').not( newlySelCol ).unselect();
            }

            newlySelCol.select();
          }

          // always need redraw in case eles unselectable
          r.redraw();
          
        }
        
        // Cancel drag pan
        if( r.hoverData.dragging ){
          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          r.redraw();
        }

        r.hoverData.dragging = false;
        
        if (!select[4]) {
          // console.log('free at end', draggedElements)

          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true; 
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          
          for (var i=0; i < draggedElements.length; i++) {
            
            if(draggedElements[i]._private.group === 'nodes') { 
              draggedElements[i]._private.rscratch.inDragLayer = false;
              draggedElements[i]._private.grabbed = false;
              
              var sEdges = draggedElements[i]._private.edges;
              for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }

              // for compound nodes, also remove related nodes and edges from the drag layer
              updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });
              
            } else if( draggedElements[i]._private.group === 'edges' ){
              draggedElements[i]._private.rscratch.inDragLayer = false;
            }
            
          }

          if( down ){ down.trigger('free'); }

  //        draggedElements = r.dragData.possibleDragElements = [];
          
        }
      
      } // else not right mouse

      select[4] = 0; r.hoverData.down = null;
      
      //r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true; 
      
//      console.log('mu', pos[0], pos[1]);
//      console.log('ss', select);
      
      r.dragData.didDrag = false;
      r.hoverData.dragDelta = [];
      
    }, false);

    var wheelHandler = function(e) { 
      if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

      var cy = r.data.cy;
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var rpos = [pos[0] * cy.zoom() + cy.pan().x,
                    pos[1] * cy.zoom() + cy.pan().y];
      
      if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
        e.preventDefault();
        return;
      }

      if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
        e.preventDefault();
        
        r.data.wheelZooming = true;
        clearTimeout( r.data.wheelTimeout );
        r.data.wheelTimeout = setTimeout(function(){
          r.data.wheelZooming = false;

          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          r.redraw();
        }, 150);

        var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;
        diff = diff * r.wheelSensitivity;

        var needsWheelFix = e.deltaMode === 1;
        if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
          diff *= 33;
        }

        cy.zoom({
          level: cy.zoom() * Math.pow(10, diff),
          renderedPosition: { x: rpos[0], y: rpos[1] }
        });
      }

    };
    
    // Functions to help with whether mouse wheel should trigger zooming
    // --
    r.registerBinding(r.data.container, 'wheel', wheelHandler, true);

    // disable nonstandard wheel events
    // r.registerBinding(r.data.container, 'mousewheel', wheelHandler, true);
    // r.registerBinding(r.data.container, 'DOMMouseScroll', wheelHandler, true);
    // r.registerBinding(r.data.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

    r.registerBinding(window, 'scroll', function(e){
      r.scrollingPage = true;

      clearTimeout( r.scrollingPageTimeout );
      r.scrollingPageTimeout = setTimeout(function(){
        r.scrollingPage = false;
      }, 250);
    }, true);
    
    // Functions to help with handling mouseout/mouseover on the Cytoscape container
          // Handle mouseout on Cytoscape container
    r.registerBinding(r.data.container, 'mouseout', function(e) { 
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseout',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);
    
    r.registerBinding(r.data.container, 'mouseover', function(e) { 
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseover',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);
    
    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
    var center1, modelCenter1; // center point on start pinch to zoom
    var offsetLeft, offsetTop;
    var containerWidth, containerHeight;
    var twoFingersStartInside;

    var distance = function(x1, y1, x2, y2){
      return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
    };

    var distanceSq = function(x1, y1, x2, y2){
      return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
    };

    r.registerBinding(r.data.container, 'touchstart', function(e) {

      clearTimeout( this.threeFingerSelectTimeout );

      if( e.target !== r.data.link ){
        e.preventDefault();
      }
    
      r.touchData.capture = true;
      r.data.bgActivePosistion = undefined;

      var cy = r.data.cy; 
      var nodes = r.getCachedNodes();
      var edges = r.getCachedEdges();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;
      
      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
    

      // record starting points for pinch-to-zoom
      if( e.touches[1] ){

        // anything in the set of dragged eles should be released
        var release = function( eles ){
          for( var i = 0; i < eles.length; i++ ){
            eles[i]._private.grabbed = false;
            eles[i]._private.rscratch.inDragLayer = false;
            if( eles[i].active() ){ eles[i].unactivate(); }
          }
        };
        release(nodes);
        release(edges);

        var offsets = r.findContainerClientCoords();
        offsetLeft = offsets[0];
        offsetTop = offsets[1];
        containerWidth = offsets[2];
        containerHeight = offsets[3];

        f1x1 = e.touches[0].clientX - offsetLeft;
        f1y1 = e.touches[0].clientY - offsetTop;
        
        f2x1 = e.touches[1].clientX - offsetLeft;
        f2y1 = e.touches[1].clientY - offsetTop;

        twoFingersStartInside = 
             0 <= f1x1 && f1x1 <= containerWidth
          && 0 <= f2x1 && f2x1 <= containerWidth
          && 0 <= f1y1 && f1y1 <= containerHeight
          && 0 <= f2y1 && f2y1 <= containerHeight
        ;

        var pan = cy.pan();
        var zoom = cy.zoom();

        distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
        distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
        center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];
        modelCenter1 = [ 
          (center1[0] - pan.x) / zoom,
          (center1[1] - pan.y) / zoom
        ];

        // consider context tap
        var cxtDistThreshold = 200;
        var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
        if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

          var near1 = r.findNearestElement(now[0], now[1], true);
          var near2 = r.findNearestElement(now[2], now[3], true);

          //console.log(distance1)

          if( near1 && near1.isNode() ){
            near1.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near1;
          
          } else if( near2 && near2.isNode() ){
            near2.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near2;
          
          } else {
            cy.trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = null;
          } 

          if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
          r.touchData.cxt = true;
          r.touchData.cxtDragged = false;
          r.data.bgActivePosistion = undefined;

          //console.log('cxttapstart')

          r.redraw();
          return;
          
        }

        // console.log(center1);
        // console.log('touchstart ptz');
        // console.log(offsetLeft, offsetTop);
        // console.log(f1x1, f1y1);
        // console.log(f2x1, f2y1);
        // console.log(distance1);
        // console.log(center1);
      }

      // console.log('another tapstart')
      
      
      if (e.touches[2]) {
      
      } else if (e.touches[1]) {
        
      } else if (e.touches[0]) {
        var near = r.findNearestElement(now[0], now[1], true);

        if (near != null) {
          near.activate();

          r.touchData.start = near;
          
          if( near.isNode() && r.nodeIsDraggable(near) ){

            var draggedEles = r.dragData.touchDragEles = [];
            
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

            if( near.selected() ){
              // reset drag elements, since near will be added again

              var selectedNodes = cy.$(function(){
                return this.isNode() && this.selected();
              });

              for( var k = 0; k < selectedNodes.length; k++ ){
                var selectedNode = selectedNodes[k];

                if( r.nodeIsDraggable(selectedNode) ){
                  addNodeToDrag( selectedNode, { addToList: draggedEles } );
                }
              }
            } else {
              addNodeToDrag( near, { addToList: draggedEles } );
            }

            near.trigger( new $$.Event(e, {
              type: 'grab',
              cyPosition: { x: now[0], y: now[1] }
            }) );
          }
          
          near
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousdown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;
        } if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousedown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;

          r.data.bgActivePosistion = {
            x: pos[0],
            y: pos[1]
          };

          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          r.redraw();
        }
        
        
        // Tap, taphold
        // -----
        
        for (var i=0; i<now.length; i++) {
          earlier[i] = now[i];
          r.touchData.startPosition[i] = now[i];
        }
        
        r.touchData.singleTouchMoved = false;
        r.touchData.singleTouchStartTime = +new Date();
        
        clearTimeout( r.touchData.tapholdTimeout );
        r.touchData.tapholdTimeout = setTimeout(function() {
          if(
              r.touchData.singleTouchMoved === false
              && !r.pinching // if pinching, then taphold unselect shouldn't take effect

              // This time double constraint prevents multiple quick taps
              // followed by a taphold triggering multiple taphold events
              //&& Date.now() - r.touchData.singleTouchStartTime > 250
          ){
            if (r.touchData.start) {
              r.touchData.start.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            } else {
              r.data.cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.$(':selected').unselect();
            }

//            console.log('taphold');
          }
        }, r.tapholdDuration);
      }
      
      //r.redraw();
      
    }, false);
    
// console.log = function(m){ $('#console').append('<div>'+m+'</div>'); };

    r.registerBinding(window, 'touchmove', $$.util.throttle(function(e) {
    
      var select = r.data.select;
      var capture = r.touchData.capture; //if (!capture) { return; }; 
      if( capture ){ e.preventDefault(); }
    
      var cy = r.data.cy; 
      var now = r.touchData.now; var earlier = r.touchData.earlier;
      var zoom = cy.zoom();
      
      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }
      
      var startPos = r.touchData.startPosition;

      var dx = now[0] - startPos[0];
      var dx2 = dx * dx;
      var dy = now[1] - startPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      if( capture && r.touchData.cxt ){
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
        // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        var factorSq = distance2Sq / distance1Sq;

        var distThreshold = 150;
        var distThresholdSq = distThreshold * distThreshold;
        var factorThreshold = 1.5;
        var factorThresholdSq = factorThreshold * factorThreshold;

        //console.log(factor, distance2)

        // cancel ctx gestures if the distance b/t the fingers increases
        if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
          r.touchData.cxt = false;
          if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }
          r.data.bgActivePosistion = undefined;
          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

          var cxtEvt = new $$.Event(e, {
            type: 'cxttapend',
            cyPosition: { x: now[0], y: now[1] }
          });
          if( r.touchData.start ){
            r.touchData.start.trigger( cxtEvt );
          } else {
            cy.trigger( cxtEvt );
          }
        }

      }  

      if( capture && r.touchData.cxt ){ 
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: now[0], y: now[1] }
        });
        r.data.bgActivePosistion = undefined;
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

        if( r.touchData.start ){
          r.touchData.start.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxtDragged = true;

        //console.log('cxtdrag')

        var near = r.findNearestElement(now[0], now[1], true);

        if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

          if( r.touchData.cxtOver ){
            r.touchData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragout');
          }

          r.touchData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragover');
          }

        }

      } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){ 
        r.data.bgActivePosistion = undefined;
        clearTimeout( this.threeFingerSelectTimeout );
        this.lastThreeTouch = +new Date();

        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

        if( !select || select.length === 0 || select[0] === undefined ){
          select[0] = (now[0] + now[2] + now[4])/3;
          select[1] = (now[1] + now[3] + now[5])/3;
          select[2] = (now[0] + now[2] + now[4])/3 + 1;
          select[3] = (now[1] + now[3] + now[5])/3 + 1;
        } else {
          select[2] = (now[0] + now[2] + now[4])/3;
          select[3] = (now[1] + now[3] + now[5])/3;
        }

        select[4] = 1;

        r.redraw();

      } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom
        r.data.bgActivePosistion = undefined;
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

        var draggedEles = r.dragData.touchDragEles;
        if( draggedEles ){ 
          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

          for( var i = 0; i < draggedEles.length; i++ ){
            draggedEles[i]._private.grabbed = false;
            draggedEles[i]._private.rscratch.inDragLayer = false;
          }
        }

        // console.log('touchmove ptz');

        // (x2, y2) for fingers 1 and 2
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;

        // console.log( f1x2, f1y2 )
        // console.log( f2x2, f2y2 )

        var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
        var factor = distance2 / distance1;

        // console.log(distance2)
        // console.log(factor)

        if( factor != 1 && twoFingersStartInside){

          // console.log(factor)
          // console.log(distance2 + ' / ' + distance1);
          // console.log('--');

          // delta finger1
          var df1x = f1x2 - f1x1;
          var df1y = f1y2 - f1y1;

          // delta finger 2
          var df2x = f2x2 - f2x1;
          var df2y = f2y2 - f2y1;

          // translation is the normalised vector of the two fingers movement
          // i.e. so pinching cancels out and moving together pans
          var tx = (df1x + df2x)/2;
          var ty = (df1y + df2y)/2;

          // adjust factor by the speed multiplier
          // var speed = 1.5;
          // if( factor > 1 ){
          //   factor = (factor - 1) * speed + 1;
          // } else {
          //   factor = 1 - (1 - factor) * speed;
          // }

          // now calculate the zoom
          var zoom1 = cy.zoom();
          var zoom2 = zoom1 * factor;
          var pan1 = cy.pan();

          // the model center point converted to the current rendered pos
          var ctrx = modelCenter1[0] * zoom1 + pan1.x;
          var ctry = modelCenter1[1] * zoom1 + pan1.y;

          var pan2 = {
            x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,
            y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry
          };

          // console.log(pan2);
          // console.log(zoom2);

          // remove dragged eles
          if( r.touchData.start ){
            var draggedEles = r.dragData.touchDragEles;

            if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){
              draggedEles[i]._private.grabbed = false;
              draggedEles[i]._private.rscratch.inDragLayer = false;
            } }

            r.touchData.start._private.active = false;
            r.touchData.start._private.grabbed = false;
            r.touchData.start._private.rscratch.inDragLayer = false;

            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

            r.touchData.start
              .trigger('free')
              .trigger('unactivate')
            ;
          }

          cy.viewport({
            zoom: zoom2,
            pan: pan2,
            cancelOnFailedZoom: true
          });

          distance1 = distance2;  
          f1x1 = f1x2;
          f1y1 = f1y2;
          f2x1 = f2x2;
          f2y1 = f2y2;

          r.pinching = true;
        }
        
        // Re-project
        if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
        if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
        if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

      } else if (e.touches[0]) {
        var start = r.touchData.start;
        var last = r.touchData.last;
        var near = near || r.findNearestElement(now[0], now[1], true);

        if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){

          if( rdist2 >= r.tapThreshold2 ){ // then dragging can happen
            var draggedEles = r.dragData.touchDragEles;

            for( var k = 0; k < draggedEles.length; k++ ){
              var draggedEle = draggedEles[k];

              if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){
                r.dragData.didDrag = true;
                var dPos = draggedEle._private.position;
                var justStartedDrag = !r.hoverData.draggingEles;

                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];
                }

                if( justStartedDrag ){
                  addNodeToDrag( draggedEle, { inDragLayer: true } );

                  var dragDelta = r.touchData.dragDelta;

                  if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                    dPos.x += dragDelta[0];
                    dPos.y += dragDelta[1];
                  }

                }
              }
            }

            var tcol = new $$.Collection(cy, draggedEle);
            
            tcol.updateCompoundBounds();
            tcol.trigger('position drag');

            r.hoverData.draggingEles = true;
            
            r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

            if( 
                 r.touchData.startPosition[0] == earlier[0]
              && r.touchData.startPosition[1] == earlier[1]
            ){
              
              r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
            }
            
            r.redraw();
          } else { // otherise keep track of drag delta for later
            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

            if( dragDelta.length === 0 ){
              dragDelta.push(0);
              dragDelta.push(0);
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          }
        }
        
        // Touchmove event
        {

          if (start != null) {
            start.trigger( new $$.Event(e, {
              type: 'touchmove',
              cyPosition: { x: now[0], y: now[1] }
            }) ); 

            start.trigger( new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: now[0], y: now[1] }
            }) ); 

            start.trigger( new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: now[0], y: now[1] }
            }) ); 
          }
          
          if (start == null) { 

            if (near != null) { 
              near.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) ); 

              near.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              near.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            }

            if (near == null) { 
              cy.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) ); 

              cy.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) ); 

              cy.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) ); 
            }
          }

          if (near != last) {
            if (last) { last.trigger(new $$.Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }
            if (near) { near.trigger(new $$.Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }
          }

          r.touchData.last = near;
        }
        
        // Check to cancel taphold
        for (var i=0;i<now.length;i++) {
          if (now[i] 
            && r.touchData.startPosition[i]
            && Math.abs(now[i] - r.touchData.startPosition[i]) > 4) {
            
            r.touchData.singleTouchMoved = true;
          }
        }
        
        if(
            capture
            && ( start == null || start.isEdge() )
            && cy.panningEnabled() && cy.userPanningEnabled()
        ){

          if( r.swipePanning ){
            cy.panBy({
              x: disp[0] * zoom,
              y: disp[1] * zoom
            });

          } else if( rdist2 >= r.tapThreshold2 ){
            r.swipePanning = true;

            cy.panBy({
              x: dx * zoom,
              y: dy * zoom
            });
          }

          if( start ){
            start.unactivate();

            if( !r.data.bgActivePosistion ){
              r.data.bgActivePosistion = {
                x: now[0],
                y: now[1]
              };
            }

            r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

            r.touchData.start = null;
          }
          
          // Re-project
          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0]; now[1] = pos[1];
        }
      }

      for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }
      //r.redraw();
      
    }, 1000/30, { trailing: true }), false);
    
    r.registerBinding(window, 'touchcancel', function(e) {
      var start = r.touchData.start;

      r.touchData.capture = false;

      if( start ){
        start.unactivate();
      }
    });

    r.registerBinding(window, 'touchend', function(e) {
      var start = r.touchData.start;

      var capture = r.touchData.capture; 

      if( capture ){
        r.touchData.capture = false;
      } else {
        return;
      }
      
      e.preventDefault();
      var select = r.data.select;

      r.swipePanning = false;
      r.hoverData.draggingEles = false;
      
      var cy = r.data.cy; 
      var zoom = cy.zoom();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
      
      if( start ){
        start.unactivate();
      }

      var ctxTapend;
      if( r.touchData.cxt ){
        ctxTapend = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: now[0], y: now[1] }
        });

        if( start ){
          start.trigger( ctxTapend );
        } else {
          cy.trigger( ctxTapend );
        }

        //console.log('cxttapend')

        if( !r.touchData.cxtDragged ){
          var ctxTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: now[0], y: now[1] }
          });

          if( start ){
            start.trigger( ctxTap );
          } else {
            cy.trigger( ctxTap );
          }

          //console.log('cxttap')
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = false;
        r.touchData.start = null;

        r.redraw();
        return;
      }

      // no more box selection if we don't have three fingers
      if( !e.touches[2] && cy.boxSelectionEnabled() ){
        clearTimeout( this.threeFingerSelectTimeout );
        //this.threeFingerSelectTimeout = setTimeout(function(){
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          select[0] = undefined;
          select[1] = undefined;
          select[2] = undefined;
          select[3] = undefined;
          select[4] = 0;

          r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

          // console.log(box);
          for( var i = 0; i< box.length; i++ ) { 
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').not( newlySelCol ).unselect();
          }

          newlySelCol.select();
          
          if( newlySelCol.length > 0 ) { 
            r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          } else {
            r.redraw();
          }

        //}, 100);
      }

      var updateStartStyle = false;

      if( start != null ){
        start._private.active = false;
        updateStartStyle = true;
        start.unactivate();
      }

      if (e.touches[2]) {
        r.data.bgActivePosistion = undefined;
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
      } else if (e.touches[1]) {
        
      } else if (e.touches[0]) {
      
      // Last touch released
      } else if (!e.touches[0]) {
        
        r.data.bgActivePosistion = undefined;
        r.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;

        if (start != null ) {

          if( start._private.grabbed ){
            start._private.grabbed = false;
            start.trigger('free');
            start._private.rscratch.inDragLayer = false;
          }
          
          var sEdges = start._private.edges;
          for (var j=0;j<sEdges.length;j++) { sEdges[j]._private.rscratch.inDragLayer = false; }
          updateAncestorsInDragLayer(start, false);
          
          if( start.selected() ){
            var selectedNodes = cy.$('node:selected');

            for( var k = 0; k < selectedNodes.length; k++ ){

              var selectedNode = selectedNodes[k];
              selectedNode._private.rscratch.inDragLayer = false;
              selectedNode._private.grabbed = false;

              var sEdges = selectedNode._private.edges;
              for (var j=0; j<sEdges.length; j++) {
                sEdges[j]._private.rscratch.inDragLayer = false;
              }

              updateAncestorsInDragLayer(selectedNode, false);
            }
          }

          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true; 
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
          
          start
            .trigger(new $$.Event(e, {
              type: 'touchend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmouseup',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;
          
          start.unactivate();

          r.touchData.start = null;
          
        } else {
          var near = r.findNearestElement(now[0], now[1], true);
        
          if (near != null) { 
            near
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }

          if (near == null) { 
            cy
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }
        }

        var dx = r.touchData.startPosition[0] - now[0];
        var dx2 = dx * dx;
        var dy = r.touchData.startPosition[1] - now[1];
        var dy2 = dy * dy;
        var dist2 = dx2 + dy2;
        var rdist2 = dist2 * zoom * zoom;
        
        // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
        if (start != null 
            && !r.dragData.didDrag // didn't drag nodes around
            && start._private.selectable 
            && rdist2 < r.tapThreshold2
            && !r.pinching // pinch to zoom should not affect selection
        ) {

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').not( start ).unselect();
            start.select();
          } else {
            if( start.selected() ){
              start.unselect();
            } else {
              start.select();
            }
          }

          updateStartStyle = true;

          
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
        }
        
        // Tap event, roughly same as mouse click event for touch
        if ( r.touchData.singleTouchMoved === false ) {

          if (start) {
            start
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          } else {
            cy
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }
          
//          console.log('tap');
        }
        
        r.touchData.singleTouchMoved = true;
      }
      
      for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }

      r.dragData.didDrag = false; // reset for next mousedown

      if( e.touches[0] ){
        r.touchData.dragDelta = [];
      }

      if( updateStartStyle && start ){
        start.updateStyle(false);
      }

      if( e.touches.length < 2 ){
        r.pinching = false;
        r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true; 
        r.redraw();
      }

      //r.redraw();
      
    }, false);
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var renderer = CanvasRenderer.prototype;
  var usePaths = CanvasRenderer.usePaths();

  // Node shape contract:
  //
  // draw: draw
  // intersectLine: report intersection from x, y, to node center
  // checkPoint: check x, y in node

  var nodeShapes = CanvasRenderer.nodeShapes = {};

  var sin0 = Math.sin(0);
  var cos0 = Math.cos(0);

  var sin = {};
  var cos = {};

  var ellipseStepSize = 0.1;

  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
    sin[i] = Math.sin(i);
    cos[i] = Math.cos(i);
  }

  nodeShapes['ellipse'] = {
    draw: function(context, centerX, centerY, width, height) {
      nodeShapes['ellipse'].drawPath(context, centerX, centerY, width, height);
      context.fill();
      
//      console.log('drawing ellipse');
//      console.log(arguments);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      
      if( usePaths ){
        if( context.beginPath ){ context.beginPath(); }

        var xPos, yPos;
        var rw = width/2;
        var rh = height/2;
        for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
            xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;
            yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;

            if (i === 0) {
                context.moveTo(xPos, yPos);
            } else {
                context.lineTo(xPos, yPos);
            }
        }
        context.closePath();

      } else {

        if( context.beginPath ){ context.beginPath(); }
        context.translate(centerX, centerY);
        context.scale(width / 2, height / 2);
        // At origin, radius 1, 0 to 2pi
        context.arc(0, 0, 1, 0, Math.PI * 2 * 0.999, false); // *0.999 b/c chrome rendering bug on full circle
        context.closePath();

        context.scale(2/width, 2/height);
        context.translate(-centerX, -centerY);

      }
      
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      var intersect = $$.math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding);
      
      return intersect;
    },
    
    intersectBox: function(
      x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      return $$.math.boxIntersectEllipse(
        x1, y1, x2, y2, padding, width, height, centerX, centerY);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
//      console.log(arguments);
      
      x -= centerX;
      y -= centerY;
      
      x /= (width / 2 + padding);
      y /= (height / 2 + padding);
      
      return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
    }
  };
  
  nodeShapes['triangle'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(3, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['triangle'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['triangle'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.polygonIntersectLine(
        x, y,
        nodeShapes['triangle'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    
      /*
      polygonIntersectLine(x, y, basePoints, centerX, centerY, 
        width, height, padding);
      */
      
      
      /*
      return renderer.polygonIntersectLine(
        node, width, height,
        x, y, nodeShapes['triangle'].points);
      */
    },
    
    intersectBox: function(
      x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['triangle'].points;
      
      return $$.math.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(
        x, y, nodeShapes['triangle'].points,
        centerX, centerY, width, height,
        [0, -1], padding);
    }
  };
  
  nodeShapes['square'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['square'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['square'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.polygonIntersectLine(
          x, y,
          nodeShapes['square'].points,
          nodeX,
          nodeY,
          width / 2, height / 2,
          padding);
    },
    
    intersectBox: function(
      x1, y1, x2, y2,
      width, height, centerX, 
      centerY, padding) {
      
      var points = nodeShapes['square'].points;
      
      return $$.math.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, 
        centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['square'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  nodeShapes['rectangle'] = nodeShapes['square'];
  
  nodeShapes['octogon'] = {};
  
  nodeShapes['roundrectangle'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectangle(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectanglePath(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.roundRectangleIntersectLine(
          x, y,
          nodeX,
          nodeY,
          width, height,
          padding);
    },
    
    intersectBox: function(
      x1, y1, x2, y2,
      width, height, centerX, 
      centerY, padding) {

      return $$.math.roundRectangleIntersectBox(
        x1, y1, x2, y2, 
        width, height, centerX, centerY, padding);
    },
    
    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
      
      // Check hBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding)) {
        return true;
      }
      
      // Check vBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding)) {
        return true;
      }
      
      var checkInEllipse = function(x, y, centerX, centerY, width, height, padding) {
        x -= centerX;
        y -= centerY;
        
        x /= (width / 2 + padding);
        y /= (height / 2 + padding);
        
        return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
      };
      
      
      // Check top left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      /*
      if (renderer.boxIntersectEllipse(x, y, x, y, padding, 
        cornerRadius * 2, cornerRadius * 2,
        centerX - width + cornerRadius,
        centerY - height + cornerRadius)) {
        return true;
      }
      */
      
      // Check top right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      return false;
    }
  };
  
  nodeShapes['pentagon'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(5, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height, nodeShapes['pentagon'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height, nodeShapes['pentagon'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return renderer.polygonIntersectLine(
        x, y,
        nodeShapes['pentagon'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
      x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['pentagon'].points;
      
      return $$.math.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['pentagon'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  nodeShapes['hexagon'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(6, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['hexagon'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['hexagon'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.polygonIntersectLine(
        x, y,
        nodeShapes['hexagon'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
        x1, y1, x2, y2, width, height, centerX, centerY, padding) {
        
      var points = nodeShapes['hexagon'].points;
      
      return $$.math.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['hexagon'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  nodeShapes['heptagon'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(7, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['heptagon'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['heptagon'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return renderer.polygonIntersectLine(
        x, y,
        nodeShapes['heptagon'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
        x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['heptagon'].points;
      
      return renderer.boxIntersectPolygon(
        x1, y1, x2, y2,
        points, width, height, centerX, centerY, [0, -1], padding);
    },

    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['heptagon'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  nodeShapes['octagon'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(8, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['octagon'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['octagon'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return renderer.polygonIntersectLine(
        x, y,
        nodeShapes['octagon'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
        x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['octagon'].points;
      
      return renderer.boxIntersectPolygon(
          x1, y1, x2, y2,
          points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['octagon'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };
  
  var star5Points = new Array(20);
  {
    var outerPoints = $$.math.generateUnitNgonPoints(5, 0);
    var innerPoints = $$.math.generateUnitNgonPoints(5, Math.PI / 5);
    
//    console.log(outerPoints);
//    console.log(innerPoints);
    
    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;
    
    for (var i=0;i<innerPoints.length/2;i++) {
      innerPoints[i*2] *= innerRadius;
      innerPoints[i*2+1] *= innerRadius;
    }
    
    for (var i=0;i<20/4;i++) {
      star5Points[i*4] = outerPoints[i*2];
      star5Points[i*4+1] = outerPoints[i*2+1];
      
      star5Points[i*4+2] = innerPoints[i*2];
      star5Points[i*4+3] = innerPoints[i*2+1];
    }
    
//    console.log(star5Points);
  }

  star5Points = $$.math.fitPolygonToSquare( star5Points );
  
  nodeShapes['star5'] = nodeShapes['star'] = {
    points: star5Points,
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawPolygon(context,
        centerX, centerY,
        width, height,
        nodeShapes['star5'].points);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawPolygonPath(context,
        centerX, centerY,
        width, height,
        nodeShapes['star5'].points);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return renderer.polygonIntersectLine(
        x, y,
        nodeShapes['star5'].points,
        nodeX,
        nodeY,
        width / 2, height / 2,
        padding);
    },
    
    intersectBox: function(
        x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      var points = nodeShapes['star5'].points;
      
      return renderer.boxIntersectPolygon(
          x1, y1, x2, y2,
          points, width, height, centerX, centerY, [0, -1], padding);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      return $$.math.pointInsidePolygon(x, y, nodeShapes['star5'].points,
        centerX, centerY, width, height, [0, -1], padding);
    }
  };

})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout

    // callbacks on layout events
    ready: undefined, // callback on layoutready 
    stop: undefined, // callback on layoutstop

    // forces used by arbor (use arbor default on undefined)
    repulsion: undefined,
    stiffness: undefined,
    friction: undefined,
    gravity: true,
    fps: undefined,
    precision: undefined,

    // static numbers or functions that dynamically return what these
    // values should be for each element
    // e.g. nodeMass: function(n){ return n.data('weight') }
    nodeMass: undefined, 
    edgeLength: undefined,

    stepSize: 0.1, // smoothing of arbor bounding box

    // function that returns true if the system is stable to indicate
    // that the layout can be stopped
    stableEnergy: function( energy ){
      var e = energy; 
      return (e.max <= 0.5) || (e.mean <= 0.3);
    },

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };
  
  function ArborLayout(options){
    this._private = {};

    this._private.options = $$.util.extend({}, defaults, options);
  }
    
  ArborLayout.prototype.run = function(){
    var layout = this;
    var options = this._private.options;

    $$.util.require('arbor', function(arbor){

      var cy = options.cy;
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      var simUpdatingPos = false;

      layout.trigger({ type: 'layoutstart', layout: layout });

      // backward compatibility for old animation option
      if( options.liveUpdate !== undefined ){
        options.animate = options.liveUpdate;
      }

      // arbor doesn't work with just 1 node 
      if( cy.nodes().size() <= 1 ){
        if( options.fit ){
          cy.reset();
        }

        cy.nodes().position({
          x: Math.round( (bb.x1 + bb.x2)/2 ),
          y: Math.round( (bb.y1 + bb.y2)/2 )
        });

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        return;
      }

      var sys = layout._private.system = arbor.ParticleSystem();

      sys.parameters({
        repulsion: options.repulsion,
        stiffness: options.stiffness, 
        friction: options.friction, 
        gravity: options.gravity, 
        fps: options.fps, 
        dt: options.dt, 
        precision: options.precision
      });

      if( options.animate && options.fit ){
        cy.fit( bb, options.padding );
      }
      
      var doneTime = 250;
      var doneTimeout;
      
      var ready = false;
      
      var lastDraw = +new Date();
      var sysRenderer = {
        init: function(system){
        },
        redraw: function(){
          var energy = sys.energy();

          // if we're stable (according to the client), we're done
          if( !options.infinite && options.stableEnergy != null && energy != null && energy.n > 0 && options.stableEnergy(energy) ){
            layout.stop();
            return;
          }

          if( !options.infinite && doneTime != Infinity ){
            clearTimeout(doneTimeout);
            doneTimeout = setTimeout(doneHandler, doneTime);
          }
          
          var movedNodes = cy.collection();
          
          sys.eachNode(function(n, point){ 
            var data = n.data;
            var node = data.element;
            
            if( node == null ){
              return;
            }

            if( !node.locked() && !node.grabbed() ){
              node.silentPosition({
                x: bb.x1 + point.x,
                y: bb.y1 + point.y
              });

              movedNodes.merge( node );
            }
          });
          

          if( options.animate && movedNodes.length > 0 ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            lastDraw = +new Date();
            simUpdatingPos = false;
          }

          
          if( !ready ){
            ready = true;
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          }
        }
        
      };
      sys.renderer = sysRenderer;
      sys.screenSize( bb.w, bb.h );
      sys.screenPadding( options.padding, options.padding, options.padding, options.padding );
      sys.screenStep( options.stepSize );

      function calculateValueForElement(element, value){
        if( value == null ){
          return undefined;
        } else if( typeof value == typeof function(){} ){
          return value.apply(element, [element._private.data, {
            nodes: nodes.length,
            edges: edges.length,
            element: element
          }]); 
        } else {
          return value;
        }
      }

      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        if( simUpdatingPos ){ return; }

        var pos = this.position();
        var apos = sys.fromScreen( pos );
        if( !apos ){ return; }

        var p = arbor.Point(apos.x, apos.y);
        var padding = options.padding;

        if(
          bb.x1 + padding <= pos.x && pos.x <= bb.x2 - padding &&
          bb.y1 + padding <= pos.y && pos.y <= bb.y2 - padding
        ){
          this.scratch().arbor.p = p;
        }
        
        switch( e.type ){
        case 'grab':
          this.scratch().arbor.fixed = true;
          break;
        case 'free':
          this.scratch().arbor.fixed = false;
          //this.scratch().arbor.tempMass = 1000;
          break;
        }
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        node.scratch().arbor.fixed = node.locked();
      });
            
      var removeHandler;
      eles.on('remove', removeHandler = function(e){ return; // TODO enable when layout add/remove api added
        // var ele = this;
        // var arborEle = ele.scratch().arbor;

        // if( !arborEle ){ return; }

        // if( ele.isNode() ){
        //   sys.pruneNode( arborEle );
        // } else {
        //   sys.pruneEdge( arborEle );
        // }
      });

      var addHandler;
      cy.on('add', '*', addHandler = function(){ return; // TODO enable when layout add/remove api added
        // var ele = this;

        // if( ele.isNode() ){
        //   addNode( ele );
        // } else {
        //   addEdge( ele );
        // }
      });

      var resizeHandler;
      cy.on('resize', resizeHandler = function(){
        if( options.boundingBox == null && layout._private.system != null ){
          var w = cy.width();
          var h = cy.height();

          sys.screenSize( w, h );
        }
      });

      function addNode( node ){
        if( node.isFullAutoParent() ){ return; } // they don't exist in the sim

        var id = node._private.data.id;
        var mass = calculateValueForElement(node, options.nodeMass);
        var locked = node._private.locked;
        var nPos = node.position();
        
        var pos = sys.fromScreen({
          x: nPos.x,
          y: nPos.y
        });

        node.scratch().arbor = sys.addNode(id, {
          element: node,
          mass: mass,
          fixed: locked,
          x: locked ? pos.x : undefined,
          y: locked ? pos.y : undefined
        });
      }

      function addEdge( edge ){
        var src = edge.source().id();
        var tgt = edge.target().id();
        var length = calculateValueForElement(edge, options.edgeLength);
        
        edge.scratch().arbor = sys.addEdge(src, tgt, {
          length: length
        }); 
      }

      nodes.each(function(i, node){
        addNode( node );
      });
      
      edges.each(function(i, edge){
        addEdge( edge );
      });
      
      var grabbableNodes = nodes.filter(":grabbable");
      // disable grabbing if so set
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }
      
      var doneHandler = layout._private.doneHandler = function(){
        layout._private.doneHandler = null;

        if( !options.animate ){
          if( options.fit ){
            cy.reset();
          }

          nodes.rtrigger('position');
        }

        // unbind handlers
        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);
        eles.off('remove', removeHandler);
        cy.off('add', '*', addHandler);
        cy.off('resize', resizeHandler);
        
        // enable back grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };
      
      sys.start();
      if( !options.infinite && options.maxSimulationTime != null && options.maxSimulationTime > 0 && options.maxSimulationTime !== Infinity ){
        setTimeout(function(){
          layout.stop();
        }, options.maxSimulationTime);
      }
    
    }); // require

    return this; // chaining
  };


  ArborLayout.prototype.stop = function(){
    if( this._private.system != null ){
      this._private.system.stop();
    }

    if( this._private.doneHandler ){
      this._private.doneHandler();
    }

    return this; // chaining
  };
  
  $$('layout', 'arbor', ArborLayout);
  
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
    padding: 30, // padding on fit
    circle: false, // put depths in concentric circles if true, put depths top down if false
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    roots: undefined, // the roots of the trees
    maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function BreadthFirstLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  BreadthFirstLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    var graph = eles;
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var roots;
    if( $$.is.elementOrCollection(options.roots) ){
      roots = options.roots;
    } else if( $$.is.array(options.roots) ){
      var rootsArray = [];

      for( var i = 0; i < options.roots.length; i++ ){
        var id = options.roots[i];
        var ele = cy.getElementById( id );
        rootsArray.push( ele );
      }

      roots = new $$.Collection( cy, rootsArray );
    } else if( $$.is.string(options.roots) ){
      roots = cy.$( options.roots );

    } else {
      if( options.directed ){
        roots = nodes.roots();
      } else {
        var components = [];
        var unhandledNodes = nodes;

        while( unhandledNodes.length > 0 ){
          var currComp = cy.collection();

          eles.bfs({
            roots: unhandledNodes[0],
            visit: function(i, depth, node, edge, pNode){
              currComp = currComp.add( node );
            },
            directed: false
          });

          unhandledNodes = unhandledNodes.not( currComp );
          components.push( currComp );
        }

        roots = cy.collection();
        for( var i = 0; i < components.length; i++ ){
          var comp = components[i];
          var maxDegree = comp.maxDegree( false );
          var compRoots = comp.filter(function(){
            return this.degree(false) === maxDegree;
          });

          roots = roots.add( compRoots );
        }
        
      }
    }


    var depths = [];
    var foundByBfs = {};
    var id2depth = {};
    var prevNode = {};
    var prevEdge = {};
    var successors = {};

    // find the depths of the nodes
    graph.bfs({
      roots: roots,
      directed: options.directed,
      visit: function(i, depth, node, edge, pNode){
        var ele = this[0];
        var id = ele.id();

        if( !depths[depth] ){
          depths[depth] = [];
        }

        depths[depth].push( ele );
        foundByBfs[ id ] = true;
        id2depth[ id ] = depth;
        prevNode[ id ] = pNode;
        prevEdge[ id ] = edge;

        if( pNode ){
          var prevId = pNode.id();
          var succ = successors[ prevId ] = successors[ prevId ] || [];
          
          succ.push( node );
        }
      }
    });

    // check for nodes not found by bfs
    var orphanNodes = [];
    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[i];

      if( foundByBfs[ ele.id() ] ){
        continue;
      } else {
        orphanNodes.push( ele );
      }
    }

    // assign orphan nodes a depth from their neighborhood
    var maxChecks = orphanNodes.length * 3;
    var checks = 0;
    while( orphanNodes.length !== 0 && checks < maxChecks ){
      var node = orphanNodes.shift();
      var neighbors = node.neighborhood().nodes();
      var assignedDepth = false;

      for( var i = 0; i < neighbors.length; i++ ){
        var depth = id2depth[ neighbors[i].id() ];

        if( depth !== undefined ){
          depths[depth].push( node );
          assignedDepth = true;
          break;
        }
      }

      if( !assignedDepth ){
        orphanNodes.push( node );
      }

      checks++;
    }

    // assign orphan nodes that are still left to the depth of their subgraph
    while( orphanNodes.length !== 0 ){
      var node = orphanNodes.shift();
      //var subgraph = graph.bfs( node ).path;
      var assignedDepth = false;

      // for( var i = 0; i < subgraph.length; i++ ){
      //   var depth = id2depth[ subgraph[i].id() ];

      //   if( depth !== undefined ){
      //     depths[depth].push( node );
      //     assignedDepth = true;
      //     break;
      //   }
      // }

      if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
        if( depths.length === 0 ){
          depths.push([]);
        }
        
        depths[0].push( node );
      }
    }

    // assign the nodes a depth and index
    var assignDepthsToEles = function(){
      for( var i = 0; i < depths.length; i++ ){
        var eles = depths[i];

        for( var j = 0; j < eles.length; j++ ){
          var ele = eles[j];

          ele._private.scratch.breadthfirst = {
            depth: i,
            index: j
          };
        }
      }
    };
    assignDepthsToEles();


    var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
      var edges = node.connectedEdges(function(){
        return this.data('target') === node.id();
      });
      var thisInfo = node._private.scratch.breadthfirst;
      var highestDepthOfOther = 0;
      var highestOther;
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];
        var otherNode = edge.source()[0];
        var otherInfo = otherNode._private.scratch.breadthfirst;

        if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
          highestDepthOfOther = otherInfo.depth;
          highestOther = otherNode;
        }
      }

      return highestOther;
    };

     // make maximal if so set by adjusting depths
    for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

      var nDepths = depths.length;
      var elesToMove = [];
      for( var i = 0; i < nDepths; i++ ){
        var depth = depths[i];

        var nDepth = depth.length;
        for( var j = 0; j < nDepth; j++ ){
          var ele = depth[j];
          var info = ele._private.scratch.breadthfirst;
          var intEle = intersectsDepth(ele);

          if( intEle ){
            info.intEle = intEle;
            elesToMove.push( ele );
          }
        }
      }

      for( var i = 0; i < elesToMove.length; i++ ){ 
        var ele = elesToMove[i];
        var info = ele._private.scratch.breadthfirst;
        var intEle = info.intEle;
        var intInfo = intEle._private.scratch.breadthfirst;

        depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

        // add to end of new depth
        var newDepth = intInfo.depth + 1;
        while( newDepth > depths.length - 1 ){
          depths.push([]);
        }
        depths[ newDepth ].push( ele );

        info.depth = newDepth;
        info.index = depths[newDepth].length - 1;
      }

      assignDepthsToEles();
    }

    // find min distance we need to leave between nodes
    var minDistance = 0;
    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var w = nodes[i].outerWidth();
        var h = nodes[i].outerHeight();
        
        minDistance = Math.max(minDistance, w, h);
      }
      minDistance *= 1.75; // just to have some nice spacing
    }

    // get the weighted percent for an element based on its connectivity to other levels
    var cachedWeightedPercent = {};
    var getWeightedPercent = function( ele ){
      if( cachedWeightedPercent[ ele.id() ] ){
        return cachedWeightedPercent[ ele.id() ];
      }

      var eleDepth = ele._private.scratch.breadthfirst.depth;
      var neighbors = ele.neighborhood().nodes();
      var percent = 0;
      var samples = 0;

      for( var i = 0; i < neighbors.length; i++ ){
        var neighbor = neighbors[i];
        var index = neighbor._private.scratch.breadthfirst.index;
        var depth = neighbor._private.scratch.breadthfirst.depth;
        var nDepth = depths[depth].length;

        if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
          percent += index / nDepth;
          samples++;
        }
      }

      samples = Math.max(1, samples);
      percent = percent / samples;

      if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
        percent = undefined;
      }

      cachedWeightedPercent[ ele.id() ] = percent;
      return percent;
    };


    // rearrange the indices in each depth level based on connectivity

    var sortFn = function(a, b){
      var apct = getWeightedPercent( a );
      var bpct = getWeightedPercent( b );

      return apct - bpct;
    };

    for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

      for( var i = 0; i < depths.length; i++ ){
        depths[i] = depths[i].sort( sortFn );
      }
      assignDepthsToEles(); // and update

    }

    var biggestDepthSize = 0;
    for( var i = 0; i < depths.length; i++ ){
      biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );
    }

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.x1 + bb.h/2
    };
   
    var getPosition = function( ele, isBottomDepth ){
      var info = ele._private.scratch.breadthfirst;
      var depth = info.depth;
      var index = info.index;
      var depthSize = depths[depth].length;

      if( options.strictHierarchy ){
        depthSize = biggestDepthSize;
      }

      var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
      var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
      var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
      radiusStepSize = Math.max( radiusStepSize, minDistance );

      if( options.strictHierarchy && !options.circle ){
        
        var epos = {
          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
          y: (depth + 1) * distanceY
        };

        if( isBottomDepth ){
          return epos;
        }

        var succs = successors[ ele.id() ];
        if( succs ){
          epos.x = 0;

          for( var i = 0 ; i < succs.length; i++ ){
            var spos = pos[ succs[i].id() ];
            
            epos.x += spos.x;
          }

          epos.x /= succs.length;
        } else {
          //debugger;
        }

        return epos;

      } else {
        if( options.circle ){
          var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);
          var theta = 2 * Math.PI / depths[depth].length * index;

          if( depth === 0 && depths[0].length === 1 ){
            radius = 1;
          }

          return {
            x: center.x + radius * Math.cos(theta),
            y: center.y + radius * Math.sin(theta)
          };

        } else {
          return {
            x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
            y: (depth + 1) * distanceY
          };
        }
      }
      
    };

    // get positions in reverse depth order
    var pos = {};
    for( var i = depths.length - 1; i >=0; i-- ){
      var depth = depths[i];

      for( var j = 0; j < depth.length; j++ ){
        var node = depth[j];

        pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
      }
    }

    nodes.layoutPositions(this, options, function(){
      return pos[ this.id() ];
    });
    
    return this; // chaining
  };
  
  $$('layout', 'breadthfirst', BreadthFirstLayout);
  
})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
    radius: undefined, // the radius of the circle
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function CircleLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  CircleLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
      
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var theta = options.startAngle;
    var dTheta = 2 * Math.PI / nodes.length;
    var r;

    var minDistance = 0;
    for( var i = 0; i < nodes.length; i++ ){
      var w = nodes[i].outerWidth();
      var h = nodes[i].outerHeight();
      
      minDistance = Math.max(minDistance, w, h);
    }

    if( $$.is.number(options.radius) ){
      r = options.radius;
    } else if( nodes.length <= 1 ){
      r = 0;
    } else {
      r = Math.min( bb.h, bb.w )/2 - minDistance;
    }

    // calculate the radius
    if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      minDistance *= 1.75; // just to have some nice spacing

      var dTheta = 2 * Math.PI / nodes.length;
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
      r = Math.max( rMin, r );
    }

    var getPos = function( i, ele ){
      var rx = r * Math.cos( theta );
      var ry = r * Math.sin( theta );
      var pos = {
        x: center.x + rx,
        y: center.y + ry
      };

      theta = options.counterclockwise ? theta - dTheta : theta + dTheta;
      return pos;
    };
    
    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  $$('layout', 'circle', CircleLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    animate: true, // whether to show the layout as it's running
    refresh: 1, // number of ticks per frame; higher is faster but more jerky
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }

    // layout event callbacks
    ready: function(){}, // on layoutready
    stop: function(){}, // on layoutstop

    // positioning options
    randomize: false, // use random node positions at beginning of layout
    avoidOverlap: true, // if true, prevents overlap of node bounding boxes
    handleDisconnected: true, // if true, avoids disconnected components from overlapping
    nodeSpacing: function( node ){ return 10; }, // extra spacing around nodes
    flow: undefined, // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }
    alignment: undefined, // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }

    // different methods of specifying edge length
    // each can be a constant numerical value or a function like `function( edge ){ return 2; }`
    edgeLength: undefined, // sets edge length directly in simulation
    edgeSymDiffLength: undefined, // symmetric diff edge length in simulation
    edgeJaccardLength: undefined, // jaccard edge length in simulation

    // iterations of cola algorithm; uses default values on undefined
    unconstrIter: undefined, // unconstrained initial layout iterations
    userConstIter: undefined, // initial layout iterations with user-specified constraints
    allConstIter: undefined, // initial layout iterations with all constraints including non-overlap

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };

  // constructor
  // options : object containing layout options
  function ColaLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  ColaLayout.prototype.run = function(){
    var layout = this;
    var options = this.options;

    $$.util.require('cola', function(cola){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;
      var nodes = eles.nodes();
      var edges = eles.edges();
      var ready = false;
      
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var getOptVal = function( val, ele ){
        if( $$.is.fn(val) ){
          var fn = val;
          return fn.apply( ele, [ ele ] );
        } else {
          return val;
        }
      };

      var updateNodePositions = function(){
        var x = { min: Infinity, max: -Infinity };
        var y = { min: Infinity, max: -Infinity };

        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var scratch = node._private.scratch.cola;

          x.min = Math.min( x.min, scratch.x );
          x.max = Math.max( x.max, scratch.x );

          y.min = Math.min( y.min, scratch.y );
          y.max = Math.max( y.max, scratch.y );
        }

        nodes.positions(function(i, node){
          var pos = node._private.position;
          var scratch = node._private.scratch.cola;

          if( !node.grabbed() ){
            pos.x = bb.x1 + scratch.x - x.min;
            pos.y = bb.y1 + scratch.y - y.min;
          }
        });

        if( !ready ){
          onReady();
          ready = true;
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
      };

      var onDone = function(){
        layout.manuallyStopped = false;

        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);

        // trigger layoutstop when the layout stops (e.g. finishes)
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };

      var onReady = function(){
        // trigger layoutready when each node has had its position set at least once
        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      };

      var ticksPerFrame = options.refresh;
      var tickSkip = 1; // frames until a tick; used to slow down sim for debugging

      if( options.refresh < 0 ){
        tickSkip = Math.abs( options.refresh );
        ticksPerFrame = 1;
      } else {
        ticksPerFrame = Math.max( 1, ticksPerFrame ); // at least 1
      }

      var adaptor = cola.adaptor({
        trigger: function( e ){ // on sim event
          switch( e.type ){
            case 'tick':
              if( options.animate ){
                updateNodePositions();
              }
              break;

            case 'end': 
              updateNodePositions();
              if( !options.infinite || layout.manuallyStopped ){ onDone(); }           
              break;
          }
        },

        kick: function( tick ){ // kick off the simulation
          var skip = 0;

          var inftick = function(){
            var ret = tick();

            if( ret && options.infinite ){ // resume layout if done
              adaptor.resume(); // resume => new kick
            }
            
            return ret; // allow regular finish b/c of new kick
          };

          var multitick = function(){ // multiple ticks in a row
            var ret;

            // skip ticks to slow down layout for debugging
            var thisSkip = skip;
            skip = (skip + 1) % tickSkip;
            if( thisSkip !== 0 ){
              return false;
            }

            for( var i = 0; i < ticksPerFrame && !ret; i++ ){
              ret = ret || inftick(); // pick up true ret vals => sim done
            }

            return ret;
          };

          if( options.animate ){
            var frame = function(){
              if( multitick() ){ return; }

              $$.util.requestAnimationFrame( frame );
            };

            $$.util.requestAnimationFrame( frame );
          } else {
            while( !inftick() ){}
          }
        },

        on: function( type, listener ){}, // dummy; not needed

        drag: function(){} // TODO
      });
      layout.adaptor = adaptor;

      // if set no grabbing during layout
      var grabbableNodes = nodes.filter(':grabbable');
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }

      // handle node dragging
      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
        var pos = node._private.position;

        if( node.grabbed() ){
          scrCola.x = pos.x - bb.x1;
          scrCola.y = pos.y - bb.y1;

          adaptor.dragstart( scrCola );
        } else if( $$.is.number(scrCola.x) && $$.is.number(scrCola.y) ){
          pos.x = scrCola.x + bb.x1;
          pos.y = scrCola.y + bb.y1;
        }

        switch( e.type ){
          case 'grab':
            adaptor.dragstart( scrCola );
            adaptor.resume();
            break;
          case 'free':
            adaptor.dragend( scrCola );
            break;
        }
        
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
      
        if( node.locked() ){
          adaptor.dragstart( scrCola );
        } else {
          adaptor.dragend( scrCola );
        }
      });

      var nonparentNodes = nodes.stdFilter(function( node ){
        return !node.isParent();
      });

      // add nodes to cola
      adaptor.nodes( nonparentNodes.map(function( node, i ){
        var padding = getOptVal( options.nodeSpacing, node );
        var pos = node.position();

        var struct = node._private.scratch.cola = {
          x: options.randomize ? Math.round( Math.random() * bb.w ) : pos.x,
          y: options.randomize ? Math.round( Math.random() * bb.h ) : pos.y,
          width: node.outerWidth() + 2*padding,
          height: node.outerHeight() + 2*padding,
          index: i
        };

        return struct;
      }) );

      if( options.alignment ){ // then set alignment constraints

        var offsetsX = [];
        var offsetsY = [];

        nonparentNodes.forEach(function( node ){
          var align = getOptVal( options.alignment, node );
          var scrCola = node._private.scratch.cola;
          var index = scrCola.index;

          if( !align ){ return; }

          if( align.x != null ){
            offsetsX.push({
              node: index,
              offset: align.x
            });
          }

          if( align.y != null ){
            offsetsY.push({
              node: index,
              offset: align.y
            });
          }
        });

        // add alignment constraints on nodes
        var constraints = [];

        if( offsetsX.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'x',
            offsets: offsetsX
          });
        }

        if( offsetsY.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'y',
            offsets: offsetsY
          });
        }
        
        adaptor.constraints( constraints );

      }

      // add compound nodes to cola
      adaptor.groups( nodes.stdFilter(function( node ){
        return node.isParent();
      }).map(function( node, i ){ // add basic group incl leaf nodes
        node._private.scratch.cola = {
          index: i,

          leaves: node.children().stdFilter(function( child ){
            return !child.isParent();
          }).map(function( child ){
            return child[0]._private.scratch.cola.index;
          })
        };

        return node;
      }).map(function( node ){ // add subgroups
        node._private.scratch.cola.groups = node.children().stdFilter(function( child ){
          return child.isParent();
        }).map(function( child ){
          return child._private.scratch.cola.index;
        });

        return node._private.scratch.cola;
      }) );

      // get the edge length setting mechanism
      var length;
      var lengthFnName;
      if( options.edgeLength != null ){
        length = options.edgeLength;
        lengthFnName = 'linkDistance';
      } else if( options.edgeSymDiffLength != null ){
        length = options.edgeSymDiffLength;
        lengthFnName = 'symmetricDiffLinkLengths';
      } else if( options.edgeJaccardLength != null ){
        length = options.edgeJaccardLength;
        lengthFnName = 'jaccardLinkLengths';
      } else {
        length = 100;
        lengthFnName = 'linkDistance';
      }

      var lengthGetter = function( link ){
        return link.calcLength;
      };

      // add the edges to cola
      adaptor.links( edges.stdFilter(function( edge ){
        return !edge.source().isParent() && !edge.target().isParent();
      }).map(function( edge, i ){
        var c = edge._private.scratch.cola = {
          source: edge.source()[0]._private.scratch.cola.index,
          target: edge.target()[0]._private.scratch.cola.index
        };

        if( length != null ){
          c.calcLength = getOptVal( length, edge );
        }

        return c;
      }) );

      adaptor.size([ bb.w, bb.h ]);

      if( length != null ){
        adaptor[ lengthFnName ]( lengthGetter );
      }

      // set the flow of cola
      if( options.flow ){
        var flow;
        var defAxis = 'y';
        var defMinSep = 50;

        if( $$.is.string(options.flow) ){
          flow = {
            axis: options.flow,
            minSeparation: defMinSep
          };
        } else if( $$.is.number(options.flow) ){
          flow = {
            axis: defAxis,
            minSeparation: options.flow
          };
        } else if( $$.is.plainObject(options.flow) ){
          flow = options.flow;

          flow.axis = flow.axis || defAxis;
          flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;
        } else { // e.g. options.flow: true
          flow = {
            axis: defAxis,
            minSeparation: defMinSep
          };
        }

        adaptor.flowLayout( flow.axis , flow.minSeparation );
      }

      adaptor
        .avoidOverlaps( options.avoidOverlap )
        .handleDisconnected( options.handleDisconnected )
        .start( options.unconstrIter, options.userConstIter, options.allConstIter)
      ;

      layout.trigger({ type: 'layoutstart', layout: layout });

      if( !options.infinite ){
        setTimeout(function(){
          adaptor.stop();
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  ColaLayout.prototype.stop = function(){
    if( this.adaptor ){
      this.manuallyStopped = true;
      this.adaptor.stop();
    }

    return this; // chaining
  };

  // register the layout
  $$('layout', 'cola', ColaLayout);

})(cytoscape);
;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise/anticlockwise (true) or clockwise (false)
    minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    height: undefined, // height of layout area (overrides container height)
    width: undefined, // width of layout area (overrides container width)
    concentric: function(){ // returns numeric value for each node, placing higher nodes in levels towards the centre
      return this.degree();
    },
    levelWidth: function(nodes){ // the variation of concentric values in each level
      return nodes.maxDegree() / 4;
    },
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function ConcentricLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  ConcentricLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var nodeValues = []; // { node, value }
    var theta = options.startAngle;
    var maxNodeSize = 0;

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];
      var value;
      
      // calculate the node value
      value = options.concentric.call(node);
      nodeValues.push({
        value: value,
        node: node
      });

      // for style mapping
      node._private.layoutData.concentric = value;
    }

    // in case we used the `concentric` in style
    nodes.updateStyle();

    // calculate max size now based on potentially updated mappers
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];

      maxNodeSize = Math.max( maxNodeSize, node.outerWidth(), node.outerHeight() );
    }

    // sort node values in descreasing order
    nodeValues.sort(function(a, b){
      return b.value - a.value;
    });

    var levelWidth = options.levelWidth( nodes );

    // put the values into levels
    var levels = [ [] ];
    var currentLevel = levels[0];
    for( var i = 0; i < nodeValues.length; i++ ){
      var val = nodeValues[i];

      if( currentLevel.length > 0 ){
        var diff = Math.abs( currentLevel[0].value - val.value );

        if( diff >= levelWidth ){
          currentLevel = [];
          levels.push( currentLevel );
        }
      }

      currentLevel.push( val );
    }

    // create positions from levels

    var pos = {}; // id => position
    var r = 0;
    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

    if( !options.avoidOverlap ){ // then strictly constrain to bb
      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
      var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );
      var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

      minDist = Math.min( minDist, rStep );
    }

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[i];
      var dTheta = 2 * Math.PI / level.length;

      // calculate the radius
      if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
        var dcos = Math.cos(dTheta) - Math.cos(0);
        var dsin = Math.sin(dTheta) - Math.sin(0);
        var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
        r = Math.max( rMin, r );
      }

      for( var j = 0; j < level.length; j++ ){
        var val = level[j];
        var theta = options.startAngle + (options.counterclockwise ? 1 : -1) * dTheta * j;

        var p = {
          x: center.x + r * Math.cos(theta),
          y: center.y + r * Math.sin(theta)
        };

        pos[ val.node.id() ] = p;
      }

      r += minDist;
      
    } 

    // position the nodes
    nodes.layoutPositions(this, options, function(){
      var id = this.id();

      return pos[id];
    });
  
    return this; // chaining
  };
  
  $$('layout', 'concentric', ConcentricLayout);
  
})( cytoscape );

/*
  The CoSE layout was written by Gerardo Huck.

  Modifications tracked on Github.
*/

;(function($$) { 'use strict';

  var DEBUG;

  /**
   * @brief :  default layout options
   */
  var defaults = {
    // Called on `layoutready`
    ready               : function() {},

    // Called on `layoutstop`
    stop                : function() {},

    // Whether to animate while running the layout
    animate             : true,

    // Number of iterations between consecutive screen positions update (0 -> only updated on the end)
    refresh             : 4,
    
    // Whether to fit the network view after when done
    fit                 : true, 

    // Padding on fit
    padding             : 30, 

    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    boundingBox         : undefined,

    // Whether to randomize node positions on the beginning
    randomize           : true,
    
    // Whether to use the JS console to print debug messages
    debug               : false,

    // Node repulsion (non overlapping) multiplier
    nodeRepulsion       : 400000,
    
    // Node repulsion (overlapping) multiplier
    nodeOverlap         : 10,
    
    // Ideal edge (non nested) length
    idealEdgeLength     : 10,
    
    // Divisor to compute edge forces
    edgeElasticity      : 100,
    
    // Nesting factor (multiplier) to compute ideal edge length for nested edges
    nestingFactor       : 5, 
    
    // Gravity force (constant)
    gravity             : 250, 
    
    // Maximum number of iterations to perform
    numIter             : 100,
    
    // Initial temperature (maximum node displacement)
    initialTemp         : 200,
    
    // Cooling factor (how the temperature is reduced between consecutive iterations
    coolingFactor       : 0.95, 
    
    // Lower temperature threshold (below this point the layout will end)
    minTemp             : 1.0
  };


  /**
   * @brief       : constructor
   * @arg options : object containing layout options
   */
  function CoseLayout(options) {
    this.options = $$.util.extend({}, defaults, options); 
  }


  /**
   * @brief : runs the layout
   */
  CoseLayout.prototype.run = function() {
    var options = this.options;
    var cy      = options.cy;
    var layout  = this;

    layout.stopped = false;

    layout.trigger({ type: 'layoutstart', layout: layout });

    // Set DEBUG - Global variable
    if (true === options.debug) {
      DEBUG = true;
    } else {
      DEBUG = false;
    }

    // Get start time
    var startTime = new Date();

    // Initialize layout info
    var layoutInfo = createLayoutInfo(cy, layout, options);
    
    // Show LayoutInfo contents if debugging
    if (DEBUG) {
      printLayoutInfo(layoutInfo);
    }

    // If required, randomize node positions
    if (true === options.randomize) {
      randomizePositions(layoutInfo, cy);
    }

    updatePositions(layoutInfo, cy, options);

    var mainLoop = function(i){
      if( layout.stopped ){
        logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step(layoutInfo, cy, options, i);
      
      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      logDebug("New temperature: " + layoutInfo.temperature);

      if (layoutInfo.temperature < options.minTemp) {
        logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var done = function(){
      refreshPositions(layoutInfo, cy, options);

      // Fit the graph if necessary
      if (true === options.fit) {
        cy.fit( options.padding );
      }
      
      // Get end time
      var endTime = new Date();

      console.info('Layout took ' + (endTime - startTime) + ' ms');

      // Layout has finished
      layout.one('layoutstop', options.stop);
      layout.trigger({ type: 'layoutstop', layout: layout });
    };

    if( options.animate ){
      var i = 0;
      var frame = function(){

        var f = 0;
        var loopRet;
        while( f < options.refresh && i < options.numIter ){
          var loopRet = mainLoop(i);
          if( loopRet === false ){ break; }

          f++;
          i++;
        }

        refreshPositions(layoutInfo, cy, options);
        if( options.fit ){
          cy.fit( options.padding );
        }

        if ( loopRet !== false && i + 1 < options.numIter ) {
          $$.util.requestAnimationFrame( frame );
        } else {
          done();
        }
      };

      $$.util.requestAnimationFrame( frame );
    } else {
      for (var i = 0; i < options.numIter; i++) {
        if( mainLoop(i) === false ){ break; }
      }

      done();
    }
   
    return this; // chaining
  };


  /**
   * @brief : called on continuous layouts to stop them before they finish
   */
  CoseLayout.prototype.stop = function(){
    this.stopped = true;

    return this; // chaining
  };


  /**
   * @brief     : Creates an object which is contains all the data
   *              used in the layout process
   * @arg cy    : cytoscape.js object
   * @return    : layoutInfo object initialized
   */
  var createLayoutInfo = function(cy, layout, options) {
    // Shortcut
    var edges = options.eles.edges();
    var nodes = options.eles.nodes();

    var layoutInfo   = {
      layout       : layout,
      layoutNodes  : [], 
      idToIndex    : {},
      nodeSize     : nodes.size(),
      graphSet     : [],
      indexToGraph : [], 
      layoutEdges  : [],
      edgeSize     : edges.size(),
      temperature  : options.initialTemp,
      clientWidth  : cy.width(),
      clientHeight : cy.width(),
      boundingBox  : $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                       x1: 0, y1: 0, w: cy.width(), h: cy.height()
                     } )
    }; 
    
    // Iterate over all nodes, creating layout nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var tempNode        = {};
      tempNode.id         = nodes[i].data('id');
      tempNode.parentId   = nodes[i].data('parent');      
      tempNode.children   = [];
      tempNode.positionX  = nodes[i].position('x');
      tempNode.positionY  = nodes[i].position('y');
      tempNode.offsetX    = 0;      
      tempNode.offsetY    = 0;
      tempNode.height     = nodes[i].height();
      tempNode.width      = nodes[i].width();
      tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
      tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
      tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
      tempNode.minY       = tempNode.positionY - tempNode.height / 2;
      tempNode.padLeft    = nodes[i]._private.style['padding-left'].pxValue;
      tempNode.padRight   = nodes[i]._private.style['padding-right'].pxValue;
      tempNode.padTop     = nodes[i]._private.style['padding-top'].pxValue;
      tempNode.padBottom  = nodes[i]._private.style['padding-bottom'].pxValue;
      
      // Add new node
      layoutInfo.layoutNodes.push(tempNode);
      // Add entry to id-index map
      layoutInfo.idToIndex[tempNode.id] = i;
    }

    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    var tempGraph = [];

    // Second pass to add child information and 
    // initialize queue for hierarchical traversal
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var p_id = n.parentId;
      // Check if node n has a parent node
      if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
      } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);    
      }
    }
    
    // Add root graph to graphSet
    layoutInfo.graphSet.push(tempGraph);

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var node_id  = queue[start++];
      var node_ix  = layoutInfo.idToIndex[node_id];
      var node     = layoutInfo.layoutNodes[node_ix];
      var children = node.children;
      if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children);
      // Add children to que queue to be visited
      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
      }
    }

    // Create indexToGraph map
    for (var i = 0; i < layoutInfo.graphSet.length; i++) {      
      var graph = layoutInfo.graphSet[i];
      for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
      }
    }
    
    // Iterate over all edges, creating Layout Edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      var e = edges[i];
      var tempEdge = {};      
      tempEdge.id       = e.data('id');
      tempEdge.sourceId = e.data('source');
      tempEdge.targetId = e.data('target');

      // Compute ideal length
      var idealLength = options.idealEdgeLength;

      // Check if it's an inter graph edge
      var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];
      var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];
      var sourceGraph = layoutInfo.indexToGraph[sourceIx];
      var targetGraph = layoutInfo.indexToGraph[targetIx];

      if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[targetIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +  
         ". Index: " + lca + " Contents: " + lcaGraph.toString() + 
         ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
      }

      tempEdge.idealLength = idealLength;

      layoutInfo.layoutEdges.push(tempEdge);
    }

    // Finally, return layoutInfo object
    return layoutInfo;
  };

  
  /**
   * @brief : This function finds the index of the lowest common 
   *          graph ancestor between 2 nodes in the subtree 
   *          (from the graph hierarchy induced tree) whose
   *          root is graphIx
   *
   * @arg node1: node1's ID
   * @arg node2: node2's ID
   * @arg layoutInfo: layoutInfo object
   *
   */
  var findLCA = function(node1, node2, layoutInfo) {
    // Find their common ancester, starting from the root graph
    var res = findLCA_aux(node1, node2, 0, layoutInfo);
    if (2 > res.count) {
      // If aux function couldn't find the common ancester, 
      // then it is the root graph
      return 0;
    } else {
      return res.graph;
    }
  };


  /**
   * @brief          : Auxiliary function used for LCA computation
   * 
   * @arg node1      : node1's ID
   * @arg node2      : node2's ID
   * @arg graphIx    : subgraph index
   * @arg layoutInfo : layoutInfo object
   *
   * @return         : object of the form {count: X, graph: Y}, where:
   *                   X is the number of ancesters (max: 2) found in 
   *                   graphIx (and it's subgraphs),
   *                   Y is the graph index of the lowest graph containing 
   *                   all X nodes
   */
  var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {
    var graph = layoutInfo.graphSet[graphIx];
    // If both nodes belongs to graphIx
    if (-1 < $.inArray(node1, graph) && -1 < $.inArray(node2, graph)) {
      return {count:2, graph:graphIx};
    }

    // Make recursive calls for all subgraphs
    var c = 0;
    for (var i = 0; i < graph.length; i++) {
      var nodeId   = graph[i];
      var nodeIx   = layoutInfo.idToIndex[nodeId];
      var children = layoutInfo.layoutNodes[nodeIx].children;

      // If the node has no child, skip it
      if (0 === children.length) {
      continue;
      }

      var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
      var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
      if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
      } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;
      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
      } else {
      // Both nodes are present in this subgraph
      return result;
      }      
    }
    
    return {count:c, graph:graphIx};
  };


  /**
   * @brief: printsLayoutInfo into js console
   *         Only used for debbuging 
   */
  var printLayoutInfo = function(layoutInfo) {
    if (!DEBUG) {
      return;
    }
    console.debug("layoutNodes:");
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var s = 
      "\nindex: "     + i + 
      "\nId: "        + n.id + 
      "\nChildren: "  + n.children.toString() +  
      "\nparentId: "  + n.parentId  + 
      "\npositionX: " + n.positionX + 
      "\npositionY: " + n.positionY +
      "\nOffsetX: " + n.offsetX + 
      "\nOffsetY: " + n.offsetY + 
      "\npadLeft: " + n.padLeft + 
      "\npadRight: " + n.padRight + 
      "\npadTop: " + n.padTop + 
      "\npadBottom: " + n.padBottom;

      console.debug(s);    
    }  
    
    console.debug('idToIndex');
    for (var i in layoutInfo.idToIndex) {
      console.debug("Id: " + i + "\nIndex: " + layoutInfo.idToIndex[i]);
    }

    console.debug('Graph Set');
    var set = layoutInfo.graphSet;
    for (var i = 0; i < set.length; i ++) {
      console.debug("Set : " + i + ": " + set[i].toString());
    } 

    var s = 'IndexToGraph';
    for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {
      s += "\nIndex : " + i + " Graph: "+ layoutInfo.indexToGraph[i];
    }
    console.debug(s);

    s = 'Layout Edges';
    for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
      var e = layoutInfo.layoutEdges[i];
      s += "\nEdge Index: " + i + " ID: " + e.id + 
      " SouceID: " + e.sourceId + " TargetId: " + e.targetId + 
      " Ideal Length: " + e.idealLength;
    }
    console.debug(s);

    s =  "nodeSize: " + layoutInfo.nodeSize;
    s += "\nedgeSize: " + layoutInfo.edgeSize;
    s += "\ntemperature: " + layoutInfo.temperature;
    console.debug(s);

    return;
  };


  /**
   * @brief : Randomizes the position of all nodes
   */
  var randomizePositions = function(layoutInfo, cy) {
    var width     = layoutInfo.clientWidth;
    var height    = layoutInfo.clientHeight;

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      // No need to randomize compound nodes
      if (true || 0 === n.children.length) {
        n.positionX = Math.random() * width;
        n.positionY = Math.random() * height;
      }
    }
  };

  
  /**
   * @brief          : Updates the positions of nodes in the network
   * @arg layoutInfo : LayoutInfo object
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var refreshPositions = function(layoutInfo, cy, options) {  
    var s = 'Refreshing positions';
    logDebug(s);

    var layout = layoutInfo.layout;
    var nodes = options.eles.nodes();
    var bb = layoutInfo.boundingBox;
    var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
    
    if( options.boundingBox ){
      nodes.forEach(function( node ){
        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

        coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
        coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

        coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
        coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
      });

      coseBB.w = coseBB.x2 - coseBB.x1;
      coseBB.h = coseBB.y2 - coseBB.y1;
    }

    nodes.positions(function(i, ele) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
      s = "Node: " + lnode.id + ". Refreshed position: (" + 
      lnode.positionX + ", " + lnode.positionY + ").";
      logDebug(s);

      if( options.boundingBox ){ // then add extra bounding box constraint
        var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
        var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

        return {
          x: bb.x1 + pctX * bb.w,
          y: bb.y1 + pctY * bb.h
        };
      } else {
        return {
          x: lnode.positionX,
          y: lnode.positionY
        };
      }
    });

    // Trigger layoutReady only on first call
    if (true !== layoutInfo.ready) {
      s = 'Triggering layoutready';
      logDebug(s);
      layoutInfo.ready = true;
      layout.one('layoutready', options.ready);
      layout.trigger({ type: 'layoutready', layout: this });
    }
  };


  /**
   * @brief          : Performs one iteration of the physical simulation
   * @arg layoutInfo : LayoutInfo object already initialized
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var step = function(layoutInfo, cy, options, step) {  
    var s = "\n\n###############################";
    s += "\nSTEP: " + step;
    s += "\n###############################\n";
    logDebug(s);

    // Calculate node repulsions
    calculateNodeForces(layoutInfo, cy, options);
    // Calculate edge forces
    calculateEdgeForces(layoutInfo, cy, options);
    // Calculate gravity forces
    calculateGravityForces(layoutInfo, cy, options);
    // Propagate forces from parent to child
    propagateForces(layoutInfo, cy, options);
    // Update positions based on calculated forces
    updatePositions(layoutInfo, cy, options);
  };

  
  /**
   * @brief : Computes the node repulsion forces
   */
  var calculateNodeForces = function(layoutInfo, cy, options) {
    // Go through each of the graphs in graphSet
    // Nodes only repel each other if they belong to the same graph
    var s = 'calculateNodeForces';
    logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      s = "Set: " + graph.toString();
      logDebug(s);

      // Now get all the pairs of nodes 
      // Only get each pair once, (A, B) = (B, A)
      for (var j = 0; j < numNodes; j++) {
      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
      for (var k = j + 1; k < numNodes; k++) {
        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
        nodeRepulsion(node1, node2, layoutInfo, cy, options);
      } 
      }
    } 
  };


  /**
   * @brief : Compute the node repulsion forces between a pair of nodes
   */
  var nodeRepulsion = function(node1, node2, layoutInfo, cy, options) {
    var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

    // Get direction of line connecting both node centers
    var directionX = node2.positionX - node1.positionX;
    var directionY = node2.positionY - node1.positionY;
    s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

    // If both centers are the same, apply a random force
    if (0 === directionX && 0 === directionY) {
      s += "\nNodes have the same position.";
      return; // TODO
    }

    var overlap = nodesOverlap(node1, node2, directionX, directionY);
    
    if (overlap > 0) {
      s += "\nNodes DO overlap.";
      s += "\nOverlap: " + overlap;
      // If nodes overlap, repulsion force is proportional 
      // to the overlap
      var force    = options.nodeOverlap * overlap;

      // Compute the module and components of the force vector
      var distance = Math.sqrt(directionX * directionX + directionY * directionY);
      s += "\nDistance: " + distance;
      var forceX   = force * directionX / distance;
      var forceY   = force * directionY / distance;

    } else {
      s += "\nNodes do NOT overlap.";
      // If there's no overlap, force is inversely proportional 
      // to squared distance

      // Get clipping points for both nodes
      var point1 = findClippingPoint(node1, directionX, directionY);
      var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

      // Use clipping points to compute distance
      var distanceX   = point2.x - point1.x;
      var distanceY   = point2.y - point1.y;
      var distanceSqr = distanceX * distanceX + distanceY * distanceY;
      var distance    = Math.sqrt(distanceSqr);
      s += "\nDistance: " + distance;

      // Compute the module and components of the force vector
      var force  = options.nodeRepulsion / distanceSqr;
      var forceX = force * distanceX / distance;
      var forceY = force * distanceY / distance;
    }

    // Apply force
    node1.offsetX -= forceX;
    node1.offsetY -= forceY;
    node2.offsetX += forceX;
    node2.offsetY += forceY;

    s += "\nForceX: " + forceX + " ForceY: " + forceY;
    logDebug(s);

    return;
  };


  /**
   * @brief : Finds the point in which an edge (direction dX, dY) intersects 
   *          the rectangular bounding box of it's source/target node 
   */
  var findClippingPoint = function(node, dX, dY) {

    // Shorcuts
    var X = node.positionX;
    var Y = node.positionY;
    var H = node.height;
    var W = node.width;
    var dirSlope     = dY / dX;
    var nodeSlope    = H / W;

    var s = 'Computing clipping point of node ' + node.id + 
      " . Height:  " + H + ", Width: " + W + 
      "\nDirection " + dX + ", " + dY; 
    
    // Compute intersection
    var res = {};
    do {
      // Case: Vertical direction (up)
      if (0 === dX && 0 < dY) {
        res.x = X;
        s += "\nUp direction";
        res.y = Y + H / 2;
        break;
      }

      // Case: Vertical direction (down)
      if (0 === dX && 0 > dY) {
        res.x = X;
        res.y = Y + H / 2;
        s += "\nDown direction";
        break;
      }      

      // Case: Intersects the right border
      if (0 < dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X + W / 2;
        res.y = Y + (W * dY / 2 / dX);
        s += "\nRightborder";
        break;
      }

      // Case: Intersects the left border
      if (0 > dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X - W / 2;
        res.y = Y - (W * dY / 2 / dX);
        s += "\nLeftborder";
        break;
      }

      // Case: Intersects the top border
      if (0 < dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X + (H * dX / 2 / dY);
        res.y = Y + H / 2;
        s += "\nTop border";
        break;
      }

      // Case: Intersects the bottom border
      if (0 > dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X - (H * dX / 2 / dY);
        res.y = Y - H / 2;
        s += "\nBottom border";
        break;
      }

    } while (false);

    s += "\nClipping point found at " + res.x + ", " + res.y;
    logDebug(s);
    return res;
  };


  /**
   * @brief  : Determines whether two nodes overlap or not
   * @return : Amount of overlapping (0 => no overlap)
   */
  var nodesOverlap = function(node1, node2, dX, dY) {

    if (dX > 0) {
      var overlapX = node1.maxX - node2.minX;
    } else {
      var overlapX = node2.maxX - node1.minX;
    }

    if (dY > 0) {
      var overlapY = node1.maxY - node2.minY;
    } else {
      var overlapY = node2.maxY - node1.minY;
    }

    if (overlapX >= 0 && overlapY >= 0) {
      return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
    } else {
      return 0;
    }
  };
    
  
  /**
   * @brief : Calculates all edge forces
   */
  var calculateEdgeForces = function(layoutInfo, cy, options) {
    // Iterate over all edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      // Get edge, source & target nodes
      var edge     = layoutInfo.layoutEdges[i];
      var sourceIx = layoutInfo.idToIndex[edge.sourceId];
      var source   = layoutInfo.layoutNodes[sourceIx];
      var targetIx = layoutInfo.idToIndex[edge.targetId];
      var target   = layoutInfo.layoutNodes[targetIx];

      // Get direction of line connecting both node centers
      var directionX = target.positionX - source.positionX;
      var directionY = target.positionY - source.positionY;
      
      // If both centers are the same, do nothing.
      // A random force has already been applied as node repulsion
      if (0 === directionX && 0 === directionY) {
      return;
      }

      // Get clipping points for both nodes
      var point1 = findClippingPoint(source, directionX, directionY);
      var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);


      var lx = point2.x - point1.x;
      var ly = point2.y - point1.y;
      var l  = Math.sqrt(lx * lx + ly * ly);

      var force  = Math.pow(edge.idealLength - l, 2) / options.edgeElasticity; 

      if (0 !== l) {
        var forceX = force * lx / l;
        var forceY = force * ly / l;
      } else {
        var forceX = 0;
        var forceY = 0;
      }

      // Add this force to target and source nodes
      source.offsetX += forceX;
      source.offsetY += forceY;
      target.offsetX -= forceX;
      target.offsetY -= forceY;

      var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
      s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
      logDebug(s);
    }
  };


  /**
   * @brief : Computes gravity forces for all nodes
   */
  var calculateGravityForces = function(layoutInfo, cy, options) {
    var s = 'calculateGravityForces';
    logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      s = "Set: " + graph.toString();
      logDebug(s);
          
      // Compute graph center
      if (0 === i) {
        var centerX   = layoutInfo.clientHeight / 2;
        var centerY   = layoutInfo.clientWidth  / 2;    
      } else {
        // Get Parent node for this graph, and use its position as center
        var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
        var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
        var centerX = parent.positionX;
        var centerY = parent.positionY;
      }
      s = "Center found at: " + centerX + ", " + centerY;
      logDebug(s);

      // Apply force to all nodes in graph
      for (var j = 0; j < numNodes; j++) {
        var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
        s = "Node: " + node.id;
        var dx = centerX - node.positionX;
        var dy = centerY - node.positionY;
        var d  = Math.sqrt(dx * dx + dy * dy);
        if (d > 1.0) { // TODO: Use global variable for distance threshold
          var fx = options.gravity * dx / d;
          var fy = options.gravity * dy / d;
          node.offsetX += fx;
          node.offsetY += fy;
          s += ": Applied force: " + fx + ", " + fy;
        } else {
          s += ": skypped since it's too close to center";
        }
        logDebug(s);
      }
    }
  };


  /**
   * @brief          : This function propagates the existing offsets from 
   *                   parent nodes to its descendents.
   * @arg layoutInfo : layoutInfo Object
   * @arg cy         : cytoscape Object
   * @arg options    : Layout options
   */
  var propagateForces = function(layoutInfo, cy, options) {  
    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    logDebug('propagateForces');

    // Start by visiting the nodes in the root graph
    queue.push.apply(queue, layoutInfo.graphSet[0]);
    end += layoutInfo.graphSet[0].length;

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var nodeId    = queue[start++];
      var nodeIndex = layoutInfo.idToIndex[nodeId];
      var node      = layoutInfo.layoutNodes[nodeIndex];
      var children  = node.children;

      // We only need to process the node if it's compound
      if (0 < children.length) {    
      var offX = node.offsetX;
      var offY = node.offsetY;

      var s = "Propagating offset from parent node : " + node.id + 
        ". OffsetX: " + offX + ". OffsetY: " + offY;
      s += "\n Children: " + children.toString();
      logDebug(s);
      
      for (var i = 0; i < children.length; i++) {
        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
        // Propagate offset
        childNode.offsetX += offX;
        childNode.offsetY += offY;
        // Add children to queue to be visited
        queue[++end] = children[i];
      }
      
      // Reset parent offsets
      node.offsetX = 0;
      node.offsetY = 0;
      }
      
    }
  };


  /**
   * @brief : Updates the layout model positions, based on 
   *          the accumulated forces
   */
  var updatePositions = function(layoutInfo, cy, options) {
    var s = 'Updating positions';
    logDebug(s);

    // Reset boundaries for compound nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        logDebug("Resetting boundaries of compound node: " + n.id);
        n.maxX = undefined;
        n.minX = undefined;
        n.maxY = undefined;
        n.minY = undefined;
      }
    }

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        // No need to set compound node position
        logDebug("Skipping position update of node: " + n.id);
        continue;
      }
      s = "Node: " + n.id + " Previous position: (" + 
      n.positionX + ", " + n.positionY + ")."; 

      // Limit displacement in order to improve stability
      var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
      n.positionX += tempForce.x; 
      n.positionY += tempForce.y;
      n.offsetX = 0;
      n.offsetY = 0;
      n.minX    = n.positionX - n.width; 
      n.maxX    = n.positionX + n.width; 
      n.minY    = n.positionY - n.height; 
      n.maxY    = n.positionY + n.height; 
      s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
      logDebug(s);

      // Update ancestry boudaries
      updateAncestryBoundaries(n, layoutInfo);
    }

    // Update size, position of compund nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        n.positionX = (n.maxX + n.minX) / 2;
        n.positionY = (n.maxY + n.minY) / 2;
        n.width     = n.maxX - n.minX;
        n.height    = n.maxY - n.minY;
        s = "Updating position, size of compound node " + n.id;
        s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
        s += "\nWidth: " + n.width + ", Height: " + n.height;
        logDebug(s);
      }
    }  
  };


  /**
   * @brief : Limits a force (forceX, forceY) to be not 
   *          greater (in modulo) than max. 
   8          Preserves force direction. 
   */
  var limitForce = function(forceX, forceY, max) {
    var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
    var force = Math.sqrt(forceX * forceX + forceY * forceY);

    if (force > max) {
      var res = {
      x : max * forceX / force,
      y : max * forceY / force
      };      

    } else {
      var res = {
      x : forceX,
      y : forceY
      };
    }

    s += ".\nResult: (" + res.x + ", " + res.y + ")";
    logDebug(s);

    return res;
  };


  /**
   * @brief : Function used for keeping track of compound node 
   *          sizes, since they should bound all their subnodes.
   */
  var updateAncestryBoundaries = function(node, layoutInfo) {
    var s = "Propagating new position/size of node " + node.id;
    var parentId = node.parentId;
    if (null == parentId) {
      // If there's no parent, we are done
      s += ". No parent node.";
      logDebug(s);
      return;
    }

    // Get Parent Node
    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
    var flag = false;

    // MaxX
    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
      p.maxX = node.maxX + p.padRight;
      flag = true;
      s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
    }

    // MinX
    if (null == p.minX || node.minX - p.padLeft < p.minX) {
      p.minX = node.minX - p.padLeft;
      flag = true;
      s += "\nNew minX for parent node " + p.id + ": " + p.minX;
    }

    // MaxY
    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
      p.maxY = node.maxY + p.padBottom;
      flag = true;
      s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
    }

    // MinY
    if (null == p.minY || node.minY - p.padTop < p.minY) {
      p.minY = node.minY - p.padTop;
      flag = true;
      s += "\nNew minY for parent node " + p.id + ": " + p.minY;
    }

    // If updated boundaries, propagate changes upward
    if (flag) {
      logDebug(s);
      return updateAncestryBoundaries(p, layoutInfo);
    } 

    s += ". No changes in boundaries/position of parent node " + p.id;  
    logDebug(s);
    return;
  };


  /**
   * @brief : Logs a debug message in JS console, if DEBUG is ON
   */
  var logDebug = function(text) {
    if (DEBUG) {
      console.debug(text);
    }
  };


  // register the layout
  $$('layout', 'cose', CoseLayout);

})(cytoscape);
;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    // dagre algo options, uses default value on undefined
    nodeSep: undefined, // the separation between adjacent nodes in the same rank
    edgeSep: undefined, // the separation between adjacent edges in the same rank
    rankSep: undefined, // the separation between adjacent nodes in the same rank
    rankDir: undefined, // 'TB' for top to bottom flow, 'LR' for left to right
    minLen: function( edge ){ return 1; }, // number of ranks to keep between the source and target of the edge
    
    // general layout options
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function DagreLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  DagreLayout.prototype.run = function(){
    var options = this.options;
    var layout = this;

    $$.util.require('dagre', function(dagre){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;

      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var g = new dagre.Digraph();

      // add nodes to dagre
      var nodes = eles.nodes().not(':parent');
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];

        g.addNode( node.id(), {
          width: node.width(),
          height: node.height()
        } );
      }

      // add edges to dagre
      var edges = eles.edges();
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];

        g.addEdge( edge.id(), edge.source().id(), edge.target().id(), {
          minLen: $$.is.fn(options.minLen) ? options.minLen.apply( edge, [ edge ] ) : options.minLen
        } );
      }

      var d = dagre.layout();

      if( options.nodeSep ){
        d.nodeSep( options.nodeSep );
      }

      if( options.edgeSep ){
        d.edgeSep( options.edgeSep );
      }
      
      if( options.rankSep ){
        d.rankSep( options.rankSep );
      }

      if( options.rankDir ){
        d.rankDir( options.rankDir );
      }
        
      d = d.run(g);

      d.eachNode(function(id, n) {
        cy.getElementById(id).scratch().dagre = n;
      });

      var dagreBB;

      if( options.boundingBox ){
        dagreBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
        nodes.forEach(function( node ){
          var dModel = node.scratch().dagre;

          dagreBB.x1 = Math.min( dagreBB.x1, dModel.x );
          dagreBB.x2 = Math.max( dagreBB.x2, dModel.x );

          dagreBB.y1 = Math.min( dagreBB.y1, dModel.y );
          dagreBB.y2 = Math.max( dagreBB.y2, dModel.y );
        });

        dagreBB.w = dagreBB.x2 - dagreBB.x1;
        dagreBB.h = dagreBB.y2 - dagreBB.y1;
      } else {
        dagreBB = bb;
      }

      var constrainPos = function( p ){
        if( options.boundingBox ){
          var xPct = (p.x - dagreBB.x1) / dagreBB.w;
          var yPct = (p.y - dagreBB.y1) / dagreBB.h;

          return {
            x: bb.x1 + xPct * bb.w,
            y: bb.y1 + yPct * bb.h
          };
        } else {
          return p;
        }
      };

      nodes.layoutPositions(layout, options, function(){
        var dModel = this.scratch().dagre;

        return constrainPos({
          x: dModel.x,
          y: dModel.y
        });
      });

    }); // require

    return this; // chaining
  };

  // register the layout
  $$('layout', 'dagre', DagreLayout);

})(cytoscape);
;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding used on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    rows: undefined, // force num of rows in the grid
    columns: undefined, // force num of cols in the grid
    position: function( node ){}, // returns { row, col } for element
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function GridLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  GridLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    if( bb.h === 0 || bb.w === 0){
      nodes.layoutPositions(this, options, function(){
        return { x: bb.x1, y: bb.y1 };
      });
      
    } else {
      
      // width/height * splits^2 = cells where splits is number of times to split width
      var cells = nodes.size();
      var splits = Math.sqrt( cells * bb.h/bb.w );
      var rows = Math.round( splits );
      var cols = Math.round( bb.w/bb.h * splits );

      var small = function(val){
        if( val == null ){
          return Math.min(rows, cols);
        } else {
          var min = Math.min(rows, cols);
          if( min == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      var large = function(val){
        if( val == null ){
          return Math.max(rows, cols);
        } else {
          var max = Math.max(rows, cols);
          if( max == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      // if rows or columns were set in options, use those values
      if( options.rows != null && options.columns != null ){
        rows = options.rows;
        cols = options.columns;
      } else if( options.rows != null && options.columns == null ){
        rows = options.rows;
        cols = Math.ceil( cells / rows );
      } else if( options.rows == null && options.columns != null ){
        cols = options.columns;
        rows = Math.ceil( cells / cols );
      }
      
      // otherwise use the automatic values and adjust accordingly
      
      // if rounding was up, see if we can reduce rows or columns
      else if( cols * rows > cells ){
        var sm = small();
        var lg = large();
        
        // reducing the small side takes away the most cells, so try it first
        if( (sm - 1) * lg >= cells ){
          small(sm - 1);
        } else if( (lg - 1) * sm >= cells ){
          large(lg - 1);
        } 
      } else {
        
        // if rounding was too low, add rows or columns
        while( cols * rows < cells ){
          var sm = small();
          var lg = large();
          
          // try to add to larger side first (adds less in multiplication)
          if( (lg + 1) * sm >= cells ){
            large(lg + 1);
          } else {
            small(sm + 1);
          }
        }
      }
      
      var cellWidth = bb.w / cols;
      var cellHeight = bb.h / rows;

      if( options.avoidOverlap ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var w = node.outerWidth();
          var h = node.outerHeight();

          cellWidth = Math.max( cellWidth, w );
          cellHeight = Math.max( cellHeight, h );
        }
      }
      
      var cellUsed = {}; // e.g. 'c-0-2' => true
      
      var used = function(row, col){
        return cellUsed['c-' + row + '-' + col] ? true : false;
      };
      
      var use = function(row, col){
        cellUsed['c-' + row + '-' + col] = true;
      };

      // to keep track of current cell position
      var row = 0;
      var col = 0;
      var moveToNextCell = function(){
        col++;
        if( col >= cols ){
          col = 0;
          row++;
        }
      };

      // get a cache of all the manual positions
      var id2manPos = {};
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var rcPos = options.position( node );

        if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
          var pos = {
            row: rcPos.row,
            col: rcPos.col
          };

          if( pos.col === undefined ){ // find unused col
            pos.col = 0;

            while( used(pos.row, pos.col) ){
              pos.col++;
            }
          } else if( pos.row === undefined ){ // find unused row
            pos.row = 0;

            while( used(pos.row, pos.col) ){
              pos.row++;
            }
          }

          id2manPos[ node.id() ] = pos;
          use( pos.row, pos.col );
        }
      }

      var getPos = function(i, element){
        var x, y;

        if( element.locked() || element.isFullAutoParent() ){
          return false;
        }

        // see if we have a manual position set
        var rcPos = id2manPos[ element.id() ];
        if( rcPos ){
          x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;
          y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;
        
        } else { // otherwise set automatically
        
          while( used(row, col) ){
            moveToNextCell();
          }

          x = col * cellWidth + cellWidth/2 + bb.x1;
          y = row * cellHeight + cellHeight/2 + bb.y1;
          use( row, col );
          
          moveToNextCell();
        }
        
        return { x: x, y: y };
        
      };

      nodes.layoutPositions( this, options, getPos );
    }

    return this; // chaining
    
  };
  
  $$('layout', 'grid', GridLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function NullLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  NullLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles; // elements to consider in the layout
    var layout = this;

    // cy is automatically populated for us in the constructor
    var cy = options.cy; // jshint ignore:line

    layout.trigger('layoutstart');

    // puts all nodes at (0, 0)
    eles.nodes().positions(function(){
      return {
        x: 0,
        y: 0
      };
    });

    // trigger layoutready when each node has had its position set at least once
    layout.one('layoutready', options.ready);
    layout.trigger('layoutready');

    // trigger layoutstop when the layout stops (e.g. finishes)
    layout.one('layoutstop', options.stop);
    layout.trigger('layoutstop');

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  NullLayout.prototype.stop = function(){
    return this; // chaining
  };

  // register the layout
  $$('layout', 'null', NullLayout);

})(cytoscape);
;(function($$){ 'use strict';
  
  var defaults = {
    positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
    zoom: undefined, // the zoom level to set (prob want fit = false if set)
    pan: undefined, // the pan level to set (prob want fit = false if set)
    fit: true, // whether to fit to viewport
    padding: 30, // padding on fit
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function PresetLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  PresetLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles;

    var nodes = eles.nodes();
    var posIsFn = $$.is.fn( options.positions );

    function getPosition(node){
      if( options.positions == null ){
        return null;
      }

      if( posIsFn ){
        return options.positions.apply( node, [ node ] );
      }
      
      var pos = options.positions[node._private.data.id];

      if( pos == null ){
        return null;
      }
      
      return pos;
    }
    
    nodes.layoutPositions(this, options, function(i, node){
      var position = getPosition(node);
      
      if( node.locked() || position == null ){
        return false;
      }
      
      return position;
    });
        
    return this; // chaining
  };
  
  $$('layout', 'preset', PresetLayout);
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function RandomLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  RandomLayout.prototype.run = function(){
    var options = this.options;
    var cy = options.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var getPos = function( i, node ){
      return {
        x: bb.x1 + Math.round( Math.random() * bb.w ),
        y: bb.y1 + Math.round( Math.random() * bb.h )
      };
    };

    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  // register the layout
  $$(
    'layout', // we're registering a layout
    'random', // the layout name
    RandomLayout // the layout prototype
  );
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    random: false, // whether to use random initial positions
    infinite: false, // overrides all other options for a forces-all-the-time mode
    ready: undefined, // callback on layoutready
    stop: undefined, // callback on layoutstop

    // springy forces
    stiffness: 400,
    repulsion: 400,
    damping: 0.5
  };

  function SpringyLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  SpringyLayout.prototype.run = function(){
    var layout = this;
    var self = this;
    var options = this.options;

    $$.util.require('Springy', function(Springy){

      var simUpdatingPos = false;

      var cy = options.cy;
      layout.trigger({ type: 'layoutstart', layout: layout });
      
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
   
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      
      // make a new graph
      var graph = new Springy.Graph();

      // make some nodes
      nodes.each(function(i, node){
        node.scratch('springy', {
          model: graph.newNode({
            element: node
          })
        });
      });

      // connect them with edges
      edges.each(function(i, edge){
        var fdSrc = edge.source().scratch('springy').model;
        var fdTgt = edge.target().scratch('springy').model;
        
        edge.scratch('springy', {
          model: graph.newEdge(fdSrc, fdTgt, {
            element: edge
          })
        });
      });
      
      var sim = window.sim = new Springy.Layout.ForceDirected(graph, options.stiffness, options.repulsion, options.damping);

      if( options.infinite ){
        sim.minEnergyThreshold = -Infinity;
      }

      var currentBB = sim.getBoundingBox();
      // var targetBB = {bottomleft: new Springy.Vector(-2, -2), topright: new Springy.Vector(2, 2)};
      
      // convert to/from screen coordinates
      var toScreen = function(p) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var sx = p.subtract(currentBB.bottomleft).divide(size.x).x * bb.w + bb.x1;
        var sy = p.subtract(currentBB.bottomleft).divide(size.y).y * bb.h + bb.x1;

        return new Springy.Vector(sx, sy);
      };

      var fromScreen = function(s) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var px = ((s.x - bb.x1) / bb.w) * size.x + currentBB.bottomleft.x;
        var py = ((s.y - bb.y1) / bb.h) * size.y + currentBB.bottomleft.y;

        return new Springy.Vector(px, py);
      };
      
      var movedNodes = cy.collection();
      
      var numNodes = cy.nodes().size();
      var drawnNodes = 1;
      var fdRenderer = new Springy.Renderer(sim,
        function clear() {
          if( movedNodes.length > 0 && options.animate ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            movedNodes = cy.collection();

            simUpdatingPos = false;
          }
        },

        function drawEdge(edge, p1, p2) {
          // draw an edge
        },

        function drawNode(node, p) {
          var v = toScreen(p);
          var element = node.data.element;
          
          if( !element.locked() && !element.grabbed() ){
              element._private.position = {
                x: v.x,
                y: v.y
              };
              movedNodes.merge(element);
          } else {
            //setLayoutPositionForElement(element);
          }
          
          if( drawnNodes == numNodes ){
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          } 
          
          drawnNodes++;
        
        }
      );
      
      // set initial node points
      nodes.each(function(i, ele){
        if( !options.random ){
          setLayoutPositionForElement(ele);
        }
      });
      
      // update node positions when dragging
      var dragHandler;
      nodes.on('position', dragHandler = function(){
        if( simUpdatingPos ){ return; }

        setLayoutPositionForElement(this);
      });
      
      function setLayoutPositionForElement(element){
        var fdId = element.scratch('springy').model.id;
        var fdP = fdRenderer.layout.nodePoints[fdId].p;
        var pos = element.position();
        var positionInFd = (pos.x != null && pos.y != null) ? fromScreen(element.position()) : {
          x: Math.random() * 4 - 2,
          y: Math.random() * 4 - 2
        };
        
        fdP.x = positionInFd.x;
        fdP.y = positionInFd.y;
      }
      
      var grabbableNodes = nodes.filter(":grabbable");
      
      function start(){
        // disable grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.ungrabify();
        }
        
        fdRenderer.start();
      }
      
      self.stopSystem = function(){
        graph.filterNodes(function(){
          return false; // remove all nodes
        });
        
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
        
        nodes.off('drag position', dragHandler);

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        self.stopSystem = null;
      };
      
      start();
      if( !options.infinite ){
        setTimeout(function(){
          self.stop();
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  SpringyLayout.prototype.stop = function(){
    if( this.stopSystem != null ){
      this.stopSystem();
    }

    return this; // chaining
  };
  
  $$('layout', 'springy', SpringyLayout);

  
})(cytoscape);

;(function($$){ 'use strict';
    
  function NullRenderer(options){
    this.options = options;
  }
  
  NullRenderer.prototype.recalculateRenderedStyle = function(){
  };

  NullRenderer.prototype.notify = function(){
    // the null renderer does nothing
  };
  
  $$('renderer', 'null', NullRenderer);
  
})( cytoscape );

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/cytoscape/dist/cytoscape.js","/../node_modules/cytoscape/dist")
},{"1YiZ5S":18,"buffer":15}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/index.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer")
},{"1YiZ5S":18,"base64-js":16,"buffer":15,"ieee754":17}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib")
},{"1YiZ5S":18,"buffer":15}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754")
},{"1YiZ5S":18,"buffer":15}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../node_modules/gulp-browserify/node_modules/browserify/node_modules/process/browser.js","/../node_modules/gulp-browserify/node_modules/browserify/node_modules/process")
},{"1YiZ5S":18,"buffer":15}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9qdmlsbGF2ZWNlcy9TaXRlcy9iaW9qcy12aXMtUFNJQ1FVSUNHcmFwaC9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvanMvZmFrZV8yY2U2NjE1OC5qcyIsIi9Vc2Vycy9qdmlsbGF2ZWNlcy9TaXRlcy9iaW9qcy12aXMtUFNJQ1FVSUNHcmFwaC9qcy9wR3JhcGguanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLW1pdGFiL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1pby1taXRhYi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvaW5kZXguanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvZ2xvYmFsL3dpbmRvdy5qcyIsIi9Vc2Vycy9qdmlsbGF2ZWNlcy9TaXRlcy9iaW9qcy12aXMtUFNJQ1FVSUNHcmFwaC9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvZm9yLWVhY2gvbm9kZV9tb2R1bGVzL2lzLWZ1bmN0aW9uL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL3RyaW0vaW5kZXguanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUvZGlzdC9jeXRvc2NhcGUuanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvanZpbGxhdmVjZXMvU2l0ZXMvYmlvanMtdmlzLVBTSUNRVUlDR3JhcGgvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL2p2aWxsYXZlY2VzL1NpdGVzL2Jpb2pzLXZpcy1QU0lDUVVJQ0dyYXBoL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsZ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3c3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmJpb2pzdmlzcHNpY3F1aWMgPSByZXF1aXJlKCcuL3BHcmFwaC5qcycpO1xubW9kdWxlLmV4cG9ydHMgPSBiaW9qc3Zpc3BzaWNxdWljO1xuLy9MaWJyYXJpZXNcbnZhciBwc2ljcXVpYyA9IHJlcXVpcmUoJ2Jpb2pzLXJlc3QtcHNpY3F1aWMnKTtcbnZhciBjeXRvc2NhcGUgPSByZXF1aXJlKCdjeXRvc2NhcGUnKTtcbnZhciBNSVRhYiA9IHJlcXVpcmUoJ2Jpb2pzLWlvLW1pdGFiJyk7XG5cbi8vUHJpdmF0ZSBtZW1iZXJzXG52YXIgX3NlbGVjdG9yID0gJ2JvZHknO1xudmFyIF9kaXYgPSBudWxsO1xuXG4vLyBwc2ljcXVpYyB2YXJzXG52YXIgX3VybCA9ICcnLCBfcHJveHkgPSBudWxsLCBfbWV0aG9kID0gJ3F1ZXJ5JywgX3BhcmFtcyA9IG51bGwsIF9xdWVyeT0nJztcblxudmFyIF9pbml0U2VsZWN0b3IgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgX2RpdiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgIF9kaXYuc3R5bGUubGVmdCA9IDA7XG4gICAgX2Rpdi5zdHlsZS50b3AgPSAwO1xuICAgIF9kaXYuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgX2Rpdi5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgX2Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG59O1xuXG4vLyBQdWJsaWMgbWVtYmVyc1xudmFyIHBHcmFwaCA9IGZ1bmN0aW9uKCl7fTtcblxucEdyYXBoLnVybCA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF91cmw7XG4gICAgX3VybCA9IF87XG4gICAgcmV0dXJuIHBHcmFwaDtcbn07XG5cbnBHcmFwaC5wcm94eSA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9wcm94eTtcbiAgICBfcHJveHkgPSBfO1xuICAgIHJldHVybiBwR3JhcGg7XG59O1xuXG5wR3JhcGgubWV0aG9kID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX21ldGhvZDtcbiAgICBfbWV0aG9kID0gXztcbiAgICByZXR1cm4gcEdyYXBoO1xufTtcblxucEdyYXBoLnBhcmFtcyA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9wYXJhbXM7XG4gICAgX3BhcmFtcyA9IF87XG4gICAgcmV0dXJuIHBHcmFwaDtcbn07XG5cbnBHcmFwaC5xdWVyeSA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9xdWVyeTtcbiAgICBfcXVlcnkgPSBfO1xuICAgIHJldHVybiBwR3JhcGg7XG59O1xuXG5wR3JhcGguc2VsZWN0b3IgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfc2VsZWN0b3I7XG4gICAgXG4gICAgX3NlbGVjdG9yID0gXztcbiAgICByZXR1cm4gcEdyYXBoO1xufTtcblxucEdyYXBoLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoX2RpdiA9PT0gbnVsbCkgX2luaXRTZWxlY3Rvcihfc2VsZWN0b3IpO1xuICAgIFxuICAgIHBzaWNxdWljLnVybChfdXJsKS5wYXJhbXMoX3BhcmFtcykubWV0aG9kKF9tZXRob2QpLnByb3h5KF9wcm94eSkucXVlcnkoX3F1ZXJ5LCBmdW5jdGlvbihlcnIsIHJlc3AsIGJvZHkpe1xuICAgICAgICB2YXIgcGFyc2VkID0gTUlUYWIucGFyc2UoYm9keSk7XG4gICAgICAgIGNvbnNvbGUubG9nKHBhcnNlZCk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBHcmFwaDtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvZmFrZV8yY2U2NjE1OC5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vTGlicmFyaWVzXG52YXIgcHNpY3F1aWMgPSByZXF1aXJlKCdiaW9qcy1yZXN0LXBzaWNxdWljJyk7XG52YXIgY3l0b3NjYXBlID0gcmVxdWlyZSgnY3l0b3NjYXBlJyk7XG52YXIgTUlUYWIgPSByZXF1aXJlKCdiaW9qcy1pby1taXRhYicpO1xuXG4vL1ByaXZhdGUgbWVtYmVyc1xudmFyIF9zZWxlY3RvciA9ICdib2R5JztcbnZhciBfZGl2ID0gbnVsbDtcblxuLy8gcHNpY3F1aWMgdmFyc1xudmFyIF91cmwgPSAnJywgX3Byb3h5ID0gbnVsbCwgX21ldGhvZCA9ICdxdWVyeScsIF9wYXJhbXMgPSBudWxsLCBfcXVlcnk9Jyc7XG5cbnZhciBfaW5pdFNlbGVjdG9yID0gZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgIF9kaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICBfZGl2LnN0eWxlLmxlZnQgPSAwO1xuICAgIF9kaXYuc3R5bGUudG9wID0gMDtcbiAgICBfZGl2LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIF9kaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIF9kaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xufTtcblxuLy8gUHVibGljIG1lbWJlcnNcbnZhciBwR3JhcGggPSBmdW5jdGlvbigpe307XG5cbnBHcmFwaC51cmwgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfdXJsO1xuICAgIF91cmwgPSBfO1xuICAgIHJldHVybiBwR3JhcGg7XG59O1xuXG5wR3JhcGgucHJveHkgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfcHJveHk7XG4gICAgX3Byb3h5ID0gXztcbiAgICByZXR1cm4gcEdyYXBoO1xufTtcblxucEdyYXBoLm1ldGhvZCA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9tZXRob2Q7XG4gICAgX21ldGhvZCA9IF87XG4gICAgcmV0dXJuIHBHcmFwaDtcbn07XG5cbnBHcmFwaC5wYXJhbXMgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfcGFyYW1zO1xuICAgIF9wYXJhbXMgPSBfO1xuICAgIHJldHVybiBwR3JhcGg7XG59O1xuXG5wR3JhcGgucXVlcnkgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfcXVlcnk7XG4gICAgX3F1ZXJ5ID0gXztcbiAgICByZXR1cm4gcEdyYXBoO1xufTtcblxucEdyYXBoLnNlbGVjdG9yID0gZnVuY3Rpb24oXyl7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gX3NlbGVjdG9yO1xuICAgIFxuICAgIF9zZWxlY3RvciA9IF87XG4gICAgcmV0dXJuIHBHcmFwaDtcbn07XG5cbnBHcmFwaC51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIGlmKF9kaXYgPT09IG51bGwpIF9pbml0U2VsZWN0b3IoX3NlbGVjdG9yKTtcbiAgICBcbiAgICBwc2ljcXVpYy51cmwoX3VybCkucGFyYW1zKF9wYXJhbXMpLm1ldGhvZChfbWV0aG9kKS5wcm94eShfcHJveHkpLnF1ZXJ5KF9xdWVyeSwgZnVuY3Rpb24oZXJyLCByZXNwLCBib2R5KXtcbiAgICAgICAgdmFyIHBhcnNlZCA9IE1JVGFiLnBhcnNlKGJvZHkpO1xuICAgICAgICBjb25zb2xlLmxvZyhwYXJzZWQpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwR3JhcGg7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3BHcmFwaC5qc1wiLFwiL1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1JVGFiID0gKGZ1bmN0aW9uKCkge1xuICAgICBcbiAgICB2YXIgbm9kZXMgPSB7fTsgXG4gICAgdmFyIGxpbmtzID0gW107XG4gICAgdmFyIHNjb3JlcyA9IHt9O1xuICAgIHZhciB0ZXh0SW5QYXJlbnRoZXNpcyA9IC9cXCgoLio/KVxcKS87XG4gICAgdmFyIHRleHRJblF1b3RlcyA9IC9cXFwiKC4qPylcXFwiLztcbiAgICB2YXIgdGV4dEluVGF4ID0gL1xcOiguKj8pXFwoLztcbiAgICBcbiAgICAvLyBDcmVhdGVzIGEgbm9kZSBmcm9tIGlkZW50aWZpZXJzLCBhbHRlcm5hdGl2ZSBpZGVuaWZpZXJzLFxuICAgIC8vIGFuZCB0YXhvbm9teSB2YWx1ZXNcbiAgICB2YXIgX2dldE5vZGUgPSBmdW5jdGlvbihpZFN0ciwgYWx0SWRzU3RyLCB0YXhTdHIpe1xuICAgICAgICBcbiAgICAgICAgdmFyIGlkcyA9IF8ubWFwKGlkU3RyLnNwbGl0KCd8JyksIF9tYXBQdWIpO1xuICAgICAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgICAgIGlkOiBpZHNbMF0udmFsdWUsXG4gICAgICAgICAgICBpZHM6IGlkcyxcbiAgICAgICAgICAgIGFsdElkczogXy5tYXAoYWx0SWRzU3RyLnNwbGl0KCd8JyksIF9tYXBQdWIpLFxuICAgICAgICAgICAgdGF4b25vbXk6IF8udW5pcShfLm1hcCh0YXhTdHIuc3BsaXQoJ3wnKSwgX21hcFRheG9ub215KSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGFyc2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIGFuIGludGVyYWN0aW9uXG4gICAgdmFyIF9wYXJzZSA9IGZ1bmN0aW9uKGxpbmUsIGkpe1xuICAgICAgICBcbiAgICAgICAgaWYgKCEgXy5pc1N0cmluZyhsaW5lKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNSVRhYiBjYW5ub3QgcGFyc2UgbGluZSAnICsgaSk7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBmaWVsZHMgPSBsaW5lLnNwbGl0KCdcXHQnKTtcbiAgICAgICAgXG4gICAgICAgIGlmKGZpZWxkcy5sZW5ndGggPCAxNSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNSVRhYiBjYW5ub3QgcGFyc2UgbGluZSAnICsgaSk7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBub2RlQSA9IF9nZXROb2RlKGZpZWxkc1swXSwgZmllbGRzWzJdLCBmaWVsZHNbOV0pO1xuICAgICAgICB2YXIgbm9kZUIgPSBfZ2V0Tm9kZShmaWVsZHNbMV0sIGZpZWxkc1szXSwgZmllbGRzWzEwXSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgc291cmNlOiBub2RlQS5pZCxcbiAgICAgICAgICAgIHRhcmdldDogbm9kZUIuaWQsXG4gICAgICAgICAgICBkZXRNZXRob2RzOiBfLm1hcChmaWVsZHNbNl0uc3BsaXQoJ3wnKSwgX21hcEZpZWxkKSxcbiAgICAgICAgICAgIGZpcnN0QXV0aG9yOiBmaWVsZHNbN10uc3BsaXQoJ3wnKSxcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uczogXy5tYXAoZmllbGRzWzhdLnNwbGl0KCd8JyksIF9tYXBQdWIpLFxuICAgICAgICAgICAgaW50VHlwZXM6IF8ubWFwKGZpZWxkc1sxMV0uc3BsaXQoJ3wnKSwgX21hcEZpZWxkKSxcbiAgICAgICAgICAgIHNvdXJjZURiczogXy5tYXAoZmllbGRzWzEyXS5zcGxpdCgnfCcpLCBfbWFwRmllbGQpLFxuICAgICAgICAgICAgaW50SWRzIDogXy5tYXAoZmllbGRzWzEzXS5zcGxpdCgnfCcpLCBfbWFwUHViKSxcbiAgICAgICAgICAgIHNjb3JlczogXy5tYXAoZmllbGRzWzE0XS5zcGxpdCgnfCcpLCBfbWFwU2NvcmUpXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBub2Rlc1tub2RlQS5pZF0gPSBub2RlQTtcbiAgICAgICAgbm9kZXNbbm9kZUIuaWRdID0gbm9kZUI7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb247XG4gICAgfVxuICAgIFxuICAgIHZhciBfbWFwU2NvcmUgPSBmdW5jdGlvbihzY29yZVN0cil7XG4gICAgICAgIHZhciBhcnIgPSBzY29yZVN0ci5zcGxpdCgnOicpLCBzY29yZSA9IHtuYW1lOmFyclswXSwgc2NvcmU6K2FyclsxXX07XG4gICAgICAgIFxuICAgICAgICBfYWRkU2NvcmUoc2NvcmUpO1xuICAgICAgICByZXR1cm4gc2NvcmU7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgX21hcEZpZWxkID0gZnVuY3Rpb24oZmllbGRTdHIpe1xuICAgICAgICBpZihmaWVsZFN0ci5tYXRjaCh0ZXh0SW5RdW90ZXMpID09IG51bGwgfHwgZmllbGRTdHIubWF0Y2godGV4dEluUGFyZW50aGVzaXMpID09IG51bGwpe1xuICAgICAgICAgICAgdmFyIGFyciA9IGZpZWxkU3RyLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICByZXR1cm4ge25hbWU6YXJyWzBdLCBzY29yZTphcnJbMV19O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7bmFtZTpmaWVsZFN0ci5tYXRjaCh0ZXh0SW5RdW90ZXMpWzFdLCB2YWx1ZTpmaWVsZFN0ci5tYXRjaCh0ZXh0SW5QYXJlbnRoZXNpcylbMV19O1xuICAgIH07XG4gICAgXG4gICAgdmFyIF9tYXBQdWIgPSBmdW5jdGlvbihwdWJTdHIpe1xuICAgICAgICB2YXIgYXJyID0gcHViU3RyLnNwbGl0KCc6Jyk7XG4gICAgICAgIHJldHVybiB7bmFtZTphcnJbMF0sIHZhbHVlOmFyclsxXX07XG4gICAgfTtcbiAgICBcbiAgICB2YXIgX21hcFRheG9ub215ID0gZnVuY3Rpb24odGF4U3RyKXtcbiAgICAgICAgaWYodGF4U3RyICE9ICctJyl7XG4gICAgICAgICAgICByZXR1cm4gKHRheFN0ci5tYXRjaCh0ZXh0SW5UYXgpID09IG51bGwpID8gdGF4U3RyLnNwbGl0KCc6JylbMV0gOiB0YXhTdHIubWF0Y2godGV4dEluVGF4KVsxXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIF9hZGRTY29yZSA9IGZ1bmN0aW9uKHNjb3JlKXtcbiAgICAgICAgaWYoICFfLmlzTmFOKHNjb3JlLnNjb3JlKSAmJiBfLmlzTnVtYmVyKHNjb3JlLnNjb3JlKSl7XG4gICAgICAgICAgICBpZihfLmhhcyhzY29yZXMsIHNjb3JlLm5hbWUpKXtcbiAgICAgICAgICAgICAgICBpZihzY29yZXNbc2NvcmUubmFtZV0ubWluID4gc2NvcmUuc2NvcmUpIHNjb3Jlc1tzY29yZS5uYW1lXS5taW4gPSBzY29yZS5zY29yZTtcbiAgICAgICAgICAgICAgICBpZihzY29yZXNbc2NvcmUubmFtZV0ubWF4IDwgc2NvcmUuc2NvcmUpIHNjb3Jlc1tzY29yZS5uYW1lXS5tYXggPSBzY29yZS5zY29yZTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHNjb3Jlc1tzY29yZS5uYW1lXSA9IHtuYW1lOnNjb3JlLm5hbWUsIG1pbjpzY29yZS5zY29yZSwgbWF4OnNjb3JlLnNjb3JlfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gTUlUYWIoKSB7fVxuICAgIFxuICAgIE1JVGFiLnBhcnNlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICBcbiAgICAgICAgaWYgKCEgXy5pc1N0cmluZyh0ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgJ01JVGFiIGNhbm5vdCBwYXJzZSAnICsgdHlwZW9mIHRleHQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzXG4gICAgICAgIG5vZGVzID0ge307IFxuICAgICAgICBsaW5rcyA9IFtdO1xuICAgICAgICBzY29yZXMgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIHZhciBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGludGVyYWN0aW9ucyA9IF8ucmVqZWN0KF8ubWFwKGxpbmVzLCBfcGFyc2UpLCBfLmlzRW1wdHkpO1xuICAgICAgICB2YXIgbm9kZXZhbCA9IF8udmFsdWVzKG5vZGVzKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5rczogaW50ZXJhY3Rpb25zLFxuICAgICAgICAgICAgbm9kZXM6IG5vZGV2YWwsXG4gICAgICAgICAgICBpZHM6IF8ucGx1Y2sobm9kZXZhbCwgJ2lkJyksXG4gICAgICAgICAgICB0YXhhOiBfLmNvbXBhY3QoXy5yZWR1Y2Uobm9kZXZhbCwgZnVuY3Rpb24obWVtbyxuKXsgcmV0dXJuIF8udW5pb24obWVtbyxuLnRheG9ub215KX0sW10pKSxcbiAgICAgICAgICAgIHNjb3JlczogXy52YWx1ZXMoc2NvcmVzKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIE1JVGFiO1xufSkoKTtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLW1pdGFiL2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLW1pdGFiXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjJcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjguMic7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XG4gIH07XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuICAvLyBzcGFyc2UgYXJyYXktbGlrZXMgYXMgaWYgdGhleSB3ZXJlIGRlbnNlLlxuICBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuICBmdW5jdGlvbiBjcmVhdGVSZWR1Y2UoZGlyKSB7XG4gICAgLy8gT3B0aW1pemVkIGl0ZXJhdG9yIGZ1bmN0aW9uIGFzIHVzaW5nIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAvLyBpbiB0aGUgbWFpbiBmdW5jdGlvbiB3aWxsIGRlb3B0aW1pemUgdGhlLCBzZWUgIzE5OTEuXG4gICAgZnVuY3Rpb24gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCkge1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgICBtZW1vID0gaXRlcmF0ZWUobWVtbywgb2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgNCk7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICAgIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpbml0aWFsIHZhbHVlIGlmIG5vbmUgaXMgcHJvdmlkZWQuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gKipSZWR1Y2UqKiBidWlsZHMgdXAgYSBzaW5nbGUgcmVzdWx0IGZyb20gYSBsaXN0IG9mIHZhbHVlcywgYWthIGBpbmplY3RgLFxuICAvLyBvciBgZm9sZGxgLlxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGNyZWF0ZVJlZHVjZSgxKTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgXy5yZWR1Y2VSaWdodCA9IF8uZm9sZHIgPSBjcmVhdGVSZWR1Y2UoLTEpO1xuXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBrZXk7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGtleSA9IF8uZmluZEluZGV4KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gXy5maW5kS2V5KG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKGtleSAhPT0gdm9pZCAwICYmIGtleSAhPT0gLTEpIHJldHVybiBvYmpba2V5XTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyB0aGF0IHBhc3MgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBzZWxlY3RgLlxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cbiAgXy5yZWplY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubmVnYXRlKGNiKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cbiAgXy5ldmVyeSA9IF8uYWxsID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAoIXByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXG4gIF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0LCBmcm9tSW5kZXgpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIHRhcmdldCwgdHlwZW9mIGZyb21JbmRleCA9PSAnbnVtYmVyJyAmJiBmcm9tSW5kZXgpID49IDA7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXTtcbiAgICAgIHJldHVybiBmdW5jID09IG51bGwgPyBmdW5jIDogZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgbWFwYDogZmV0Y2hpbmcgYSBwcm9wZXJ0eS5cbiAgXy5wbHVjayA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ud2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVyKGF0dHJzKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gLUluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA+IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gLUluZmluaXR5ICYmIHJlc3VsdCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA8IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFNodWZmbGUgYSBjb2xsZWN0aW9uLCB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHNldCA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBzZXQubGVuZ3RoO1xuICAgIHZhciBzaHVmZmxlZCA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmFuZCA9IF8ucmFuZG9tKDAsIGluZGV4KTtcbiAgICAgIGlmIChyYW5kICE9PSBpbmRleCkgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbcmFuZF07XG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBzaHVmZmxlZDtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbi5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICByZXR1cm4gXy5zaHVmZmxlKG9iaikuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbikpO1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRlZS5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgcmV0dXJuIF8ucGx1Y2soXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcbiAgfSk7XG5cbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxuICAvLyB3aGVuIHlvdSBrbm93IHRoYXQgeW91ciBpbmRleCB2YWx1ZXMgd2lsbCBiZSB1bmlxdWUuXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH0pO1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XSsrOyBlbHNlIHJlc3VsdFtrZXldID0gMTtcbiAgfSk7XG5cbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHtcbiAgICAgIChwcmVkaWNhdGUodmFsdWUsIGtleSwgb2JqKSA/IHBhc3MgOiBmYWlsKS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Bhc3MsIGZhaWxdO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XG4gICAgcmV0dXJuIF8uaW5pdGlhbChhcnJheSwgYXJyYXkubGVuZ3RoIC0gbik7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgbGFzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEVzcGVjaWFsbHkgdXNlZnVsIG9uXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSAobiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pKSk7XG4gIH07XG5cbiAgLy8gR2V0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGxhc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIF8uaWRlbnRpdHkpO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBzdGFydEluZGV4KSB7XG4gICAgdmFyIG91dHB1dCA9IFtdLCBpZHggPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4IHx8IDAsIGxlbmd0aCA9IGlucHV0ICYmIGlucHV0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2ldLFxuICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSwgaSwgYXJyYXkpIDogdmFsdWU7XG4gICAgICBpZiAoaXNTb3J0ZWQpIHtcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IGNvbXB1dGVkKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHNlZW4sIGNvbXB1dGVkKSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFfLmNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bmlxKGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgJ2xlbmd0aCcpLmxlbmd0aCB8fCAwO1xuICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IF8ucGx1Y2soYXJyYXksIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxuICAvLyB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBsaXN0ICYmIGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuIGl0ZW0gaW4gYW4gYXJyYXksXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxuICAvLyBmb3IgKippc1NvcnRlZCoqIHRvIHVzZSBiaW5hcnkgc2VhcmNoLlxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcbiAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5ICYmIGFycmF5Lmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdudW1iZXInKSB7XG4gICAgICBpID0gaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQ7XG4gICAgfSBlbHNlIGlmIChpc1NvcnRlZCAmJiBsZW5ndGgpIHtcbiAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgIHJldHVybiBhcnJheVtpXSA9PT0gaXRlbSA/IGkgOiAtMTtcbiAgICB9XG4gICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgIHJldHVybiBfLmZpbmRJbmRleChzbGljZS5jYWxsKGFycmF5LCBpKSwgXy5pc05hTik7XG4gICAgfVxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIF8ubGFzdEluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgZnJvbSkge1xuICAgIHZhciBpZHggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgaWYgKHR5cGVvZiBmcm9tID09ICdudW1iZXInKSB7XG4gICAgICBpZHggPSBmcm9tIDwgMCA/IGlkeCArIGZyb20gKyAxIDogTWF0aC5taW4oaWR4LCBmcm9tICsgMSk7XG4gICAgfVxuICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICByZXR1cm4gXy5maW5kTGFzdEluZGV4KHNsaWNlLmNhbGwoYXJyYXksIDAsIGlkeCksIF8uaXNOYU4pO1xuICAgIH1cbiAgICB3aGlsZSAoLS1pZHggPj0gMCkgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpbmRJbmRleCBhbmQgZmluZExhc3RJbmRleCBmdW5jdGlvbnNcbiAgZnVuY3Rpb24gY3JlYXRlSW5kZXhGaW5kZXIoZGlyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgIT0gbnVsbCAmJiBhcnJheS5sZW5ndGg7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZUluZGV4RmluZGVyKDEpO1xuXG4gIF8uZmluZExhc3RJbmRleCA9IGNyZWF0ZUluZGV4RmluZGVyKC0xKTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgdmFyIHZhbHVlID0gaXRlcmF0ZWUob2JqKTtcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG4gICAgXG4gICAgLy8gSW5pdGlhbGl6aW5nIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIC8vIEl0J3MgZG9uZSBoZXJlIHNpbmNlIHdlIG9ubHkgbmVlZCB0aGVtIGZvciBvYmplY3RzIGFuZCBhcnJheXMgY29tcGFyaXNvbi5cbiAgICBhU3RhY2sgPSBhU3RhY2sgfHwgW107XG4gICAgYlN0YWNrID0gYlN0YWNrIHx8IFtdO1xuICAgIHZhciBsZW5ndGggPSBhU3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXG4gICAgICAvLyB1bmlxdWUgbmVzdGVkIHN0cnVjdHVyZXMuXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PT0gYjtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG5cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICBpZiAoYXJlQXJyYXlzKSB7XG4gICAgICAvLyBDb21wYXJlIGFycmF5IGxlbmd0aHMgdG8gZGV0ZXJtaW5lIGlmIGEgZGVlcCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeS5cbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIERlZXAgY29tcGFyZSB0aGUgY29udGVudHMsIGlnbm9yaW5nIG5vbi1udW1lcmljIHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgaWYgKCFlcShhW2xlbmd0aF0sIGJbbGVuZ3RoXSwgYVN0YWNrLCBiU3RhY2spKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgdmFyIGtleXMgPSBfLmtleXMoYSksIGtleTtcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMgYmVmb3JlIGNvbXBhcmluZyBkZWVwIGVxdWFsaXR5LlxuICAgICAgaWYgKF8ua2V5cyhiKS5sZW5ndGggIT09IGxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxuICAgICAgICBrZXkgPSBrZXlzW2xlbmd0aF07XG4gICAgICAgIGlmICghKF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnBvcCgpO1xuICAgIGJTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBQZXJmb3JtIGEgZGVlcCBjb21wYXJpc29uIHRvIGNoZWNrIGlmIHR3byBvYmplY3RzIGFyZSBlcXVhbC5cbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBlcShhLCBiKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSAmJiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopIHx8IF8uaXNBcmd1bWVudHMob2JqKSkpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xuICAgIHJldHVybiBfLmtleXMob2JqKS5sZW5ndGggPT09IDA7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSBhbiBvYmplY3Q/XG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHNvbWUgaXNUeXBlIG1ldGhvZHM6IGlzQXJndW1lbnRzLCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXIsIGlzRGF0ZSwgaXNSZWdFeHAsIGlzRXJyb3IuXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJywgJ0Vycm9yJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmhhcyhvYmosICdjYWxsZWUnKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBzb21lIHR5cGVvZiBidWdzIGluIG9sZCB2OCxcbiAgLy8gSUUgMTEgKCMxNjIxKSwgYW5kIGluIFNhZmFyaSA4ICgjMTkyOSkuXG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0Jykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIGlzRmluaXRlKG9iaikgJiYgIWlzTmFOKHBhcnNlRmxvYXQob2JqKSk7XG4gIH07XG5cbiAgLy8gSXMgdGhlIGdpdmVuIHZhbHVlIGBOYU5gPyAoTmFOIGlzIHRoZSBvbmx5IG51bWJlciB3aGljaCBkb2VzIG5vdCBlcXVhbCBpdHNlbGYpLlxuICBfLmlzTmFOID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdGVlcy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFByZWRpY2F0ZS1nZW5lcmF0aW5nIGZ1bmN0aW9ucy4gT2Z0ZW4gdXNlZnVsIG91dHNpZGUgb2YgVW5kZXJzY29yZS5cbiAgXy5jb25zdGFudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH07XG5cbiAgXy5ub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gIF8ucHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgXG4gIC8vIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLm1hdGNoZXIgPSBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xuICAgIGF0dHJzID0gXy5leHRlbmRPd24oe30sIGF0dHJzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5pc01hdGNoKG9iaiwgYXR0cnMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUnVuIGEgZnVuY3Rpb24gKipuKiogdGltZXMuXG4gIF8udGltZXMgPSBmdW5jdGlvbihuLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdGVlKGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBBIChwb3NzaWJseSBmYXN0ZXIpIHdheSB0byBnZXQgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGFzIGFuIGludGVnZXIuXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9O1xuXG4gICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZXNjYXBlTWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjeDI3OycsXG4gICAgJ2AnOiAnJiN4NjA7J1xuICB9O1xuICB2YXIgdW5lc2NhcGVNYXAgPSBfLmludmVydChlc2NhcGVNYXApO1xuXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbihtYXApIHtcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcbiAgICB9O1xuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZFxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XG4gICAgICByZXR1cm4gdGVzdFJlZ2V4cC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZXBsYWNlUmVnZXhwLCBlc2NhcGVyKSA6IHN0cmluZztcbiAgICB9O1xuICB9O1xuICBfLmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIoZXNjYXBlTWFwKTtcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xuXG4gIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgbmFtZWQgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0IHdpdGggdGhlXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxuICBfLnJlc3VsdCA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHksIGZhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB2b2lkIDAgOiBvYmplY3RbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IGZhbGxiYWNrO1xuICAgIH1cbiAgICByZXR1cm4gXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwob2JqZWN0KSA6IHZhbHVlO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXG4gICAgZXNjYXBlICAgICAgOiAvPCUtKFtcXHNcXFNdKz8pJT4vZ1xuICB9O1xuXG4gIC8vIFdoZW4gY3VzdG9taXppbmcgYHRlbXBsYXRlU2V0dGluZ3NgLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byBkZWZpbmUgYW5cbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cbiAgdmFyIG5vTWF0Y2ggPSAvKC4pXi87XG5cbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbiAgLy8gc3RyaW5nIGxpdGVyYWwuXG4gIHZhciBlc2NhcGVzID0ge1xuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAgICdcXFxcJzogICAgICdcXFxcJyxcbiAgICAnXFxyJzogICAgICdyJyxcbiAgICAnXFxuJzogICAgICduJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgdmFyIGVzY2FwZUNoYXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcbiAgfTtcblxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxuICAvLyBVbmRlcnNjb3JlIHRlbXBsYXRpbmcgaGFuZGxlcyBhcmJpdHJhcnkgZGVsaW1pdGVycywgcHJlc2VydmVzIHdoaXRlc3BhY2UsXG4gIC8vIGFuZCBjb3JyZWN0bHkgZXNjYXBlcyBxdW90ZXMgd2l0aGluIGludGVycG9sYXRlZCBjb2RlLlxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gIF8udGVtcGxhdGUgPSBmdW5jdGlvbih0ZXh0LCBzZXR0aW5ncywgb2xkU2V0dGluZ3MpIHtcbiAgICBpZiAoIXNldHRpbmdzICYmIG9sZFNldHRpbmdzKSBzZXR0aW5ncyA9IG9sZFNldHRpbmdzO1xuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XG5cbiAgICAvLyBDb21iaW5lIGRlbGltaXRlcnMgaW50byBvbmUgcmVndWxhciBleHByZXNzaW9uIHZpYSBhbHRlcm5hdGlvbi5cbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXG4gICAgICAoc2V0dGluZ3MuZXNjYXBlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXG4gICAgXS5qb2luKCd8JykgKyAnfCQnLCAnZycpO1xuXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xuICAgICAgc291cmNlICs9IHRleHQuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShlc2NhcGVyLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgdmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIHJlbmRlci5jYWxsKHRoaXMsIGRhdGEsIF8pO1xuICAgIH07XG5cbiAgICAvLyBQcm92aWRlIHRoZSBjb21waWxlZCBzb3VyY2UgYXMgYSBjb252ZW5pZW5jZSBmb3IgcHJlY29tcGlsYXRpb24uXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyBhcmd1bWVudCArICcpe1xcbicgKyBzb3VyY2UgKyAnfSc7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH07XG5cbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBfKG9iaik7XG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgLy8gT09QXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxuICAvLyBjYW4gYmUgdXNlZCBPTy1zdHlsZS4gVGhpcyB3cmFwcGVyIGhvbGRzIGFsdGVyZWQgdmVyc2lvbnMgb2YgYWxsIHRoZVxuICAvLyB1bmRlcnNjb3JlIGZ1bmN0aW9ucy4gV3JhcHBlZCBvYmplY3RzIG1heSBiZSBjaGFpbmVkLlxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb250aW51ZSBjaGFpbmluZyBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgdmFyIHJlc3VsdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQodGhpcywgZnVuYy5hcHBseShfLCBhcmdzKSk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cbiAgXy5taXhpbihfKTtcblxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ2NvbmNhdCcsICdqb2luJywgJ3NsaWNlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB1bndyYXBwaW5nIHByb3h5IGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XG4gIFxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1pby1taXRhYi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLWlvLW1pdGFiL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIHhociA9IHJlcXVpcmUoJ25ldHMnKVxuXG52YXIgX3VybCA9ICcnLCBfcHJveHkgPSBudWxsLCBfbWV0aG9kID0gJ3F1ZXJ5JywgX3BhcmFtcyA9IG51bGw7XG5cbi8vUHJpdmF0ZSBtZW1iZXJzXG52YXIgX2ZldGNoID0gZnVuY3Rpb24odXJsLCBjYWxsYmFjayl7XG4gICAgeGhyKHtcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIG1ldGhvZDogJ0dFVCdcbiAgICB9LCBcbiAgICBjYWxsYmFjaylcbn1cblxudmFyIF9ldmFsX3BhcmFtcyA9IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGlmKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9ZWxzZSBpZih0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0Jyl7XG4gICAgICAgIGZvcih2YXIga2V5IGluIHBhcmFtcyl7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KGtleSkpIHN0ciArPSBrZXkrJz0nK3BhcmFtc1trZXldKycmJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuXG52YXIgX2NyZWF0ZVVybCA9IGZ1bmN0aW9uKG1ldGhvZCwgcXVlcnksIHBhcmFtcyl7XG4gICAgXG4gICAgdmFyIHBhcmFtc1N0ciA9ICcnOyBcbiAgICBpZihwYXJhbXMgIT09IG51bGwpXG4gICAgICAgIHBhcmFtc1N0ciA9ICc/JytfZXZhbF9wYXJhbXMocGFyYW1zKTtcbiAgICBcbiAgICB2YXIgdXJsID0gX3VybCsnLycrbWV0aG9kKycvJytxdWVyeStwYXJhbXNTdHI7XG4gICAgdXJsID0gdXJsLnJlcGxhY2UoJy8vJyttZXRob2QsICcvJyttZXRob2QpXG4gICAgXG4gICAgaWYoX3Byb3h5ID09PSBudWxsKSByZXR1cm4gdXJsO1xuICAgIFxuICAgIHJldHVybiBfcHJvY2Vzc1Byb3h5KHVybCk7XG59XG5cbnZhciBfcHJvY2Vzc1Byb3h5ID0gZnVuY3Rpb24odXJsKXtcbiAgICBpZiAodHlwZW9mIF9wcm94eSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIF9wcm94eSh1cmwpO1xuICAgIFxuICAgIGlmKHR5cGVvZiBfcHJveHkgPT09ICdzdHJpbmcnKSByZXR1cm4gX3Byb3h5ICsnP3VybD0nK3VybDtcbiAgICBcbiAgICByZXR1cm4gdXJsO1xufVxuXG4vL1B1YmxpYyBtZW1iZXJzXG52YXIgcHNpY3F1aWNTZXJ2ZXIgPSBmdW5jdGlvbigpe31cbiAgICBcbnBzaWNxdWljU2VydmVyLnVybCA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF91cmw7XG4gICAgX3VybCA9IF87XG4gICAgcmV0dXJuIHBzaWNxdWljU2VydmVyO1xufTtcblxucHNpY3F1aWNTZXJ2ZXIucHJveHkgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfcHJveHk7XG4gICAgX3Byb3h5ID0gXztcbiAgICByZXR1cm4gcHNpY3F1aWNTZXJ2ZXI7XG59O1xuXG5wc2ljcXVpY1NlcnZlci5tZXRob2QgPSBmdW5jdGlvbihfKXtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBfbWV0aG9kO1xuICAgIF9tZXRob2QgPSBfO1xuICAgIHJldHVybiBwc2ljcXVpY1NlcnZlcjtcbn07XG5cbnBzaWNxdWljU2VydmVyLnBhcmFtcyA9IGZ1bmN0aW9uKF8pe1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIF9wYXJhbXM7XG4gICAgX3BhcmFtcyA9IF87XG4gICAgcmV0dXJuIHBzaWNxdWljU2VydmVyO1xufTtcblxucHNpY3F1aWNTZXJ2ZXIucXVlcnkgPSBmdW5jdGlvbihxdWVyeSwgY2FsbGJhY2spe1xuICAgIHZhciB1cmwgPSBfY3JlYXRlVXJsKF9tZXRob2QsIHF1ZXJ5LCBfcGFyYW1zKTtcbiAgICBfZmV0Y2godXJsLCBjYWxsYmFjayk7XG59O1xuXG5wc2ljcXVpY1NlcnZlci5jb3VudCA9IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjayl7XG4gICAgdmFyIHVybCA9IF9jcmVhdGVVcmwoX21ldGhvZCwgcXVlcnksIHtmb3JtYXQ6J2NvdW50J30pO1xuICAgIF9mZXRjaCh1cmwsIGNhbGxiYWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwc2ljcXVpY1NlcnZlcjtcbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpY1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciByZXEgPSByZXF1aXJlKCdyZXF1ZXN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBOZXRzXG5cbmZ1bmN0aW9uIE5ldHModXJpLCBvcHRzLCBjYikge1xuICByZXEodXJpLCBvcHRzLCBjYilcbn1cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0c1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciB3aW5kb3cgPSByZXF1aXJlKFwiZ2xvYmFsL3dpbmRvd1wiKVxudmFyIG9uY2UgPSByZXF1aXJlKFwib25jZVwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJ3BhcnNlLWhlYWRlcnMnKVxuXG52YXIgbWVzc2FnZXMgPSB7XG4gICAgXCIwXCI6IFwiSW50ZXJuYWwgWE1MSHR0cFJlcXVlc3QgRXJyb3JcIixcbiAgICBcIjRcIjogXCI0eHggQ2xpZW50IEVycm9yXCIsXG4gICAgXCI1XCI6IFwiNXh4IFNlcnZlciBFcnJvclwiXG59XG5cbnZhciBYSFIgPSB3aW5kb3cuWE1MSHR0cFJlcXVlc3QgfHwgbm9vcFxudmFyIFhEUiA9IFwid2l0aENyZWRlbnRpYWxzXCIgaW4gKG5ldyBYSFIoKSkgPyBYSFIgOiB3aW5kb3cuWERvbWFpblJlcXVlc3RcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcblxuZnVuY3Rpb24gY3JlYXRlWEhSKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7IHVyaTogb3B0aW9ucyB9XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spXG5cbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgfHwgbnVsbFxuXG4gICAgaWYgKCF4aHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29ycyB8fCBvcHRpb25zLnVzZVhEUikge1xuICAgICAgICAgICAgeGhyID0gbmV3IFhEUigpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgeGhyID0gbmV3IFhIUigpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdXJpID0geGhyLnVybCA9IG9wdGlvbnMudXJpIHx8IG9wdGlvbnMudXJsXG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIga2V5XG4gICAgdmFyIGxvYWQgPSBvcHRpb25zLnJlc3BvbnNlID8gbG9hZFJlc3BvbnNlIDogbG9hZFhoclxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvclxuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIC8vIGhhdGUgSUVcbiAgICB4aHIub250aW1lb3V0ID0gbm9vcFxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGlmIChvcHRpb25zLndpdGhDcmVkZW50aWFscyB8fCAob3B0aW9ucy5jb3JzICYmIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzICE9PSBmYWxzZSkpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgeGhyLnRpbWVvdXQgPSBcInRpbWVvdXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy50aW1lb3V0IDogNTAwMFxuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIilcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cbiAgICBcbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJiBcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgeGhyLnNlbmQoYm9keSlcblxuICAgIHJldHVybiB4aHJcblxuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgbG9hZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gbnVsbFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIXhoci5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IHhoci5yZXNwb25zZVhNTFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgZ2V0dGluZyBhIG5vbmUtb2sgc3RhdHVzQ29kZSwgYnVpbGQgJiByZXR1cm4gYW4gZXJyb3JcbiAgICBmdW5jdGlvbiBlcnJvckZyb21TdGF0dXNDb2RlKHN0YXR1cywgYm9keSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBudWxsXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDAgfHwgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAodHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIgPyBib2R5IDogZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbU3RyaW5nKHN0YXR1cykuY2hhckF0KDApXVxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgICAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSBzdGF0dXNcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlcnJvclxuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkUmVzcG9uc2UoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBnZXRTdGF0dXNDb2RlKClcbiAgICAgICAgdmFyIGJvZHkgPSBnZXRCb2R5KClcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JGcm9tU3RhdHVzQ29kZShzdGF0dXMsIGJvZHkpXG4gICAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIHJhdzogeGhyXG4gICAgICAgIH1cbiAgICAgICAgaWYoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycyl7IC8vcmVtZW1iZXIgeGhyIGNhbiBpbiBmYWN0IGJlIFhEUiBmb3IgQ09SUyBpbiBJRVxuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSlcbiAgICB9XG5cbiAgICAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgYW5kIGFkZCBzb21lIHJlc3BvbnNlIHByb3BlcnRpZXMgdG8gdGhlIHNvdXJjZSB4aHJcbiAgICAvLyBhbmQgdGhlbiByZXNwb25kIHdpdGggdGhhdFxuICAgIGZ1bmN0aW9uIGxvYWRYaHIoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBnZXRTdGF0dXNDb2RlKClcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JGcm9tU3RhdHVzQ29kZShzdGF0dXMpXG5cbiAgICAgICAgeGhyLnN0YXR1cyA9IHhoci5zdGF0dXNDb2RlID0gc3RhdHVzXG4gICAgICAgIHhoci5ib2R5ID0gZ2V0Qm9keSgpXG4gICAgICAgIHhoci5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcblxuICAgICAgICBjYWxsYmFjayhlcnJvciwgeGhyLCB4aHIuYm9keSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihldnQpIHtcbiAgICAgICAgY2FsbGJhY2soZXZ0LCB4aHIpXG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBzZWxmO1xufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9O1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9nbG9iYWxcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5tb2R1bGUuZXhwb3J0cyA9IG9uY2Vcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuXG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9vbmNlXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGlzRnVuY3Rpb24gPSByZXF1aXJlKCdpcy1mdW5jdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaFxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG5cbmZ1bmN0aW9uIGZvckVhY2gobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWlzRnVuY3Rpb24oaXRlcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2l0ZXJhdG9yIG11c3QgYmUgYSBmdW5jdGlvbicpXG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzXG4gICAgfVxuICAgIFxuICAgIGlmICh0b1N0cmluZy5jYWxsKGxpc3QpID09PSAnW29iamVjdCBBcnJheV0nKVxuICAgICAgICBmb3JFYWNoQXJyYXkobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZSBpZiAodHlwZW9mIGxpc3QgPT09ICdzdHJpbmcnKVxuICAgICAgICBmb3JFYWNoU3RyaW5nKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2VcbiAgICAgICAgZm9yRWFjaE9iamVjdChsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbn1cblxuZnVuY3Rpb24gZm9yRWFjaEFycmF5KGFycmF5LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgaSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgYXJyYXlbaV0sIGksIGFycmF5KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoU3RyaW5nKHN0cmluZywgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIC8vIG5vIHN1Y2ggdGhpbmcgYXMgYSBzcGFyc2Ugc3RyaW5nLlxuICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHN0cmluZy5jaGFyQXQoaSksIGksIHN0cmluZylcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hPYmplY3Qob2JqZWN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGsgaW4gb2JqZWN0KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgaykpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqZWN0W2tdLCBrLCBvYmplY3QpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvZm9yLWVhY2gvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb24vaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvYmlvanMtcmVzdC1wc2ljcXVpYy9ub2RlX21vZHVsZXMvbmV0cy9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy9mb3ItZWFjaC9ub2RlX21vZHVsZXMvaXMtZnVuY3Rpb25cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRyaW07XG5cbmZ1bmN0aW9uIHRyaW0oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKnxcXHMqJC9nLCAnJyk7XG59XG5cbmV4cG9ydHMubGVmdCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJyk7XG59O1xuXG5leHBvcnRzLnJpZ2h0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9ub2RlX21vZHVsZXMvdHJpbS9pbmRleC5qc1wiLFwiLy4uL25vZGVfbW9kdWxlcy9iaW9qcy1yZXN0LXBzaWNxdWljL25vZGVfbW9kdWxlcy9uZXRzL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL3RyaW1cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgdHJpbSA9IHJlcXVpcmUoJ3RyaW0nKVxuICAsIGZvckVhY2ggPSByZXF1aXJlKCdmb3ItZWFjaCcpXG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcbiAgICAgICAgICAsIGtleSA9IHRyaW0ocm93LnNsaWNlKDAsIGluZGV4KSkudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICwgdmFsdWUgPSB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuXG4gICAgICAgIGlmICh0eXBlb2YocmVzdWx0W2tleV0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHJlc3VsdFtrZXldKSkge1xuICAgICAgICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBbIHJlc3VsdFtrZXldLCB2YWx1ZSBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn1cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVycy9wYXJzZS1oZWFkZXJzLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2Jpb2pzLXJlc3QtcHNpY3F1aWMvbm9kZV9tb2R1bGVzL25ldHMvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvcGFyc2UtaGVhZGVyc1wiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qIVxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2YgQ3l0b3NjYXBlLmpzIDIuMy45LlxuICogXG4gKiBDeXRvc2NhcGUuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlXG4gKiBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueVxuICogbGF0ZXIgdmVyc2lvbi5cbiAqIFxuICogQ3l0b3NjYXBlLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXG4gKiBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTU1xuICogRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZVxuICogZGV0YWlscy5cbiAqIFxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFsb25nIHdpdGhcbiAqIEN5dG9zY2FwZS5qcy4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG4gXG5cbi8vIHRoaXMgaXMgcHV0IGFzIGEgZ2xvYmFsIHZhciBpbiB0aGUgYnJvd3NlclxuLy8gb3IgaXQncyBqdXN0IGEgZ2xvYmFsIHRvIHRoaXMgbW9kdWxlIGlmIGNvbW1vbmpzXG5cbnZhciBjeXRvc2NhcGU7XG5cbihmdW5jdGlvbih3aW5kb3cpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gdGhlIG9iamVjdCBpdGVzZWxmIGlzIGEgZnVuY3Rpb24gdGhhdCBpbml0J3MgYW4gaW5zdGFuY2Ugb2YgY3l0b3NjYXBlXG5cbiAgdmFyICQkID0gY3l0b3NjYXBlID0gZnVuY3Rpb24oKXsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgcmV0dXJuIGN5dG9zY2FwZS5pbml0LmFwcGx5KGN5dG9zY2FwZSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAkJC52ZXJzaW9uID0gJzIuMy45JztcbiAgXG4gIC8vIGFsbG93IGZ1bmN0aW9uYWwgYWNjZXNzIHRvIGN5dG9zY2FwZS5qc1xuICAvLyBlLmcuIHZhciBjeXRvID0gJC5jeXRvc2NhcGUoeyBzZWxlY3RvcjogXCIjZm9vXCIsIC4uLiB9KTtcbiAgLy8gICAgICB2YXIgbm9kZXMgPSBjeXRvLm5vZGVzKCk7XG4gICQkLmluaXQgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIFxuICAgIC8vIGlmIG5vIG9wdGlvbnMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdFxuICAgIGlmKCBvcHRpb25zID09PSB1bmRlZmluZWQgKXtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgaW5zdGFuY2VcbiAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoIG9wdGlvbnMgKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5Db3JlKCBvcHRpb25zICk7XG4gICAgfSBcbiAgICBcbiAgICAvLyBhbGxvdyBmb3IgcmVnaXN0cmF0aW9uIG9mIGV4dGVuc2lvbnNcbiAgICAvLyBlLmcuICQuY3l0b3NjYXBlKCdyZW5kZXJlcicsICdzdmcnLCBTdmdSZW5kZXJlcik7XG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVzaGFwZScsICdlbGxpcHNlJywgU3ZnRWxsaXBzZU5vZGVTaGFwZSk7XG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgnY29yZScsICdkb1NvbWV0aGluZycsIGZ1bmN0aW9uKCl7IC8qIGRvU29tZXRoaW5nIGNvZGUgKi8gfSk7XG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgnY29sbGVjdGlvbicsICdkb1NvbWV0aGluZycsIGZ1bmN0aW9uKCl7IC8qIGRvU29tZXRoaW5nIGNvZGUgKi8gfSk7XG4gICAgZWxzZSBpZiggJCQuaXMuc3RyaW5nKCBvcHRpb25zICkgKSB7XG4gICAgICByZXR1cm4gJCQuZXh0ZW5zaW9uLmFwcGx5KCQkLmV4dGVuc2lvbiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZGVmaW5lIHRoZSBmdW5jdGlvbiBuYW1lc3BhY2UgaGVyZSwgc2luY2UgaXQgaGFzIG1lbWJlcnMgaW4gbWFueSBwbGFjZXNcbiAgJCQuZm4gPSB7fTtcblxuICBpZiggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMgKXsgLy8gZXhwb3NlIGFzIGEgY29tbW9uanMgbW9kdWxlXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjeXRvc2NhcGU7XG4gIH1cblxuICBpZiggdHlwZW9mIGRlZmluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZGVmaW5lLmFtZCApeyAvLyBleHBvc2UgYXMgYW4gYW1kL3JlcXVpcmVqcyBtb2R1bGVcbiAgICBkZWZpbmUoJ2N5dG9zY2FwZScsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gY3l0b3NjYXBlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIGFsd2F5cyByZWdpc3RlciBpbiB0aGUgd2luZG93IGp1c3QgaW4gY2FzZSAoZS5nLiB3LyBkZXJieWpzKVxuICBpZiggd2luZG93ICl7XG4gICAgd2luZG93LmN5dG9zY2FwZSA9IGN5dG9zY2FwZTtcbiAgfVxuICBcbn0pKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuLy8gdHlwZSB0ZXN0aW5nIHV0aWxpdHkgZnVuY3Rpb25zXG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5pcyA9IHtcbiAgICBkZWZpbmVkOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsOyAvLyBub3QgdW5kZWZpbmVkIG9yIG51bGxcbiAgICB9LFxuXG4gICAgc3RyaW5nOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT0gdHlwZW9mICcnO1xuICAgIH0sXG4gICAgXG4gICAgZm46IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mIGZ1bmN0aW9uKCl7fTtcbiAgICB9LFxuICAgIFxuICAgIGFycmF5OiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5KG9iaikgOiBvYmogIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiBBcnJheTtcbiAgICB9LFxuICAgIFxuICAgIHBsYWluT2JqZWN0OiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiB7fSAmJiAhJCQuaXMuYXJyYXkob2JqKSAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbiAgICB9LFxuICAgIFxuICAgIG51bWJlcjogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgMSAmJiAhaXNOYU4ob2JqKTtcbiAgICB9LFxuXG4gICAgaW50ZWdlcjogZnVuY3Rpb24oIG9iaiApe1xuICAgICAgcmV0dXJuICQkLmlzLm51bWJlcihvYmopICYmIE1hdGguZmxvb3Iob2JqKSA9PT0gb2JqO1xuICAgIH0sXG4gICAgXG4gICAgY29sb3I6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mICcnICYmICQuQ29sb3Iob2JqKS50b1N0cmluZygpICE9PSAnJztcbiAgICB9LFxuICAgIFxuICAgIGJvb2w6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mIHRydWU7XG4gICAgfSxcbiAgICBcbiAgICBlbGVtZW50T3JDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuICQkLmlzLmVsZW1lbnQob2JqKSB8fCAkJC5pcy5jb2xsZWN0aW9uKG9iaik7XG4gICAgfSxcbiAgICBcbiAgICBlbGVtZW50OiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLkVsZW1lbnQgJiYgb2JqLl9wcml2YXRlLnNpbmdsZTtcbiAgICB9LFxuICAgIFxuICAgIGNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuQ29sbGVjdGlvbiAmJiAhb2JqLl9wcml2YXRlLnNpbmdsZTtcbiAgICB9LFxuICAgIFxuICAgIGNvcmU6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuQ29yZTtcbiAgICB9LFxuXG4gICAgc3R5bGU6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuU3R5bGU7XG4gICAgfSxcblxuICAgIHN0eWxlc2hlZXQ6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuU3R5bGVzaGVldDtcbiAgICB9LFxuXG4gICAgZXZlbnQ6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuRXZlbnQ7XG4gICAgfSxcblxuICAgIGVtcHR5U3RyaW5nOiBmdW5jdGlvbihvYmope1xuICAgICAgaWYoICFvYmogKXsgLy8gbnVsbCBpcyBlbXB0eVxuICAgICAgICByZXR1cm4gdHJ1ZTsgXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhvYmopICl7XG4gICAgICAgIGlmKCBvYmogPT09ICcnIHx8IG9iai5tYXRjaCgvXlxccyskLykgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZW1wdHkgc3RyaW5nIGlzIGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvdGhlcndpc2UsIHdlIGRvbid0IGtub3cgd2hhdCB3ZSd2ZSBnb3RcbiAgICB9LFxuICAgIFxuICAgIG5vbmVtcHR5U3RyaW5nOiBmdW5jdGlvbihvYmope1xuICAgICAgaWYoIG9iaiAmJiAkJC5pcy5zdHJpbmcob2JqKSAmJiBvYmogIT09ICcnICYmICFvYmoubWF0Y2goL15cXHMrJC8pICl7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGRvbUVsZW1lbnQ6IGZ1bmN0aW9uKG9iail7XG4gICAgICBpZiggdHlwZW9mIEhUTUxFbGVtZW50ID09PSAndW5kZWZpbmVkJyApe1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIG5vdCBpbiBhIGJyb3dzZXIgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYm91bmRpbmdCb3g6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gJCQuaXMucGxhaW5PYmplY3Qob2JqKSAmJiBcbiAgICAgICAgJCQuaXMubnVtYmVyKG9iai54MSkgJiYgJCQuaXMubnVtYmVyKG9iai54MikgJiZcbiAgICAgICAgJCQuaXMubnVtYmVyKG9iai55MSkgJiYgJCQuaXMubnVtYmVyKG9iai55MilcbiAgICAgIDtcbiAgICB9LFxuXG4gICAgdG91Y2g6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gd2luZG93ICYmICggKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoICk7XG4gICAgfSxcblxuICAgIGdlY2tvOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcgfHwgKCdNb3pBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpO1xuICAgIH0sXG5cbiAgICB3ZWJraXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIHdlYmtpdFVSTCAhPT0gJ3VuZGVmaW5lZCcgfHwgKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpO1xuICAgIH0sXG5cbiAgICBjaHJvbWl1bTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgY2hyb21lICE9PSAndW5kZWZpbmVkJztcbiAgICB9LFxuXG4gICAga2h0bWw6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gbmF2aWdhdG9yLnZlbmRvci5tYXRjaCgva2RlL2kpOyAvLyBUT0RPIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuICAgIH0sXG5cbiAgICBraHRtbEV0YzogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiAkJC5pcy5raHRtbCgpIHx8ICQkLmlzLndlYmtpdCgpIHx8ICQkLmlzLmJsaW5rKCk7XG4gICAgfSxcblxuICAgIHRyaWRlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgcmV0dXJuIHR5cGVvZiBBY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJyB8fCAvKkBjY19vbiFAKi9mYWxzZTtcbiAgICB9LFxuXG4gICAgd2luZG93czogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvV2luL2kpO1xuICAgIH0sXG5cbiAgICBtYWM6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL01hYy9pKTtcbiAgICB9LFxuXG4gICAgbGludXg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL0xpbnV4L2kpO1xuICAgIH0sXG5cbiAgICB1bml4OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9YMTEvaSk7XG4gICAgfVxuICB9OyAgXG4gIFxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIHV0aWxpdHkgZnVuY3Rpb25zIG9ubHkgZm9yIGludGVybmFsIHVzZVxuXG4gICQkLnV0aWwgPSB7XG5cbiAgICAvLyB0aGUganF1ZXJ5IGV4dGVuZCgpIGZ1bmN0aW9uXG4gICAgLy8gTkI6IG1vZGlmaWVkIHRvIHVzZSAkJC5pcyBldGMgc2luY2Ugd2UgY2FuJ3QgdXNlIGpxdWVyeSBmdW5jdGlvbnNcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGkgPSAxLFxuICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBkZWVwID0gZmFsc2U7XG5cbiAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICAgIGlmICggdHlwZW9mIHRhcmdldCA9PT0gJ2Jvb2xlYW4nICkge1xuICAgICAgICBkZWVwID0gdGFyZ2V0O1xuICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgICAgIC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgaSA9IDI7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JyAmJiAhJCQuaXMuZm4odGFyZ2V0KSApIHtcbiAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgICAgaWYgKCBsZW5ndGggPT09IGkgKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC0taTtcbiAgICAgIH1cblxuICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgaWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICBzcmMgPSB0YXJnZXRbIG5hbWUgXTtcbiAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICBpZiAoIGRlZXAgJiYgY29weSAmJiAoICQkLmlzLnBsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9ICQkLmlzLmFycmF5KGNvcHkpKSApICkge1xuICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICkge1xuICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgJCQuaXMuYXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgJCQuaXMucGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG4gICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gJCQudXRpbC5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLy8gcmVxdWlyZSB0aGF0IHB1bGxzIGluIG1vZHVsZSBmcm9tIGNvbW1vbmpzLCBhbWQsIG9yIHdpbmRvdyAoZmFsbGluZyBiYWNrIHVudGlsIGZvdW5kKVxuICAgIHJlcXVpcmU6IGZ1bmN0aW9uKCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucyApe1xuICAgICAgdmFyIHJldDtcbiAgICAgIG9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7XG4gICAgICAgIG1zZ0lmTm90Rm91bmQ6IHRydWVcbiAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgdmFyIGZ1bGZpbCA9IGZ1bmN0aW9uKCByZXQgKXtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCByZXQgKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGVja1dpbmRvdyA9IGZ1bmN0aW9uKCBuZXh0ICl7XG4gICAgICAgIGlmKCB3aW5kb3cgKXsgLy8gZGV0ZWN0ZWQgYnJvd3Nlci93aW5kb3cgZW52XG4gICAgICAgICAgcmV0ID0gd2luZG93WyBuYW1lIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgZnVsZmlsKHJldCk7IH1cbiAgICAgICAgaWYoIG5leHQgKXsgbmV4dCgpOyB9XG4gICAgICB9O1xuICAgICAgdmFyIG9uQ2hlY2tXaW5kb3dEb25lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoICFkb25lICl7XG4gICAgICAgICAgY2hlY2tDb21tb25Kcyggb25DaGVja0NvbW1vbkpzRG9uZSApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2tDb21tb25KcyA9IGZ1bmN0aW9uKCBuZXh0ICl7XG4gICAgICAgIGlmKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyAmJiByZXF1aXJlICl7IC8vIGRldGVjdGVkIGNvbW1vbmpzIGVudlxuICAgICAgICAgIHJldCA9IHJlcXVpcmUoIG5hbWUgKTsgLy8gcmVndWxhciByZXF1aXJlXG4gICAgICAgIH1cblxuICAgICAgICBpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgZnVsZmlsKHJldCk7IH1cbiAgICAgICAgaWYoIG5leHQgKXsgbmV4dCgpOyB9XG4gICAgICB9O1xuICAgICAgdmFyIG9uQ2hlY2tDb21tb25Kc0RvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggIWRvbmUgKXtcbiAgICAgICAgICBjaGVja0FtZCggb25DaGVja0FtZERvbmUgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGNoZWNrQW1kID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgICAgaWYoIHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQgJiYgcmVxdWlyZSApeyAvLyBkZXRlY3RlZCBhbWQgZW52IHcvIGRlZmluZWQgbW9kdWxlXG4gICAgICAgICAgcmVxdWlyZShbIG5hbWUgXSwgZnVuY3Rpb24oIG5hbWVJbXBsICl7XG4gICAgICAgICAgICByZXQgPSBuYW1lSW1wbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIHJldCAhPT0gdW5kZWZpbmVkICl7IGZ1bGZpbChyZXQpOyB9XG4gICAgICAgICAgICBpZiggbmV4dCApeyBuZXh0KCk7IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBvbkNoZWNrQW1kRG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCAhZG9uZSAmJiBvcHRpb25zLm1zZ0lmTm90Rm91bmQgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdDeXRvc2NhcGUuanMgdHJpZWQgdG8gcHVsbCBpbiBkZXBlbmRlbmN5IGAnICsgbmFtZSArICdgIGJ1dCBubyBtb2R1bGUgKGkuZS4gQ29tbW9uSlMsIEFNRCwgb3Igd2luZG93KSB3YXMgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8ga2ljayBvZmYgMXN0IGNoZWNrOiB3aW5kb3dcbiAgICAgIGNoZWNrV2luZG93KCBvbkNoZWNrV2luZG93RG9uZSApO1xuXG4gICAgfSxcblxuICAgIC8vIG11bHRpcGxlIHJlcXVpcmVzIGluIG9uZSBjYWxsYmFja1xuICAgIHJlcXVpcmVzOiBmdW5jdGlvbiggbmFtZXMsIGNhbGxiYWNrICl7XG4gICAgICB2YXIgaW1wbHMgPSBbXTtcbiAgICAgIHZhciBnb3RJbXBsID0gW107XG5cbiAgICAgIHZhciBjaGVja0RvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrICl7IC8vIGNoZWNrIGhhdmUgYWxsIGltcGxzXG4gICAgICAgICAgaWYoICFnb3RJbXBsW2ldICl7IHJldHVybjsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBhbGwgZ290IGFsbCBpbXBscyA9PiBkb25lXG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KCBjYWxsYmFjaywgaW1wbHMgKTsgXG4gICAgICB9O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrICl7IChmdW5jdGlvbigpeyAvLyB3L3Njb3BlXG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIHZhciBpbmRleCA9IGk7XG5cbiAgICAgICAgJCQudXRpbC5yZXF1aXJlKG5hbWUsIGZ1bmN0aW9uKGltcGwpe1xuICAgICAgICAgIGltcGxzW2luZGV4XSA9IGltcGw7XG4gICAgICAgICAgZ290SW1wbFtpbmRleF0gPSB0cnVlO1xuXG4gICAgICAgICAgY2hlY2tEb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoKTsgfVxuICAgIH0sXG5cbiAgICAvLyBwb3J0ZWQgbG9kYXNoIHRocm90dGxlIGZ1bmN0aW9uXG4gICAgdGhyb3R0bGU6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgb3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgICAgIG9wdGlvbnMudHJhaWxpbmcgPSB0cmFpbGluZztcblxuICAgICAgcmV0dXJuICQkLnV0aWwuZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIG5vdzogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgICB9LFxuXG4gICAgLy8gcG9ydGVkIGxvZGFzaCBkZWJvdW5jZSBmdW5jdGlvblxuICAgIGRlYm91bmNlOiBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyxcbiAgICAgICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoISQkLmlzLmZuKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSBNYXRoLm1heCgwLCB3YWl0KSB8fCAwO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICgkJC5pcy5wbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKE1hdGgubWF4KHdhaXQsIG9wdGlvbnMubWF4V2FpdCkgfHwgMCk7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGRlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAoJCQudXRpbC5ub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gJCQudXRpbC5ub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9ICQkLnV0aWwubm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN0YW1wID0gJCQudXRpbC5ub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwO1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBlcnJvcjogZnVuY3Rpb24oIG1zZyApe1xuICAgICAgaWYoIGNvbnNvbGUgKXtcbiAgICAgICAgaWYoIGNvbnNvbGUuZXJyb3IgKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcbiAgICAgICAgfSBlbHNlIGlmKCBjb25zb2xlLmxvZyApe1xuICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBtc2c7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG1zZztcbiAgICAgIH1cbiAgICB9LCAgICBcblxuICAgIGNsb25lOiBmdW5jdGlvbiggb2JqICl7XG4gICAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAoIG9iai5oYXNPd25Qcm9wZXJ0eShpKSApIHsgLy8gVE9ETyBpcyB0aGlzIGhhc093blByb3BlcnR5KCkgY2FsbCBuZWNlc3NhcnkgZm9yIG91ciB1c2U/XG4gICAgICAgICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvLyBnZXRzIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcmd1bWVudFxuICAgIGNvcHk6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICAgIGlmKCBvYmogPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSBpZiggJCQuaXMuYXJyYXkob2JqKSApe1xuICAgICAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG9iaikgKXtcbiAgICAgICAgcmV0dXJuICQkLnV0aWwuY2xvbmUoIG9iaiApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIC8vIG1ha2VzIGEgZnVsbCBiYiAoeDEsIHkxLCB4MiwgeTIsIHcsIGgpIGZyb20gaW1wbGljaXQgcGFyYW1zXG4gICAgbWFrZUJvdW5kaW5nQm94OiBmdW5jdGlvbiggYmIgKXtcbiAgICAgIGlmKCBiYi54MSAhPSBudWxsICYmIGJiLnkxICE9IG51bGwgKXtcbiAgICAgICAgaWYoIGJiLngyICE9IG51bGwgJiYgYmIueTIgIT0gbnVsbCAmJiBiYi54MiA+PSBiYi54MSAmJiBiYi55MiA+PSBiYi55MSApe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MTogYmIueDEsXG4gICAgICAgICAgICB5MTogYmIueTEsXG4gICAgICAgICAgICB4MjogYmIueDIsXG4gICAgICAgICAgICB5MjogYmIueTIsXG4gICAgICAgICAgICB3OiBiYi54MiAtIGJiLngxLFxuICAgICAgICAgICAgaDogYmIueTIgLSBiYi55MVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiggYmIudyAhPSBudWxsICYmIGJiLmggIT0gbnVsbCAmJiBiYi53ID49IDAgJiYgYmIuaCA+PSAwICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgICAgIHgyOiBiYi54MSArIGJiLncsXG4gICAgICAgICAgICB5MjogYmIueTEgKyBiYi5oLFxuICAgICAgICAgICAgdzogYmIudyxcbiAgICAgICAgICAgIGg6IGJiLmhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IFxuICAgIH0sXG5cbiAgICAvLyBoYXMgYW55dGhpbmcgYmVlbiBzZXQgaW4gdGhlIG1hcFxuICAgIG1hcEVtcHR5OiBmdW5jdGlvbiggbWFwICl7XG4gICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuXG4gICAgICBpZiggbWFwICE9IG51bGwgKXtcbiAgICAgICAgZm9yKHZhciBpIGluIG1hcCl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0sXG5cbiAgICAvLyBwdXNoZXMgdG8gdGhlIGFycmF5IGF0IHRoZSBlbmQgb2YgYSBtYXAgKG1hcCBtYXkgbm90IGJlIGJ1aWx0KVxuICAgIHB1c2hNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgYXJyYXkgPSAkJC51dGlsLmdldE1hcChvcHRpb25zKTtcblxuICAgICAgaWYoIGFycmF5ID09IG51bGwgKXsgLy8gaWYgZW1wdHksIHB1dCBpbml0aWFsIGFycmF5XG4gICAgICAgICQkLnV0aWwuc2V0TWFwKCAkLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgIHZhbHVlOiBbIG9wdGlvbnMudmFsdWUgXVxuICAgICAgICB9KSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXkucHVzaCggb3B0aW9ucy52YWx1ZSApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBzZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCAobWFwIG1heSBub3QgYmUgYnVpbHQpXG4gICAgc2V0TWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgICAgdmFyIGtleTtcbiAgICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdUcmllZCB0byBzZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGkgPCBrZXlzLmxlbmd0aCAtIDEgKXtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBleHRlbmQgdGhlIG1hcCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBpZiggb2JqW2tleV0gPT0gbnVsbCApe1xuICAgICAgICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgICAgIG9ialtrZXldID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgLy8gZ2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgZXZlbiBpZiBpdCdzIG5vdCBidWlsdCBpbiBwbGFjZXNcbiAgICBnZXRNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgICBcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspe1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignVHJpZWQgdG8gZ2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgICAgaWYoIG9iaiA9PSBudWxsICl7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvLyBkZWxldGVzIHRoZSBlbnRyeSBpbiB0aGUgbWFwXG4gICAgZGVsZXRlTWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGtlZXBDaGlsZHJlbiA9IG9wdGlvbnMua2VlcENoaWxkcmVuO1xuICAgICAgXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1RyaWVkIHRvIGRlbGV0ZSBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdEtleSA9IGkgPT09IG9wdGlvbnMua2V5cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiggbGFzdEtleSApe1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBrZWVwQ2hpbGRyZW4gKXsgLy8gdGhlbiBvbmx5IGRlbGV0ZSBjaGlsZCBmaWVsZHMgbm90IGluIGtlZXBDaGlsZHJlblxuICAgICAgICAgICAgZm9yKCB2YXIgY2hpbGQgaW4gb2JqICl7XG4gICAgICAgICAgICAgIGlmKCAha2VlcENoaWxkcmVuW2NoaWxkXSApe1xuICAgICAgICAgICAgICAgIG9ialtjaGlsZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGNhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cil7XG4gICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoc3RyKSApe1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgICB9LFxuXG4gICAgY2FtZWwyZGFzaDogZnVuY3Rpb24oIHN0ciApe1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgY2ggPSBzdHJbaV07XG4gICAgICAgIHZhciBjaExvd2VyQ2FzZSA9IGNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBpc1VwcGVyQ2FzZSA9IGNoICE9PSBjaExvd2VyQ2FzZTtcblxuICAgICAgICBpZiggaXNVcHBlckNhc2UgKXtcbiAgICAgICAgICByZXQucHVzaCggJy0nICk7XG4gICAgICAgICAgcmV0LnB1c2goIGNoTG93ZXJDYXNlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LnB1c2goIGNoICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vVXBwZXJDYXNlcyA9IHJldC5sZW5ndGggPT09IHN0ci5sZW5ndGg7XG4gICAgICBpZiggbm9VcHBlckNhc2VzICl7IHJldHVybiBzdHI7IH0gLy8gY2hlYXBlciB0aGFuIC5qb2luKClcblxuICAgICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgZGFzaDJjYW1lbDogZnVuY3Rpb24oIHN0ciApe1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgdmFyIG5leHRJc1VwcGVyID0gZmFsc2U7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICAgICAgdmFyIGlzRGFzaCA9IGNoID09PSAnLSc7XG5cbiAgICAgICAgaWYoIGlzRGFzaCApe1xuICAgICAgICAgIG5leHRJc1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiggbmV4dElzVXBwZXIgKXtcbiAgICAgICAgICAgIHJldC5wdXNoKCBjaC50b1VwcGVyQ2FzZSgpICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldC5wdXNoKCBjaCApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHRJc1VwcGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gc3RyaXAgc3BhY2VzIGZyb20gYmVnaW5uaW5nIG9mIHN0cmluZyBhbmQgZW5kIG9mIHN0cmluZ1xuICAgIHRyaW06IGZ1bmN0aW9uKCBzdHIgKXtcbiAgICAgIHZhciBmaXJzdCwgbGFzdDtcblxuICAgICAgLy8gZmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuICAgICAgZm9yKCBmaXJzdCA9IDA7IGZpcnN0IDwgc3RyLmxlbmd0aCAmJiBzdHJbZmlyc3RdID09PSAnICc7IGZpcnN0KysgKXt9XG5cbiAgICAgIC8vIGZpbmQgbGFzdCBub24tc3BhY2UgY2hhclxuICAgICAgZm9yKCBsYXN0ID0gc3RyLmxlbmd0aCAtIDE7IGxhc3QgPiBmaXJzdCAmJiBzdHJbbGFzdF0gPT09ICcgJzsgbGFzdC0tICl7fVxuXG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhmaXJzdCwgbGFzdCArIDEpO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgW3IsIGcsIGJdIGZyb20gI2FiYyBvciAjYWFiYmNjXG4gICAgaGV4MnR1cGxlOiBmdW5jdGlvbiggaGV4ICl7XG4gICAgICBpZiggIShoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHx8IGhleFswXSAhPT0gXCIjXCIgKXsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBzaG9ydEhleCA9IGhleC5sZW5ndGggPT09IDQ7XG4gICAgICB2YXIgciwgZywgYjtcbiAgICAgIHZhciBiYXNlID0gMTY7XG5cbiAgICAgIGlmKCBzaG9ydEhleCApe1xuICAgICAgICByID0gcGFyc2VJbnQoIGhleFsxXSArIGhleFsxXSwgYmFzZSApO1xuICAgICAgICBnID0gcGFyc2VJbnQoIGhleFsyXSArIGhleFsyXSwgYmFzZSApO1xuICAgICAgICBiID0gcGFyc2VJbnQoIGhleFszXSArIGhleFszXSwgYmFzZSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHBhcnNlSW50KCBoZXhbMV0gKyBoZXhbMl0sIGJhc2UgKTtcbiAgICAgICAgZyA9IHBhcnNlSW50KCBoZXhbM10gKyBoZXhbNF0sIGJhc2UgKTtcbiAgICAgICAgYiA9IHBhcnNlSW50KCBoZXhbNV0gKyBoZXhbNl0sIGJhc2UgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIGhzbCgwLCAwLCAwKSBvciBoc2xhKDAsIDAsIDAsIDApXG4gICAgaHNsMnR1cGxlOiBmdW5jdGlvbiggaHNsICl7XG4gICAgICB2YXIgcmV0O1xuICAgICAgdmFyIGgsIHMsIGwsIGEsIHIsIGcsIGI7XG4gICAgICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpe1xuICAgICAgICBpZih0IDwgMCkgdCArPSAxO1xuICAgICAgICBpZih0ID4gMSkgdCAtPSAxO1xuICAgICAgICBpZih0IDwgMS82KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgICAgaWYodCA8IDEvMikgcmV0dXJuIHE7XG4gICAgICAgIGlmKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyAkJC51dGlsLnJlZ2V4LmhzbGEgKyBcIiRcIikuZXhlYyhoc2wpO1xuICAgICAgaWYoIG0gKXtcblxuICAgICAgICAvLyBnZXQgaHVlXG4gICAgICAgIGggPSBwYXJzZUludCggbVsxXSApOyBcbiAgICAgICAgaWYoIGggPCAwICl7XG4gICAgICAgICAgaCA9ICggMzYwIC0gKC0xKmggJSAzNjApICkgJSAzNjA7XG4gICAgICAgIH0gZWxzZSBpZiggaCA+IDM2MCApe1xuICAgICAgICAgIGggPSBoICUgMzYwO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gMzYwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgICAgcyA9IHBhcnNlRmxvYXQoIG1bMl0gKTtcbiAgICAgICAgaWYoIHMgPCAwIHx8IHMgPiAxMDAgKXsgcmV0dXJuOyB9IC8vIHNhdHVyYXRpb24gaXMgWzAsIDEwMF1cbiAgICAgICAgcyA9IHMvMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgICAgbCA9IHBhcnNlRmxvYXQoIG1bM10gKTtcbiAgICAgICAgaWYoIGwgPCAwIHx8IGwgPiAxMDAgKXsgcmV0dXJuOyB9IC8vIGxpZ2h0bmVzcyBpcyBbMCwgMTAwXVxuICAgICAgICBsID0gbC8xMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgICBhID0gbVs0XTtcbiAgICAgICAgaWYoIGEgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KCBhICk7XG5cbiAgICAgICAgICBpZiggYSA8IDAgfHwgYSA+IDEgKXsgcmV0dXJuOyB9IC8vIGFscGhhIGlzIFswLCAxXVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93LCBjb252ZXJ0IHRvIHJnYlxuICAgICAgICAvLyBjb2RlIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuICAgICAgICBpZiggcyA9PT0gMCApe1xuICAgICAgICAgIHIgPSBnID0gYiA9IE1hdGgucm91bmQobCAqIDI1NSk7IC8vIGFjaHJvbWF0aWNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgICAgciA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCArIDEvMykgKTtcbiAgICAgICAgICBnID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYihwLCBxLCBoKSApO1xuICAgICAgICAgIGIgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKHAsIHEsIGggLSAxLzMpICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBbciwgZywgYiwgYV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSByZ2IoMCwgMCwgMCkgb3IgcmdiYSgwLCAwLCAwLCAwKVxuICAgIHJnYjJ0dXBsZTogZnVuY3Rpb24oIHJnYiApe1xuICAgICAgdmFyIHJldDtcblxuICAgICAgdmFyIG0gPSBuZXcgUmVnRXhwKFwiXlwiICsgJCQudXRpbC5yZWdleC5yZ2JhICsgXCIkXCIpLmV4ZWMocmdiKTtcbiAgICAgIGlmKCBtICl7XG4gICAgICAgIHJldCA9IFtdO1xuXG4gICAgICAgIHZhciBpc1BjdCA9IFtdO1xuICAgICAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAzOyBpKysgKXtcbiAgICAgICAgICB2YXIgY2hhbm5lbCA9IG1baV07XG5cbiAgICAgICAgICBpZiggY2hhbm5lbFsgY2hhbm5lbC5sZW5ndGggLSAxIF0gPT09IFwiJVwiICl7XG4gICAgICAgICAgICBpc1BjdFtpXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYW5uZWwgPSBwYXJzZUZsb2F0KCBjaGFubmVsICk7XG5cbiAgICAgICAgICBpZiggaXNQY3RbaV0gKXtcbiAgICAgICAgICAgIGNoYW5uZWwgPSBjaGFubmVsLzEwMCAqIDI1NTsgLy8gbm9ybWFsaXNlIHRvIFswLCAyNTVdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGNoYW5uZWwgPCAwIHx8IGNoYW5uZWwgPiAyNTUgKXsgcmV0dXJuOyB9IC8vIGludmFsaWQgY2hhbm5lbCB2YWx1ZVxuXG4gICAgICAgICAgcmV0LnB1c2goIE1hdGguZmxvb3IoY2hhbm5lbCkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdExlYXN0T25lSXNQY3QgPSBpc1BjdFsxXSB8fCBpc1BjdFsyXSB8fCBpc1BjdFszXTtcbiAgICAgICAgdmFyIGFsbEFyZVBjdCA9IGlzUGN0WzFdICYmIGlzUGN0WzJdICYmIGlzUGN0WzNdO1xuICAgICAgICBpZiggYXRMZWFzdE9uZUlzUGN0ICYmICFhbGxBcmVQY3QgKXsgcmV0dXJuOyB9IC8vIG11c3QgYWxsIGJlIHBlcmNlbnQgdmFsdWVzIGlmIG9uZSBpc1xuXG4gICAgICAgIHZhciBhbHBoYSA9IG1bNF07XG4gICAgICAgIGlmKCBhbHBoYSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KCBhbHBoYSApO1xuXG4gICAgICAgICAgaWYoIGFscGhhIDwgMCB8fCBhbHBoYSA+IDEgKXsgcmV0dXJuOyB9IC8vIGludmFsaWQgYWxwaGEgdmFsdWVcblxuICAgICAgICAgIHJldC5wdXNoKCBhbHBoYSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIGNvbG9ybmFtZTJ0dXBsZTogZnVuY3Rpb24oIGNvbG9yICl7XG4gICAgICByZXR1cm4gJCQudXRpbC5jb2xvcnNbIGNvbG9yLnRvTG93ZXJDYXNlKCkgXTtcbiAgICB9LFxuXG4gICAgY29sb3IydHVwbGU6IGZ1bmN0aW9uKCBjb2xvciApe1xuICAgICAgcmV0dXJuICggJCQuaXMuYXJyYXkoY29sb3IpID8gY29sb3IgOiBudWxsICkgXG4gICAgICAgIHx8ICQkLnV0aWwuY29sb3JuYW1lMnR1cGxlKGNvbG9yKVxuICAgICAgICB8fCAkJC51dGlsLmhleDJ0dXBsZShjb2xvcilcbiAgICAgICAgfHwgJCQudXRpbC5yZ2IydHVwbGUoY29sb3IpXG4gICAgICAgIHx8ICQkLnV0aWwuaHNsMnR1cGxlKGNvbG9yKTtcbiAgICB9LFxuXG4gICAgdHVwbGUyaGV4OiBmdW5jdGlvbiggdHVwbGUgKXtcbiAgICAgIHZhciByID0gdHVwbGVbMF07XG4gICAgICB2YXIgZyA9IHR1cGxlWzFdO1xuICAgICAgdmFyIGIgPSB0dXBsZVsyXTtcblxuICAgICAgZnVuY3Rpb24gY2gyaGV4KCBjaCApe1xuICAgICAgICB2YXIgaGV4ID0gY2gudG9TdHJpbmcoMTYpO1xuXG4gICAgICAgIGlmKCBoZXgubGVuZ3RoID09PSAxICl7XG4gICAgICAgICAgaGV4ID0gJzAnICsgaGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcjJyArIGNoMmhleChyKSArIGNoMmhleChnKSArIGNoMmhleChiKTtcbiAgICB9LFxuXG4gICAgY29sb3JzOiB7XG4gICAgICAvLyBzcGVjaWFsIGNvbG91ciBuYW1lc1xuICAgICAgdHJhbnNwYXJlbnQ6ICAgICAgWzAsMCwwLDBdLCAvLyBOQiBhbHBoYSA9PT0gMFxuXG4gICAgICAvLyByZWd1bGFyIGNvbG91cnNcbiAgICAgIGFsaWNlYmx1ZTogICAgICAgIFsyNDAsMjQ4LDI1NV0sXG4gICAgICBhbnRpcXVld2hpdGU6ICAgICAgWzI1MCwyMzUsMjE1XSxcbiAgICAgIGFxdWE6ICAgICAgICAgIFswLDI1NSwyNTVdLFxuICAgICAgYXF1YW1hcmluZTogICAgICAgIFsxMjcsMjU1LDIxMl0sXG4gICAgICBhenVyZTogICAgICAgICAgWzI0MCwyNTUsMjU1XSxcbiAgICAgIGJlaWdlOiAgICAgICAgICBbMjQ1LDI0NSwyMjBdLFxuICAgICAgYmlzcXVlOiAgICAgICAgICBbMjU1LDIyOCwxOTZdLFxuICAgICAgYmxhY2s6ICAgICAgICAgIFswLDAsMF0sXG4gICAgICBibGFuY2hlZGFsbW9uZDogICAgICBbMjU1LDIzNSwyMDVdLFxuICAgICAgYmx1ZTogICAgICAgICAgWzAsMCwyNTVdLFxuICAgICAgYmx1ZXZpb2xldDogICAgICAgIFsxMzgsNDMsMjI2XSxcbiAgICAgIGJyb3duOiAgICAgICAgICBbMTY1LDQyLDQyXSxcbiAgICAgIGJ1cmx5d29vZDogICAgICAgIFsyMjIsMTg0LDEzNV0sXG4gICAgICBjYWRldGJsdWU6ICAgICAgICBbOTUsMTU4LDE2MF0sXG4gICAgICBjaGFydHJldXNlOiAgICAgICAgWzEyNywyNTUsMF0sXG4gICAgICBjaG9jb2xhdGU6ICAgICAgICBbMjEwLDEwNSwzMF0sXG4gICAgICBjb3JhbDogICAgICAgICAgWzI1NSwxMjcsODBdLFxuICAgICAgY29ybmZsb3dlcmJsdWU6ICAgICAgWzEwMCwxNDksMjM3XSxcbiAgICAgIGNvcm5zaWxrOiAgICAgICAgWzI1NSwyNDgsMjIwXSxcbiAgICAgIGNyaW1zb246ICAgICAgICBbMjIwLDIwLDYwXSxcbiAgICAgIGN5YW46ICAgICAgICAgIFswLDI1NSwyNTVdLFxuICAgICAgZGFya2JsdWU6ICAgICAgICBbMCwwLDEzOV0sXG4gICAgICBkYXJrY3lhbjogICAgICAgIFswLDEzOSwxMzldLFxuICAgICAgZGFya2dvbGRlbnJvZDogICAgICBbMTg0LDEzNCwxMV0sXG4gICAgICBkYXJrZ3JheTogICAgICAgIFsxNjksMTY5LDE2OV0sXG4gICAgICBkYXJrZ3JlZW46ICAgICAgICBbMCwxMDAsMF0sXG4gICAgICBkYXJrZ3JleTogICAgICAgIFsxNjksMTY5LDE2OV0sXG4gICAgICBkYXJra2hha2k6ICAgICAgICBbMTg5LDE4MywxMDddLFxuICAgICAgZGFya21hZ2VudGE6ICAgICAgWzEzOSwwLDEzOV0sXG4gICAgICBkYXJrb2xpdmVncmVlbjogICAgICBbODUsMTA3LDQ3XSxcbiAgICAgIGRhcmtvcmFuZ2U6ICAgICAgICBbMjU1LDE0MCwwXSxcbiAgICAgIGRhcmtvcmNoaWQ6ICAgICAgICBbMTUzLDUwLDIwNF0sXG4gICAgICBkYXJrcmVkOiAgICAgICAgWzEzOSwwLDBdLFxuICAgICAgZGFya3NhbG1vbjogICAgICAgIFsyMzMsMTUwLDEyMl0sXG4gICAgICBkYXJrc2VhZ3JlZW46ICAgICAgWzE0MywxODgsMTQzXSxcbiAgICAgIGRhcmtzbGF0ZWJsdWU6ICAgICAgWzcyLDYxLDEzOV0sXG4gICAgICBkYXJrc2xhdGVncmF5OiAgICAgIFs0Nyw3OSw3OV0sXG4gICAgICBkYXJrc2xhdGVncmV5OiAgICAgIFs0Nyw3OSw3OV0sXG4gICAgICBkYXJrdHVycXVvaXNlOiAgICAgIFswLDIwNiwyMDldLFxuICAgICAgZGFya3Zpb2xldDogICAgICAgIFsxNDgsMCwyMTFdLFxuICAgICAgZGVlcHBpbms6ICAgICAgICBbMjU1LDIwLDE0N10sXG4gICAgICBkZWVwc2t5Ymx1ZTogICAgICBbMCwxOTEsMjU1XSxcbiAgICAgIGRpbWdyYXk6ICAgICAgICBbMTA1LDEwNSwxMDVdLFxuICAgICAgZGltZ3JleTogICAgICAgIFsxMDUsMTA1LDEwNV0sXG4gICAgICBkb2RnZXJibHVlOiAgICAgICAgWzMwLDE0NCwyNTVdLFxuICAgICAgZmlyZWJyaWNrOiAgICAgICAgWzE3OCwzNCwzNF0sXG4gICAgICBmbG9yYWx3aGl0ZTogICAgICBbMjU1LDI1MCwyNDBdLFxuICAgICAgZm9yZXN0Z3JlZW46ICAgICAgWzM0LDEzOSwzNF0sXG4gICAgICBmdWNoc2lhOiAgICAgICAgWzI1NSwwLDI1NV0sXG4gICAgICBnYWluc2Jvcm86ICAgICAgICBbMjIwLDIyMCwyMjBdLFxuICAgICAgZ2hvc3R3aGl0ZTogICAgICAgIFsyNDgsMjQ4LDI1NV0sXG4gICAgICBnb2xkOiAgICAgICAgICBbMjU1LDIxNSwwXSxcbiAgICAgIGdvbGRlbnJvZDogICAgICAgIFsyMTgsMTY1LDMyXSxcbiAgICAgIGdyYXk6ICAgICAgICAgIFsxMjgsMTI4LDEyOF0sXG4gICAgICBncmV5OiAgICAgICAgICBbMTI4LDEyOCwxMjhdLFxuICAgICAgZ3JlZW46ICAgICAgICAgIFswLDEyOCwwXSxcbiAgICAgIGdyZWVueWVsbG93OiAgICAgIFsxNzMsMjU1LDQ3XSxcbiAgICAgIGhvbmV5ZGV3OiAgICAgICAgWzI0MCwyNTUsMjQwXSxcbiAgICAgIGhvdHBpbms6ICAgICAgICBbMjU1LDEwNSwxODBdLFxuICAgICAgaW5kaWFucmVkOiAgICAgICAgWzIwNSw5Miw5Ml0sXG4gICAgICBpbmRpZ286ICAgICAgICAgIFs3NSwwLDEzMF0sXG4gICAgICBpdm9yeTogICAgICAgICAgWzI1NSwyNTUsMjQwXSxcbiAgICAgIGtoYWtpOiAgICAgICAgICBbMjQwLDIzMCwxNDBdLFxuICAgICAgbGF2ZW5kZXI6ICAgICAgICBbMjMwLDIzMCwyNTBdLFxuICAgICAgbGF2ZW5kZXJibHVzaDogICAgICBbMjU1LDI0MCwyNDVdLFxuICAgICAgbGF3bmdyZWVuOiAgICAgICAgWzEyNCwyNTIsMF0sXG4gICAgICBsZW1vbmNoaWZmb246ICAgICAgWzI1NSwyNTAsMjA1XSxcbiAgICAgIGxpZ2h0Ymx1ZTogICAgICAgIFsxNzMsMjE2LDIzMF0sXG4gICAgICBsaWdodGNvcmFsOiAgICAgICAgWzI0MCwxMjgsMTI4XSxcbiAgICAgIGxpZ2h0Y3lhbjogICAgICAgIFsyMjQsMjU1LDI1NV0sXG4gICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogIFsyNTAsMjUwLDIxMF0sXG4gICAgICBsaWdodGdyYXk6ICAgICAgICBbMjExLDIxMSwyMTFdLFxuICAgICAgbGlnaHRncmVlbjogICAgICAgIFsxNDQsMjM4LDE0NF0sXG4gICAgICBsaWdodGdyZXk6ICAgICAgICBbMjExLDIxMSwyMTFdLFxuICAgICAgbGlnaHRwaW5rOiAgICAgICAgWzI1NSwxODIsMTkzXSxcbiAgICAgIGxpZ2h0c2FsbW9uOiAgICAgIFsyNTUsMTYwLDEyMl0sXG4gICAgICBsaWdodHNlYWdyZWVuOiAgICAgIFszMiwxNzgsMTcwXSxcbiAgICAgIGxpZ2h0c2t5Ymx1ZTogICAgICBbMTM1LDIwNiwyNTBdLFxuICAgICAgbGlnaHRzbGF0ZWdyYXk6ICAgICAgWzExOSwxMzYsMTUzXSxcbiAgICAgIGxpZ2h0c2xhdGVncmV5OiAgICAgIFsxMTksMTM2LDE1M10sXG4gICAgICBsaWdodHN0ZWVsYmx1ZTogICAgICBbMTc2LDE5NiwyMjJdLFxuICAgICAgbGlnaHR5ZWxsb3c6ICAgICAgWzI1NSwyNTUsMjI0XSxcbiAgICAgIGxpbWU6ICAgICAgICAgIFswLDI1NSwwXSxcbiAgICAgIGxpbWVncmVlbjogICAgICAgIFs1MCwyMDUsNTBdLFxuICAgICAgbGluZW46ICAgICAgICAgIFsyNTAsMjQwLDIzMF0sXG4gICAgICBtYWdlbnRhOiAgICAgICAgWzI1NSwwLDI1NV0sXG4gICAgICBtYXJvb246ICAgICAgICAgIFsxMjgsMCwwXSxcbiAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICAgIFsxMDIsMjA1LDE3MF0sXG4gICAgICBtZWRpdW1ibHVlOiAgICAgICAgWzAsMCwyMDVdLFxuICAgICAgbWVkaXVtb3JjaGlkOiAgICAgIFsxODYsODUsMjExXSxcbiAgICAgIG1lZGl1bXB1cnBsZTogICAgICBbMTQ3LDExMiwyMTldLFxuICAgICAgbWVkaXVtc2VhZ3JlZW46ICAgICAgWzYwLDE3OSwxMTNdLFxuICAgICAgbWVkaXVtc2xhdGVibHVlOiAgICBbMTIzLDEwNCwyMzhdLFxuICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46ICAgIFswLDI1MCwxNTRdLFxuICAgICAgbWVkaXVtdHVycXVvaXNlOiAgICBbNzIsMjA5LDIwNF0sXG4gICAgICBtZWRpdW12aW9sZXRyZWQ6ICAgIFsxOTksMjEsMTMzXSxcbiAgICAgIG1pZG5pZ2h0Ymx1ZTogICAgICBbMjUsMjUsMTEyXSxcbiAgICAgIG1pbnRjcmVhbTogICAgICAgIFsyNDUsMjU1LDI1MF0sXG4gICAgICBtaXN0eXJvc2U6ICAgICAgICBbMjU1LDIyOCwyMjVdLFxuICAgICAgbW9jY2FzaW46ICAgICAgICBbMjU1LDIyOCwxODFdLFxuICAgICAgbmF2YWpvd2hpdGU6ICAgICAgWzI1NSwyMjIsMTczXSxcbiAgICAgIG5hdnk6ICAgICAgICAgIFswLDAsMTI4XSxcbiAgICAgIG9sZGxhY2U6ICAgICAgICBbMjUzLDI0NSwyMzBdLFxuICAgICAgb2xpdmU6ICAgICAgICAgIFsxMjgsMTI4LDBdLFxuICAgICAgb2xpdmVkcmFiOiAgICAgICAgWzEwNywxNDIsMzVdLFxuICAgICAgb3JhbmdlOiAgICAgICAgICBbMjU1LDE2NSwwXSxcbiAgICAgIG9yYW5nZXJlZDogICAgICAgIFsyNTUsNjksMF0sXG4gICAgICBvcmNoaWQ6ICAgICAgICAgIFsyMTgsMTEyLDIxNF0sXG4gICAgICBwYWxlZ29sZGVucm9kOiAgICAgIFsyMzgsMjMyLDE3MF0sXG4gICAgICBwYWxlZ3JlZW46ICAgICAgICBbMTUyLDI1MSwxNTJdLFxuICAgICAgcGFsZXR1cnF1b2lzZTogICAgICBbMTc1LDIzOCwyMzhdLFxuICAgICAgcGFsZXZpb2xldHJlZDogICAgICBbMjE5LDExMiwxNDddLFxuICAgICAgcGFwYXlhd2hpcDogICAgICAgIFsyNTUsMjM5LDIxM10sXG4gICAgICBwZWFjaHB1ZmY6ICAgICAgICBbMjU1LDIxOCwxODVdLFxuICAgICAgcGVydTogICAgICAgICAgWzIwNSwxMzMsNjNdLFxuICAgICAgcGluazogICAgICAgICAgWzI1NSwxOTIsMjAzXSxcbiAgICAgIHBsdW06ICAgICAgICAgIFsyMjEsMTYwLDIyMV0sXG4gICAgICBwb3dkZXJibHVlOiAgICAgICAgWzE3NiwyMjQsMjMwXSxcbiAgICAgIHB1cnBsZTogICAgICAgICAgWzEyOCwwLDEyOF0sXG4gICAgICByZWQ6ICAgICAgICAgIFsyNTUsMCwwXSxcbiAgICAgIHJvc3licm93bjogICAgICAgIFsxODgsMTQzLDE0M10sXG4gICAgICByb3lhbGJsdWU6ICAgICAgICBbNjUsMTA1LDIyNV0sXG4gICAgICBzYWRkbGVicm93bjogICAgICBbMTM5LDY5LDE5XSxcbiAgICAgIHNhbG1vbjogICAgICAgICAgWzI1MCwxMjgsMTE0XSxcbiAgICAgIHNhbmR5YnJvd246ICAgICAgICBbMjQ0LDE2NCw5Nl0sXG4gICAgICBzZWFncmVlbjogICAgICAgIFs0NiwxMzksODddLFxuICAgICAgc2Vhc2hlbGw6ICAgICAgICBbMjU1LDI0NSwyMzhdLFxuICAgICAgc2llbm5hOiAgICAgICAgICBbMTYwLDgyLDQ1XSxcbiAgICAgIHNpbHZlcjogICAgICAgICAgWzE5MiwxOTIsMTkyXSxcbiAgICAgIHNreWJsdWU6ICAgICAgICBbMTM1LDIwNiwyMzVdLFxuICAgICAgc2xhdGVibHVlOiAgICAgICAgWzEwNiw5MCwyMDVdLFxuICAgICAgc2xhdGVncmF5OiAgICAgICAgWzExMiwxMjgsMTQ0XSxcbiAgICAgIHNsYXRlZ3JleTogICAgICAgIFsxMTIsMTI4LDE0NF0sXG4gICAgICBzbm93OiAgICAgICAgICBbMjU1LDI1MCwyNTBdLFxuICAgICAgc3ByaW5nZ3JlZW46ICAgICAgWzAsMjU1LDEyN10sXG4gICAgICBzdGVlbGJsdWU6ICAgICAgICBbNzAsMTMwLDE4MF0sXG4gICAgICB0YW46ICAgICAgICAgIFsyMTAsMTgwLDE0MF0sXG4gICAgICB0ZWFsOiAgICAgICAgICBbMCwxMjgsMTI4XSxcbiAgICAgIHRoaXN0bGU6ICAgICAgICBbMjE2LDE5MSwyMTZdLFxuICAgICAgdG9tYXRvOiAgICAgICAgICBbMjU1LDk5LDcxXSxcbiAgICAgIHR1cnF1b2lzZTogICAgICAgIFs2NCwyMjQsMjA4XSxcbiAgICAgIHZpb2xldDogICAgICAgICAgWzIzOCwxMzAsMjM4XSxcbiAgICAgIHdoZWF0OiAgICAgICAgICBbMjQ1LDIyMiwxNzldLFxuICAgICAgd2hpdGU6ICAgICAgICAgIFsyNTUsMjU1LDI1NV0sXG4gICAgICB3aGl0ZXNtb2tlOiAgICAgICAgWzI0NSwyNDUsMjQ1XSxcbiAgICAgIHllbGxvdzogICAgICAgICAgWzI1NSwyNTUsMF0sXG4gICAgICB5ZWxsb3dncmVlbjogICAgICBbMTU0LDIwNSw1MF1cbiAgICB9XG4gICAgICBcbiAgfTtcblxuICAkJC51dGlsLnJlZ2V4ID0ge307XG4gIFxuICAkJC51dGlsLnJlZ2V4Lm51bWJlciA9IFwiKD86Wy1dP1xcXFxkKlxcXFwuXFxcXGQrfFstXT9cXFxcZCt8Wy1dP1xcXFxkKlxcXFwuXFxcXGQrW2VFXVxcXFxkKylcIjtcbiAgXG4gICQkLnV0aWwucmVnZXgucmdiYSA9IFwicmdiW2FdP1xcXFwoKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KVxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPykoPzpcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICAkJC51dGlsLnJlZ2V4LnJnYmFOb0JhY2tSZWZzID0gXCJyZ2JbYV0/XFxcXCgoPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKD86XCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pXFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KSg/OlxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiKSk/XFxcXClcIjtcbiAgXG4gICQkLnV0aWwucmVnZXguaHNsYSA9IFwiaHNsW2FdP1xcXFwoKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdKVxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXSkoPzpcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICAkJC51dGlsLnJlZ2V4LmhzbGFOb0JhY2tSZWZzID0gXCJoc2xbYV0/XFxcXCgoPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiKVxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdKVxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdKSg/OlxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiKSk/XFxcXClcIjtcbiAgXG4gICQkLnV0aWwucmVnZXguaGV4MyA9IFwiXFxcXCNbMC05YS1mQS1GXXszfVwiO1xuICAkJC51dGlsLnJlZ2V4LmhleDYgPSBcIlxcXFwjWzAtOWEtZkEtRl17Nn1cIjtcblxuICB2YXIgcmFmID0gIXdpbmRvdyA/IG51bGwgOiAoIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAgXG4gICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICk7XG5cbiAgcmFmID0gcmFmIHx8IGZ1bmN0aW9uKGZuKXsgaWYoZm4peyBzZXRUaW1lb3V0KGZuLCAxMDAwLzYwKTsgfSB9O1xuXG4gICQkLnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oZm4pe1xuICAgIHJhZiggZm4gKTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQubWF0aCA9IHt9O1xuICBcbiAgJCQubWF0aC5zaWdudW0gPSBmdW5jdGlvbih4KXtcbiAgICBpZiggeCA+IDAgKXtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiggeCA8IDAgKXtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuXG4gICQkLm1hdGguZGlzdGFuY2UgPSBmdW5jdGlvbiggcDEsIHAyICl7XG4gICAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gICAgdmFyIGR5ID0gcDIueSAtIHAxLnk7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCBkeCpkeCArIGR5KmR5ICk7XG4gIH07XG5cbiAgLy8gZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0LDqXppZXJfY3VydmUjUXVhZHJhdGljX2N1cnZlc1xuICAkJC5tYXRoLnFiZXppZXJBdCA9IGZ1bmN0aW9uKHAwLCBwMSwgcDIsIHQpe1xuICAgIHJldHVybiAoMSAtIHQpKigxIC0gdCkqcDAgKyAyKigxIC0gdCkqdCpwMSArIHQqdCpwMjtcbiAgfTtcblxuICAkJC5tYXRoLnFiZXppZXJQdEF0ID0gZnVuY3Rpb24ocDAsIHAxLCBwMiwgdCl7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICQkLm1hdGgucWJlemllckF0KCBwMC54LCBwMS54LCBwMi54LCB0ICksXG4gICAgICB5OiAkJC5tYXRoLnFiZXppZXJBdCggcDAueSwgcDEueSwgcDIueSwgdCApXG4gICAgfTtcbiAgfTtcblxuICAkJC5tYXRoLmJvdW5kaW5nQm94ZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiggYmIxLCBiYjIgKXtcbiAgICAvLyBjYXNlOiBvbmUgYmIgdG8gcmlnaHQgb2Ygb3RoZXJcbiAgICBpZiggYmIxLngxID4gYmIyLngyICl7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmKCBiYjIueDEgPiBiYjEueDIgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBjYXNlOiBvbmUgYmIgdG8gbGVmdCBvZiBvdGhlclxuICAgIGlmKCBiYjEueDIgPCBiYjIueDEgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYoIGJiMi54MiA8IGJiMS54MSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIGNhc2U6IG9uZSBiYiBhYm92ZSBvdGhlclxuICAgIGlmKCBiYjEueTIgPCBiYjIueTEgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYoIGJiMi55MiA8IGJiMS55MSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIGNhc2U6IG9uZSBiYiBiZWxvdyBvdGhlclxuICAgIGlmKCBiYjEueTEgPiBiYjIueTIgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYoIGJiMi55MSA+IGJiMS55MiApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIG90aGVyd2lzZSwgbXVzdCBoYXZlIHNvbWUgb3ZlcmxhcFxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gICQkLm1hdGguaW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBiYiwgeCwgeSApe1xuICAgIHJldHVybiBiYi54MSA8PSB4ICYmIHggPD0gYmIueDIgJiYgYmIueTEgPD0geSAmJiB5IDw9IGJiLnkyO1xuICB9O1xuXG4gICQkLm1hdGgucG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiLCBwdCApe1xuICAgIHJldHVybiB0aGlzLmluQm91bmRpbmdCb3goIGJiLCBwdC54LCBwdC55ICk7XG4gIH07XG5cbiAgJCQubWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUgPSBmdW5jdGlvbihcbiAgICB4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgICBcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gdGhpcy5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICBcbiAgICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuICAgIHZhciBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIFxuICAgIC8vIFRvcCBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gICAge1xuICAgICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgLSBwYWRkaW5nO1xuICAgICAgdmFyIHRvcEVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgdG9wU3RhcnRYLCB0b3BTdGFydFksIHRvcEVuZFgsIHRvcEVuZFksIGZhbHNlKTtcbiAgICAgIFxuICAgICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICAgIHtcbiAgICAgIHZhciByaWdodFN0YXJ0WCA9IG5vZGVYICsgaGFsZldpZHRoICsgcGFkZGluZztcbiAgICAgIHZhciByaWdodFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgcmlnaHRFbmRYID0gcmlnaHRTdGFydFg7XG4gICAgICB2YXIgcmlnaHRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgcmlnaHRTdGFydFgsIHJpZ2h0U3RhcnRZLCByaWdodEVuZFgsIHJpZ2h0RW5kWSwgZmFsc2UpO1xuICAgICAgXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBCb3R0b20gc2VnbWVudCwgbGVmdCB0byByaWdodFxuICAgIHtcbiAgICAgIHZhciBib3R0b21TdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgYm90dG9tU3RhcnRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIHZhciBib3R0b21FbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgICAgdmFyIGJvdHRvbUVuZFkgPSBib3R0b21TdGFydFk7XG4gICAgICBcbiAgICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgICB4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVN0YXJ0WCwgYm90dG9tU3RhcnRZLCBib3R0b21FbmRYLCBib3R0b21FbmRZLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIExlZnQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICAgIHtcbiAgICAgIHZhciBsZWZ0U3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggLSBwYWRkaW5nO1xuICAgICAgdmFyIGxlZnRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgICAgdmFyIGxlZnRFbmRYID0gbGVmdFN0YXJ0WDtcbiAgICAgIHZhciBsZWZ0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICBcbiAgICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgICB4LCB5LCBub2RlWCwgbm9kZVksIGxlZnRTdGFydFgsIGxlZnRTdGFydFksIGxlZnRFbmRYLCBsZWZ0RW5kWSwgZmFsc2UpO1xuICAgICAgXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggYXJjIHNlZ21lbnRzXG4gICAgdmFyIGFyY0ludGVyc2VjdGlvbnM7XG4gICAgXG4gICAgLy8gVG9wIExlZnRcbiAgICB7XG4gICAgICB2YXIgdG9wTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciB0b3BMZWZ0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgXG4gICAgICAgIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IHRvcExlZnRDZW50ZXJYXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wTGVmdENlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVG9wIFJpZ2h0XG4gICAge1xuICAgICAgdmFyIHRvcFJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHRvcFJpZ2h0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgXG4gICAgICAgIHRvcFJpZ2h0Q2VudGVyWCwgdG9wUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gdG9wUmlnaHRDZW50ZXJYXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wUmlnaHRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEJvdHRvbSBSaWdodFxuICAgIHtcbiAgICAgIHZhciBib3R0b21SaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBib3R0b21SaWdodENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgICB4LCB5LCBub2RlWCwgbm9kZVksIFxuICAgICAgICBib3R0b21SaWdodENlbnRlclgsIGJvdHRvbVJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IGJvdHRvbVJpZ2h0Q2VudGVyWFxuICAgICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbVJpZ2h0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBCb3R0b20gTGVmdFxuICAgIHtcbiAgICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gYm90dG9tTGVmdENlbnRlclhcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21MZWZ0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xuICB9O1xuICBcbiAgJCQubWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdEJveCA9IGZ1bmN0aW9uKFxuICAgIGJveFgxLCBib3hZMSwgYm94WDIsIGJveFkyLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgXG4gICAgLy8gV2UgaGF2ZSB0aGUgZm9sbG93aW5nIHNocGFlXG4gICAgXG4gICAgLy8gICAgX19fX19cbiAgICAvLyAgX3wgICAgIHxfXG4gICAgLy8gfCAgICAgICAgIHxcbiAgICAvLyB8XyAgICAgICBffFxuICAgIC8vICAgfF9fX19ffFxuICAgIC8vXG4gICAgLy8gV2l0aCBhIHF1YXJ0ZXIgY2lyY2xlIGF0IGVhY2ggY29ybmVyLlxuICAgIFxuICAgIHZhciBjb3JuZXJSYWRpdXMgPSB0aGlzLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIHZhciBoQm94VG9wTGVmdFggPSBjZW50ZXJYIC0gd2lkdGggLyAyIC0gcGFkZGluZztcbiAgICB2YXIgaEJveFRvcExlZnRZID0gY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBoQm94Qm90dG9tUmlnaHRYID0gY2VudGVyWCArIHdpZHRoIC8gMiArIHBhZGRpbmc7XG4gICAgdmFyIGhCb3hCb3R0b21SaWdodFkgPSBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgXG4gICAgdmFyIHZCb3hUb3BMZWZ0WCA9IGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciB2Qm94VG9wTGVmdFkgPSBjZW50ZXJZIC0gaGVpZ2h0IC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHZCb3hCb3R0b21SaWdodFggPSBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgdkJveEJvdHRvbVJpZ2h0WSA9IGNlbnRlclkgKyBoZWlnaHQgLyAyICsgcGFkZGluZztcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGUgYm94IGlzIG91dCBvZiBib3VuZHNcbiAgICB2YXIgYm94TWluWCA9IE1hdGgubWluKGJveFgxLCBib3hYMik7XG4gICAgdmFyIGJveE1heFggPSBNYXRoLm1heChib3hYMSwgYm94WDIpO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oYm94WTEsIGJveFkyKTtcbiAgICB2YXIgYm94TWF4WSA9IE1hdGgubWF4KGJveFkxLCBib3hZMik7XG4gICAgXG4gICAgaWYgKGJveE1heFggPCBoQm94VG9wTGVmdFgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGJveE1pblggPiBoQm94Qm90dG9tUmlnaHRYKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhZIDwgdkJveFRvcExlZnRZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChib3hNaW5ZID4gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhbiBoQm94IHBvaW50IGlzIGluIGdpdmVuIGJveFxuICAgIGlmIChoQm94VG9wTGVmdFggPj0gYm94TWluWCAmJiBoQm94VG9wTGVmdFggPD0gYm94TWF4WFxuICAgICAgICAmJiBoQm94VG9wTGVmdFkgPj0gYm94TWluWSAmJiBoQm94VG9wTGVmdFkgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChoQm94Qm90dG9tUmlnaHRYID49IGJveE1pblggJiYgaEJveEJvdHRvbVJpZ2h0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIGhCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIGhCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGhCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiBoQm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgaEJveEJvdHRvbVJpZ2h0WSA+PSBib3hNaW5ZICYmIGhCb3hCb3R0b21SaWdodFkgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChoQm94VG9wTGVmdFggPj0gYm94TWluWCAmJiBoQm94VG9wTGVmdFggPD0gYm94TWF4WFxuICAgICAgICAmJiBoQm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgaEJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYSBnaXZlbiBwb2ludCBib3ggaXMgaW4gdGhlIGhCb3hcbiAgICBpZiAoYm94TWluWCA+PSBoQm94VG9wTGVmdFggJiYgYm94TWluWCA8PSBoQm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNaW5ZID49IGhCb3hUb3BMZWZ0WSAmJiBib3hNaW5ZIDw9IGhCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWF4WCA+PSBoQm94VG9wTGVmdFggJiYgYm94TWF4WCA8PSBoQm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNaW5ZID49IGhCb3hUb3BMZWZ0WSAmJiBib3hNaW5ZIDw9IGhCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWF4WCA+PSBoQm94VG9wTGVmdFggJiYgYm94TWF4WCA8PSBoQm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNYXhZID49IGhCb3hUb3BMZWZ0WSAmJiBib3hNYXhZIDw9IGhCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWluWCA+PSBoQm94VG9wTGVmdFggJiYgYm94TWluWCA8PSBoQm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNYXhZID49IGhCb3hUb3BMZWZ0WSAmJiBib3hNYXhZIDw9IGhCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhbiB2Qm94IHBvaW50IGlzIGluIGdpdmVuIGJveFxuICAgIGlmICh2Qm94VG9wTGVmdFggPj0gYm94TWluWCAmJiB2Qm94VG9wTGVmdFggPD0gYm94TWF4WFxuICAgICAgICAmJiB2Qm94VG9wTGVmdFkgPj0gYm94TWluWSAmJiB2Qm94VG9wTGVmdFkgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh2Qm94Qm90dG9tUmlnaHRYID49IGJveE1pblggJiYgdkJveEJvdHRvbVJpZ2h0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIHZCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIHZCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHZCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiB2Qm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgdkJveEJvdHRvbVJpZ2h0WSA+PSBib3hNaW5ZICYmIHZCb3hCb3R0b21SaWdodFkgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh2Qm94VG9wTGVmdFggPj0gYm94TWluWCAmJiB2Qm94VG9wTGVmdFggPD0gYm94TWF4WFxuICAgICAgICAmJiB2Qm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgdkJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYSBnaXZlbiBwb2ludCBib3ggaXMgaW4gdGhlIHZCb3hcbiAgICBpZiAoYm94TWluWCA+PSB2Qm94VG9wTGVmdFggJiYgYm94TWluWCA8PSB2Qm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNaW5ZID49IHZCb3hUb3BMZWZ0WSAmJiBib3hNaW5ZIDw9IHZCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWF4WCA+PSB2Qm94VG9wTGVmdFggJiYgYm94TWF4WCA8PSB2Qm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNaW5ZID49IHZCb3hUb3BMZWZ0WSAmJiBib3hNaW5ZIDw9IHZCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWF4WCA+PSB2Qm94VG9wTGVmdFggJiYgYm94TWF4WCA8PSB2Qm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNYXhZID49IHZCb3hUb3BMZWZ0WSAmJiBib3hNYXhZIDw9IHZCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWluWCA+PSB2Qm94VG9wTGVmdFggJiYgYm94TWluWCA8PSB2Qm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNYXhZID49IHZCb3hUb3BMZWZ0WSAmJiBib3hNYXhZIDw9IHZCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBMYXN0bHksIGNoZWNrIGlmIG9uZSBvZiB0aGUgZWxsaXBzZXMgY29pbmNpZGUgd2l0aCB0aGUgYm94XG4gICAgXG4gICAgaWYgKHRoaXMuYm94SW50ZXJzZWN0RWxsaXBzZShib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94VG9wTGVmdFggKyBwYWRkaW5nLCBoQm94VG9wTGVmdFkgKyBwYWRkaW5nKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmJveEludGVyc2VjdEVsbGlwc2UoYm94TWluWCwgYm94TWluWSwgYm94TWF4WCwgYm94TWF4WSwgcGFkZGluZyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgdkJveEJvdHRvbVJpZ2h0WCAtIHBhZGRpbmcsIGhCb3hUb3BMZWZ0WSArIHBhZGRpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuYm94SW50ZXJzZWN0RWxsaXBzZShib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94Qm90dG9tUmlnaHRYIC0gcGFkZGluZywgaEJveEJvdHRvbVJpZ2h0WSAtIHBhZGRpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuYm94SW50ZXJzZWN0RWxsaXBzZShib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94VG9wTGVmdFggKyBwYWRkaW5nLCBoQm94Qm90dG9tUmlnaHRZIC0gcGFkZGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICAvLyBATyBBcHByb3hpbWF0ZSBjb2xsaXNpb24gZnVuY3Rpb25zXG4gICQkLm1hdGguY2hlY2tJbkJvdW5kaW5nQ2lyY2xlID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgZmFydGhlc3RQb2ludFNxRGlzdGFuY2UsIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICBcbiAgICB4ID0gKHggLSBjZW50ZXJYKSAvICh3aWR0aCArIHBhZGRpbmcpO1xuICAgIHkgPSAoeSAtIGNlbnRlclkpIC8gKGhlaWdodCArIHBhZGRpbmcpO1xuICAgIFxuICAgIHJldHVybiAoeCAqIHggKyB5ICogeSkgPD0gZmFydGhlc3RQb2ludFNxRGlzdGFuY2U7XG4gIH07XG4gIFxuICAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkgPSBmdW5jdGlvbihcbiAgICB4MWJveCwgeTFib3gsIHgyYm94LCB5MmJveCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gICAgXG4gICAgLy8gUmV0dXJuIHZhbHVlczpcbiAgICAvLyAwIC0gY3VydmUgaXMgbm90IGluIGJveFxuICAgIC8vIDEgLSBjdXJ2ZSBtYXkgYmUgaW4gYm94OyBuZWVkcyBwcmVjaXNlIGNoZWNrXG4gICAgLy8gMiAtIGN1cnZlIGlzIGluIGJveFxuICAgIFxuICAgIC8vIG1pZHBvaW50XG4gICAgdmFyIG1pZFggPSAwLjI1ICogeDEgKyAwLjUgKiB4MiArIDAuMjUgKiB4MztcbiAgICB2YXIgbWlkWSA9IDAuMjUgKiB5MSArIDAuNSAqIHkyICsgMC4yNSAqIHkzO1xuXG4gICAgdmFyIGJveE1pblggPSBNYXRoLm1pbih4MWJveCwgeDJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oeTFib3gsIHkyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KHgxYm94LCB4MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFkgPSBNYXRoLm1heCh5MWJveCwgeTJib3gpICsgdG9sZXJhbmNlO1xuICAgIFxuICAgIGlmICh4MSA+PSBib3hNaW5YICYmIHgxIDw9IGJveE1heFggJiYgeTEgPj0gYm94TWluWSAmJiB5MSA8PSBib3hNYXhZKSB7IC8vICh4MSwgeTEpIGluIGJveFxuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh4MyA+PSBib3hNaW5YICYmIHgzIDw9IGJveE1heFggJiYgeTMgPj0gYm94TWluWSAmJiB5MyA8PSBib3hNYXhZKSB7IC8vICh4MywgeTMpIGluIGJveFxuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChtaWRYID49IGJveE1pblggJiYgbWlkWCA8PSBib3hNYXhYICYmIG1pZFkgPj0gYm94TWluWSAmJiBtaWRZIDw9IGJveE1heFkpIHsgLy8gKG1pZFgsIG1pZFkpIGluIGJveFxuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh4MiA+PSBib3hNaW5YICYmIHgyIDw9IGJveE1heFggJiYgeTIgPj0gYm94TWluWSAmJiB5MiA8PSBib3hNYXhZKSB7IC8vIGN0cmwgcHQgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGN1cnZlTWluWCA9IE1hdGgubWluKHgxLCBtaWRYLCB4Myk7XG4gICAgdmFyIGN1cnZlTWluWSA9IE1hdGgubWluKHkxLCBtaWRZLCB5Myk7XG4gICAgdmFyIGN1cnZlTWF4WCA9IE1hdGgubWF4KHgxLCBtaWRYLCB4Myk7XG4gICAgdmFyIGN1cnZlTWF4WSA9IE1hdGgubWF4KHkxLCBtaWRZLCB5Myk7XG4gICAgXG4gICAgLypcbiAgICBjb25zb2xlLmxvZyhjdXJ2ZU1pblggKyBcIiwgXCIgKyBjdXJ2ZU1pblkgKyBcIiwgXCIgKyBjdXJ2ZU1heFggXG4gICAgICArIFwiLCBcIiArIGN1cnZlTWF4WSk7XG4gICAgaWYgKGN1cnZlTWluWCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwidW5kZWZpbmVkIGN1cnZlTWluWDogXCIgKyB4MSArIFwiLCBcIiArIHgyICsgXCIsIFwiICsgeDMpO1xuICAgIH1cbiAgICAqL1xuICAgIFxuICAgIGlmIChjdXJ2ZU1pblggPiBib3hNYXhYXG4gICAgICB8fCBjdXJ2ZU1heFggPCBib3hNaW5YXG4gICAgICB8fCBjdXJ2ZU1pblkgPiBib3hNYXhZXG4gICAgICB8fCBjdXJ2ZU1heFkgPCBib3hNaW5ZKSB7XG4gICAgICBcbiAgICAgIHJldHVybiAwOyAgXG4gICAgfVxuICAgIFxuICAgIHJldHVybiAxO1xuICB9O1xuXG4gICQkLm1hdGguY2hlY2tCZXppZXJJbkJveCA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UpIHtcblxuICAgIGZ1bmN0aW9uIHNhbXBsZUluQm94KHQpe1xuICAgICAgdmFyIHggPSAkJC5tYXRoLnFiZXppZXJBdCh4MSwgeDIsIHgzLCB0KTtcbiAgICAgIHZhciB5ID0gJCQubWF0aC5xYmV6aWVyQXQoeTEsIHkyLCB5MywgdCk7XG5cbiAgICAgIHJldHVybiB4MWJveCA8PSB4ICYmIHggPD0geDJib3hcbiAgICAgICAgJiYgeTFib3ggPD0geSAmJiB5IDw9IHkyYm94XG4gICAgICA7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgdCA9IDA7IHQgPD0gMTsgdCArPSAwLjI1ICl7XG4gICAgICBpZiggIXNhbXBsZUluQm94KHQpICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguY2hlY2tTdHJhaWdodEVkZ2VJbkJveCA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgdG9sZXJhbmNlKSB7XG5cbiAgICByZXR1cm4geDFib3ggPD0geDEgJiYgeDEgPD0geDJib3hcbiAgICAgICYmIHgxYm94IDw9IHgyICYmIHgyIDw9IHgyYm94XG4gICAgICAmJiB5MWJveCA8PSB5MSAmJiB5MSA8PSB5MmJveFxuICAgICAgJiYgeTFib3ggPD0geTIgJiYgeTIgPD0geTJib3hcbiAgICA7XG4gIH07XG5cbiAgJCQubWF0aC5jaGVja1N0cmFpZ2h0RWRnZUNyb3NzZXNCb3ggPSBmdW5jdGlvbihcbiAgICB4MWJveCwgeTFib3gsIHgyYm94LCB5MmJveCwgeDEsIHkxLCB4MiwgeTIsIHRvbGVyYW5jZSkge1xuICAgIFxuICAgLy9jb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgIFxuICAgIHZhciBib3hNaW5YID0gTWF0aC5taW4oeDFib3gsIHgyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWluWSA9IE1hdGgubWluKHkxYm94LCB5MmJveCkgLSB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFggPSBNYXRoLm1heCh4MWJveCwgeDJib3gpICsgdG9sZXJhbmNlO1xuICAgIHZhciBib3hNYXhZID0gTWF0aC5tYXgoeTFib3gsIHkyYm94KSArIHRvbGVyYW5jZTtcbiAgICBcbiAgICAvLyBDaGVjayBsZWZ0ICsgcmlnaHQgYm91bmRzXG4gICAgdmFyIGFYID0geDIgLSB4MTtcbiAgICB2YXIgYlggPSB4MTtcbiAgICB2YXIgeVZhbHVlO1xuICAgIFxuICAgIC8vIFRvcCBhbmQgYm90dG9tXG4gICAgdmFyIGFZID0geTIgLSB5MTtcbiAgICB2YXIgYlkgPSB5MTtcbiAgICB2YXIgeFZhbHVlO1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhhWCkgPCAwLjAwMDEpIHtcbiAgICAgIHJldHVybiAoeDEgPj0gYm94TWluWCAmJiB4MSA8PSBib3hNYXhYXG4gICAgICAgICYmIE1hdGgubWluKHkxLCB5MikgPD0gYm94TWluWVxuICAgICAgICAmJiBNYXRoLm1heCh5MSwgeTIpID49IGJveE1heFkpOyAgXG4gICAgfVxuICAgIFxuICAgIHZhciB0TGVmdCA9IChib3hNaW5YIC0gYlgpIC8gYVg7XG4gICAgaWYgKHRMZWZ0ID4gMCAmJiB0TGVmdCA8PSAxKSB7XG4gICAgICB5VmFsdWUgPSBhWSAqIHRMZWZ0ICsgYlk7XG4gICAgICBpZiAoeVZhbHVlID49IGJveE1pblkgJiYgeVZhbHVlIDw9IGJveE1heFkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IFxuICAgIH1cbiAgICBcbiAgICB2YXIgdFJpZ2h0ID0gKGJveE1heFggLSBiWCkgLyBhWDtcbiAgICBpZiAodFJpZ2h0ID4gMCAmJiB0UmlnaHQgPD0gMSkge1xuICAgICAgeVZhbHVlID0gYVkgKiB0UmlnaHQgKyBiWTtcbiAgICAgIGlmICh5VmFsdWUgPj0gYm94TWluWSAmJiB5VmFsdWUgPD0gYm94TWF4WSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIHZhciB0VG9wID0gKGJveE1pblkgLSBiWSkgLyBhWTtcbiAgICBpZiAodFRvcCA+IDAgJiYgdFRvcCA8PSAxKSB7XG4gICAgICB4VmFsdWUgPSBhWCAqIHRUb3AgKyBiWDtcbiAgICAgIGlmICh4VmFsdWUgPj0gYm94TWluWCAmJiB4VmFsdWUgPD0gYm94TWF4WCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIHZhciB0Qm90dG9tID0gKGJveE1heFkgLSBiWSkgLyBhWTtcbiAgICBpZiAodEJvdHRvbSA+IDAgJiYgdEJvdHRvbSA8PSAxKSB7XG4gICAgICB4VmFsdWUgPSBhWCAqIHRCb3R0b20gKyBiWDtcbiAgICAgIGlmICh4VmFsdWUgPj0gYm94TWluWCAmJiB4VmFsdWUgPD0gYm94TWF4WCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguY2hlY2tCZXppZXJDcm9zc2VzQm94ID0gZnVuY3Rpb24oXG4gICAgeDFib3gsIHkxYm94LCB4MmJveCwgeTJib3gsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSkge1xuICAgIFxuICAgIHZhciBib3hNaW5YID0gTWF0aC5taW4oeDFib3gsIHgyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWluWSA9IE1hdGgubWluKHkxYm94LCB5MmJveCkgLSB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFggPSBNYXRoLm1heCh4MWJveCwgeDJib3gpICsgdG9sZXJhbmNlO1xuICAgIHZhciBib3hNYXhZID0gTWF0aC5tYXgoeTFib3gsIHkyYm94KSArIHRvbGVyYW5jZTtcbiAgICBcbiAgICBpZiAoeDEgPj0gYm94TWluWCAmJiB4MSA8PSBib3hNYXhYICYmIHkxID49IGJveE1pblkgJiYgeTEgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh4MyA+PSBib3hNaW5YICYmIHgzIDw9IGJveE1heFggJiYgeTMgPj0gYm94TWluWSAmJiB5MyA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGFYID0geDEgLSAyICogeDIgKyB4MztcbiAgICB2YXIgYlggPSAtMiAqIHgxICsgMiAqIHgyO1xuICAgIHZhciBjWCA9IHgxO1xuXG4gICAgdmFyIHhJbnRlcnZhbHMgPSBbXTtcbiAgICBcbiAgICBpZiAoTWF0aC5hYnMoYVgpIDwgMC4wMDAxKSB7XG4gICAgICB2YXIgbGVmdFBhcmFtID0gKGJveE1pblggLSB4MSkgLyBiWDtcbiAgICAgIHZhciByaWdodFBhcmFtID0gKGJveE1heFggLSB4MSkgLyBiWDtcbiAgICAgIFxuICAgICAgeEludGVydmFscy5wdXNoKGxlZnRQYXJhbSwgcmlnaHRQYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgd2hlbiB4IGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGNyb3NzZXMgdGhlIGxlZnQgc2lkZSBvZiB0aGUgYm94XG4gICAgICB2YXIgZGlzY3JpbWluYW50WDEgPSBiWCAqIGJYIC0gNCAqIGFYICogKGNYIC0gYm94TWluWCk7XG4gICAgICB2YXIgdFgxLCB0WDI7XG4gICAgICBpZiAoZGlzY3JpbWluYW50WDEgPiAwKSB7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudFgxKTtcbiAgICAgICAgdFgxID0gKC1iWCArIHNxcnQpIC8gKDIgKiBhWCk7XG4gICAgICAgIHRYMiA9ICgtYlggLSBzcXJ0KSAvICgyICogYVgpO1xuICAgICAgICBcbiAgICAgICAgeEludGVydmFscy5wdXNoKHRYMSwgdFgyKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGRpc2NyaW1pbmFudFgyID0gYlggKiBiWCAtIDQgKiBhWCAqIChjWCAtIGJveE1heFgpO1xuICAgICAgdmFyIHRYMywgdFg0O1xuICAgICAgaWYgKGRpc2NyaW1pbmFudFgyID4gMCkge1xuICAgICAgICB2YXIgc3FydCA9IE1hdGguc3FydChkaXNjcmltaW5hbnRYMik7XG4gICAgICAgIHRYMyA9ICgtYlggKyBzcXJ0KSAvICgyICogYVgpO1xuICAgICAgICB0WDQgPSAoLWJYIC0gc3FydCkgLyAoMiAqIGFYKTtcbiAgICAgICAgXG4gICAgICAgIHhJbnRlcnZhbHMucHVzaCh0WDMsIHRYNCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHhJbnRlcnZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgXG4gICAgdmFyIGFZID0geTEgLSAyICogeTIgKyB5MztcbiAgICB2YXIgYlkgPSAtMiAqIHkxICsgMiAqIHkyO1xuICAgIHZhciBjWSA9IHkxO1xuICAgIFxuICAgIHZhciB5SW50ZXJ2YWxzID0gW107XG4gICAgXG4gICAgaWYgKE1hdGguYWJzKGFZKSA8IDAuMDAwMSkge1xuICAgICAgdmFyIHRvcFBhcmFtID0gKGJveE1pblkgLSB5MSkgLyBiWTtcbiAgICAgIHZhciBib3R0b21QYXJhbSA9IChib3hNYXhZIC0geTEpIC8gYlk7XG4gICAgICBcbiAgICAgIHlJbnRlcnZhbHMucHVzaCh0b3BQYXJhbSwgYm90dG9tUGFyYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlzY3JpbWluYW50WTEgPSBiWSAqIGJZIC0gNCAqIGFZICogKGNZIC0gYm94TWluWSk7XG4gICAgICBcbiAgICAgIHZhciB0WTEsIHRZMjtcbiAgICAgIGlmIChkaXNjcmltaW5hbnRZMSA+IDApIHtcbiAgICAgICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQoZGlzY3JpbWluYW50WTEpO1xuICAgICAgICB0WTEgPSAoLWJZICsgc3FydCkgLyAoMiAqIGFZKTtcbiAgICAgICAgdFkyID0gKC1iWSAtIHNxcnQpIC8gKDIgKiBhWSk7XG4gICAgICAgIFxuICAgICAgICB5SW50ZXJ2YWxzLnB1c2godFkxLCB0WTIpO1xuICAgICAgfVxuICBcbiAgICAgIHZhciBkaXNjcmltaW5hbnRZMiA9IGJZICogYlkgLSA0ICogYVkgKiAoY1kgLSBib3hNYXhZKTtcbiAgICAgIFxuICAgICAgdmFyIHRZMywgdFk0O1xuICAgICAgaWYgKGRpc2NyaW1pbmFudFkyID4gMCkge1xuICAgICAgICB2YXIgc3FydCA9IE1hdGguc3FydChkaXNjcmltaW5hbnRZMik7XG4gICAgICAgIHRZMyA9ICgtYlkgKyBzcXJ0KSAvICgyICogYVkpO1xuICAgICAgICB0WTQgPSAoLWJZIC0gc3FydCkgLyAoMiAqIGFZKTtcbiAgICAgICAgXG4gICAgICAgIHlJbnRlcnZhbHMucHVzaCh0WTMsIHRZNCk7XG4gICAgICB9XG4gICAgfVxuICAgICAgICBcbiAgICB5SW50ZXJ2YWxzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHhJbnRlcnZhbHMubGVuZ3RoOyBpbmRleCArPSAyKSB7XG4gICAgICBmb3IgKHZhciB5SW5kZXggPSAxOyB5SW5kZXggPCB5SW50ZXJ2YWxzLmxlbmd0aDsgeUluZGV4ICs9IDIpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGV4aXN0cyB2YWx1ZXMgZm9yIHRoZSBCZXppZXIgY3VydmVcbiAgICAgICAgLy8gcGFyYW1ldGVyIGJldHdlZW4gMCBhbmQgMSB3aGVyZSBib3RoIHRoZSBjdXJ2ZSdzXG4gICAgICAgIC8vIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGUgYm91bmRzIHNwZWNpZmllZCBieSB0aGUgYm94XG4gICAgICAgIGlmICh4SW50ZXJ2YWxzW2luZGV4XSA8IHlJbnRlcnZhbHNbeUluZGV4XVxuICAgICAgICAgICYmIHlJbnRlcnZhbHNbeUluZGV4XSA+PSAwLjBcbiAgICAgICAgICAmJiB4SW50ZXJ2YWxzW2luZGV4XSA8PSAxLjBcbiAgICAgICAgICAmJiB4SW50ZXJ2YWxzW2luZGV4ICsgMV0gPiB5SW50ZXJ2YWxzW3lJbmRleCAtIDFdXG4gICAgICAgICAgJiYgeUludGVydmFsc1t5SW5kZXggLSAxXSA8PSAxLjBcbiAgICAgICAgICAmJiB4SW50ZXJ2YWxzW2luZGV4ICsgMV0gPj0gMC4wKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5pbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uKHgsIHksIGx4MSwgbHkxLCBseDIsIGx5MiwgdG9sZXJhbmNlKXtcbiAgICB2YXIgdCA9IHRvbGVyYW5jZTtcblxuICAgIHZhciB4MSA9IE1hdGgubWluKGx4MSwgbHgyKTtcbiAgICB2YXIgeDIgPSBNYXRoLm1heChseDEsIGx4Mik7XG4gICAgdmFyIHkxID0gTWF0aC5taW4obHkxLCBseTIpO1xuICAgIHZhciB5MiA9IE1hdGgubWF4KGx5MSwgbHkyKTtcblxuICAgIHJldHVybiB4MSAtIHQgPD0geCAmJiB4IDw9IHgyICsgdFxuICAgICAgJiYgeTEgLSB0IDw9IHkgJiYgeSA8PSB5MiArIHQ7XG4gIH07XG5cbiAgJCQubWF0aC5pbkJlemllclZpY2luaXR5ID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlU3F1YXJlZCkge1xuXG4gICAgdmFyIGJiID0ge1xuICAgICAgeDE6IE1hdGgubWluKCB4MSwgeDMsIHgyICksXG4gICAgICB4MjogTWF0aC5tYXgoIHgxLCB4MywgeDIgKSxcbiAgICAgIHkxOiBNYXRoLm1pbiggeTEsIHkzLCB5MiApLFxuICAgICAgeTI6IE1hdGgubWF4KCB5MSwgeTMsIHkyIClcbiAgICB9O1xuXG4gICAgLy8gaWYgb3V0c2lkZSB0aGUgcm91Z2ggYm91bmRpbmcgYm94IGZvciB0aGUgYmV6aWVyLCB0aGVuIGl0IGNhbid0IGJlIGEgaGl0XG4gICAgaWYoIHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55MiApe1xuICAgICAgLy8gY29uc29sZS5sb2coJ2JlemllciBvdXQgb2Ygcm91Z2ggYmInKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZG8gbW9yZSBleHBlbnNpdmUgY2hlY2snKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICB9O1xuICBcbiAgJCQubWF0aC5zb2x2ZUN1YmljID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgcmVzdWx0KSB7XG4gICAgXG4gICAgLy8gU29sdmVzIGEgY3ViaWMgZnVuY3Rpb24sIHJldHVybnMgcm9vdCBpbiBmb3JtIFtyMSwgaTEsIHIyLCBpMiwgcjMsIGkzXSwgd2hlcmVcbiAgICAvLyByIGlzIHRoZSByZWFsIGNvbXBvbmVudCwgaSBpcyB0aGUgaW1hZ2luYXJ5IGNvbXBvbmVudFxuXG4gICAgLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENhcmRhbm8gbWV0aG9kIGZyb20gdGhlIHllYXIgMTU0NVxuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfZnVuY3Rpb24jVGhlX25hdHVyZV9vZl90aGVfcm9vdHNcblxuICAgIGIgLz0gYTtcbiAgICBjIC89IGE7XG4gICAgZCAvPSBhO1xuICAgIFxuICAgIHZhciBkaXNjcmltaW5hbnQsIHEsIHIsIGR1bTEsIHMsIHQsIHRlcm0xLCByMTM7XG5cbiAgICBxID0gKDMuMCAqIGMgLSAoYiAqIGIpKSAvIDkuMDtcbiAgICByID0gLSgyNy4wICogZCkgKyBiICogKDkuMCAqIGMgLSAyLjAgKiAoYiAqIGIpKTtcbiAgICByIC89IDU0LjA7XG4gICAgXG4gICAgZGlzY3JpbWluYW50ID0gcSAqIHEgKiBxICsgciAqIHI7XG4gICAgcmVzdWx0WzFdID0gMDtcbiAgICB0ZXJtMSA9IChiIC8gMy4wKTtcbiAgICBcbiAgICBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgICAgcyA9IHIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgIHMgPSAoKHMgPCAwKSA/IC1NYXRoLnBvdygtcywgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3cocywgKDEuMCAvIDMuMCkpKTtcbiAgICAgIHQgPSByIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgICB0ID0gKCh0IDwgMCkgPyAtTWF0aC5wb3coLXQsICgxLjAgLyAzLjApKSA6IE1hdGgucG93KHQsICgxLjAgLyAzLjApKSk7XG4gICAgICByZXN1bHRbMF0gPSAtdGVybTEgKyBzICsgdDtcbiAgICAgIHRlcm0xICs9IChzICsgdCkgLyAyLjA7XG4gICAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtdGVybTE7XG4gICAgICB0ZXJtMSA9IE1hdGguc3FydCgzLjApICogKC10ICsgcykgLyAyO1xuICAgICAgcmVzdWx0WzNdID0gdGVybTE7XG4gICAgICByZXN1bHRbNV0gPSAtdGVybTE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHJlc3VsdFs1XSA9IHJlc3VsdFszXSA9IDA7XG4gICAgXG4gICAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgICAgcjEzID0gKChyIDwgMCkgPyAtTWF0aC5wb3coLXIsICgxLjAgLyAzLjApKSA6IE1hdGgucG93KHIsICgxLjAgLyAzLjApKSk7XG4gICAgICByZXN1bHRbMF0gPSAtdGVybTEgKyAyLjAgKiByMTM7XG4gICAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtKHIxMyArIHRlcm0xKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgcSA9IC1xO1xuICAgIGR1bTEgPSBxICogcSAqIHE7XG4gICAgZHVtMSA9IE1hdGguYWNvcyhyIC8gTWF0aC5zcXJ0KGR1bTEpKTtcbiAgICByMTMgPSAyLjAgKiBNYXRoLnNxcnQocSk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoZHVtMSAvIDMuMCk7XG4gICAgcmVzdWx0WzJdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyAyLjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gICAgcmVzdWx0WzRdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyA0LjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gICAgXG4gICAgcmV0dXJuO1xuICB9O1xuXG4gICQkLm1hdGguc3FEaXN0YW5jZVRvUXVhZHJhdGljQmV6aWVyID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIFxuICAgIC8vIEZpbmQgbWluaW11bSBkaXN0YW5jZSBieSB1c2luZyB0aGUgbWluaW11bSBvZiB0aGUgZGlzdGFuY2UgXG4gICAgLy8gZnVuY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnQgYW5kIHRoZSBjdXJ2ZVxuICAgIFxuICAgIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcmVzdWx0aW5nIGN1YmljIGVxdWF0aW9uXG4gICAgLy8gd2hvc2Ugcm9vdHMgdGVsbCB1cyB3aGVyZSBhIHBvc3NpYmxlIG1pbmltdW0gaXNcbiAgICAvLyAoQ29lZmZpY2llbnRzIGFyZSBkaXZpZGVkIGJ5IDQpXG4gICAgXG4gICAgdmFyIGEgPSAxLjAgKiB4MSp4MSAtIDQqeDEqeDIgKyAyKngxKngzICsgNCp4Mip4MiAtIDQqeDIqeDMgKyB4Myp4M1xuICAgICAgKyB5MSp5MSAtIDQqeTEqeTIgKyAyKnkxKnkzICsgNCp5Mip5MiAtIDQqeTIqeTMgKyB5Myp5MztcbiAgICBcbiAgICB2YXIgYiA9IDEuMCAqIDkqeDEqeDIgLSAzKngxKngxIC0gMyp4MSp4MyAtIDYqeDIqeDIgKyAzKngyKngzXG4gICAgICArIDkqeTEqeTIgLSAzKnkxKnkxIC0gMyp5MSp5MyAtIDYqeTIqeTIgKyAzKnkyKnkzO1xuICAgIFxuICAgIHZhciBjID0gMS4wICogMyp4MSp4MSAtIDYqeDEqeDIgKyB4MSp4MyAtIHgxKnggKyAyKngyKngyICsgMip4Mip4IC0geDMqeFxuICAgICAgKyAzKnkxKnkxIC0gNip5MSp5MiArIHkxKnkzIC0geTEqeSArIDIqeTIqeTIgKyAyKnkyKnkgLSB5Myp5O1xuICAgICAgXG4gICAgdmFyIGQgPSAxLjAgKiB4MSp4MiAtIHgxKngxICsgeDEqeCAtIHgyKnhcbiAgICAgICsgeTEqeTIgLSB5MSp5MSArIHkxKnkgLSB5Mip5O1xuICAgIFxuICAgIC8vIGRlYnVnKFwiY29lZmZpY2llbnRzOiBcIiArIGEgLyBhICsgXCIsIFwiICsgYiAvIGEgKyBcIiwgXCIgKyBjIC8gYSArIFwiLCBcIiArIGQgLyBhKTtcbiAgICBcbiAgICB2YXIgcm9vdHMgPSBbXTtcbiAgICBcbiAgICAvLyBVc2UgdGhlIGN1YmljIHNvbHZpbmcgYWxnb3JpdGhtXG4gICAgdGhpcy5zb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJvb3RzKTtcbiAgICBcbiAgICB2YXIgemVyb1RocmVzaG9sZCA9IDAuMDAwMDAwMTtcbiAgICBcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IDY7IGluZGV4ICs9IDIpIHtcbiAgICAgIGlmIChNYXRoLmFicyhyb290c1tpbmRleCArIDFdKSA8IHplcm9UaHJlc2hvbGRcbiAgICAgICAgICAmJiByb290c1tpbmRleF0gPj0gMFxuICAgICAgICAgICYmIHJvb3RzW2luZGV4XSA8PSAxLjApIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocm9vdHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcGFyYW1zLnB1c2goMS4wKTtcbiAgICBwYXJhbXMucHVzaCgwLjApO1xuICAgIFxuICAgIHZhciBtaW5EaXN0YW5jZVNxdWFyZWQgPSAtMTtcbiAgICB2YXIgY2xvc2VzdFBhcmFtO1xuICAgIFxuICAgIHZhciBjdXJYLCBjdXJZLCBkaXN0U3F1YXJlZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VyWCA9IE1hdGgucG93KDEuMCAtIHBhcmFtc1tpXSwgMi4wKSAqIHgxXG4gICAgICAgICsgMi4wICogKDEgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeDJcbiAgICAgICAgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB4MztcbiAgICAgICAgXG4gICAgICBjdXJZID0gTWF0aC5wb3coMSAtIHBhcmFtc1tpXSwgMi4wKSAqIHkxXG4gICAgICAgICsgMiAqICgxLjAgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeTJcbiAgICAgICAgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB5MztcbiAgICAgICAgXG4gICAgICBkaXN0U3F1YXJlZCA9IE1hdGgucG93KGN1clggLSB4LCAyKSArIE1hdGgucG93KGN1clkgLSB5LCAyKTtcbiAgICAgIC8vIGRlYnVnKCdkaXN0YW5jZSBmb3IgcGFyYW0gJyArIHBhcmFtc1tpXSArIFwiOiBcIiArIE1hdGguc3FydChkaXN0U3F1YXJlZCkpO1xuICAgICAgaWYgKG1pbkRpc3RhbmNlU3F1YXJlZCA+PSAwKSB7XG4gICAgICAgIGlmIChkaXN0U3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgICAgICAgIGNsb3Nlc3RQYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICAgIGNsb3Nlc3RQYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLypcbiAgICBkZWJ1Z1N0YXRzLmNsaWNrWCA9IHg7XG4gICAgZGVidWdTdGF0cy5jbGlja1kgPSB5O1xuICAgIFxuICAgIGRlYnVnU3RhdHMuY2xvc2VzdFggPSBNYXRoLnBvdygxLjAgLSBjbG9zZXN0UGFyYW0sIDIuMCkgKiB4MVxuICAgICAgICArIDIuMCAqICgxLjAgLSBjbG9zZXN0UGFyYW0pICogY2xvc2VzdFBhcmFtICogeDJcbiAgICAgICAgKyBjbG9zZXN0UGFyYW0gKiBjbG9zZXN0UGFyYW0gKiB4MztcbiAgICAgICAgXG4gICAgZGVidWdTdGF0cy5jbG9zZXN0WSA9IE1hdGgucG93KDEuMCAtIGNsb3Nlc3RQYXJhbSwgMi4wKSAqIHkxXG4gICAgICAgICsgMi4wICogKDEuMCAtIGNsb3Nlc3RQYXJhbSkgKiBjbG9zZXN0UGFyYW0gKiB5MlxuICAgICAgICArIGNsb3Nlc3RQYXJhbSAqIGNsb3Nlc3RQYXJhbSAqIHkzO1xuICAgICovXG4gICAgXG4gICAgLy8gZGVidWcoXCJnaXZlbjogXCIgXG4gICAgLy8gICArIFwiKCBcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIpLCBcIiBcbiAgICAvLyAgICsgXCIoIFwiICsgeDEgKyBcIiwgXCIgKyB5MSArIFwiKSwgXCIgXG4gICAgLy8gICArIFwiKCBcIiArIHgyICsgXCIsIFwiICsgeTIgKyBcIiksIFwiXG4gICAgLy8gICArIFwiKCBcIiArIHgzICsgXCIsIFwiICsgeTMgKyBcIilcIik7XG4gICAgXG4gICAgXG4gICAgLy8gZGVidWcoXCJyb290czogXCIgKyByb290cyk7XG4gICAgLy8gZGVidWcoXCJwYXJhbXM6IFwiICsgcGFyYW1zKTtcbiAgICAvLyBkZWJ1ZyhcImNsb3Nlc3QgcGFyYW06IFwiICsgY2xvc2VzdFBhcmFtKTtcbiAgICByZXR1cm4gbWluRGlzdGFuY2VTcXVhcmVkO1xuICB9O1xuICBcbiAgJCQubWF0aC5zcURpc3RhbmNlVG9GaW5pdGVMaW5lID0gZnVuY3Rpb24oeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gW3ggLSB4MSwgeSAtIHkxXTtcbiAgICB2YXIgbGluZSA9IFt4MiAtIHgxLCB5MiAtIHkxXTtcbiAgICBcbiAgICB2YXIgbGluZVNxID0gbGluZVswXSAqIGxpbmVbMF0gKyBsaW5lWzFdICogbGluZVsxXTtcbiAgICB2YXIgaHlwU3EgPSBvZmZzZXRbMF0gKiBvZmZzZXRbMF0gKyBvZmZzZXRbMV0gKiBvZmZzZXRbMV07XG4gICAgXG4gICAgdmFyIGRvdFByb2R1Y3QgPSBvZmZzZXRbMF0gKiBsaW5lWzBdICsgb2Zmc2V0WzFdICogbGluZVsxXTtcbiAgICB2YXIgYWRqU3EgPSBkb3RQcm9kdWN0ICogZG90UHJvZHVjdCAvIGxpbmVTcTtcbiAgICBcbiAgICBpZiAoZG90UHJvZHVjdCA8IDApIHtcbiAgICAgIHJldHVybiBoeXBTcTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGFkalNxID4gbGluZVNxKSB7XG4gICAgICByZXR1cm4gKHggLSB4MikgKiAoeCAtIHgyKSArICh5IC0geTIpICogKHkgLSB5Mik7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBoeXBTcSAtIGFkalNxO1xuICB9O1xuXG4gICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG5cbiAgICAvL3ZhciBkaXJlY3Rpb24gPSBhcmd1bWVudHNbNl07XG4gICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcblxuICAgIC8vIEdpdmVzIG5lZ2F0aXZlIGFuZ2xlXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGRpcmVjdGlvblsxXSAvIChNYXRoLnNxcnQoZGlyZWN0aW9uWzBdICogZGlyZWN0aW9uWzBdIFxuICAgICAgKyBkaXJlY3Rpb25bMV0gKiBkaXJlY3Rpb25bMV0pKSk7XG4gICAgXG4gICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gICAgICAgIFxuICAgIHZhciBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgIFxuLy8gICAgY29uc29sZS5sb2coXCJiYXNlOiBcIiArIGJhc2VQb2ludHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSBcbiAgICAgICAgd2lkdGggLyAyICogKGJhc2VQb2ludHNbaSAqIDJdICogY29zXG4gICAgICAgICAgLSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBzaW4pO1xuICAgICAgXG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gXG4gICAgICAgIGhlaWdodCAvIDIgKiAoYmFzZVBvaW50c1tpICogMiArIDFdICogY29zIFxuICAgICAgICAgICsgYmFzZVBvaW50c1tpICogMl0gKiBzaW4pO1xuXG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gKz0gY2VudGVyWDtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gKz0gY2VudGVyWTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHBvaW50cztcbiAgICBcbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSB0aGlzLmV4cGFuZFBvbHlnb24oXG4gICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzLFxuICAgICAgICAtcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHBvaW50cyA9IHRoaXMuam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgICBcbiAgICB2YXIgeDEsIHkxLCB4MiwgeTI7XG4gICAgdmFyIHkzO1xuICAgIFxuICAgIC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcbiAgICB2YXIgdXAgPSAwO1xuICAgIHZhciBkb3duID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIFxuICAgICAgeDEgPSBwb2ludHNbaSAqIDJdO1xuICAgICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIFxuICAgICAgaWYgKGkgKyAxIDwgcG9pbnRzLmxlbmd0aCAvIDIpIHtcbiAgICAgICAgeDIgPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgICB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICAgIHkyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDIgKyAxXTtcbiAgICAgIH1cbiAgICAgIFxuLy8qICAgICAgY29uc29sZS5sb2coXCJsaW5lIGZyb20gKFwiICsgeDEgKyBcIiwgXCIgKyB5MSArIFwiKSB0byAoXCIgKyB4MiArIFwiLCBcIiArIHkyICsgXCIpXCIpO1xuXG4vLyYgICAgICBjb25zb2xlLmxvZyh4MSwgeCwgeDIpO1xuXG4gICAgICBpZiAoeDEgPT0geCAmJiB4MiA9PSB4KSB7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmICgoeDEgPj0geCAmJiB4ID49IHgyKVxuICAgICAgICB8fCAoeDEgPD0geCAmJiB4IDw9IHgyKSkge1xuICAgICAgICBcbiAgICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuICAgICAgICBcbiAgICAgICAgaWYgKHkzID4geSkge1xuICAgICAgICAgIHVwKys7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh5MyA8IHkpIHtcbiAgICAgICAgICBkb3duKys7XG4gICAgICAgIH1cbiAgICAgICAgXG4vLyogICAgICAgIGNvbnNvbGUubG9nKHkzLCB5KTtcbiAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuLy8qICAgICAgICBjb25zb2xlLmxvZygnMjInKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gICAgXG4vLyogICAgY29uc29sZS5sb2coXCJ1cDogXCIgKyB1cCArIFwiLCBkb3duOiBcIiArIGRvd24pO1xuICAgIFxuICAgIGlmICh1cCAlIDIgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gICQkLm1hdGguam9pbkxpbmVzID0gZnVuY3Rpb24obGluZVNldCkge1xuICAgIFxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBBcnJheShsaW5lU2V0Lmxlbmd0aCAvIDIpO1xuICAgIFxuICAgIHZhciBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZO1xuICAgIHZhciBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVNldC5sZW5ndGggLyA0OyBpKyspIHtcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRYID0gbGluZVNldFtpICogNF07XG4gICAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbaSAqIDQgKyAxXTtcbiAgICAgIGN1cnJlbnRMaW5lRW5kWCA9IGxpbmVTZXRbaSAqIDQgKyAyXTtcbiAgICAgIGN1cnJlbnRMaW5lRW5kWSA9IGxpbmVTZXRbaSAqIDQgKyAzXTtcbiAgICAgIFxuICAgICAgaWYgKGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxKSB7XG4gICAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFsoaSArIDEpICogNF07XG4gICAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsoaSArIDEpICogNCArIDFdO1xuICAgICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMl07XG4gICAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFswXTtcbiAgICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WzFdO1xuICAgICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WzJdO1xuICAgICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WzNdO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgICAgY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLFxuICAgICAgICBjdXJyZW50TGluZUVuZFgsIGN1cnJlbnRMaW5lRW5kWSxcbiAgICAgICAgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLFxuICAgICAgICBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWSxcbiAgICAgICAgdHJ1ZSk7XG4gICAgICBcbiAgICAgIHZlcnRpY2VzW2kgKiAyXSA9IGludGVyc2VjdGlvblswXTtcbiAgICAgIHZlcnRpY2VzW2kgKiAyICsgMV0gPSBpbnRlcnNlY3Rpb25bMV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgfTtcblxuICAkJC5tYXRoLmV4cGFuZFBvbHlnb24gPSBmdW5jdGlvbihwb2ludHMsIHBhZCkge1xuICAgIFxuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuICAgIFxuICAgIHZhciBjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLCBuZXh0UG9pbnRYLCBuZXh0UG9pbnRZO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY3VycmVudFBvaW50WCA9IHBvaW50c1tpICogMl07XG4gICAgICBjdXJyZW50UG9pbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICBcbiAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIG5leHRQb2ludFggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWzBdO1xuICAgICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWzFdO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDdXJyZW50IGxpbmU6IFtjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZXSB0byBbbmV4dFBvaW50WCwgbmV4dFBvaW50WV1cbiAgICAgIFxuICAgICAgLy8gQXNzdW1lIENDVyBwb2x5Z29uIHdpbmRpbmdcbiAgICAgIFxuICAgICAgdmFyIG9mZnNldFggPSAobmV4dFBvaW50WSAtIGN1cnJlbnRQb2ludFkpO1xuICAgICAgdmFyIG9mZnNldFkgPSAtKG5leHRQb2ludFggLSBjdXJyZW50UG9pbnRYKTtcbiAgICAgIFxuICAgICAgLy8gTm9ybWFsaXplXG4gICAgICB2YXIgb2Zmc2V0TGVuZ3RoID0gTWF0aC5zcXJ0KG9mZnNldFggKiBvZmZzZXRYICsgb2Zmc2V0WSAqIG9mZnNldFkpO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRYID0gb2Zmc2V0WCAvIG9mZnNldExlbmd0aDtcbiAgICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG4gICAgICBcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNF0gPSBjdXJyZW50UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAxXSA9IGN1cnJlbnRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDJdID0gbmV4dFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgM10gPSBuZXh0UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBleHBhbmRlZExpbmVTZXQ7XG4gIH07XG5cbiAgJCQubWF0aC5pbnRlcnNlY3RMaW5lRWxsaXBzZSA9IGZ1bmN0aW9uKFxuICAgIHgsIHksIGNlbnRlclgsIGNlbnRlclksIGVsbGlwc2VXcmFkaXVzLCBlbGxpcHNlSHJhZGl1cykge1xuICAgIFxuICAgIHZhciBkaXNwWCA9IGNlbnRlclggLSB4O1xuICAgIHZhciBkaXNwWSA9IGNlbnRlclkgLSB5O1xuICAgIFxuICAgIGRpc3BYIC89IGVsbGlwc2VXcmFkaXVzO1xuICAgIGRpc3BZIC89IGVsbGlwc2VIcmFkaXVzO1xuICAgIFxuICAgIHZhciBsZW4gPSBNYXRoLnNxcnQoZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkpO1xuICAgIFxuICAgIHZhciBuZXdMZW5ndGggPSBsZW4gLSAxO1xuICAgIFxuICAgIGlmIChuZXdMZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHZhciBsZW5Qcm9wb3J0aW9uID0gbmV3TGVuZ3RoIC8gbGVuO1xuICAgIFxuICAgIHJldHVybiBbKGNlbnRlclggLSB4KSAqIGxlblByb3BvcnRpb24gKyB4LCAoY2VudGVyWSAtIHkpICogbGVuUHJvcG9ydGlvbiArIHldO1xuICB9O1xuICBcbiAgJCQubWF0aC5kb3RQcm9kdWN0ID0gZnVuY3Rpb24oXG4gICAgdmVjMSwgdmVjMikge1xuICAgIFxuICAgIGlmICh2ZWMxLmxlbmd0aCAhPSAyIHx8IHZlYzIubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93ICdkb3QgcHJvZHVjdDogYXJndW1lbnRzIGFyZSBub3QgdmVjdG9ycyc7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiAodmVjMVswXSAqIHZlYzJbMF0gKyB2ZWMxWzFdICogdmVjMlsxXSk7XG4gIH07XG4gIFxuICAvLyBSZXR1cm5zIGludGVyc2VjdGlvbnMgb2YgaW5jcmVhc2luZyBkaXN0YW5jZSBmcm9tIGxpbmUncyBzdGFydCBwb2ludFxuICAkJC5tYXRoLmludGVyc2VjdExpbmVDaXJjbGUgPSBmdW5jdGlvbihcbiAgICB4MSwgeTEsIHgyLCB5MiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKSB7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGQsIGRpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICAgIHZhciBkID0gW3gyIC0geDEsIHkyIC0geTFdOyAvLyBEaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcbiAgICB2YXIgYyA9IFtjZW50ZXJYLCBjZW50ZXJZXTsgLy8gQ2VudGVyIG9mIGNpcmNsZVxuICAgIHZhciBmID0gW3gxIC0gY2VudGVyWCwgeTEgLSBjZW50ZXJZXTtcbiAgICBcbiAgICB2YXIgYSA9IGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV07XG4gICAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICAgIHZhciBjID0gKGZbMF0gKiBmWzBdICsgZlsxXSAqIGZbMV0pIC0gcmFkaXVzICogcmFkaXVzIDtcbiAgICBcbiAgICB2YXIgZGlzY3JpbWluYW50ID0gYipiLTQqYSpjO1xuICAgIFxuICAgIGlmIChkaXNjcmltaW5hbnQgPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgICBcbiAgICB2YXIgdE1pbiA9IE1hdGgubWluKHQxLCB0Mik7XG4gICAgdmFyIHRNYXggPSBNYXRoLm1heCh0MSwgdDIpO1xuICAgIHZhciBpblJhbmdlUGFyYW1zID0gW107XG4gICAgXG4gICAgaWYgKHRNaW4gPj0gMCAmJiB0TWluIDw9IDEpIHtcbiAgICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWluKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRNYXggPj0gMCAmJiB0TWF4IDw9IDEpIHtcbiAgICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWF4KTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGluUmFuZ2VQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHZhciBuZWFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMF0gKiBkWzBdICsgeDE7XG4gICAgdmFyIG5lYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMV0gKyB5MTtcbiAgICBcbiAgICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgXG4gICAgICBpZiAoaW5SYW5nZVBhcmFtc1swXSA9PSBpblJhbmdlUGFyYW1zWzFdKSB7XG4gICAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMV0gKyB5MTtcbiAgICAgIFxuICAgICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSwgZmFySW50ZXJzZWN0aW9uWCwgZmFySW50ZXJzZWN0aW9uWV07XG4gICAgICB9XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgIH1cbiAgICBcbiAgfTtcbiAgXG4gICQkLm1hdGguZmluZENpcmNsZU5lYXJQb2ludCA9IGZ1bmN0aW9uKGNlbnRlclgsIGNlbnRlclksIFxuICAgIHJhZGl1cywgZmFyWCwgZmFyWSkge1xuICAgIFxuICAgIHZhciBkaXNwbGFjZW1lbnRYID0gZmFyWCAtIGNlbnRlclg7XG4gICAgdmFyIGRpc3BsYWNlbWVudFkgPSBmYXJZIC0gY2VudGVyWTtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzcGxhY2VtZW50WCAqIGRpc3BsYWNlbWVudFggXG4gICAgICArIGRpc3BsYWNlbWVudFkgKiBkaXNwbGFjZW1lbnRZKTtcbiAgICBcbiAgICB2YXIgdW5pdERpc3BsYWNlbWVudFggPSBkaXNwbGFjZW1lbnRYIC8gZGlzdGFuY2U7XG4gICAgdmFyIHVuaXREaXNwbGFjZW1lbnRZID0gZGlzcGxhY2VtZW50WSAvIGRpc3RhbmNlO1xuICAgIFxuICAgIHJldHVybiBbY2VudGVyWCArIHVuaXREaXNwbGFjZW1lbnRYICogcmFkaXVzLCBcbiAgICAgIGNlbnRlclkgKyB1bml0RGlzcGxhY2VtZW50WSAqIHJhZGl1c107XG4gIH07XG4gIFxuICAkJC5tYXRoLmZpbmRNYXhTcURpc3RhbmNlVG9PcmlnaW4gPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICB2YXIgbWF4U3FEaXN0YW5jZSA9IDAuMDAwMDAxO1xuICAgIHZhciBzcURpc3RhbmNlO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgXG4gICAgICBzcURpc3RhbmNlID0gcG9pbnRzW2kgKiAyXSAqIHBvaW50c1tpICogMl0gXG4gICAgICAgICsgcG9pbnRzW2kgKiAyICsgMV0gKiBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIFxuICAgICAgaWYgKHNxRGlzdGFuY2UgPiBtYXhTcURpc3RhbmNlKSB7XG4gICAgICAgIG1heFNxRGlzdGFuY2UgPSBzcURpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbWF4U3FEaXN0YW5jZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QgPSBmdW5jdGlvbihcbiAgICB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGluZmluaXRlTGluZXMpIHtcbiAgICBcbiAgICB2YXIgdWFfdCA9ICh4NCAtIHgzKSAqICh5MSAtIHkzKSAtICh5NCAtIHkzKSAqICh4MSAtIHgzKTtcbiAgICB2YXIgdWJfdCA9ICh4MiAtIHgxKSAqICh5MSAtIHkzKSAtICh5MiAtIHkxKSAqICh4MSAtIHgzKTtcbiAgICB2YXIgdV9iID0gKHk0IC0geTMpICogKHgyIC0geDEpIC0gKHg0IC0geDMpICogKHkyIC0geTEpO1xuXG4gICAgaWYgKHVfYiAhPT0gMCkge1xuICAgICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICAgIHZhciB1YiA9IHViX3QgLyB1X2I7XG4gICAgICBcbiAgICAgIGlmICgwIDw9IHVhICYmIHVhIDw9IDEgJiYgMCA8PSB1YiAmJiB1YiA8PSAxKSB7ICBcbiAgICAgICAgcmV0dXJuIFt4MSArIHVhICogKHgyIC0geDEpLCB5MSArIHVhICogKHkyIC0geTEpXTtcbiAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWluZmluaXRlTGluZXMpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt4MSArIHVhICogKHgyIC0geDEpLCB5MSArIHVhICogKHkyIC0geTEpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodWFfdCA9PT0gMCB8fCB1Yl90ID09PSAwKSB7XG5cbiAgICAgICAgLy8gUGFyYWxsZWwsIGNvaW5jaWRlbnQgbGluZXMuIENoZWNrIGlmIG92ZXJsYXBcblxuICAgICAgICAvLyBDaGVjayBlbmRwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgICBpZiAoW3gxLCB4MiwgeDRdLnNvcnQoKVsxXSA9PT0geDQpIHtcbiAgICAgICAgICByZXR1cm4gW3g0LCB5NF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIHN0YXJ0IHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICAgIGlmIChbeDEsIHgyLCB4M10uc29ydCgpWzFdID09PSB4Mykge1xuICAgICAgICAgIHJldHVybiBbeDMsIHkzXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRW5kcG9pbnQgb2YgZmlyc3QgbGluZVxuICAgICAgICBpZiAoW3gzLCB4NCwgeDJdLnNvcnQoKVsxXSA9PT0geDIpIHtcbiAgICAgICAgICByZXR1cm4gW3gyLCB5Ml07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICBcbiAgICAgICAgLy8gUGFyYWxsZWwsIG5vbi1jb2luY2lkZW50XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICAvLyAoYm94TWluWCwgYm94TWluWSwgYm94TWF4WCwgYm94TWF4WSwgcGFkZGluZyxcbiAgLy8gICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94VG9wTGVmdFggKyBwYWRkaW5nLCBoQm94VG9wTGVmdFkgKyBwYWRkaW5nKSkge1xuICBcbiAgJCQubWF0aC5ib3hJbnRlcnNlY3RFbGxpcHNlID0gZnVuY3Rpb24oXG4gICAgeDEsIHkxLCB4MiwgeTIsIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICBcbiAgICBpZiAoeDIgPCB4MSkge1xuICAgICAgdmFyIG9sZFgxID0geDE7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeDIgPSBvbGRYMTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHkyIDwgeTEpIHtcbiAgICAgIHZhciBvbGRZMSA9IHkxO1xuICAgICAgeTEgPSB5MjtcbiAgICAgIHkyID0gb2xkWTE7XG4gICAgfVxuICAgIFxuICAgIC8vIDQgb3J0aG8gZXh0cmVtZSBwb2ludHNcbiAgICB2YXIgd2VzdCA9IFtjZW50ZXJYIC0gd2lkdGggLyAyIC0gcGFkZGluZywgY2VudGVyWV07XG4gICAgdmFyIGVhc3QgPSBbY2VudGVyWCArIHdpZHRoIC8gMiArIHBhZGRpbmcsIGNlbnRlclldO1xuICAgIHZhciBub3J0aCA9IFtjZW50ZXJYLCBjZW50ZXJZIC0gaGVpZ2h0IC8gMiAtIHBhZGRpbmddO1xuICAgIHZhciBzb3V0aCA9IFtjZW50ZXJYLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiArIHBhZGRpbmddO1xuICAgIFxuICAgIC8vIG91dCBvZiBib3VuZHM6IHJldHVybiBmYWxzZVxuICAgIGlmICh4MiA8IHdlc3RbMF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgxID4gZWFzdFswXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTEgPiBzb3V0aFsxXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTIgPCBub3J0aFsxXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyAxIG9mIDQgb3J0aG8gZXh0cmVtZSBwb2ludHMgaW4gYm94OiByZXR1cm4gdHJ1ZVxuICAgIGlmICh4MSA8PSBlYXN0WzBdICYmIGVhc3RbMF0gPD0geDJcbiAgICAgICAgJiYgeTEgPD0gZWFzdFsxXSAmJiBlYXN0WzFdIDw9IHkyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgxIDw9IHdlc3RbMF0gJiYgd2VzdFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSB3ZXN0WzFdICYmIHdlc3RbMV0gPD0geTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPD0gbm9ydGhbMF0gJiYgbm9ydGhbMF0gPD0geDJcbiAgICAgICAgJiYgeTEgPD0gbm9ydGhbMV0gJiYgbm9ydGhbMV0gPD0geTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPD0gc291dGhbMF0gJiYgc291dGhbMF0gPD0geDJcbiAgICAgICAgJiYgeTEgPD0gc291dGhbMV0gJiYgc291dGhbMV0gPD0geTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBib3ggY29ybmVyIGluIGVsbGlwc2U6IHJldHVybiB0cnVlICAgIFxuICAgIHgxID0gKHgxIC0gY2VudGVyWCkgLyAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgeDIgPSAoeDIgLSBjZW50ZXJYKSAvICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICBcbiAgICB5MSA9ICh5MSAtIGNlbnRlclkpIC8gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICB5MiA9ICh5MiAtIGNlbnRlclkpIC8gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICBcbiAgICBpZiAoeDEgKiB4MSArIHkxICogeTEgPD0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MiAqIHgyICsgeTEgKiB5MSA8PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgyICogeDIgKyB5MiAqIHkyIDw9IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgKiB4MSArIHkyICogeTIgPD0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguYm94SW50ZXJzZWN0UG9seWdvbiA9IGZ1bmN0aW9uKFxuICAgIHgxLCB5MSwgeDIsIHkyLCBiYXNlUG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICBcbi8vICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgXG4gICAgaWYgKHgyIDwgeDEpIHtcbiAgICAgIHZhciBvbGRYMSA9IHgxO1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHgyID0gb2xkWDE7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MiA8IHkxKSB7XG4gICAgICB2YXIgb2xkWTEgPSB5MTtcbiAgICAgIHkxID0geTI7XG4gICAgICB5MiA9IG9sZFkxO1xuICAgIH1cbiAgICBcbiAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuICAgIFxuICAgIC8vIEdpdmVzIG5lZ2F0aXZlIG9mIGFuZ2xlXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGRpcmVjdGlvblsxXSAvIChNYXRoLnNxcnQoZGlyZWN0aW9uWzBdICogZGlyZWN0aW9uWzBdIFxuICAgICAgKyBkaXJlY3Rpb25bMV0gKiBkaXJlY3Rpb25bMV0pKSk7XG4gICAgXG4gICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gICAgXG4gICAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IFxuICAgICAgICB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3NcbiAgICAgICAgICAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG4gICAgICBcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBcbiAgICAgICAgaGVpZ2h0IC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBjb3MgXG4gICAgICAgICAgKyBiYXNlUG9pbnRzW2kgKiAyXSAqIHNpbik7XG4gICAgICBcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSArPSBjZW50ZXJZO1xuICAgIH1cbiAgICBcbiAgICAvLyBBc3N1bWUgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoID4gMCwgYW5kIGNoZWNrIGlmIGludGVyc2VjdGlvbiBpcyBwb3NzaWJsZVxuICAgIHZhciBtaW5UcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1swXTtcbiAgICB2YXIgbWF4VHJhbnNmb3JtZWRYID0gdHJhbnNmb3JtZWRQb2ludHNbMF07XG4gICAgdmFyIG1pblRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzWzFdO1xuICAgIHZhciBtYXhUcmFuc2Zvcm1lZFkgPSB0cmFuc2Zvcm1lZFBvaW50c1sxXTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgaWYgKHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA+IG1heFRyYW5zZm9ybWVkWCkge1xuICAgICAgICBtYXhUcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPCBtaW5UcmFuc2Zvcm1lZFgpIHtcbiAgICAgICAgbWluVHJhbnNmb3JtZWRYID0gdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA+IG1heFRyYW5zZm9ybWVkWSkge1xuICAgICAgICBtYXhUcmFuc2Zvcm1lZFkgPSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA8IG1pblRyYW5zZm9ybWVkWSkge1xuICAgICAgICBtaW5UcmFuc2Zvcm1lZFkgPSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoeDIgPCBtaW5UcmFuc2Zvcm1lZFggLSBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSA+IG1heFRyYW5zZm9ybWVkWCArIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHkyIDwgbWluVHJhbnNmb3JtZWRZIC0gcGFkZGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTEgPiBtYXhUcmFuc2Zvcm1lZFkgKyBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnRpbnVlIGNoZWNraW5nIHdpdGggcGFkZGluZy1jb3JyZWN0ZWQgcG9pbnRzXG4gICAgdmFyIHBvaW50cztcbiAgICBcbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSAkJC5tYXRoLmV4cGFuZFBvbHlnb24oXG4gICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzLFxuICAgICAgICAtcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHBvaW50cyA9ICQkLm1hdGguam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhIHBvaW50IGlzIGluIGJveFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBpZiAoeDEgPD0gdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdXG4gICAgICAgICAgJiYgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdIDw9IHgyKSB7XG4gICAgICAgIFxuICAgICAgICBpZiAoeTEgPD0gdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXVxuICAgICAgICAgICAgJiYgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA8PSB5Mikge1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIFxuICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggdGhlIHNlbGVjdGlvbiBib3hcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIFxuICAgICAgdmFyIGN1cnJlbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIHZhciBjdXJyZW50WSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgdmFyIG5leHRYO1xuICAgICAgdmFyIG5leHRZO1xuICAgICAgXG4gICAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgICBuZXh0WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIG5leHRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0WCA9IHBvaW50c1swXTtcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEludGVyc2VjdGlvbiB3aXRoIHRvcCBvZiBzZWxlY3Rpb24gYm94XG4gICAgICBpZiAoJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSwgeDEsIHkxLCB4MiwgeTEsIGZhbHNlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJbnRlcnNlY3Rpb24gd2l0aCBib3R0b20gb2Ygc2VsZWN0aW9uIGJveFxuICAgICAgaWYgKCQkLm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QoY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFksIHgxLCB5MiwgeDIsIHkyLCBmYWxzZSkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW50ZXJzZWN0aW9uIHdpdGggbGVmdCBzaWRlIG9mIHNlbGVjdGlvbiBib3hcbiAgICAgIGlmICgkJC5tYXRoLmZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZLCB4MSwgeTEsIHgxLCB5MiwgZmFsc2UpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEludGVyc2VjdGlvbiB3aXRoIHJpZ2h0IHNpZGUgb2Ygc2VsZWN0aW9uIGJveFxuICAgICAgaWYgKCQkLm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QoY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFksIHgyLCB5MSwgeDIsIHkyLCBmYWxzZSkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIC8vIENoZWNrIGlmIGJveCBjb3JuZXIgaW4gdGhlIHBvbHlnb25cbiAgICBpZiAoJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICB4MSwgeTEsIHBvaW50cywgMCwgMCwgMSwgMSwgMCwgZGlyZWN0aW9uKSkge1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgeDEsIHkyLCBwb2ludHMsIDAsIDAsIDEsIDEsIDAsIGRpcmVjdGlvbikpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgIHgyLCB5MiwgcG9pbnRzLCAwLCAwLCAxLCAxLCAwLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTsgXG4gICAgfSBlbHNlIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgIHgyLCB5MSwgcG9pbnRzLCAwLCAwLCAxLCAxLCAwLCBkaXJlY3Rpb24pKSB7XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAqL1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gICQkLm1hdGgucG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbihcbiAgICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gICAgXG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uO1xuICAgIFxuICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IGJhc2VQb2ludHNbaSAqIDJdICogd2lkdGggKyBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGhlaWdodCArIGNlbnRlclk7XG4gICAgfVxuICAgIFxuICAgIHZhciBwb2ludHM7XG4gICAgXG4gICAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gJCQubWF0aC5leHBhbmRQb2x5Z29uKFxuICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyxcbiAgICAgICAgLXBhZGRpbmcpO1xuICAgICAgXG4gICAgICBwb2ludHMgPSAkJC5tYXRoLmpvaW5MaW5lcyhleHBhbmRlZExpbmVTZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgICB9XG4gICAgLy8gdmFyIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIFxuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICBcbiAgICAgIGN1cnJlbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIGN1cnJlbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTsgXG4gICAgICAgIG5leHRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0WCA9IHBvaW50c1swXTsgXG4gICAgICAgIG5leHRZID0gcG9pbnRzWzFdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpbnRlcnNlY3Rpb24gPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgICB4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICBjdXJyZW50WCwgY3VycmVudFksXG4gICAgICAgIG5leHRYLCBuZXh0WSk7XG4gICAgICBcbiAgICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9O1xuICBcbiAgJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oXG4gICAgaW50ZXJzZWN0aW9uLCBvZmZzZXQsIGFtb3VudCkge1xuICAgIFxuICAgIHZhciBkaXNwID0gW2ludGVyc2VjdGlvblswXSAtIG9mZnNldFswXSwgaW50ZXJzZWN0aW9uWzFdIC0gb2Zmc2V0WzFdXTtcbiAgICBcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KGRpc3BbMF0gKiBkaXNwWzBdICsgZGlzcFsxXSAqIGRpc3BbMV0pO1xuICAgIFxuICAgIHZhciBsZW5SYXRpbyA9IChsZW5ndGggLSBhbW91bnQpIC8gbGVuZ3RoO1xuICAgIFxuICAgIGlmIChsZW5SYXRpbyA8IDApIHtcbiAgICAgIGxlblJhdGlvID0gMC4wMDAwMTtcbiAgICB9XG5cbiAgICByZXR1cm4gW29mZnNldFswXSArIGxlblJhdGlvICogZGlzcFswXSwgb2Zmc2V0WzFdICsgbGVuUmF0aW8gKiBkaXNwWzFdXTtcbiAgfTtcblxuICAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSA9IGZ1bmN0aW9uKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgICB2YXIgcG9pbnRzID0gJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpO1xuICAgIHBvaW50cyA9ICQkLm1hdGguZml0UG9seWdvblRvU3F1YXJlKHBvaW50cyk7XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9O1xuXG4gICQkLm1hdGguZml0UG9seWdvblRvU3F1YXJlID0gZnVuY3Rpb24ocG9pbnRzKXtcbiAgICB2YXIgeCwgeTtcbiAgICB2YXIgc2lkZXMgPSBwb2ludHMubGVuZ3RoLzI7XG4gICAgdmFyIG1pblggPSBJbmZpbml0eSwgbWluWSA9IEluZmluaXR5LCBtYXhYID0gLUluZmluaXR5LCBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgICB4ID0gcG9pbnRzWzIgKiBpXTtcbiAgICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXTtcblxuICAgICAgbWluWCA9IE1hdGgubWluKCBtaW5YLCB4ICk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgoIG1heFgsIHggKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbiggbWluWSwgeSApO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KCBtYXhZLCB5ICk7XG4gICAgfVxuICAgIFxuICAgIC8vIHN0cmV0Y2ggZmFjdG9yc1xuICAgIHZhciBzeCA9IDIgLyAobWF4WCAtIG1pblgpO1xuICAgIHZhciBzeSA9IDIgLyAobWF4WSAtIG1pblkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKXtcbiAgICAgIHggPSBwb2ludHNbMiAqIGldID0gcG9pbnRzWzIgKiBpXSAqIHN4O1xuICAgICAgeSA9IHBvaW50c1syICogaSArIDFdID0gcG9pbnRzWzIgKiBpICsgMV0gKiBzeTtcblxuICAgICAgbWluWCA9IE1hdGgubWluKCBtaW5YLCB4ICk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgoIG1heFgsIHggKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbiggbWluWSwgeSApO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KCBtYXhZLCB5ICk7XG4gICAgfVxuXG4gICAgaWYoIG1pblkgPCAtMSApe1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKXtcbiAgICAgICAgeSA9IHBvaW50c1syICogaSArIDFdID0gcG9pbnRzWzIgKiBpICsgMV0gKyAoLTEgLW1pblkpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9O1xuXG4gICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgICBcbiAgICB2YXIgaW5jcmVtZW50ID0gMS4wIC8gc2lkZXMgKiAyICogTWF0aC5QSTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNpZGVzICUgMiA9PT0gMCA/IFxuICAgICAgTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG4vLyAgICBjb25zb2xlLmxvZyhub2RlU2hhcGVzWydzcXVhcmUnXSk7XG4gICAgc3RhcnRBbmdsZSArPSByb3RhdGlvblJhZGlhbnM7XG4gICAgXG4gICAgdmFyIHBvaW50cyA9IG5ldyBBcnJheShzaWRlcyAqIDIpO1xuXG4gICAgdmFyIGN1cnJlbnRBbmdsZSwgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgIGN1cnJlbnRBbmdsZSA9IGkgKiBpbmNyZW1lbnQgKyBzdGFydEFuZ2xlO1xuICAgICAgXG4gICAgICB4ID0gcG9pbnRzWzIgKiBpXSA9IE1hdGguY29zKGN1cnJlbnRBbmdsZSk7Ly8gKiAoMSArIGkvMik7XG4gICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBNYXRoLnNpbigtY3VycmVudEFuZ2xlKTsvLyAgKiAoMSArIGkvMik7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgJCQubWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzLCB1bmxlc3MgaGFsZiBvZiB3aWR0aCBvciBoZWlnaHQgaXMgc21hbGxlciB0aGFuIGRlZmF1bHRcbiAgICByZXR1cm4gTWF0aC5taW4od2lkdGggLyA0LCBoZWlnaHQgLyA0LCA4KTtcbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyByZWdpc3RlcmVkIGV4dGVuc2lvbnMgdG8gY3l0b3NjYXBlLCBpbmRleGVkIGJ5IG5hbWVcbiAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcbiAgJCQuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gIFxuICAvLyByZWdpc3RlcmVkIG1vZHVsZXMgZm9yIGV4dGVuc2lvbnMsIGluZGV4ZWQgYnkgbmFtZVxuICB2YXIgbW9kdWxlcyA9IHt9O1xuICAkJC5tb2R1bGVzID0gbW9kdWxlcztcbiAgXG4gIGZ1bmN0aW9uIHNldEV4dGVuc2lvbih0eXBlLCBuYW1lLCByZWdpc3RyYW50KXtcbiAgICB2YXIgaW1wbCA9IHt9O1xuICAgIGltcGxbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgIFxuICAgIHN3aXRjaCggdHlwZSApe1xuICAgIGNhc2UgJ2NvcmUnOlxuICAgIGNhc2UgJ2NvbGxlY3Rpb24nOlxuICAgICAgJCQuZm5bdHlwZV0oIGltcGwgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gZmlsbCBpbiBtaXNzaW5nIGxheW91dCBmdW5jdGlvbnMgaW4gdGhlIHByb3RvdHlwZVxuICAgIGlmKCB0eXBlID09PSAnbGF5b3V0JyApe1xuICAgICAgdmFyIGxheW91dFByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG4gICAgICB2YXIgb3B0TGF5b3V0Rm5zID0gWydzdG9wJ107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3B0TGF5b3V0Rm5zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBmbk5hbWUgPSBvcHRMYXlvdXRGbnNbaV07XG5cbiAgICAgICAgbGF5b3V0UHJvdG9bZm5OYW1lXSA9IGxheW91dFByb3RvW2ZuTmFtZV0gfHwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG4gICAgICB9XG5cbiAgICAgIC8vIGVpdGhlciAuc3RhcnQoKSBvciAucnVuKCkgaXMgZGVmaW5lZCwgc28gYXV0b2dlbiB0aGUgb3RoZXJcbiAgICAgIGlmKCBsYXlvdXRQcm90by5zdGFydCAmJiAhbGF5b3V0UHJvdG8ucnVuICl7XG4gICAgICAgIGxheW91dFByb3RvLnJ1biA9IGZ1bmN0aW9uKCl7IHRoaXMuc3RhcnQoKTsgcmV0dXJuIHRoaXM7IH07XG4gICAgICB9IGVsc2UgaWYoICFsYXlvdXRQcm90by5zdGFydCAmJiBsYXlvdXRQcm90by5ydW4gKXtcbiAgICAgICAgbGF5b3V0UHJvdG8uc3RhcnQgPSBmdW5jdGlvbigpeyB0aGlzLnJ1bigpOyByZXR1cm4gdGhpczsgfTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0UHJvdG8ub24gPSAkJC5kZWZpbmUub24oeyBsYXlvdXQ6IHRydWUgfSk7XG4gICAgICBsYXlvdXRQcm90by5vbmUgPSAkJC5kZWZpbmUub24oeyBsYXlvdXQ6IHRydWUsIHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSk7XG4gICAgICBsYXlvdXRQcm90by5vbmNlID0gJCQuZGVmaW5lLm9uKHsgbGF5b3V0OiB0cnVlLCB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0pO1xuICAgICAgbGF5b3V0UHJvdG8ub2ZmID0gJCQuZGVmaW5lLm9mZih7IGxheW91dDogdHJ1ZSB9KTtcbiAgICAgIGxheW91dFByb3RvLnRyaWdnZXIgPSAkJC5kZWZpbmUudHJpZ2dlcih7IGxheW91dDogdHJ1ZSB9KTtcblxuICAgICAgLy8gYWxpYXNlcyBmb3IgdGhvc2UgZm9sa3Mgd2hvIGxpa2Ugb2xkIHN0dWZmOlxuICAgICAgbGF5b3V0UHJvdG8uYmluZCA9IGxheW91dFByb3RvLm9uO1xuICAgICAgbGF5b3V0UHJvdG8udW5iaW5kID0gbGF5b3V0UHJvdG8ub2ZmO1xuICAgIH1cblxuICAgIHJldHVybiAkJC51dGlsLnNldE1hcCh7XG4gICAgICBtYXA6IGV4dGVuc2lvbnMsXG4gICAgICBrZXlzOiBbIHR5cGUsIG5hbWUgXSxcbiAgICAgIHZhbHVlOiByZWdpc3RyYW50XG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldEV4dGVuc2lvbih0eXBlLCBuYW1lKXtcbiAgICByZXR1cm4gJCQudXRpbC5nZXRNYXAoe1xuICAgICAgbWFwOiBleHRlbnNpb25zLFxuICAgICAga2V5czogWyB0eXBlLCBuYW1lIF1cbiAgICB9KTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gc2V0TW9kdWxlKHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUsIHJlZ2lzdHJhbnQpe1xuICAgIHJldHVybiAkJC51dGlsLnNldE1hcCh7XG4gICAgICBtYXA6IG1vZHVsZXMsXG4gICAgICBrZXlzOiBbIHR5cGUsIG5hbWUsIG1vZHVsZVR5cGUsIG1vZHVsZU5hbWUgXSxcbiAgICAgIHZhbHVlOiByZWdpc3RyYW50XG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIGdldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lKXtcbiAgICByZXR1cm4gJCQudXRpbC5nZXRNYXAoe1xuICAgICAgbWFwOiBtb2R1bGVzLFxuICAgICAga2V5czogWyB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lIF1cbiAgICB9KTtcbiAgfVxuICBcbiAgJCQuZXh0ZW5zaW9uID0gZnVuY3Rpb24oKXtcbiAgICAvLyBlLmcuICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJylcbiAgICBpZiggYXJndW1lbnRzLmxlbmd0aCA9PSAyICl7XG4gICAgICByZXR1cm4gZ2V0RXh0ZW5zaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFxuICAgIC8vIGUuZy4gJCQuZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCB7IC4uLiB9KVxuICAgIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT0gMyApe1xuICAgICAgcmV0dXJuIHNldEV4dGVuc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBlLmcuICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgJ25vZGVTaGFwZScsICdlbGxpcHNlJylcbiAgICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09IDQgKXtcbiAgICAgIHJldHVybiBnZXRNb2R1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gZS5nLiAkJC5leHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScsIHsgLi4uIH0pXG4gICAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PSA1ICl7XG4gICAgICByZXR1cm4gc2V0TW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFxuICAgIGVsc2Uge1xuICAgICAgJCQudXRpbC5lcnJvcignSW52YWxpZCBleHRlbnNpb24gYWNjZXNzIHN5bnRheCcpO1xuICAgIH1cbiAgXG4gIH07XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQsICQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgaWYoICEkICl7IHJldHVybjsgfSAvLyBubyBqcXVlcnkgPT4gZG9uJ3QgbmVlZCB0aGlzXG5cbiAgdmFyIGN5UmVnID0gZnVuY3Rpb24oICRlbGUgKXtcbiAgICB2YXIgZCA9ICRlbGVbMF0uX2N5cmVnID0gJGVsZVswXS5fY3lyZWcgfHwge307XG5cbiAgICByZXR1cm4gZDtcbiAgfTtcblxuICAvLyBhbGxvdyBjYWxscyBvbiBhIGpRdWVyeSBzZWxlY3RvciBieSBwcm94eWluZyBjYWxscyB0byAkLmN5dG9zY2FwZVxuICAvLyBlLmcuICQoXCIjZm9vXCIpLmN5dG9zY2FwZShvcHRpb25zKSA9PiAkLmN5dG9zY2FwZShvcHRpb25zKSBvbiAjZm9vXG4gICQuZm4uY3l0b3NjYXBlID0gZnVuY3Rpb24ob3B0cyl7XG4gICAgdmFyICR0aGlzID0gJCh0aGlzKTtcblxuICAgIC8vIGdldCBvYmplY3RcbiAgICBpZiggb3B0cyA9PT0gJ2dldCcgKXtcbiAgICAgIHJldHVybiBjeVJlZyggJHRoaXMgKS5jeTtcbiAgICB9XG4gICAgXG4gICAgLy8gYmluZCB0byByZWFkeVxuICAgIGVsc2UgaWYoICQkLmlzLmZuKG9wdHMpICl7XG5cbiAgICAgIHZhciByZWFkeSA9IG9wdHM7XG4gICAgICB2YXIgY3kgPSBjeVJlZyggJHRoaXMgKS5jeTtcbiAgICAgIFxuICAgICAgaWYoIGN5ICYmIGN5LmlzUmVhZHkoKSApeyAvLyBhbHJlYWR5IHJlYWR5IHNvIGp1c3QgdHJpZ2dlciBub3dcbiAgICAgICAgY3kudHJpZ2dlcigncmVhZHknLCBbXSwgcmVhZHkpO1xuXG4gICAgICB9IGVsc2UgeyAvLyBub3QgeWV0IHJlYWR5LCBzbyBhZGQgdG8gcmVhZGllcyBsaXN0XG4gICAgICAgIHZhciBkYXRhID0gY3lSZWcoICR0aGlzICk7XG4gICAgICAgIHZhciByZWFkaWVzID0gZGF0YS5yZWFkaWVzID0gZGF0YS5yZWFkaWVzIHx8IFtdO1xuXG4gICAgICAgIHJlYWRpZXMucHVzaCggcmVhZHkgKTtcbiAgICAgIH0gXG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgLy8gcHJveHkgdG8gY3JlYXRlIGluc3RhbmNlXG4gICAgZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3Qob3B0cykgKXtcbiAgICAgIHJldHVybiAkdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIG9wdHMsIHtcbiAgICAgICAgICBjb250YWluZXI6ICQodGhpcylbMF1cbiAgICAgICAgfSk7XG4gICAgICBcbiAgICAgICAgY3l0b3NjYXBlKG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gYWxsb3cgYWNjZXNzIHRvIHRoZSBnbG9iYWwgY3l0b3NjYXBlIG9iamVjdCB1bmRlciBqcXVlcnkgZm9yIGxlZ2FjeSByZWFzb25zXG4gICQuY3l0b3NjYXBlID0gY3l0b3NjYXBlO1xuICBcbiAgLy8gdXNlIHNob3J0IGFsaWFzIChjeSkgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICBpZiggJC5mbi5jeSA9PSBudWxsICYmICQuY3kgPT0gbnVsbCApe1xuICAgICQuZm4uY3kgPSAkLmZuLmN5dG9zY2FwZTtcbiAgICAkLmN5ID0gJC5jeXRvc2NhcGU7XG4gIH1cbiAgXG59KSh0eXBlb2YgalF1ZXJ5ICE9PSAndW5kZWZpbmVkJyA/IGpRdWVyeSA6IG51bGwgLCBjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gc2hhbWVsZXNzbHkgdGFrZW4gZnJvbSBqUXVlcnlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2V2ZW50LmpzXG5cbiAgJCQuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcbiAgICAvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcbiAgICBpZiAoICEodGhpcyBpbnN0YW5jZW9mICQkLkV2ZW50KSApIHtcbiAgICAgIHJldHVybiBuZXcgJCQuRXZlbnQoIHNyYywgcHJvcHMgKTtcbiAgICB9XG5cbiAgICAvLyBFdmVudCBvYmplY3RcbiAgICBpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcbiAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcbiAgICAgIHRoaXMudHlwZSA9IHNyYy50eXBlO1xuXG4gICAgICAvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuICAgICAgLy8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9ICggc3JjLmRlZmF1bHRQcmV2ZW50ZWQgKSA/IHJldHVyblRydWUgOiByZXR1cm5GYWxzZTtcblxuICAgIC8vIEV2ZW50IHR5cGVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50eXBlID0gc3JjO1xuICAgIH1cblxuICAgIC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XG4gICAgaWYgKCBwcm9wcyApIHtcbiAgICAgIC8vICQkLnV0aWwuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXG4gICAgICAvLyBtb3JlIGVmZmljaWVudCB0byBtYW51YWxseSBjb3B5IGZpZWxkcyB3ZSB1c2VcbiAgICAgIHRoaXMudHlwZSA9IHByb3BzLnR5cGUgIT09IHVuZGVmaW5lZCA/IHByb3BzLnR5cGUgOiB0aGlzLnR5cGU7XG4gICAgICB0aGlzLmN5ID0gcHJvcHMuY3k7XG4gICAgICB0aGlzLmN5VGFyZ2V0ID0gcHJvcHMuY3lUYXJnZXQ7XG4gICAgICB0aGlzLmN5UG9zaXRpb24gPSBwcm9wcy5jeVBvc2l0aW9uO1xuICAgICAgdGhpcy5jeVJlbmRlcmVkUG9zaXRpb24gPSBwcm9wcy5jeVJlbmRlcmVkUG9zaXRpb247XG4gICAgICB0aGlzLm5hbWVzcGFjZSA9IHByb3BzLm5hbWVzcGFjZTtcbiAgICAgIHRoaXMubGF5b3V0ID0gcHJvcHMubGF5b3V0O1xuICAgICAgdGhpcy5kYXRhID0gcHJvcHMuZGF0YTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuICAgIHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgK25ldyBEYXRlKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG4gICQkLkV2ZW50LnByb3RvdHlwZSA9IHtcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgaWYgKCAhZSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBwcmV2ZW50RGVmYXVsdCBleGlzdHMgcnVuIGl0IG9uIHRoZSBvcmlnaW5hbCBldmVudFxuICAgICAgaWYgKCBlLnByZXZlbnREZWZhdWx0ICkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cbiAgICAgIHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuICAgICAgaWYgKCAhZSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gaWYgc3RvcFByb3BhZ2F0aW9uIGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgICBpZiAoIGUuc3RvcFByb3BhZ2F0aW9uICkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuICAgICAgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuICAgIGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG4gICAgaXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuICAgIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZVxuICB9O1xuICBcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gdXNlIHRoaXMgbW9kdWxlIHRvIGNoZXJyeSBwaWNrIGZ1bmN0aW9ucyBpbnRvIHlvdXIgcHJvdG90eXBlXG4gIC8vICh1c2VmdWwgZm9yIGZ1bmN0aW9ucyBzaGFyZWQgYmV0d2VlbiB0aGUgY29yZSBhbmQgY29sbGVjdGlvbnMsIGZvciBleGFtcGxlKVxuXG4gIC8vIGUuZy5cbiAgLy8gJCQuZm4uY29sbGVjdGlvbih7XG4gIC8vICAgZm9vOiAkJC5kZWZpbmUuZm9vKHsgLyogcGFyYW1zLi4uICovIH0pXG4gIC8vIH0pO1xuXG4gICQkLmRlZmluZSA9IHtcblxuICAgIC8vIGFjY2VzcyBkYXRhIGZpZWxkXG4gICAgZGF0YTogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0geyBcbiAgICAgICAgZmllbGQ6ICdkYXRhJyxcbiAgICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICAgIGFsbG93U2V0dGluZzogZmFsc2UsXG4gICAgICAgIGFsbG93R2V0dGluZzogZmFsc2UsXG4gICAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgICAgaW1tdXRhYmxlS2V5czoge30sIC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgICAgICB1cGRhdGVTdHlsZTogZmFsc2UsXG4gICAgICAgIG9uU2V0OiBmdW5jdGlvbiggc2VsZiApe30sXG4gICAgICAgIGNhblNldDogZnVuY3Rpb24oIHNlbGYgKXsgcmV0dXJuIHRydWU7IH1cbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBkYXRhSW1wbCggbmFtZSwgdmFsdWUgKXtcbiAgICAgICAgdmFyIHAgPSBwYXJhbXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIHNpbmdsZSA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGZbMF0gOiBzZWxmO1xuXG4gICAgICAgIC8vIC5kYXRhKCdmb28nLCAuLi4pXG4gICAgICAgIGlmKCAkJC5pcy5zdHJpbmcobmFtZSkgKXsgLy8gc2V0IG9yIGdldCBwcm9wZXJ0eVxuXG4gICAgICAgICAgLy8gLmRhdGEoJ2ZvbycpXG4gICAgICAgICAgaWYoIHAuYWxsb3dHZXR0aW5nICYmIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gZ2V0XG5cbiAgICAgICAgICAgIHZhciByZXQ7XG4gICAgICAgICAgICBpZiggc2luZ2xlICl7XG4gICAgICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVsgcC5maWVsZCBdWyBuYW1lIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIC5kYXRhKCdmb28nLCAnYmFyJylcbiAgICAgICAgICB9IGVsc2UgaWYoIHAuYWxsb3dTZXR0aW5nICYmIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7IC8vIHNldFxuICAgICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1tuYW1lXTtcbiAgICAgICAgICAgIGlmKCB2YWxpZCApe1xuICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMCwgbCA9IGFsbC5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgICAgICAgICAgICBpZiggcC5jYW5TZXQoIGFsbFtpXSApICl7XG4gICAgICAgICAgICAgICAgICBhbGxbaV0uX3ByaXZhdGVbIHAuZmllbGQgXVsgbmFtZSBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gdXBkYXRlIG1hcHBlcnMgaWYgYXNrZWRcbiAgICAgICAgICAgICAgaWYoIHAudXBkYXRlU3R5bGUgKXsgc2VsZi51cGRhdGVTdHlsZSgpOyB9XG5cbiAgICAgICAgICAgICAgLy8gY2FsbCBvblNldCBjYWxsYmFja1xuICAgICAgICAgICAgICBwLm9uU2V0KCBzZWxmICk7XG5cbiAgICAgICAgICAgICAgaWYoIHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQgKXtcbiAgICAgICAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5zZXR0aW5nRXZlbnQgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAvLyAuZGF0YSh7ICdmb28nOiAnYmFyJyB9KVxuICAgICAgICB9IGVsc2UgaWYoIHAuYWxsb3dTZXR0aW5nICYmICQkLmlzLnBsYWluT2JqZWN0KG5hbWUpICl7IC8vIGV4dGVuZFxuICAgICAgICAgIHZhciBvYmogPSBuYW1lO1xuICAgICAgICAgIHZhciBrLCB2O1xuXG4gICAgICAgICAgZm9yKCBrIGluIG9iaiApe1xuICAgICAgICAgICAgdiA9IG9ialsgayBdO1xuXG4gICAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW2tdO1xuICAgICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICAgICAgICAgIGlmKCBwLmNhblNldCggYWxsW2ldICkgKXtcbiAgICAgICAgICAgICAgICAgIGFsbFtpXS5fcHJpdmF0ZVsgcC5maWVsZCBdWyBrIF0gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICAgIGlmKCBwLnVwZGF0ZVN0eWxlICl7IHNlbGYudXBkYXRlU3R5bGUoKTsgfVxuXG4gICAgICAgICAgLy8gY2FsbCBvblNldCBjYWxsYmFja1xuICAgICAgICAgIHAub25TZXQoIHNlbGYgKTtcblxuICAgICAgICAgIGlmKCBwLnNldHRpbmdUcmlnZ2Vyc0V2ZW50ICl7XG4gICAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5zZXR0aW5nRXZlbnQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyAuZGF0YShmdW5jdGlvbigpeyAuLi4gfSlcbiAgICAgICAgfSBlbHNlIGlmKCBwLmFsbG93QmluZGluZyAmJiAkJC5pcy5mbihuYW1lKSApeyAvLyBiaW5kIHRvIGV2ZW50XG4gICAgICAgICAgdmFyIGZuID0gbmFtZTtcbiAgICAgICAgICBzZWxmLmJpbmQoIHAuYmluZGluZ0V2ZW50LCBmbiApO1xuICAgICAgICBcbiAgICAgICAgLy8gLmRhdGEoKVxuICAgICAgICB9IGVsc2UgaWYoIHAuYWxsb3dHZXR0aW5nICYmIG5hbWUgPT09IHVuZGVmaW5lZCApeyAvLyBnZXQgd2hvbGUgb2JqZWN0XG4gICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICBpZiggc2luZ2xlICl7XG4gICAgICAgICAgICByZXQgPSBzaW5nbGUuX3ByaXZhdGVbIHAuZmllbGQgXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmFiaWxpdHlcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSwgLy8gZGF0YVxuXG4gICAgLy8gcmVtb3ZlIGRhdGEgZmllbGRcbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7IFxuICAgICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICAgIHRyaWdnZXJFdmVudDogZmFsc2UsXG4gICAgICAgIGltbXV0YWJsZUtleXM6IHt9IC8vIGtleSA9PiB0cnVlIGlmIGltbXV0YWJsZVxuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZURhdGFJbXBsKCBuYW1lcyApe1xuICAgICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICBcbiAgICAgICAgLy8gLnJlbW92ZURhdGEoJ2ZvbyBiYXInKVxuICAgICAgICBpZiggJCQuaXMuc3RyaW5nKG5hbWVzKSApeyAvLyB0aGVuIGdldCB0aGUgbGlzdCBvZiBrZXlzLCBhbmQgZGVsZXRlIHRoZW1cbiAgICAgICAgICB2YXIga2V5cyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbDsgaSsrICl7IC8vIGRlbGV0ZSBlYWNoIG5vbi1lbXB0eSBrZXlcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGtleSkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgICAgdmFyIHZhbGlkID0gIXAuaW1tdXRhYmxlS2V5c1sga2V5IF07IC8vIG5vdCB2YWxpZCBpZiBpbW11dGFibGVcbiAgICAgICAgICAgIGlmKCB2YWxpZCApe1xuICAgICAgICAgICAgICBmb3IoIHZhciBpX2EgPSAwLCBsX2EgPSBhbGwubGVuZ3RoOyBpX2EgPCBsX2E7IGlfYSsrICl7XG4gICAgICAgICAgICAgICAgYWxsWyBpX2EgXS5fcHJpdmF0ZVsgcC5maWVsZCBdWyBrZXkgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBwLnRyaWdnZXJFdmVudCApe1xuICAgICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuZXZlbnQgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gLnJlbW92ZURhdGEoKVxuICAgICAgICB9IGVsc2UgaWYoIG5hbWVzID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBkZWxldGUgYWxsIGtleXNcblxuICAgICAgICAgIGZvciggdmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKysgKXtcbiAgICAgICAgICAgIHZhciBfcHJpdmF0ZUZpZWxkcyA9IGFsbFsgaV9hIF0uX3ByaXZhdGVbIHAuZmllbGQgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKCB2YXIga2V5IGluIF9wcml2YXRlRmllbGRzICl7XG4gICAgICAgICAgICAgIHZhciB2YWxpZEtleVRvRGVsZXRlID0gIXAuaW1tdXRhYmxlS2V5c1sga2V5IF07XG5cbiAgICAgICAgICAgICAgaWYoIHZhbGlkS2V5VG9EZWxldGUgKXtcbiAgICAgICAgICAgICAgICBfcHJpdmF0ZUZpZWxkc1sga2V5IF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggcC50cmlnZ2VyRXZlbnQgKXtcbiAgICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLmV2ZW50ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9OyAvLyBmdW5jdGlvblxuICAgIH0sIC8vIHJlbW92ZURhdGFcblxuICAgIC8vIGV2ZW50IGZ1bmN0aW9uIHJldXNhYmxlIHN0dWZmXG4gICAgZXZlbnQ6IHtcbiAgICAgIHJlZ2V4OiAvKFxcdyspKFxcLlxcdyspPy8sIC8vIHJlZ2V4IGZvciBtYXRjaGluZyBldmVudCBzdHJpbmdzIChlLmcuIFwiY2xpY2submFtZXNwYWNlXCIpXG4gICAgICBvcHRpb25hbFR5cGVSZWdleDogLyhcXHcrKT8oXFwuXFx3Kyk/LyxcbiAgICAgIGZhbHNlQ2FsbGJhY2s6IGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZTsgfVxuICAgIH0sXG5cbiAgICAvLyBldmVudCBiaW5kaW5nXG4gICAgb246IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgICAgdW5iaW5kU2VsZk9uVHJpZ2dlcjogZmFsc2UsXG4gICAgICAgIHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IGZhbHNlXG4gICAgICB9O1xuICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gZnVuY3Rpb24gb25JbXBsKGV2ZW50cywgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgZXZlbnRzSXNTdHJpbmcgPSAkJC5pcy5zdHJpbmcoZXZlbnRzKTtcbiAgICAgICAgdmFyIHAgPSBwYXJhbXM7XG5cbiAgICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHNlbGVjdG9yKSApeyAvLyBzZWxlY3RvciBpcyBhY3R1YWxseSBkYXRhXG4gICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgIGRhdGEgPSBzZWxlY3RvcjtcbiAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5mbihzZWxlY3RvcikgfHwgc2VsZWN0b3IgPT09IGZhbHNlICl7IC8vIHNlbGVjdG9yIGlzIGFjdHVhbGx5IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICQkLmlzLmZuKGRhdGEpIHx8IGRhdGEgPT09IGZhbHNlICl7IC8vIGRhdGEgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzbid0IGEgY2FsbGJhY2ssIHdlIGNhbid0IHJlYWxseSBkbyBhbnl0aGluZ1xuICAgICAgICAvLyAoY2FuJ3Qgc3BlYWsgZm9yIG1hcHBlZCBldmVudHMgYXJnIHZlcnNpb24pXG4gICAgICAgIGlmKCAhKCQkLmlzLmZuKGNhbGxiYWNrKSB8fCBjYWxsYmFjayA9PT0gZmFsc2UpICYmIGV2ZW50c0lzU3RyaW5nICl7XG4gICAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICAgIH1cblxuICAgICAgICBpZiggZXZlbnRzSXNTdHJpbmcgKXsgLy8gdGhlbiBjb252ZXJ0IHRvIG1hcFxuICAgICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgICBtYXBbIGV2ZW50cyBdID0gY2FsbGJhY2s7XG4gICAgICAgICAgZXZlbnRzID0gbWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCB2YXIgZXZ0cyBpbiBldmVudHMgKXtcbiAgICAgICAgICBjYWxsYmFjayA9IGV2ZW50c1tldnRzXTtcbiAgICAgICAgICBpZiggY2FsbGJhY2sgPT09IGZhbHNlICl7XG4gICAgICAgICAgICBjYWxsYmFjayA9ICQkLmRlZmluZS5ldmVudC5mYWxzZUNhbGxiYWNrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhJCQuaXMuZm4oY2FsbGJhY2spICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBldnRzID0gZXZ0cy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGV2dCA9IGV2dHNbaV07XG4gICAgICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoZXZ0KSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goICQkLmRlZmluZS5ldmVudC5yZWdleCApOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG5cbiAgICAgICAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gbWF0Y2hbMl0gPyBtYXRjaFsyXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLCAvLyBjYWxsYmFjayB0byBydW5cbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLCAvLyBleHRyYSBkYXRhIGluIGV2ZW50T2JqLmRhdGFcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZWQ6IHNlbGVjdG9yID8gdHJ1ZSA6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBldnQgaXMgZGVsZWdhdGVkXG4gICAgICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLCAvLyB0aGUgc2VsZWN0b3IgdG8gbWF0Y2ggZm9yIGRlbGVnYXRlZCBldmVudHNcbiAgICAgICAgICAgICAgICBzZWxPYmo6IG5ldyAkJC5TZWxlY3RvcihzZWxlY3RvciksIC8vIGNhY2hlZCBzZWxlY3RvciBvYmplY3QgdG8gc2F2ZSByZWJ1aWxkaW5nXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSwgLy8gdGhlIGV2ZW50IHR5cGUgKGUuZy4gJ2NsaWNrJylcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgLy8gdGhlIGV2ZW50IG5hbWVzcGFjZSAoZS5nLiBcIi5mb29cIilcbiAgICAgICAgICAgICAgICB1bmJpbmRTZWxmT25UcmlnZ2VyOiBwLnVuYmluZFNlbGZPblRyaWdnZXIsXG4gICAgICAgICAgICAgICAgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogcC51bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyLFxuICAgICAgICAgICAgICAgIGJpbmRlcnM6IGFsbCAvLyB3aG8gYm91bmQgdG9nZXRoZXJcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGFsbC5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgICAgIGFsbFtqXS5fcHJpdmF0ZS5saXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gZm9yIGV2ZW50cyBhcnJheVxuICAgICAgICB9IC8vIGZvciBldmVudHMgbWFwXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSwgLy8gb25cblxuICAgIG9mZjogZnVuY3Rpb24gb2ZmSW1wbCggcGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICB9O1xuICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuICAgICAgXG4gICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnRzLCBzZWxlY3RvciwgY2FsbGJhY2spe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBldmVudHNJc1N0cmluZyA9ICQkLmlzLnN0cmluZyhldmVudHMpO1xuXG4gICAgICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAwICl7IC8vIHRoZW4gdW5iaW5kIGFsbFxuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIGFsbFtpXS5fcHJpdmF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAkJC5pcy5mbihzZWxlY3RvcikgfHwgc2VsZWN0b3IgPT09IGZhbHNlICl7IC8vIHNlbGVjdG9yIGlzIGFjdHVhbGx5IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBzZWxlY3RvcjtcbiAgICAgICAgICBzZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBldmVudHNJc1N0cmluZyApeyAvLyB0aGVuIGNvbnZlcnQgdG8gbWFwXG4gICAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICAgIG1hcFsgZXZlbnRzIF0gPSBjYWxsYmFjaztcbiAgICAgICAgICBldmVudHMgPSBtYXA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBldnRzIGluIGV2ZW50cyApe1xuICAgICAgICAgIGNhbGxiYWNrID0gZXZlbnRzW2V2dHNdO1xuXG4gICAgICAgICAgaWYoIGNhbGxiYWNrID09PSBmYWxzZSApe1xuICAgICAgICAgICAgY2FsbGJhY2sgPSAkJC5kZWZpbmUuZXZlbnQuZmFsc2VDYWxsYmFjaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBldnRzID0gZXZ0cy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIGZvciggdmFyIGggPSAwOyBoIDwgZXZ0cy5sZW5ndGg7IGgrKyApe1xuICAgICAgICAgICAgdmFyIGV2dCA9IGV2dHNbaF07XG4gICAgICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoZXZ0KSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goICQkLmRlZmluZS5ldmVudC5vcHRpb25hbFR5cGVSZWdleCApOyAvLyBbdHlwZV1bLm5hbWVzcGFjZV1cbiAgICAgICAgICAgIGlmKCBtYXRjaCApe1xuICAgICAgICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdID8gbWF0Y2hbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrICl7IC8vXG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IGFsbFtpXS5fcHJpdmF0ZS5saXN0ZW5lcnM7XG5cbiAgICAgICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGxpc3RlbmVycy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgdmFyIG5zTWF0Y2hlcyA9ICFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSBsaXN0ZW5lci5uYW1lc3BhY2U7XG4gICAgICAgICAgICAgICAgICB2YXIgdHlwZU1hdGNoZXMgPSAhdHlwZSB8fCBsaXN0ZW5lci50eXBlID09PSB0eXBlO1xuICAgICAgICAgICAgICAgICAgdmFyIGNiTWF0Y2hlcyA9ICFjYWxsYmFjayB8fCBjYWxsYmFjayA9PT0gbGlzdGVuZXIuY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXRjaGVzID0gbnNNYXRjaGVzICYmIHR5cGVNYXRjaGVzICYmIGNiTWF0Y2hlcztcblxuICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIGxpc3RlbmVyIGlmIGl0IG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgIGlmKCBsaXN0ZW5lck1hdGNoZXMgKXtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZm9yIGxpc3RlbmVyc1xuICAgICAgICAgICAgICB9IC8vIGZvciBhbGxcbiAgICAgICAgICAgIH0gLy8gaWYgbWF0Y2hcbiAgICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcblxuICAgICAgICB9IC8vIGZvciBldmVudHMgbWFwXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSwgLy8gb2ZmXG5cbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRyaWdnZXJJbXBsKGV2ZW50cywgZXh0cmFQYXJhbXMsIGZuVG9UcmlnZ2VyKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgZXZlbnRzSXNTdHJpbmcgPSAkJC5pcy5zdHJpbmcoZXZlbnRzKTtcbiAgICAgICAgdmFyIGV2ZW50c0lzT2JqZWN0ID0gJCQuaXMucGxhaW5PYmplY3QoZXZlbnRzKTtcbiAgICAgICAgdmFyIGV2ZW50c0lzRXZlbnQgPSAkJC5pcy5ldmVudChldmVudHMpO1xuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gbWFrZSBhIHBsYWluIGV2ZW50IG9iamVjdCBmb3IgZWFjaCBldmVudCBuYW1lXG4gICAgICAgICAgdmFyIGV2dHMgPSBldmVudHMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICBldmVudHMgPSBbXTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGV2dCA9IGV2dHNbaV07XG4gICAgICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoZXZ0KSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBldnQubWF0Y2goICQkLmRlZmluZS5ldmVudC5yZWdleCApOyAvLyB0eXBlWy5uYW1lc3BhY2VdXG4gICAgICAgICAgICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKCB7XG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIGV2ZW50c0lzT2JqZWN0ICl7IC8vIHB1dCBpbiBsZW5ndGggMSBhcnJheVxuICAgICAgICAgIHZhciBldmVudEFyZ09iaiA9IGV2ZW50cztcblxuICAgICAgICAgIGV2ZW50cyA9IFsgZXZlbnRBcmdPYmogXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBleHRyYVBhcmFtcyApe1xuICAgICAgICAgIGlmKCAhJCQuaXMuYXJyYXkoZXh0cmFQYXJhbXMpICl7IC8vIG1ha2Ugc3VyZSBleHRyYSBwYXJhbXMgYXJlIGluIGFuIGFycmF5IGlmIHNwZWNpZmllZFxuICAgICAgICAgICAgZXh0cmFQYXJhbXMgPSBbIGV4dHJhUGFyYW1zIF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIHdlJ3ZlIGdvdCBub3RoaW5nXG4gICAgICAgICAgZXh0cmFQYXJhbXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrICl7IC8vIHRyaWdnZXIgZWFjaCBldmVudCBpbiBvcmRlclxuICAgICAgICAgIHZhciBldnRPYmogPSBldmVudHNbaV07XG4gICAgICAgICAgXG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbGwubGVuZ3RoOyBqKysgKXsgLy8gZm9yIGVhY2hcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyZXIgPSBhbGxbal07XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdHJpZ2dlcmVyLl9wcml2YXRlLmxpc3RlbmVycztcbiAgICAgICAgICAgIHZhciB0cmlnZ2VyZXJJc0VsZW1lbnQgPSAkJC5pcy5lbGVtZW50KHRyaWdnZXJlcik7XG4gICAgICAgICAgICB2YXIgYnViYmxlVXAgPSB0cmlnZ2VyZXJJc0VsZW1lbnQgfHwgcGFyYW1zLmxheW91dDtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBldmVudCBmb3IgdGhpcyBlbGVtZW50IGZyb20gdGhlIGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgdmFyIGV2dDtcblxuICAgICAgICAgICAgaWYoIGV2ZW50c0lzRXZlbnQgKXsgLy8gdGhlbiBqdXN0IGdldCB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIGV2dCA9IGV2dE9iajtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGV2dC5jeVRhcmdldCA9IGV2dC5jeVRhcmdldCB8fCB0cmlnZ2VyZXI7XG4gICAgICAgICAgICAgIGV2dC5jeSA9IGV2dC5jeSB8fCBjeTtcblxuICAgICAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiB3ZSBoYXZlIHRvIG1ha2Ugb25lXG4gICAgICAgICAgICAgIGV2dCA9IG5ldyAkJC5FdmVudCggZXZ0T2JqLCB7XG4gICAgICAgICAgICAgICAgY3lUYXJnZXQ6IHRyaWdnZXJlcixcbiAgICAgICAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBldnRPYmoubmFtZXNwYWNlXG4gICAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYSBsYXlvdXQgd2FzIHNwZWNpZmllZCwgdGhlbiBwdXQgaXQgaW4gdGhlIHR5cGVkIGV2ZW50XG4gICAgICAgICAgICBpZiggZXZ0T2JqLmxheW91dCApe1xuICAgICAgICAgICAgICBldnQubGF5b3V0ID0gZXZ0T2JqLmxheW91dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdHJpZ2dlcmVkIGJ5IGxheW91dCwgcHV0IGluIGV2ZW50XG4gICAgICAgICAgICBpZiggcGFyYW1zLmxheW91dCApe1xuICAgICAgICAgICAgICBldnQubGF5b3V0ID0gdHJpZ2dlcmVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYSByZW5kZXJlZCBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgcGFzc2VkIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiggZXZ0LmN5UG9zaXRpb24gKXtcbiAgICAgICAgICAgICAgdmFyIHBvcyA9IGV2dC5jeVBvc2l0aW9uO1xuICAgICAgICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgICAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuXG4gICAgICAgICAgICAgIGV2dC5jeVJlbmRlcmVkUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgICAgICAgICAgeTogcG9zLnkgKiB6b29tICsgcGFuLnlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIGZuVG9UcmlnZ2VyICl7IC8vIHRoZW4gb3ZlcnJpZGUgdGhlIGxpc3RlbmVycyBsaXN0IHdpdGgganVzdCB0aGUgb25lIHdlIHNwZWNpZmllZFxuICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBbe1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogZXZ0Lm5hbWVzcGFjZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBldnQudHlwZSxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZm5Ub1RyaWdnZXJcbiAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgbGlzdGVuZXJzLmxlbmd0aDsgaysrICl7IC8vIGNoZWNrIGVhY2ggbGlzdGVuZXJcbiAgICAgICAgICAgICAgdmFyIGxpcyA9IGxpc3RlbmVyc1trXTtcbiAgICAgICAgICAgICAgdmFyIG5zTWF0Y2hlcyA9ICFsaXMubmFtZXNwYWNlIHx8IGxpcy5uYW1lc3BhY2UgPT09IGV2dC5uYW1lc3BhY2U7XG4gICAgICAgICAgICAgIHZhciB0eXBlTWF0Y2hlcyA9IGxpcy50eXBlID09PSBldnQudHlwZTtcbiAgICAgICAgICAgICAgdmFyIHRhcmdldE1hdGNoZXMgPSBsaXMuZGVsZWdhdGVkID8gKCB0cmlnZ2VyZXIgIT09IGV2dC5jeVRhcmdldCAmJiAkJC5pcy5lbGVtZW50KGV2dC5jeVRhcmdldCkgJiYgbGlzLnNlbE9iai5tYXRjaGVzKGV2dC5jeVRhcmdldCkgKSA6ICh0cnVlKTsgLy8gd2UncmUgbm90IGdvaW5nIHRvIHZhbGlkYXRlIHRoZSBoaWVyYXJjaHk7IHRoYXQncyB0b28gZXhwZW5zaXZlXG4gICAgICAgICAgICAgIHZhciBsaXN0ZW5lck1hdGNoZXMgPSBuc01hdGNoZXMgJiYgdHlwZU1hdGNoZXMgJiYgdGFyZ2V0TWF0Y2hlcztcblxuICAgICAgICAgICAgICBpZiggbGlzdGVuZXJNYXRjaGVzICl7IC8vIHRoZW4gdHJpZ2dlciBpdFxuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gWyBldnQgXTtcbiAgICAgICAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoIGV4dHJhUGFyYW1zICk7IC8vIGFkZCBleHRyYSBwYXJhbXMgdG8gYXJncyBsaXN0XG5cbiAgICAgICAgICAgICAgICBpZiggbGlzLmRhdGEgKXsgLy8gYWRkIG9uIGRhdGEgcGx1Z2dlZCBpbnRvIGJpbmRpbmdcbiAgICAgICAgICAgICAgICAgIGV2dC5kYXRhID0gbGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3IgY2xlYXIgaXQgaW4gY2FzZSB0aGUgZXZlbnQgb2JqIGlzIHJldXNlZFxuICAgICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIGxpcy51bmJpbmRTZWxmT25UcmlnZ2VyIHx8IGxpcy51bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyICl7IC8vIHRoZW4gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGssIDEpO1xuICAgICAgICAgICAgICAgICAgay0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCBsaXMudW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlciApeyAvLyB0aGVuIGRlbGV0ZSB0aGUgbGlzdGVuZXIgZm9yIGFsbCBiaW5kZXJzXG4gICAgICAgICAgICAgICAgICB2YXIgYmluZGVycyA9IGxpcy5iaW5kZXJzO1xuICAgICAgICAgICAgICAgICAgZm9yKCB2YXIgbCA9IDA7IGwgPCBiaW5kZXJzLmxlbmd0aDsgbCsrICl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXIgPSBiaW5kZXJzW2xdO1xuICAgICAgICAgICAgICAgICAgICBpZiggIWJpbmRlciB8fCBiaW5kZXIgPT09IHRyaWdnZXJlciApeyBjb250aW51ZTsgfSAvLyBhbHJlYWR5IGhhbmRsZWQgdHJpZ2dlcmVyIG9yIHdlIGNhbid0IGhhbmRsZSBpdFxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXJMaXN0ZW5lcnMgPSBiaW5kZXIuX3ByaXZhdGUubGlzdGVuZXJzO1xuICAgICAgICAgICAgICAgICAgICBmb3IoIHZhciBtID0gMDsgbSA8IGJpbmRlckxpc3RlbmVycy5sZW5ndGg7IG0rKyApe1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXJMaXN0ZW5lciA9IGJpbmRlckxpc3RlbmVyc1ttXTtcblxuICAgICAgICAgICAgICAgICAgICAgIGlmKCBiaW5kZXJMaXN0ZW5lciA9PT0gbGlzICl7IC8vIGRlbGV0ZSBsaXN0ZW5lciBmcm9tIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRlckxpc3RlbmVycy5zcGxpY2UobSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLS07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gcnVuIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gbGlzLmRlbGVnYXRlZCA/IGV2dC5jeVRhcmdldCA6IHRyaWdnZXJlcjtcbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gbGlzLmNhbGxiYWNrLmFwcGx5KCBjb250ZXh0LCBhcmdzICk7XG5cbiAgICAgICAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSB8fCBldnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApe1xuICAgICAgICAgICAgICAgICAgLy8gdGhlbiBkb24ndCBidWJibGVcbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVVwID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybmluZyBmYWxzZSBpcyBhIHNob3J0aGFuZCBmb3Igc3RvcHBpbmcgcHJvcGFnYXRpb24gYW5kIHByZXZlbnRpbmcgdGhlIGRlZi4gYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IC8vIGlmIGxpc3RlbmVyIG1hdGNoZXNcbiAgICAgICAgICAgIH0gLy8gZm9yIGVhY2ggbGlzdGVuZXJcblxuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGV2ZW50IGZvciBlbGVtZW50c1xuICAgICAgICAgICAgaWYoIGJ1YmJsZVVwICl7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZHMgPyB0cmlnZ2VyZXIuX3ByaXZhdGUucGFyZW50IDogbnVsbDtcbiAgICAgICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5sZW5ndGggIT09IDA7XG5cbiAgICAgICAgICAgICAgaWYoIGhhc1BhcmVudCApeyAvLyB0aGVuIGJ1YmJsZSB1cCB0byBwYXJlbnRcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgICAgICAgcGFyZW50LnRyaWdnZXIoZXZ0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCBidWJibGUgdXAgdG8gdGhlIGNvcmVcbiAgICAgICAgICAgICAgICBjeS50cmlnZ2VyKGV2dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gLy8gZm9yIGVhY2ggb2YgYWxsXG4gICAgICAgIH0gLy8gZm9yIGVhY2ggZXZlbnRcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyB0cmlnZ2VyXG5cblxuICAgIGFuaW1hdGVkOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgZm5QYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVkSW1wbCgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIHZhciBlbGUgPSBhbGxbMF07XG5cbiAgICAgICAgaWYoIGVsZSApe1xuICAgICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LCAvLyBhbmltYXRlZFxuXG4gICAgY2xlYXJRdWV1ZTogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICAgIGZuUGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBjbGVhclF1ZXVlSW1wbCgpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9LCAvLyBjbGVhclF1ZXVlXG5cbiAgICBkZWxheTogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICAgIGZuUGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBkZWxheUltcGwoIHRpbWUsIGNvbXBsZXRlICl7XG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgdGhpcy5hbmltYXRlKHtcbiAgICAgICAgICBkZWxheTogdGltZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRpbWUsXG4gICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9LCAvLyBkZWxheVxuXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICAgIGZuUGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBhbmltYXRlSW1wbCggcHJvcGVydGllcywgcGFyYW1zICl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuICAgICAgICB2YXIgaXNDb3JlID0gIXNlbGZJc0FycmF5TGlrZTtcbiAgICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG5cbiAgICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICAgIHZhciBjYWxsVGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgICAgICB2YXIgcTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBwYXJhbXMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHBhcmFtcy5kdXJhdGlvbiA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgcGFyYW1zLmR1cmF0aW9uID0gNDAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2goIHBhcmFtcy5kdXJhdGlvbiApe1xuICAgICAgICBjYXNlICdzbG93JzpcbiAgICAgICAgICBwYXJhbXMuZHVyYXRpb24gPSA2MDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Zhc3QnOlxuICAgICAgICAgIHBhcmFtcy5kdXJhdGlvbiA9IDIwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHByb3BlcnRpZXNFbXB0eSA9IHRydWU7XG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzICl7IGZvciggdmFyIGkgaW4gcHJvcGVydGllcyApe1xuICAgICAgICAgIHByb3BlcnRpZXNFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IH1cblxuICAgICAgICBpZiggcHJvcGVydGllc0VtcHR5ICl7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHByb3BlcnRpZXMuY3NzICYmIGlzRWxlcyApe1xuICAgICAgICAgIHByb3BlcnRpZXMuY3NzID0gc3R5bGUuZ2V0VmFsdWVTdHlsZSggcHJvcGVydGllcy5jc3MsIHsgYXJyYXk6IHRydWUgfSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbiAmJiBpc0VsZXMgKXtcbiAgICAgICAgICB2YXIgcnBvcyA9IHByb3BlcnRpZXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogKCBycG9zLnggLSBwYW4ueCApIC96b29tLFxuICAgICAgICAgICAgeTogKCBycG9zLnkgLSBwYW4ueSApIC96b29tXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG92ZXJyaWRlIHBhbiB3LyBwYW5CeSBpZiBzZXRcbiAgICAgICAgaWYoIHByb3BlcnRpZXMucGFuQnkgJiYgaXNDb3JlICl7XG4gICAgICAgICAgdmFyIHBhbkJ5ID0gcHJvcGVydGllcy5wYW5CeTtcbiAgICAgICAgICB2YXIgY3lQYW4gPSBjeS5wYW4oKTtcblxuICAgICAgICAgIHByb3BlcnRpZXMucGFuID0ge1xuICAgICAgICAgICAgeDogY3lQYW4ueCArIHBhbkJ5LngsXG4gICAgICAgICAgICB5OiBjeVBhbi55ICsgcGFuQnkueVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVycmlkZSBwYW4gdy8gY2VudGVyIGlmIHNldFxuICAgICAgICB2YXIgY2VudGVyID0gcHJvcGVydGllcy5jZW50ZXIgfHwgcHJvcGVydGllcy5jZW50cmU7XG4gICAgICAgIGlmKCBjZW50ZXIgJiYgaXNDb3JlICl7XG4gICAgICAgICAgdmFyIGNlbnRlclBhbiA9IGN5LmdldENlbnRlclBhbiggY2VudGVyLmVsZXMsIHByb3BlcnRpZXMuem9vbSApO1xuXG4gICAgICAgICAgaWYoIGNlbnRlclBhbiApe1xuICAgICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBjZW50ZXJQYW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgcGFuICYgem9vbSB3LyBmaXQgaWYgc2V0XG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLmZpdCAmJiBpc0NvcmUgKXtcbiAgICAgICAgICB2YXIgZml0ID0gcHJvcGVydGllcy5maXQ7XG4gICAgICAgICAgdmFyIGZpdFZwID0gY3kuZ2V0Rml0Vmlld3BvcnQoIGZpdC5lbGVzIHx8IGZpdC5ib3VuZGluZ0JveCwgZml0LnBhZGRpbmcgKTtcblxuICAgICAgICAgIGlmKCBmaXRWcCApe1xuICAgICAgICAgICAgcHJvcGVydGllcy5wYW4gPSBmaXRWcC5wYW47IC8veyB4OiBmaXRWcC5wYW4ueCwgeTogZml0VnAucGFuLnkgfTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuem9vbSA9IGZpdFZwLnpvb207XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICAgXG4gICAgICAgICAgaWYoIGVsZS5hbmltYXRlZCgpICYmIChwYXJhbXMucXVldWUgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMucXVldWUpICl7XG4gICAgICAgICAgICBxID0gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcSA9IGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBxLnB1c2goe1xuICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJhbXMuZHVyYXRpb24sXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIGNhbGxUaW1lOiBjYWxsVGltZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGlzRWxlcyApe1xuICAgICAgICAgIGN5LmFkZFRvQW5pbWF0aW9uUG9vbCggdGhpcyApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgICB9O1xuICAgIH0sIC8vIGFuaW1hdGVcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgICBmblBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gc3RvcEltcGwoIGNsZWFyUXVldWUsIGp1bXBUb0VuZCApe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3kgfHwgdGhpcztcblxuICAgICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gYWxsW2ldO1xuICAgICAgICAgIHZhciBhbmlzID0gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50O1xuXG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBhbmlzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gYW5pc1tqXTsgICAgXG4gICAgICAgICAgICBpZigganVtcFRvRW5kICl7XG4gICAgICAgICAgICAgIC8vIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBhbmltYXRpb24gbG9vcCwgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAvLyB3aWxsIGdvIHN0cmFpZ2h0IHRvIHRoZSBlbmQgYW5kIGJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgYW5pbWF0aW9uLmR1cmF0aW9uID0gMDsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGNsZWFyIHRoZSBxdWV1ZSBvZiBmdXR1cmUgYW5pbWF0aW9uc1xuICAgICAgICAgIGlmKCBjbGVhclF1ZXVlICl7XG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFqdW1wVG9FbmQgKXtcbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBub3RpZnkgKHRoZSBhbmltYXRpb24gbG9vcCBkb2Vzbid0IGRvIGl0IGZvciB1cyBvbiBgc3RvcGApXG4gICAgICAgIGN5Lm5vdGlmeSh7XG4gICAgICAgICAgY29sbGVjdGlvbjogdGhpcyxcbiAgICAgICAgICB0eXBlOiAnZHJhdydcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSAvLyBzdG9wXG5cbiAgfTsgLy8gZGVmaW5lXG5cbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uc2VsZWN0b3IgPSBmdW5jdGlvbihtYXAsIG9wdGlvbnMpe1xuICAgIGZvciggdmFyIG5hbWUgaW4gbWFwICl7XG4gICAgICB2YXIgZm4gPSBtYXBbbmFtZV07XG4gICAgICAkJC5TZWxlY3Rvci5wcm90b3R5cGVbIG5hbWUgXSA9IGZuO1xuICAgIH1cbiAgfTtcblxuICAkJC5TZWxlY3RvciA9IGZ1bmN0aW9uKG9ubHlUaGlzR3JvdXAsIHNlbGVjdG9yKXtcbiAgICBcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuU2VsZWN0b3IpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLlNlbGVjdG9yKG9ubHlUaGlzR3JvdXAsIHNlbGVjdG9yKTtcbiAgICB9XG4gIFxuICAgIGlmKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICYmIG9ubHlUaGlzR3JvdXAgIT09IHVuZGVmaW5lZCApe1xuICAgICAgc2VsZWN0b3IgPSBvbmx5VGhpc0dyb3VwO1xuICAgICAgb25seVRoaXNHcm91cCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIHNlbGYuX3ByaXZhdGUgPSB7XG4gICAgICBzZWxlY3RvclRleHQ6IG51bGwsXG4gICAgICBpbnZhbGlkOiB0cnVlXG4gICAgfTtcbiAgICBcbiAgICBpZiggIXNlbGVjdG9yIHx8ICggJCQuaXMuc3RyaW5nKHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5tYXRjaCgvXlxccyokLykgKSApe1xuICAgICAgXG4gICAgICBpZiggb25seVRoaXNHcm91cCA9PSBudWxsICl7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgICAgICBzZWxmLmxlbmd0aCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICAgICAgc2VsZlswXS5ncm91cCA9IG9ubHlUaGlzR3JvdXA7XG4gICAgICAgIHNlbGYubGVuZ3RoID0gMTtcbiAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgfSBlbHNlIGlmKCAkJC5pcy5lbGVtZW50KCBzZWxlY3RvciApICl7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IG5ldyAkJC5Db2xsZWN0aW9uKHNlbGYuY3koKSwgWyBzZWxlY3RvciBdKTtcbiAgICAgIFxuICAgICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICBzZWxmWzBdLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICAgICAgc2VsZi5sZW5ndGggPSAxO1xuICAgICAgXG4gICAgfSBlbHNlIGlmKCAkJC5pcy5jb2xsZWN0aW9uKCBzZWxlY3RvciApICl7XG4gICAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICAgIHNlbGZbMF0uY29sbGVjdGlvbiA9IHNlbGVjdG9yO1xuICAgICAgc2VsZi5sZW5ndGggPSAxO1xuICAgICAgXG4gICAgfSBlbHNlIGlmKCAkJC5pcy5mbiggc2VsZWN0b3IgKSApIHtcbiAgICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgICAgc2VsZlswXS5maWx0ZXIgPSBzZWxlY3RvcjtcbiAgICAgIHNlbGYubGVuZ3RoID0gMTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKCBzZWxlY3RvciApICl7XG5cbiAgICAgIC8vIHRoZSBjdXJyZW50IHN1YmplY3QgaW4gdGhlIHF1ZXJ5XG4gICAgICB2YXIgY3VycmVudFN1YmplY3QgPSBudWxsO1xuICAgICAgXG4gICAgICAvLyBzdG9yYWdlIGZvciBwYXJzZWQgcXVlcmllc1xuICAgICAgdmFyIG5ld1F1ZXJ5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjbGFzc2VzOiBbXSwgXG4gICAgICAgICAgY29sb25TZWxlY3RvcnM6IFtdLFxuICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgIGdyb3VwOiBudWxsLFxuICAgICAgICAgIGlkczogW10sXG4gICAgICAgICAgbWV0YTogW10sXG5cbiAgICAgICAgICAvLyBmYWtlIHNlbGVjdG9yc1xuICAgICAgICAgIGNvbGxlY3Rpb246IG51bGwsIC8vIGEgY29sbGVjdGlvbiB0byBtYXRjaCBhZ2FpbnN0XG4gICAgICAgICAgZmlsdGVyOiBudWxsLCAvLyBmaWx0ZXIgZnVuY3Rpb25cblxuICAgICAgICAgIC8vIHRoZXNlIGFyZSBkZWZpbmVkIGluIHRoZSB1cHdhcmQgZGlyZWN0aW9uIHJhdGhlciB0aGFuIGRvd24gKGUuZy4gY2hpbGQpXG4gICAgICAgICAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGdvIHVwIGluIFNlbGVjdG9yLmZpbHRlcigpXG4gICAgICAgICAgcGFyZW50OiBudWxsLCAvLyBwYXJlbnQgcXVlcnkgb2JqXG4gICAgICAgICAgYW5jZXN0b3I6IG51bGwsIC8vIGFuY2VzdG9yIHF1ZXJ5IG9ialxuICAgICAgICAgIHN1YmplY3Q6IG51bGwsIC8vIGRlZmluZXMgc3ViamVjdCBpbiBjb21wb3VuZCBxdWVyeSAoc3ViamVjdCBxdWVyeSBvYmo7IHBvaW50cyB0byBzZWxmIGlmIHN1YmplY3QpXG5cbiAgICAgICAgICAvLyB1c2UgdGhlc2Ugb25seSB3aGVuIHN1YmplY3QgaGFzIGJlZW4gZGVmaW5lZFxuICAgICAgICAgIGNoaWxkOiBudWxsLFxuICAgICAgICAgIGRlc2NlbmRhbnQ6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHRva2VucyBpbiB0aGUgcXVlcnkgbGFuZ3VhZ2VcbiAgICAgIHZhciB0b2tlbnMgPSB7XG4gICAgICAgIG1ldGFDaGFyOiAnW1xcXFwhXFxcXFwiXFxcXCNcXFxcJFxcXFwlXFxcXCZcXFxcXFwnXFxcXChcXFxcKVxcXFwqXFxcXCtcXFxcLFxcXFwuXFxcXC9cXFxcOlxcXFw7XFxcXDxcXFxcPVxcXFw+XFxcXD9cXFxcQFxcXFxbXFxcXF1cXFxcXlxcXFxgXFxcXHtcXFxcfFxcXFx9XFxcXH5dJywgLy8gY2hhcnMgd2UgbmVlZCB0byBlc2NhcGUgaW4gdmFyIG5hbWVzLCBldGNcbiAgICAgICAgY29tcGFyYXRvck9wOiAnPXxcXFxcIT18Pnw+PXw8fDw9fFxcXFwkPXxcXFxcXj18XFxcXCo9JywgLy8gYmluYXJ5IGNvbXBhcmlzb24gb3AgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpXG4gICAgICAgIGJvb2xPcDogJ1xcXFw/fFxcXFwhfFxcXFxeJywgLy8gYm9vbGVhbiAodW5hcnkpIG9wZXJhdG9ycyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICAgICAgc3RyaW5nOiAnXCIoPzpcXFxcXFxcXFwifFteXCJdKStcIicgKyAnfCcgKyBcIicoPzpcXFxcXFxcXCd8W14nXSkrJ1wiLCAvLyBzdHJpbmcgbGl0ZXJhbHMgKHVzZWQgaW4gZGF0YSBzZWxlY3RvcnMpIC0tIGRvdWJsZXF1b3RlcyB8IHNpbmdsZXF1b3Rlc1xuICAgICAgICBudW1iZXI6ICQkLnV0aWwucmVnZXgubnVtYmVyLCAvLyBudW1iZXIgbGl0ZXJhbCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0tIGUuZy4gMC4xMjM0LCAxMjM0LCAxMmUxMjNcbiAgICAgICAgbWV0YTogJ2RlZ3JlZXxpbmRlZ3JlZXxvdXRkZWdyZWUnLCAvLyBhbGxvd2VkIG1ldGFkYXRhIGZpZWxkcyAoaS5lLiBhbGxvd2VkIGZ1bmN0aW9ucyB0byB1c2UgZnJvbSAkJC5Db2xsZWN0aW9uKVxuICAgICAgICBzZXBhcmF0b3I6ICdcXFxccyosXFxcXHMqJywgLy8gcXVlcmllcyBhcmUgc2VwYXJhdGVkIGJ5IGNvbW1hcywgZS5nLiBlZGdlW2ZvbyA9ICdiYXInXSwgbm9kZS5zb21lQ2xhc3NcbiAgICAgICAgZGVzY2VuZGFudDogJ1xcXFxzKycsXG4gICAgICAgIGNoaWxkOiAnXFxcXHMrPlxcXFxzKycsXG4gICAgICAgIHN1YmplY3Q6ICdcXFxcJCdcbiAgICAgIH07XG4gICAgICB0b2tlbnMudmFyaWFibGUgPSAnKD86W1xcXFx3LV18KD86XFxcXFxcXFwnKyB0b2tlbnMubWV0YUNoYXIgKycpKSsnOyAvLyBhIHZhcmlhYmxlIG5hbWVcbiAgICAgIHRva2Vucy52YWx1ZSA9IHRva2Vucy5zdHJpbmcgKyAnfCcgKyB0b2tlbnMubnVtYmVyOyAvLyBhIHZhbHVlIGxpdGVyYWwsIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXJcbiAgICAgIHRva2Vucy5jbGFzc05hbWUgPSB0b2tlbnMudmFyaWFibGU7IC8vIGEgY2xhc3MgbmFtZSAoZm9sbG93cyB2YXJpYWJsZSBjb252ZW50aW9ucylcbiAgICAgIHRva2Vucy5pZCA9IHRva2Vucy52YXJpYWJsZTsgLy8gYW4gZWxlbWVudCBpZCAoZm9sbG93cyB2YXJpYWJsZSBjb252ZW50aW9ucylcblxuICAgICAgLy8gd2hlbiBhIHRva2VuIGxpa2UgYSB2YXJpYWJsZSBoYXMgZXNjYXBlZCBtZXRhIGNoYXJhY3RlcnMsIHdlIG5lZWQgdG8gY2xlYW4gdGhlIGJhY2tzbGFzaGVzIG91dFxuICAgICAgLy8gc28gdGhhdCB2YWx1ZXMgZ2V0IGNvbXBhcmVkIHByb3Blcmx5IGluIFNlbGVjdG9yLmZpbHRlcigpXG4gICAgICB2YXIgY2xlYW5NZXRhQ2hhcnMgPSBmdW5jdGlvbihzdHIpe1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXFxcXFwoJyArIHRva2Vucy5tZXRhQ2hhciArICcpJywgJ2cnKSwgZnVuY3Rpb24obWF0Y2gsICQxLCBvZmZzZXQsIG9yaWdpbmFsKXtcbiAgICAgICAgICByZXR1cm4gJDE7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gYWRkIEAgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG4gICAgICB2YXIgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG9wID0gb3BzW2ldO1xuICAgICAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8QCcgKyBvcDtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkICEgdmFyaWFudHMgdG8gY29tcGFyYXRvck9wXG4gICAgICB2YXIgb3BzID0gdG9rZW5zLmNvbXBhcmF0b3JPcC5zcGxpdCgnfCcpO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG9wID0gb3BzW2ldO1xuXG4gICAgICAgIGlmKCBvcC5pbmRleE9mKCchJykgPj0gMCApeyBjb250aW51ZTsgfSAvLyBza2lwIG9wcyB0aGF0IGV4cGxpY2l0bHkgY29udGFpbiAhXG4gICAgICAgIGlmKCBvcCA9PT0gJz0nICl7IGNvbnRpbnVlOyB9IC8vIHNraXAgPSBiL2MgIT0gaXMgZXhwbGljaXRseSBkZWZpbmVkXG5cbiAgICAgICAgdG9rZW5zLmNvbXBhcmF0b3JPcCArPSAnfFxcXFwhJyArIG9wO1xuICAgICAgfVxuXG4gICAgICAvLyBOT1RFOiBhZGQgbmV3IGV4cHJlc3Npb24gc3ludGF4IGhlcmUgdG8gaGF2ZSBpdCByZWNvZ25pc2VkIGJ5IHRoZSBwYXJzZXI7XG4gICAgICAvLyAtIGEgcXVlcnkgY29udGFpbnMgYWxsIGFkamFjZW50IChpLmUuIG5vIHNlcGFyYXRvciBpbiBiZXR3ZWVuKSBleHByZXNzaW9ucztcbiAgICAgIC8vIC0gdGhlIGN1cnJlbnQgcXVlcnkgaXMgc3RvcmVkIGluIHNlbGZbaV0gLS0tIHlvdSBjYW4gdXNlIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgIGluIHRoZSBwb3B1bGF0ZSBmdW5jdGlvbjtcbiAgICAgIC8vIC0geW91IG5lZWQgdG8gY2hlY2sgdGhlIHF1ZXJ5IG9iamVjdHMgaW4gU2VsZWN0b3IuZmlsdGVyKCkgZm9yIGl0IGFjdHVhbGx5IGZpbHRlciBwcm9wZXJseSwgYnV0IHRoYXQncyBwcmV0dHkgc3RyYWlnaHQgZm9yd2FyZFxuICAgICAgLy8gLSB3aGVuIHlvdSBhZGQgc29tZXRoaW5nIGhlcmUsIGFsc28gYWRkIHRvIFNlbGVjdG9yLnRvU3RyaW5nKClcbiAgICAgIHZhciBleHBycyA9IHtcbiAgICAgICAgZ3JvdXA6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJyhub2RlfGVkZ2V8XFxcXCopJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGdyb3VwICl7XG4gICAgICAgICAgICB0aGlzLmdyb3VwID0gZ3JvdXAgPT0gXCIqXCIgPyBncm91cCA6IGdyb3VwICsgJ3MnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgLy8gTkI6IGlmIG9uZSBjb2xvbiBzZWxlY3RvciBpcyBhIHN1YnN0cmluZyBvZiBhbm90aGVyIGZyb20gaXRzIHN0YXJ0LCBwbGFjZSB0aGUgbG9uZ2VyIG9uZSBmaXJzdFxuICAgICAgICAgIC8vIGUuZy4gOmZvb2Jhcnw6Zm9vXG4gICAgICAgICAgcmVnZXg6ICcoOnNlbGVjdGVkfDp1bnNlbGVjdGVkfDpsb2NrZWR8OnVubG9ja2VkfDp2aXNpYmxlfDpoaWRkZW58OnRyYW5zcGFyZW50fDpncmFiYmVkfDpmcmVlfDpyZW1vdmVkfDppbnNpZGV8OmdyYWJiYWJsZXw6dW5ncmFiYmFibGV8OmFuaW1hdGVkfDp1bmFuaW1hdGVkfDpzZWxlY3RhYmxlfDp1bnNlbGVjdGFibGV8Om9ycGhhbnw6bm9ub3JwaGFufDpwYXJlbnR8OmNoaWxkfDpsb29wfDpzaW1wbGV8OmFjdGl2ZXw6aW5hY3RpdmV8OnRvdWNoKScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBzdGF0ZSApe1xuICAgICAgICAgICAgdGhpcy5jb2xvblNlbGVjdG9ycy5wdXNoKCBzdGF0ZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGlkOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICdcXFxcIygnKyB0b2tlbnMuaWQgKycpJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGlkICl7XG4gICAgICAgICAgICB0aGlzLmlkcy5wdXNoKCBjbGVhbk1ldGFDaGFycyhpZCkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBjbGFzc05hbWU6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFwuKCcrIHRva2Vucy5jbGFzc05hbWUgKycpJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIGNsYXNzTmFtZSApe1xuICAgICAgICAgICAgdGhpcy5jbGFzc2VzLnB1c2goIGNsZWFuTWV0YUNoYXJzKGNsYXNzTmFtZSkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkYXRhRXhpc3RzOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxzKignKyB0b2tlbnMudmFyaWFibGUgKycpXFxcXHMqXFxcXF0nLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggdmFyaWFibGUgKXtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKHZhcmlhYmxlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZGF0YUNvbXBhcmU6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcrIHRva2Vucy52YXJpYWJsZSArJylcXFxccyooJysgdG9rZW5zLmNvbXBhcmF0b3JPcCArJylcXFxccyooJysgdG9rZW5zLnZhbHVlICsnKVxcXFxzKlxcXFxdJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHZhcmlhYmxlLCBjb21wYXJhdG9yT3AsIHZhbHVlICl7IFxuICAgICAgICAgICAgdmFyIHZhbHVlSXNTdHJpbmcgPSBuZXcgUmVnRXhwKCdeJyArIHRva2Vucy5zdHJpbmcgKyAnJCcpLmV4ZWModmFsdWUpICE9IG51bGw7XG5cbiAgICAgICAgICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goe1xuICAgICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgICAgICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRhdGFCb29sOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxzKignKyB0b2tlbnMuYm9vbE9wICsnKVxcXFxzKignKyB0b2tlbnMudmFyaWFibGUgKycpXFxcXHMqXFxcXF0nLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggYm9vbE9wLCB2YXJpYWJsZSApe1xuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goe1xuICAgICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpLFxuICAgICAgICAgICAgICBvcGVyYXRvcjogYm9vbE9wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBtZXRhQ29tcGFyZToge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxcW1xcXFxzKignKyB0b2tlbnMubWV0YSArJylcXFxccyooJysgdG9rZW5zLmNvbXBhcmF0b3JPcCArJylcXFxccyooJysgdG9rZW5zLm51bWJlciArJylcXFxccypcXFxcXVxcXFxdJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIG1ldGEsIGNvbXBhcmF0b3JPcCwgbnVtYmVyICl7XG4gICAgICAgICAgICB0aGlzLm1ldGEucHVzaCh7XG4gICAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyhtZXRhKSxcbiAgICAgICAgICAgICAgb3BlcmF0b3I6IGNvbXBhcmF0b3JPcCxcbiAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRRdWVyeToge1xuICAgICAgICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICAgICAgICByZWdleDogdG9rZW5zLnNlcGFyYXRvcixcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHQgcXVlcnlcbiAgICAgICAgICAgIHNlbGZbKytpXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgICAgICBjdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGNoaWxkOiB7XG4gICAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiB0b2tlbnMuY2hpbGQsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyB0aGlzIHF1ZXJ5IGlzIHRoZSBwYXJlbnQgb2YgdGhlIGZvbGxvd2luZyBxdWVyeVxuICAgICAgICAgICAgdmFyIGNoaWxkUXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICAgICAgY2hpbGRRdWVyeS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgY2hpbGRRdWVyeS5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG5cbiAgICAgICAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBjaGlsZCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICAgICAgICBzZWxmW2ldID0gY2hpbGRRdWVyeTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVzY2VuZGFudDoge1xuICAgICAgICAgIHNlcGFyYXRvcjogdHJ1ZSxcbiAgICAgICAgICByZWdleDogdG9rZW5zLmRlc2NlbmRhbnQsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyB0aGlzIHF1ZXJ5IGlzIHRoZSBhbmNlc3RvciBvZiB0aGUgZm9sbG93aW5nIHF1ZXJ5XG4gICAgICAgICAgICB2YXIgZGVzY2VuZGFudFF1ZXJ5ID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICAgIGRlc2NlbmRhbnRRdWVyeS5hbmNlc3RvciA9IHRoaXM7XG4gICAgICAgICAgICBkZXNjZW5kYW50UXVlcnkuc3ViamVjdCA9IGN1cnJlbnRTdWJqZWN0O1xuXG4gICAgICAgICAgICAvLyB3ZSdyZSBub3cgcG9wdWxhdGluZyB0aGUgZGVzY2VuZGFudCBxdWVyeSB3aXRoIGV4cHJlc3Npb25zIHRoYXQgZm9sbG93XG4gICAgICAgICAgICBzZWxmW2ldID0gZGVzY2VuZGFudFF1ZXJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdWJqZWN0OiB7XG4gICAgICAgICAgbW9kaWZpZXI6IHRydWUsXG4gICAgICAgICAgcmVnZXg6IHRva2Vucy5zdWJqZWN0LFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYoIGN1cnJlbnRTdWJqZWN0ICE9IG51bGwgJiYgdGhpcy5zdWJqZWN0ICE9IHRoaXMgKXtcbiAgICAgICAgICAgICAgJCQudXRpbC5lcnJvcignUmVkZWZpbml0aW9uIG9mIHN1YmplY3QgaW4gc2VsZWN0b3IgYCcgKyBzZWxlY3RvciArICdgJyk7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudFN1YmplY3QgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5zdWJqZWN0ID0gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGogPSAwO1xuICAgICAgZm9yKCB2YXIgbmFtZSBpbiBleHBycyApe1xuICAgICAgICBleHByc1tqXSA9IGV4cHJzW25hbWVdO1xuICAgICAgICBleHByc1tqXS5uYW1lID0gbmFtZTtcblxuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICBleHBycy5sZW5ndGggPSBqO1xuXG4gICAgICBzZWxmLl9wcml2YXRlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yO1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHNlbGVjdG9yO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgXG4gICAgICAvLyBvZiBhbGwgdGhlIGV4cHJlc3Npb25zLCBmaW5kIHRoZSBmaXJzdCBtYXRjaCBpbiB0aGUgcmVtYWluaW5nIHRleHRcbiAgICAgIHZhciBjb25zdW1lRXhwciA9IGZ1bmN0aW9uKCBleHBlY3RhdGlvbiApe1xuICAgICAgICB2YXIgZXhwcjtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZXhwcnMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZSA9IGV4cHJzW2pdO1xuICAgICAgICAgIHZhciBuID0gZS5uYW1lO1xuXG4gICAgICAgICAgLy8gaWdub3JlIHRoaXMgZXhwcmVzc2lvbiBpZiBpdCBkb2Vzbid0IG1lZXQgdGhlIGV4cGVjdGF0aW9uIGZ1bmN0aW9uXG4gICAgICAgICAgaWYoICQkLmlzLmZuKCBleHBlY3RhdGlvbiApICYmICFleHBlY3RhdGlvbihuLCBlKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIG0gPSByZW1haW5pbmcubWF0Y2gobmV3IFJlZ0V4cCggJ14nICsgZS5yZWdleCApKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggbSAhPSBudWxsICl7XG4gICAgICAgICAgICBtYXRjaCA9IG07XG4gICAgICAgICAgICBleHByID0gZTtcbiAgICAgICAgICAgIG5hbWUgPSBuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY29uc3VtZWQgPSBtWzBdO1xuICAgICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggY29uc3VtZWQubGVuZ3RoICk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBicmVhazsgLy8gd2UndmUgY29uc3VtZWQgb25lIGV4cHIsIHNvIHdlIGNhbiByZXR1cm4gbm93XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV4cHI6IGV4cHIsXG4gICAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIGNvbnN1bWUgYWxsIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGNvbnN1bWVXaGl0ZXNwYWNlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKy8pO1xuICAgICAgICBcbiAgICAgICAgaWYoIG1hdGNoICl7XG4gICAgICAgICAgdmFyIGNvbnN1bWVkID0gbWF0Y2hbMF07XG4gICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggY29uc3VtZWQubGVuZ3RoICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpOyAvLyBnZXQgc3RhcnRlZFxuXG4gICAgICBjb25zdW1lV2hpdGVzcGFjZSgpOyAvLyBnZXQgcmlkIG9mIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgZm9yKDs7KXsgICAgICAgIFxuICAgICAgICB2YXIgY2hlY2sgPSBjb25zdW1lRXhwcigpO1xuICAgICAgICBcbiAgICAgICAgaWYoIGNoZWNrLmV4cHIgPT0gbnVsbCApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1RoZSBzZWxlY3RvciBgJysgc2VsZWN0b3IgKydgaXMgaW52YWxpZCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgIGZvcih2YXIgaiA9IDE7IGogPCBjaGVjay5tYXRjaC5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICBhcmdzLnB1c2goIGNoZWNrLm1hdGNoW2pdICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGxldCB0aGUgdG9rZW4gcG9wdWxhdGUgdGhlIHNlbGVjdG9yIG9iamVjdCAoaS5lLiBpbiBzZWxmW2ldKVxuICAgICAgICAgIHZhciByZXQgPSBjaGVjay5leHByLnBvcHVsYXRlLmFwcGx5KCBzZWxmW2ldLCBhcmdzICk7XG5cbiAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyByZXR1cm47IH0gLy8gZXhpdCBpZiBwb3B1bGF0aW9uIGZhaWxlZFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB3ZSdyZSBkb25lIHdoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gcGFyc2VcbiAgICAgICAgaWYoIHJlbWFpbmluZy5tYXRjaCgvXlxccyokLykgKXtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBzZWxmLmxlbmd0aCA9IGkgKyAxO1xuXG4gICAgICAvLyBhZGp1c3QgcmVmZXJlbmNlcyBmb3Igc3ViamVjdFxuICAgICAgZm9yKGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG5cbiAgICAgICAgaWYoIHF1ZXJ5LnN1YmplY3QgIT0gbnVsbCApe1xuICAgICAgICAgIC8vIGdvIHVwIHRoZSB0cmVlIHVudGlsIHdlIHJlYWNoIHRoZSBzdWJqZWN0XG4gICAgICAgICAgZm9yKDs7KXtcbiAgICAgICAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ID09IHF1ZXJ5ICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgc3ViamVjdCBpcyBzZWxmXG5cbiAgICAgICAgICAgIGlmKCBxdWVyeS5wYXJlbnQgIT0gbnVsbCApeyAvLyBzd2FwIHBhcmVudC9jaGlsZCByZWZlcmVuY2VcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHF1ZXJ5LnBhcmVudDtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gcXVlcnk7XG5cbiAgICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgcGFyZW50LmNoaWxkID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgcXVlcnkgPSBwYXJlbnQ7IC8vIGdvIHVwIHRoZSB0cmVlXG4gICAgICAgICAgICB9IGVsc2UgaWYoIHF1ZXJ5LmFuY2VzdG9yICE9IG51bGwgKXsgLy8gc3dhcCBhbmNlc3Rvci9kZXNjZW5kYW50XG4gICAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHF1ZXJ5LmFuY2VzdG9yO1xuICAgICAgICAgICAgICB2YXIgZGVzY2VuZGFudCA9IHF1ZXJ5O1xuXG4gICAgICAgICAgICAgIGRlc2NlbmRhbnQuYW5jZXN0b3IgPSBudWxsO1xuICAgICAgICAgICAgICBhbmNlc3Rvci5kZXNjZW5kYW50ID0gZGVzY2VuZGFudDtcblxuICAgICAgICAgICAgICBxdWVyeSA9IGFuY2VzdG9yOyAvLyBnbyB1cCB0aGUgdHJlZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJCQudXRpbC5lcnJvcignV2hlbiBhZGp1c3RpbmcgcmVmZXJlbmNlcyBmb3IgdGhlIHNlbGVjdG9yIGAnKyBxdWVyeSArJ2AsIG5laXRoZXIgcGFyZW50IG5vciBhbmNlc3RvciB3YXMgZm91bmQnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBmb3JcblxuICAgICAgICAgIHNlbGZbal0gPSBxdWVyeS5zdWJqZWN0OyAvLyBzdWJqZWN0IHNob3VsZCBiZSB0aGUgcm9vdCBxdWVyeVxuICAgICAgICB9IC8vIGlmXG4gICAgICB9IC8vIGZvclxuXG4gICAgICAvLyBtYWtlIHN1cmUgZm9yIGVhY2ggcXVlcnkgdGhhdCB0aGUgc3ViamVjdCBncm91cCBtYXRjaGVzIHRoZSBpbXBsaWNpdCBncm91cCBpZiBhbnlcbiAgICAgIGlmKCBvbmx5VGhpc0dyb3VwICE9IG51bGwgKXtcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgICAgIGlmKCBzZWxmW2pdLmdyb3VwICE9IG51bGwgJiYgc2VsZltqXS5ncm91cCAhPSBvbmx5VGhpc0dyb3VwICl7XG4gICAgICAgICAgICAkJC51dGlsLmVycm9yKCdHcm91cCBgJysgc2VsZltqXS5ncm91cCArJ2AgY29uZmxpY3RzIHdpdGggaW1wbGljaXQgZ3JvdXAgYCcrIG9ubHlUaGlzR3JvdXAgKydgIGluIHNlbGVjdG9yIGAnKyBzZWxlY3RvciArJ2AnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmW2pdLmdyb3VwID0gb25seVRoaXNHcm91cDsgLy8gc2V0IHRvIGltcGxpY2l0IGdyb3VwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICAkJC51dGlsLmVycm9yKCdBIHNlbGVjdG9yIG11c3QgYmUgY3JlYXRlZCBmcm9tIGEgc3RyaW5nOyBmb3VuZCAnICsgc2VsZWN0b3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuX3ByaXZhdGUuaW52YWxpZCA9IGZhbHNlO1xuICAgIFxuICB9O1xuXG4gICQkLnNlbGZuID0gJCQuU2VsZWN0b3IucHJvdG90eXBlO1xuICBcbiAgJCQuc2VsZm4uc2l6ZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICB9O1xuICBcbiAgJCQuc2VsZm4uZXEgPSBmdW5jdGlvbihpKXtcbiAgICByZXR1cm4gdGhpc1tpXTtcbiAgfTtcbiAgXG4gIC8vIGdldCBlbGVtZW50cyBmcm9tIHRoZSBjb3JlIGFuZCB0aGVuIGZpbHRlciB0aGVtXG4gICQkLnNlbGZuLmZpbmQgPSBmdW5jdGlvbigpe1xuICAgIC8vIFRPRE8gaW1wbCBpZiB3ZSBkZWNpZGUgdG8gdXNlIGEgREIgZm9yIHN0b3JpbmcgZWxlbWVudHNcbiAgfTtcbiAgXG4gIHZhciBxdWVyeU1hdGNoZXMgPSBmdW5jdGlvbihxdWVyeSwgZWxlbWVudCl7XG4gICAgLy8gY2hlY2sgZ3JvdXBcbiAgICBpZiggcXVlcnkuZ3JvdXAgIT0gbnVsbCAmJiBxdWVyeS5ncm91cCAhPSAnKicgJiYgcXVlcnkuZ3JvdXAgIT0gZWxlbWVudC5fcHJpdmF0ZS5ncm91cCApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBjeSA9IGVsZW1lbnQuY3koKTtcbiAgICBcbiAgICAvLyBjaGVjayBjb2xvbiBzZWxlY3RvcnNcbiAgICB2YXIgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IHRydWU7XG4gICAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzLmxlbmd0aDsgaysrKXtcbiAgICAgIHZhciBzZWwgPSBxdWVyeS5jb2xvblNlbGVjdG9yc1trXTtcbiAgICAgIFxuICAgICAgc3dpdGNoKHNlbCl7XG4gICAgICBjYXNlICc6c2VsZWN0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5zZWxlY3RlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bnNlbGVjdGVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LnNlbGVjdGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnNlbGVjdGFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5zZWxlY3RhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVuc2VsZWN0YWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5zZWxlY3RhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmxvY2tlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmxvY2tlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp1bmxvY2tlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5sb2NrZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dmlzaWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnZpc2libGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6aGlkZGVuJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LnZpc2libGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dHJhbnNwYXJlbnQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC50cmFuc3BhcmVudCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpncmFiYmVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuZ3JhYmJlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpmcmVlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmdyYWJiZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6cmVtb3ZlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnJlbW92ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6aW5zaWRlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LnJlbW92ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6Z3JhYmJhYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuZ3JhYmJhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVuZ3JhYmJhYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmdyYWJiYWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzphbmltYXRlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmFuaW1hdGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVuYW5pbWF0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuYW5pbWF0ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6cGFyZW50JzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNOb2RlKCkgJiYgZWxlbWVudC5jaGlsZHJlbigpLm5vbmVtcHR5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmNoaWxkJzpcbiAgICAgIGNhc2UgJzpub25vcnBoYW4nOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc05vZGUoKSAmJiBlbGVtZW50LnBhcmVudCgpLm5vbmVtcHR5KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOm9ycGhhbic6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzTm9kZSgpICYmIGVsZW1lbnQucGFyZW50KCkuZW1wdHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6bG9vcCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzRWRnZSgpICYmIGVsZW1lbnQuZGF0YSgnc291cmNlJykgPT09IGVsZW1lbnQuZGF0YSgndGFyZ2V0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnNpbXBsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzRWRnZSgpICYmIGVsZW1lbnQuZGF0YSgnc291cmNlJykgIT09IGVsZW1lbnQuZGF0YSgndGFyZ2V0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmFjdGl2ZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmFjdGl2ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzppbmFjdGl2ZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5hY3RpdmUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dG91Y2gnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gJCQuaXMudG91Y2goKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCAhYWxsQ29sb25TZWxlY3RvcnNNYXRjaCApIGJyZWFrO1xuICAgIH1cbiAgICBpZiggIWFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gY2hlY2sgaWRcbiAgICB2YXIgYWxsSWRzTWF0Y2ggPSB0cnVlO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCBxdWVyeS5pZHMubGVuZ3RoOyBrKyspe1xuICAgICAgdmFyIGlkID0gcXVlcnkuaWRzW2tdO1xuICAgICAgdmFyIGFjdHVhbElkID0gZWxlbWVudC5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgXG4gICAgICBhbGxJZHNNYXRjaCA9IGFsbElkc01hdGNoICYmIChpZCA9PSBhY3R1YWxJZCk7XG4gICAgICBcbiAgICAgIGlmKCAhYWxsSWRzTWF0Y2ggKSBicmVhaztcbiAgICB9XG4gICAgaWYoICFhbGxJZHNNYXRjaCApIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBjaGVjayBjbGFzc2VzXG4gICAgdmFyIGFsbENsYXNzZXNNYXRjaCA9IHRydWU7XG4gICAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5LmNsYXNzZXMubGVuZ3RoOyBrKyspe1xuICAgICAgdmFyIGNscyA9IHF1ZXJ5LmNsYXNzZXNba107XG4gICAgICBcbiAgICAgIGFsbENsYXNzZXNNYXRjaCA9IGFsbENsYXNzZXNNYXRjaCAmJiBlbGVtZW50Lmhhc0NsYXNzKGNscyk7XG4gICAgICBcbiAgICAgIGlmKCAhYWxsQ2xhc3Nlc01hdGNoICkgYnJlYWs7XG4gICAgfVxuICAgIGlmKCAhYWxsQ2xhc3Nlc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIGdlbmVyaWMgY2hlY2tpbmcgZm9yIGRhdGEvbWV0YWRhdGFcbiAgICB2YXIgb3BlcmFuZHNNYXRjaCA9IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgICB2YXIgYWxsRGF0YU1hdGNoZXMgPSB0cnVlO1xuICAgICAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5W3BhcmFtcy5uYW1lXS5sZW5ndGg7IGsrKyl7XG4gICAgICAgIHZhciBkYXRhID0gcXVlcnlbcGFyYW1zLm5hbWVdW2tdO1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSBkYXRhLm9wZXJhdG9yO1xuICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICB2YXIgZmllbGQgPSBkYXRhLmZpZWxkO1xuICAgICAgICB2YXIgbWF0Y2hlcztcbiAgICAgICAgXG4gICAgICAgIGlmKCBvcGVyYXRvciAhPSBudWxsICYmIHZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgZmllbGRWYWwgPSBwYXJhbXMuZmllbGRWYWx1ZShmaWVsZCk7XG4gICAgICAgICAgdmFyIGZpZWxkU3RyID0gISQkLmlzLnN0cmluZyhmaWVsZFZhbCkgJiYgISQkLmlzLm51bWJlcihmaWVsZFZhbCkgPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgICAgICAgdmFyIHZhbFN0ciA9ICcnICsgdmFsdWU7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIGlmKCBvcGVyYXRvci5pbmRleE9mKCdAJykgPj0gMCApe1xuICAgICAgICAgICAgZmllbGRTdHIgPSBmaWVsZFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFsU3RyID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSgnQCcsICcnKTtcbiAgICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5vdEV4cHIgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgaGFuZGxlZE5vdEV4cHIgPSBmYWxzZTtcbiAgICAgICAgICBpZiggb3BlcmF0b3IuaW5kZXhPZignIScpID49IDAgKXtcbiAgICAgICAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSgnIScsICcnKTtcbiAgICAgICAgICAgIG5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBpZiB3ZSdyZSBkb2luZyBhIGNhc2UgaW5zZW5zaXRpdmUgY29tcGFyaXNvbiwgdGhlbiB3ZSdyZSB1c2luZyBhIFNUUklORyBjb21wYXJpc29uXG4gICAgICAgICAgLy8gZXZlbiBpZiB3ZSdyZSBjb21wYXJpbmcgbnVtYmVyc1xuICAgICAgICAgIGlmKCBjYXNlSW5zZW5zaXRpdmUgKXtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmaWVsZFZhbCA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoKG9wZXJhdG9yKXtcbiAgICAgICAgICBjYXNlICcqPSc6XG4gICAgICAgICAgICBtYXRjaGVzID0gZmllbGRTdHIuc2VhcmNoKHZhbFN0cikgPj0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyQ9JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBuZXcgUmVnRXhwKHZhbFN0ciArICckJykuZXhlYyhmaWVsZFN0cikgIT0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ149JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBuZXcgUmVnRXhwKCdeJyArIHZhbFN0cikuZXhlYyhmaWVsZFN0cikgIT0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID09PSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCAhPT0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSAhbm90RXhwciA/IGZpZWxkVmFsID4gdmFsdWUgOiBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgICAgICAgIGhhbmRsZWROb3RFeHByID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSAhbm90RXhwciA/IGZpZWxkVmFsID49IHZhbHVlIDogZmllbGRWYWwgPCB2YWx1ZTtcbiAgICAgICAgICAgIGhhbmRsZWROb3RFeHByID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPCB2YWx1ZSA6IGZpZWxkVmFsID49IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPD0gdmFsdWUgOiBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIG9wZXJhdG9yICE9IG51bGwgKXtcbiAgICAgICAgICBzd2l0Y2gob3BlcmF0b3Ipe1xuICAgICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IHBhcmFtcy5maWVsZFRydXRoeShmaWVsZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSAhcGFyYW1zLmZpZWxkVHJ1dGh5KGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IHBhcmFtcy5maWVsZFVuZGVmaW5lZChmaWVsZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7ICAgXG4gICAgICAgICAgbWF0Y2hlcyA9ICFwYXJhbXMuZmllbGRVbmRlZmluZWQoZmllbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG5vdEV4cHIgJiYgIWhhbmRsZWROb3RFeHByICl7XG4gICAgICAgICAgbWF0Y2hlcyA9ICFtYXRjaGVzO1xuICAgICAgICAgIGhhbmRsZWROb3RFeHByID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoICFtYXRjaGVzICl7XG4gICAgICAgICAgYWxsRGF0YU1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcbiAgICAgIFxuICAgICAgcmV0dXJuIGFsbERhdGFNYXRjaGVzO1xuICAgIH07IC8vIG9wZXJhbmRzTWF0Y2hcbiAgICBcbiAgICAvLyBjaGVjayBkYXRhIG1hdGNoZXNcbiAgICB2YXIgYWxsRGF0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKHtcbiAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuX3ByaXZhdGUuZGF0YVtmaWVsZF07XG4gICAgICB9LFxuICAgICAgZmllbGRSZWY6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuICdlbGVtZW50Ll9wcml2YXRlLmRhdGEuJyArIGZpZWxkO1xuICAgICAgfSxcbiAgICAgIGZpZWxkVW5kZWZpbmVkOiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50Ll9wcml2YXRlLmRhdGFbZmllbGRdID09PSB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgZmllbGRUcnV0aHk6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgaWYoIGVsZW1lbnQuX3ByaXZhdGUuZGF0YVtmaWVsZF0gKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYoICFhbGxEYXRhTWF0Y2hlcyApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBjaGVjayBtZXRhZGF0YSBtYXRjaGVzXG4gICAgdmFyIGFsbE1ldGFNYXRjaGVzID0gb3BlcmFuZHNNYXRjaCh7XG4gICAgICBuYW1lOiAnbWV0YScsXG4gICAgICBmaWVsZFZhbHVlOiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50W2ZpZWxkXSgpO1xuICAgICAgfSxcbiAgICAgIGZpZWxkUmVmOiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICAgIHJldHVybiAnZWxlbWVudC4nICsgZmllbGQgKyAnKCknO1xuICAgICAgfSxcbiAgICAgIGZpZWxkVW5kZWZpbmVkOiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50W2ZpZWxkXSgpID09IG51bGw7XG4gICAgICB9LFxuICAgICAgZmllbGRUcnV0aHk6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgaWYoIGVsZW1lbnRbZmllbGRdKCkgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYoICFhbGxNZXRhTWF0Y2hlcyApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBjaGVjayBjb2xsZWN0aW9uXG4gICAgaWYoIHF1ZXJ5LmNvbGxlY3Rpb24gIT0gbnVsbCApe1xuICAgICAgdmFyIG1hdGNoZXNBbnkgPSBxdWVyeS5jb2xsZWN0aW9uLl9wcml2YXRlLmlkc1sgZWxlbWVudC5pZCgpIF0gIT0gbnVsbDtcbiAgICAgIFxuICAgICAgaWYoICFtYXRjaGVzQW55ICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gY2hlY2sgZmlsdGVyIGZ1bmN0aW9uXG4gICAgaWYoIHF1ZXJ5LmZpbHRlciAhPSBudWxsICYmIGVsZW1lbnQuY29sbGVjdGlvbigpLmZpbHRlciggcXVlcnkuZmlsdGVyICkuc2l6ZSgpID09PSAwICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuXG4gICAgLy8gY2hlY2sgcGFyZW50L2NoaWxkIHJlbGF0aW9uc1xuICAgIHZhciBjb25maXJtUmVsYXRpb25zID0gZnVuY3Rpb24oIHF1ZXJ5LCBlbGVtZW50cyApe1xuICAgICAgaWYoIHF1ZXJ5ICE9IG51bGwgKXtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBmYWxzZTtcblxuICAgICAgICBpZiggIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMoKTsgLy8gbWFrZSBlbGVtZW50cyBmdW5jdGlvbmFsIHNvIHdlIHNhdmUgY3ljbGVzIGlmIHF1ZXJ5ID09IG51bGxcblxuICAgICAgICAvLyBxdWVyeSBtdXN0IG1hdGNoIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudCAobWF5IGJlIHJlY3Vyc2l2ZSlcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICBpZiggcXVlcnlNYXRjaGVzKCBxdWVyeSwgZWxlbWVudHNbaV0gKSApe1xuICAgICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LnBhcmVudCwgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBlbGVtZW50LnBhcmVudCgpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5hbmNlc3RvciwgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBlbGVtZW50LnBhcmVudHMoKTtcbiAgICB9KSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghIGNvbmZpcm1SZWxhdGlvbnMocXVlcnkuY2hpbGQsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbigpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5kZXNjZW5kYW50LCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZGVzY2VuZGFudHMoKTtcbiAgICB9KSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCwgc28gd2UndmUgbWF0Y2hlZCBldmVyeXRoaW5nIGZvciB0aGlzIHF1ZXJ5XG4gICAgcmV0dXJuIHRydWU7XG4gIH07IC8vIHF1ZXJ5TWF0Y2hlc1xuXG4gIC8vIGZpbHRlciBhbiBleGlzdGluZyBjb2xsZWN0aW9uXG4gICQkLnNlbGZuLmZpbHRlciA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3kgPSBjb2xsZWN0aW9uLmN5KCk7XG4gICAgXG4gICAgLy8gZG9uJ3QgYm90aGVyIHRyeWluZyBpZiBpdCdzIGludmFsaWRcbiAgICBpZiggc2VsZi5fcHJpdmF0ZS5pbnZhbGlkICl7XG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5ICk7XG4gICAgfVxuICBcbiAgICB2YXIgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuICAgICAgICBcbiAgICAgICAgaWYoIHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZWxlbWVudCkgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBcbiAgICBpZiggc2VsZi5fcHJpdmF0ZS5zZWxlY3RvclRleHQgPT0gbnVsbCApe1xuICAgICAgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlOyB9O1xuICAgIH1cbiAgICBcbiAgICB2YXIgZmlsdGVyZWRDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5maWx0ZXIoIHNlbGVjdG9yRnVuY3Rpb24gKTtcbiAgICBcbiAgICByZXR1cm4gZmlsdGVyZWRDb2xsZWN0aW9uO1xuICB9OyAvLyBmaWx0ZXJcblxuICAvLyBkb2VzIHNlbGVjdG9yIG1hdGNoIGEgc2luZ2xlIGVsZW1lbnQ/XG4gICQkLnNlbGZuLm1hdGNoZXMgPSBmdW5jdGlvbihlbGUpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICAvLyBkb24ndCBib3RoZXIgdHJ5aW5nIGlmIGl0J3MgaW52YWxpZFxuICAgIGlmKCBzZWxmLl9wcml2YXRlLmludmFsaWQgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIFxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKXtcbiAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG4gICAgICBcbiAgICAgIGlmKCBxdWVyeU1hdGNoZXMocXVlcnksIGVsZSkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTsgLy8gZmlsdGVyXG4gIFxuICAvLyBpdGggcXVlcnkgdG8gc3RyaW5nXG4gICQkLnNlbGZuLnRvU3RyaW5nID0gJCQuc2VsZm4uc2VsZWN0b3IgPSBmdW5jdGlvbigpe1xuICAgIFxuICAgIHZhciBzdHIgPSAnJztcbiAgICBcbiAgICB2YXIgY2xlYW4gPSBmdW5jdGlvbihvYmosIGlzVmFsdWUpe1xuICAgICAgaWYoICQkLmlzLnN0cmluZyhvYmopICl7XG4gICAgICAgIHJldHVybiBpc1ZhbHVlID8gJ1wiJyArIG9iaiArICdcIicgOiBvYmo7XG4gICAgICB9IFxuICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHF1ZXJ5VG9TdHJpbmcgPSBmdW5jdGlvbihxdWVyeSl7XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ID09PSBxdWVyeSApe1xuICAgICAgICBzdHIgKz0gJyQnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXAgPSBjbGVhbihxdWVyeS5ncm91cCk7XG4gICAgICBzdHIgKz0gZ3JvdXAuc3Vic3RyaW5nKDAsIGdyb3VwLmxlbmd0aCAtIDEpO1xuICAgICAgXG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkuZGF0YS5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBkYXRhID0gcXVlcnkuZGF0YVtqXTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBkYXRhLnZhbHVlICl7XG4gICAgICAgICAgc3RyICs9ICdbJyArIGRhdGEuZmllbGQgKyBjbGVhbihkYXRhLm9wZXJhdG9yKSArIGNsZWFuKGRhdGEudmFsdWUsIHRydWUpICsgJ10nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSAnWycgKyBjbGVhbihkYXRhLm9wZXJhdG9yKSArIGRhdGEuZmllbGQgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5Lm1ldGEubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgbWV0YSA9IHF1ZXJ5Lm1ldGFbal07XG4gICAgICAgIHN0ciArPSAnW1snICsgbWV0YS5maWVsZCArIGNsZWFuKG1ldGEub3BlcmF0b3IpICsgY2xlYW4obWV0YS52YWx1ZSwgdHJ1ZSkgKyAnXV0nO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkuY29sb25TZWxlY3RvcnMubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgc2VsID0gcXVlcnkuY29sb25TZWxlY3RvcnNbaV07XG4gICAgICAgIHN0ciArPSBzZWw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5pZHMubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgc2VsID0gJyMnICsgcXVlcnkuaWRzW2ldO1xuICAgICAgICBzdHIgKz0gc2VsO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBzZWwgPSAnLicgKyBxdWVyeS5jbGFzc2VzW2ldO1xuICAgICAgICBzdHIgKz0gc2VsO1xuICAgICAgfVxuXG4gICAgICBpZiggcXVlcnkucGFyZW50ICE9IG51bGwgKXtcbiAgICAgICAgc3RyID0gcXVlcnlUb1N0cmluZyggcXVlcnkucGFyZW50ICkgKyAnID4gJyArIHN0cjsgXG4gICAgICB9XG5cbiAgICAgIGlmKCBxdWVyeS5hbmNlc3RvciAhPSBudWxsICl7XG4gICAgICAgIHN0ciA9IHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5LmFuY2VzdG9yICkgKyAnICcgKyBzdHI7IFxuICAgICAgfVxuXG4gICAgICBpZiggcXVlcnkuY2hpbGQgIT0gbnVsbCApe1xuICAgICAgICBzdHIgKz0gJyA+ICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5jaGlsZCApOyBcbiAgICAgIH1cblxuICAgICAgaWYoIHF1ZXJ5LmRlc2NlbmRhbnQgIT0gbnVsbCApe1xuICAgICAgICBzdHIgKz0gJyAnICsgcXVlcnlUb1N0cmluZyggcXVlcnkuZGVzY2VuZGFudCApOyBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpc1tpXTtcbiAgICAgIFxuICAgICAgc3RyICs9IHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5ICk7XG4gICAgICBcbiAgICAgIGlmKCB0aGlzLmxlbmd0aCA+IDEgJiYgaSA8IHRoaXMubGVuZ3RoIC0gMSApe1xuICAgICAgICBzdHIgKz0gJywgJztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5TdHlsZSA9IGZ1bmN0aW9uKCBjeSApe1xuXG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLlN0eWxlKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5TdHlsZShjeSk7XG4gICAgfVxuXG4gICAgaWYoICEkJC5pcy5jb3JlKGN5KSApe1xuICAgICAgJCQudXRpbC5lcnJvcignQSBzdHlsZSBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjeTogY3ksXG4gICAgICBjb3JlU3R5bGU6IHt9LFxuICAgICAgbmV3U3R5bGU6IHRydWVcbiAgICB9O1xuICAgIFxuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuYWRkRGVmYXVsdFN0eWxlc2hlZXQoKTtcbiAgfTtcblxuICAvLyBuaWNlLXRvLWhhdmUgYWxpYXNlc1xuICAkJC5zdHlsZSA9ICQkLlN0eWxlO1xuICAkJC5zdHlmbiA9ICQkLlN0eWxlLnByb3RvdHlwZTtcblxuICAvLyBkZWZpbmUgZnVuY3Rpb25zIGluIHRoZSBTdHlsZSBwcm90b3R5cGVcbiAgJCQuZm4uc3R5bGUgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBmbk5hbWUgaW4gZm5NYXAgKXtcbiAgICAgIHZhciBmbiA9IGZuTWFwWyBmbk5hbWUgXTtcbiAgICAgICQkLlN0eWxlLnByb3RvdHlwZSA9IGZuO1xuICAgIH1cbiAgfTtcblxuICAoZnVuY3Rpb24oKXtcbiAgICB2YXIgbnVtYmVyID0gJCQudXRpbC5yZWdleC5udW1iZXI7XG4gICAgdmFyIHJnYmEgPSAkJC51dGlsLnJlZ2V4LnJnYmFOb0JhY2tSZWZzO1xuICAgIHZhciBoc2xhID0gJCQudXRpbC5yZWdleC5oc2xhTm9CYWNrUmVmcztcbiAgICB2YXIgaGV4MyA9ICQkLnV0aWwucmVnZXguaGV4MztcbiAgICB2YXIgaGV4NiA9ICQkLnV0aWwucmVnZXguaGV4NjtcbiAgICB2YXIgZGF0YSA9IGZ1bmN0aW9uKCBwcmVmaXggKXsgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKFxcXFxzKihbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwpJCc7IH07XG4gICAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbiggcHJlZml4ICl7IHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXCgoW1xcXFx3XFxcXC5dKylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnfFxcXFx3K3wnICsgcmdiYSArICd8JyArIGhzbGEgKyAnfCcgKyBoZXgzICsgJ3wnICsgaGV4NiArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMgKyAnfCcgKyBoZXg2ICsgJylcXFxcKSQnOyB9O1xuXG4gICAgLy8gZWFjaCB2aXN1YWwgc3R5bGUgcHJvcGVydHkgaGFzIGEgdHlwZSBhbmQgbmVlZHMgdG8gYmUgdmFsaWRhdGVkIGFjY29yZGluZyB0byBpdFxuICAgICQkLnN0eWxlLnR5cGVzID0ge1xuICAgICAgdGltZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgdW5pdHM6ICdzfG1zJywgaW1wbGljaXRVbml0czogJ21zJyB9LFxuICAgICAgcGVyY2VudDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxMDAsIHVuaXRzOiAnJScgfSxcbiAgICAgIHplcm9PbmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICAgIG5PbmVPbmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCBtaW46IC0xLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgICBub25OZWdhdGl2ZUludDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgaW50ZWdlcjogdHJ1ZSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICAgIHBvc2l0aW9uOiB7IGVudW1zOiBbJ3BhcmVudCcsICdvcmlnaW4nXSB9LFxuICAgICAgYXV0b1NpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGVudW1zOiBbJ2F1dG8nXSB9LFxuICAgICAgbnVtYmVyOiB7IG51bWJlcjogdHJ1ZSB9LFxuICAgICAgc2l6ZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCB9LFxuICAgICAgYmdTaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBhbGxvd1BlcmNlbnQ6IHRydWUgfSxcbiAgICAgIGJnUG9zOiB7IG51bWJlcjogdHJ1ZSwgYWxsb3dQZXJjZW50OiB0cnVlIH0sXG4gICAgICBiZ1JlcGVhdDogeyBlbnVtczogWydyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCAnbm8tcmVwZWF0J10gfSxcbiAgICAgIGJnRml0OiB7IGVudW1zOiBbJ25vbmUnLCAnY29udGFpbicsICdjb3ZlciddIH0sXG4gICAgICBiZ0NsaXA6IHsgZW51bXM6IFsnbm9uZScsICdub2RlJ10gfSxcbiAgICAgIGNvbG9yOiB7IGNvbG9yOiB0cnVlIH0sXG4gICAgICBsaW5lU3R5bGU6IHsgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCddIH0sXG4gICAgICBib3JkZXJTdHlsZTogeyBlbnVtczogWydzb2xpZCcsICdkb3R0ZWQnLCAnZGFzaGVkJywgJ2RvdWJsZSddIH0sXG4gICAgICBjdXJ2ZVN0eWxlOiB7IGVudW1zOiBbJ2JlemllcicsICd1bmJ1bmRsZWQtYmV6aWVyJywgJ2hheXN0YWNrJ10gfSxcbiAgICAgIGZvbnRGYW1pbHk6IHsgcmVnZXg6ICdeKFtcXFxcdy0gXSsoPzpcXFxccyosXFxcXHMqW1xcXFx3LSBdKykqKSQnIH0sXG4gICAgICBmb250VmFyaWFudDogeyBlbnVtczogWydzbWFsbC1jYXBzJywgJ25vcm1hbCddIH0sXG4gICAgICBmb250U3R5bGU6IHsgZW51bXM6IFsnaXRhbGljJywgJ25vcm1hbCcsICdvYmxpcXVlJ10gfSxcbiAgICAgIGZvbnRXZWlnaHQ6IHsgZW51bXM6IFsnbm9ybWFsJywgJ2JvbGQnLCAnYm9sZGVyJywgJ2xpZ2h0ZXInLCAnMTAwJywgJzIwMCcsICczMDAnLCAnNDAwJywgJzUwMCcsICc2MDAnLCAnODAwJywgJzkwMCcsIDEwMCwgMjAwLCAzMDAsIDQwMCwgNTAwLCA2MDAsIDcwMCwgODAwLCA5MDBdIH0sXG4gICAgICB0ZXh0RGVjb3JhdGlvbjogeyBlbnVtczogWydub25lJywgJ3VuZGVybGluZScsICdvdmVybGluZScsICdsaW5lLXRocm91Z2gnXSB9LFxuICAgICAgdGV4dFRyYW5zZm9ybTogeyBlbnVtczogWydub25lJywgJ3VwcGVyY2FzZScsICdsb3dlcmNhc2UnXSB9LFxuICAgICAgbm9kZVNoYXBlOiB7IGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZScsICdlbGxpcHNlJywgJ3RyaWFuZ2xlJywgJ3NxdWFyZScsICdwZW50YWdvbicsICdoZXhhZ29uJywgJ2hlcHRhZ29uJywgJ29jdGFnb24nLCAnc3RhciddIH0sXG4gICAgICBhcnJvd1NoYXBlOiB7IGVudW1zOiBbJ3RlZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS10ZWUnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnLCAnc3F1YXJlJywgJ2NpcmNsZScsICdkaWFtb25kJywgJ25vbmUnXSB9LFxuICAgICAgYXJyb3dGaWxsOiB7IGVudW1zOiBbJ2ZpbGxlZCcsICdob2xsb3cnXSB9LFxuICAgICAgZGlzcGxheTogeyBlbnVtczogWydlbGVtZW50JywgJ25vbmUnXSB9LFxuICAgICAgdmlzaWJpbGl0eTogeyBlbnVtczogWydoaWRkZW4nLCAndmlzaWJsZSddIH0sXG4gICAgICB2YWxpZ246IHsgZW51bXM6IFsndG9wJywgJ2NlbnRlcicsICdib3R0b20nXSB9LFxuICAgICAgaGFsaWduOiB7IGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J10gfSxcbiAgICAgIHRleHQ6IHsgc3RyaW5nOiB0cnVlIH0sXG4gICAgICBkYXRhOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBkYXRhKCdkYXRhJykgfSxcbiAgICAgIGxheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ2xheW91dERhdGEnKSB9LFxuICAgICAgbWFwRGF0YTogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSgnbWFwRGF0YScpIH0sXG4gICAgICBtYXBMYXlvdXREYXRhOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBtYXBEYXRhKCdtYXBMYXlvdXREYXRhJykgfSxcbiAgICAgIHVybDogeyByZWdleDogJ151cmxcXFxccypcXFxcKFxcXFxzKihbXlxcXFxzXSspXFxcXHMqXFxcXHMqXFxcXCl8bm9uZXwoLispJCcgfSxcbiAgICAgIHByb3BMaXN0OiB7IHByb3BMaXN0OiB0cnVlIH0sXG4gICAgICBhbmdsZTogeyBudW1iZXI6IHRydWUsIHVuaXRzOiAnZGVnfHJhZCcgfVxuICAgIH07XG5cbiAgICAvLyBkZWZpbmUgdmlzdWFsIHN0eWxlIHByb3BlcnRpZXNcbiAgICB2YXIgdCA9ICQkLnN0eWxlLnR5cGVzO1xuICAgIHZhciBwcm9wcyA9ICQkLnN0eWxlLnByb3BlcnRpZXMgPSBbXG4gICAgICAvLyBsYWJlbHNcbiAgICAgIHsgbmFtZTogJ3RleHQtdmFsaWduJywgdHlwZTogdC52YWxpZ24gfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtaGFsaWduJywgdHlwZTogdC5oYWxpZ24gfSxcbiAgICAgIHsgbmFtZTogJ2NvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnY29udGVudCcsIHR5cGU6IHQudGV4dCB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LW91dGxpbmUtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICAvLyB7IG5hbWU6ICd0ZXh0LWRlY29yYXRpb24nLCB0eXBlOiB0LnRleHREZWNvcmF0aW9uIH0sIC8vIG5vdCBzdXBwb3J0ZWQgaW4gY2FudmFzXG4gICAgICB7IG5hbWU6ICd0ZXh0LXRyYW5zZm9ybScsIHR5cGU6IHQudGV4dFRyYW5zZm9ybSB9LFxuICAgICAgLy8geyBuYW1lOiAndGV4dC1yb3RhdGlvbicsIHR5cGU6IHQuYW5nbGUgfSwgLy8gVE9ETyBkaXNhYmxlZCBiL2Mgcm90YXRpb24gYnJlYWtzIGJvdW5kaW5nIGJveGVzXG4gICAgICB7IG5hbWU6ICdmb250LWZhbWlseScsIHR5cGU6IHQuZm9udEZhbWlseSB9LFxuICAgICAgeyBuYW1lOiAnZm9udC1zdHlsZScsIHR5cGU6IHQuZm9udFN0eWxlIH0sXG4gICAgICAvLyB7IG5hbWU6ICdmb250LXZhcmlhbnQnLCB0eXBlOiB0LmZvbnRWYXJpYW50IH0sIC8vIG5vdCB1c2VmdWxcbiAgICAgIHsgbmFtZTogJ2ZvbnQtd2VpZ2h0JywgdHlwZTogdC5mb250V2VpZ2h0IH0sXG4gICAgICB7IG5hbWU6ICdmb250LXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ21pbi16b29tZWQtZm9udC1zaXplJywgdHlwZTogdC5zaXplIH0sXG5cbiAgICAgIC8vIHZpc2liaWxpdHlcbiAgICAgIHsgbmFtZTogJ2Rpc3BsYXknLCB0eXBlOiB0LmRpc3BsYXkgfSxcbiAgICAgIHsgbmFtZTogJ3Zpc2liaWxpdHknLCB0eXBlOiB0LnZpc2liaWxpdHkgfSxcbiAgICAgIHsgbmFtZTogJ29wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3otaW5kZXgnLCB0eXBlOiB0Lm5vbk5lZ2F0aXZlSW50IH0sXG5cbiAgICAgIC8vIG92ZXJsYXlzXG4gICAgICB7IG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ292ZXJsYXktY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdvdmVybGF5LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcblxuICAgICAgLy8gdHJhbnNpdGlvbiBhbmlzXG4gICAgICB7IG5hbWU6ICd0cmFuc2l0aW9uLXByb3BlcnR5JywgdHlwZTogdC5wcm9wTGlzdCB9LFxuICAgICAgeyBuYW1lOiAndHJhbnNpdGlvbi1kdXJhdGlvbicsIHR5cGU6IHQudGltZSB9LFxuICAgICAgeyBuYW1lOiAndHJhbnNpdGlvbi1kZWxheScsIHR5cGU6IHQudGltZSB9LFxuXG4gICAgICAvLyBub2RlIGJvZHlcbiAgICAgIHsgbmFtZTogJ2hlaWdodCcsIHR5cGU6IHQuYXV0b1NpemUgfSxcbiAgICAgIHsgbmFtZTogJ3dpZHRoJywgdHlwZTogdC5hdXRvU2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnc2hhcGUnLCB0eXBlOiB0Lm5vZGVTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1ibGFja2VuJywgdHlwZTogdC5uT25lT25lTnVtYmVyIH0sXG5cbiAgICAgIC8vIG5vZGUgYm9yZGVyXG4gICAgICB7IG5hbWU6ICdib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdib3JkZXItb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdib3JkZXItc3R5bGUnLCB0eXBlOiB0LmJvcmRlclN0eWxlIH0sXG4gICAgICBcbiAgICAgIC8vIG5vZGUgYmFja2dyb3VuZCBpbWFnZXNcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2UnLCB0eXBlOiB0LnVybCB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknLCB0eXBlOiB0LmJnUG9zIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXJlcGVhdCcsIHR5cGU6IHQuYmdSZXBlYXQgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtZml0JywgdHlwZTogdC5iZ0ZpdCB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1jbGlwJywgdHlwZTogdC5iZ0NsaXAgfSxcblxuICAgICAgLy8gY29tcG91bmQgcHJvcHNcbiAgICAgIHsgbmFtZTogJ3BhZGRpbmctbGVmdCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAncGFkZGluZy1yaWdodCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAncGFkZGluZy10b3AnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3BhZGRpbmctYm90dG9tJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdwb3NpdGlvbicsIHR5cGU6IHQucG9zaXRpb24gfSxcblxuICAgICAgLy8gZWRnZSBsaW5lXG4gICAgICB7IG5hbWU6ICdsaW5lLXN0eWxlJywgdHlwZTogdC5saW5lU3R5bGUgfSxcbiAgICAgIHsgbmFtZTogJ2xpbmUtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnY29udHJvbC1wb2ludC1kaXN0YW5jZScsIHR5cGU6IHQubnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LXdlaWdodCcsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnY3VydmUtc3R5bGUnLCB0eXBlOiB0LmN1cnZlU3R5bGUgfSxcbiAgICAgIHsgbmFtZTogJ2hheXN0YWNrLXJhZGl1cycsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuXG4gICAgICAvLyBlZGdlIGFycm93c1xuICAgICAgeyBuYW1lOiAnc291cmNlLWFycm93LXNoYXBlJywgdHlwZTogdC5hcnJvd1NoYXBlIH0sXG4gICAgICB7IG5hbWU6ICd0YXJnZXQtYXJyb3ctc2hhcGUnLCB0eXBlOiB0LmFycm93U2hhcGUgfSxcbiAgICAgIHsgbmFtZTogJ21pZC1zb3VyY2UtYXJyb3ctc2hhcGUnLCB0eXBlOiB0LmFycm93U2hhcGUgfSxcbiAgICAgIHsgbmFtZTogJ21pZC10YXJnZXQtYXJyb3ctc2hhcGUnLCB0eXBlOiB0LmFycm93U2hhcGUgfSxcbiAgICAgIHsgbmFtZTogJ3NvdXJjZS1hcnJvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3RhcmdldC1hcnJvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ21pZC1zb3VyY2UtYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtdGFyZ2V0LWFycm93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnc291cmNlLWFycm93LWZpbGwnLCB0eXBlOiB0LmFycm93RmlsbCB9LFxuICAgICAgeyBuYW1lOiAndGFyZ2V0LWFycm93LWZpbGwnLCB0eXBlOiB0LmFycm93RmlsbCB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXNvdXJjZS1hcnJvdy1maWxsJywgdHlwZTogdC5hcnJvd0ZpbGwgfSxcbiAgICAgIHsgbmFtZTogJ21pZC10YXJnZXQtYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH0sXG5cbiAgICAgIC8vIHRoZXNlIGFyZSBqdXN0IGZvciB0aGUgY29yZVxuICAgICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnYWN0aXZlLWJnLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnYWN0aXZlLWJnLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ2FjdGl2ZS1iZy1zaXplJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9XG4gICAgXTtcblxuICAgIC8vIHBpZSBiYWNrZ3JvdW5kcyBmb3Igbm9kZXNcbiAgICAkJC5zdHlsZS5waWVCYWNrZ3JvdW5kTiA9IDE2OyAvLyBiZWNhdXNlIHRoZSBwaWUgcHJvcGVydGllcyBhcmUgbnVtYmVyZWQsIGdpdmUgYWNjZXNzIHRvIGEgY29uc3RhbnQgTiAoZm9yIHJlbmRlcmVyIHVzZSlcbiAgICBwcm9wcy5wdXNoKHsgbmFtZTogJ3BpZS1zaXplJywgdHlwZTogdC5iZ1NpemUgfSk7XG4gICAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gJCQuc3R5bGUucGllQmFja2dyb3VuZE47IGkrKyApe1xuICAgICAgcHJvcHMucHVzaCh7IG5hbWU6ICdwaWUtJytpKyctYmFja2dyb3VuZC1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSk7XG4gICAgICBwcm9wcy5wdXNoKHsgbmFtZTogJ3BpZS0nK2krJy1iYWNrZ3JvdW5kLXNpemUnLCB0eXBlOiB0LnBlcmNlbnQgfSk7XG4gICAgICBwcm9wcy5wdXNoKHsgbmFtZTogJ3BpZS0nK2krJy1iYWNrZ3JvdW5kLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSk7XG4gICAgfVxuXG4gICAgLy8gYWxsb3cgYWNjZXNzIG9mIHByb3BlcnRpZXMgYnkgbmFtZSAoIGUuZy4gJCQuc3R5bGUucHJvcGVydGllcy5oZWlnaHQgKVxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICBcbiAgICAgIHByb3BzWyBwcm9wLm5hbWUgXSA9IHByb3A7IC8vIGFsbG93IGxvb2t1cCBieSBuYW1lXG4gICAgfVxuICB9KSgpO1xuXG4gIC8vIGFkZHMgdGhlIGRlZmF1bHQgc3R5bGVzaGVldCB0byB0aGUgY3VycmVudCBzdHlsZVxuICAkJC5zdHlmbi5hZGREZWZhdWx0U3R5bGVzaGVldCA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gdG8gYmUgbmljZSwgd2UgYnVpbGQgZm9udCByZWxhdGVkIHN0eWxlIHByb3BlcnRpZXMgZnJvbSB0aGUgY29yZSBjb250YWluZXJcbiAgICAvLyBzbyB0aGF0IGN5dG9zY2FwZSBtYXRjaGVzIHRoZSBzdHlsZSBvZiBpdHMgY29udGFpbmVyIGJ5IGRlZmF1bHRcbiAgICAvLyBcbiAgICAvLyB1bmZvcnR1bmF0ZWx5LCB0aGlzIGRvZXNuJ3Qgc2VlbSB3b3JrIGNvbnNpc3RlbnRseSBhbmQgY2FuIGdyYWIgdGhlIGRlZmF1bHQgc3R5bGVzaGVldCB2YWx1ZXNcbiAgICAvLyBpbnN0ZWFkIG9mIHRoZSBkZXZlbG9wZXIncyB2YWx1ZXMgc28gbGV0J3MganVzdCBtYWtlIGl0IGV4cGxpY2l0IGZvciB0aGUgZGV2IGZvciBub3dcbiAgICAvL1xuICAgIC8vIGRlbGF5aW5nIHRoZSByZWFkIG9mIHRoZXNlIHZhbCdzIGlzIG5vdCBhbiBvcHQnbjogdGhhdCB3b3VsZCBkZWxheSBpbml0J2wgbG9hZCB0aW1lXG4gICAgdmFyIGZvbnRGYW1pbHkgPSAnSGVsdmV0aWNhJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtZmFtaWx5JykgfHwgJ3NhbnMtc2VyaWYnO1xuICAgIHZhciBmb250U3R5bGUgPSAnbm9ybWFsJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtc3R5bGUnKSB8fCAnbm9ybWFsJztcbiAgICAvLyB2YXIgZm9udFZhcmlhbnQgPSAnbm9ybWFsJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2ZvbnQtdmFyaWFudCcpIHx8ICdub3JtYWwnO1xuICAgIHZhciBmb250V2VpZ2h0ID0gJ25vcm1hbCcgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdmb250LXdlaWdodCcpIHx8ICdub3JtYWwnO1xuICAgIHZhciBjb2xvciA9ICcjMDAwJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ2NvbG9yJykgfHwgJyMwMDAnO1xuICAgIHZhciB0ZXh0VHJhbnNmb3JtID0gJ25vbmUnIHx8IHRoaXMuY29udGFpbmVyUHJvcGVydHlBc1N0cmluZygndGV4dC10cmFuc2Zvcm0nKSB8fCAnbm9uZSc7XG4gICAgdmFyIGZvbnRTaXplID0gMTYgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdmb250LXNpemUnKSB8fCAxNjtcblxuICAgIC8vIGZpbGwgdGhlIHN0eWxlIHdpdGggdGhlIGRlZmF1bHQgc3R5bGVzaGVldFxuICAgIHRoaXNcbiAgICAgIC5zZWxlY3Rvcignbm9kZSwgZWRnZScpIC8vIGNvbW1vbiBwcm9wZXJ0aWVzXG4gICAgICAgIC5jc3Moe1xuICAgICAgICAgICd0ZXh0LXZhbGlnbic6ICd0b3AnLFxuICAgICAgICAgICd0ZXh0LWhhbGlnbic6ICdjZW50ZXInLFxuICAgICAgICAgICdjb2xvcic6IGNvbG9yLFxuICAgICAgICAgICd0ZXh0LW91dGxpbmUtY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ3RleHQtb3V0bGluZS13aWR0aCc6IDAsXG4gICAgICAgICAgJ3RleHQtb3V0bGluZS1vcGFjaXR5JzogMSxcbiAgICAgICAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAndGV4dC1kZWNvcmF0aW9uJzogJ25vbmUnLFxuICAgICAgICAgICd0ZXh0LXRyYW5zZm9ybSc6IHRleHRUcmFuc2Zvcm0sXG4gICAgICAgICAgJ2ZvbnQtZmFtaWx5JzogZm9udEZhbWlseSxcbiAgICAgICAgICAnZm9udC1zdHlsZSc6IGZvbnRTdHlsZSxcbiAgICAgICAgICAvLyAnZm9udC12YXJpYW50JzogZm9udFZhcmlhbnQsXG4gICAgICAgICAgJ2ZvbnQtd2VpZ2h0JzogZm9udFdlaWdodCxcbiAgICAgICAgICAnZm9udC1zaXplJzogZm9udFNpemUsXG4gICAgICAgICAgJ21pbi16b29tZWQtZm9udC1zaXplJzogMCxcbiAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAnZGlzcGxheSc6ICdlbGVtZW50JyxcbiAgICAgICAgICAnb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3otaW5kZXgnOiAwLFxuICAgICAgICAgICdjb250ZW50JzogJycsXG4gICAgICAgICAgJ292ZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgICAgICAgJ292ZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgICAgICd0cmFuc2l0aW9uLXByb3BlcnR5JzogJ25vbmUnLFxuICAgICAgICAgICd0cmFuc2l0aW9uLWR1cmF0aW9uJzogMCxcbiAgICAgICAgICAndHJhbnNpdGlvbi1kZWxheSc6IDAsXG5cbiAgICAgICAgICAvLyBub2RlIHByb3BzXG4gICAgICAgICAgJ2JhY2tncm91bmQtYmxhY2tlbic6IDAsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAnIzg4OCcsXG4gICAgICAgICAgJ2JhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2UnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24teCc6ICc1MCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiAnNTAlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1yZXBlYXQnOiAnbm8tcmVwZWF0JyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1maXQnOiAnbm9uZScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtY2xpcCc6ICdub2RlJyxcbiAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAgICdib3JkZXItb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgICAgICAgJ2JvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAgICAgJ2hlaWdodCc6IDMwLFxuICAgICAgICAgICd3aWR0aCc6IDMwLFxuICAgICAgICAgICdzaGFwZSc6ICdlbGxpcHNlJyxcblxuICAgICAgICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgICAgICAgJ3BhZGRpbmctdG9wJzogMCxcbiAgICAgICAgICAncGFkZGluZy1ib3R0b20nOiAwLFxuICAgICAgICAgICdwYWRkaW5nLWxlZnQnOiAwLFxuICAgICAgICAgICdwYWRkaW5nLXJpZ2h0JzogMCxcbiAgICAgICAgICAncG9zaXRpb24nOiAnb3JpZ2luJyxcbiAgICAgICAgICBcblxuICAgICAgICAgIC8vIG5vZGUgcGllIGJnXG4gICAgICAgICAgJ3BpZS1zaXplJzogJzEwMCUnLFxuICAgICAgICAgICdwaWUtMS1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTItYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0zLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtNC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTUtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS02LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtNy1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTgtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS05LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTAtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xMS1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTEyLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTMtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xNC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTE1LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTYtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0yLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0zLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS00LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS01LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS02LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS03LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS04LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS05LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xMC1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTEtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTEyLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xMy1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTQtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTE1LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xNi1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMS1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMi1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMy1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtNC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtNS1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtNi1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtNy1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtOC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtOS1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTAtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTExLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xMi1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTMtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTE0LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xNS1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTYtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcblxuICAgICAgICAgIC8vIGVkZ2UgcHJvcHNcbiAgICAgICAgICAnc291cmNlLWFycm93LXNoYXBlJzogJ25vbmUnLFxuICAgICAgICAgICdtaWQtc291cmNlLWFycm93LXNoYXBlJzogJ25vbmUnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ21pZC10YXJnZXQtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjZGRkJyxcbiAgICAgICAgICAnbWlkLXNvdXJjZS1hcnJvdy1jb2xvcic6ICcjZGRkJyxcbiAgICAgICAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdtaWQtdGFyZ2V0LWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdzb3VyY2UtYXJyb3ctZmlsbCc6ICdmaWxsZWQnLFxuICAgICAgICAgICdtaWQtc291cmNlLWFycm93LWZpbGwnOiAnZmlsbGVkJyxcbiAgICAgICAgICAndGFyZ2V0LWFycm93LWZpbGwnOiAnZmlsbGVkJyxcbiAgICAgICAgICAnbWlkLXRhcmdldC1hcnJvdy1maWxsJzogJ2ZpbGxlZCcsXG4gICAgICAgICAgJ2xpbmUtc3R5bGUnOiAnc29saWQnLFxuICAgICAgICAgICdsaW5lLWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSc6IDQwLFxuICAgICAgICAgICdjb250cm9sLXBvaW50LXdlaWdodCc6IDAuNSxcbiAgICAgICAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJyxcbiAgICAgICAgICAnaGF5c3RhY2stcmFkaXVzJzogMC44XG4gICAgICAgIH0pXG4gICAgICAuc2VsZWN0b3IoJyRub2RlID4gbm9kZScpIC8vIGNvbXBvdW5kIChwYXJlbnQpIG5vZGUgcHJvcGVydGllc1xuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnd2lkdGgnOiAnYXV0bycsXG4gICAgICAgICAgJ2hlaWdodCc6ICdhdXRvJyxcbiAgICAgICAgICAnc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMC41LFxuICAgICAgICAgICdwYWRkaW5nLXRvcCc6IDEwLFxuICAgICAgICAgICdwYWRkaW5nLXJpZ2h0JzogMTAsXG4gICAgICAgICAgJ3BhZGRpbmctbGVmdCc6IDEwLFxuICAgICAgICAgICdwYWRkaW5nLWJvdHRvbSc6IDEwXG4gICAgICAgIH0pXG4gICAgICAuc2VsZWN0b3IoJ2VkZ2UnKSAvLyBqdXN0IGVkZ2UgcHJvcGVydGllc1xuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnd2lkdGgnOiAxXG4gICAgICAgIH0pXG4gICAgICAuc2VsZWN0b3IoJzphY3RpdmUnKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnb3ZlcmxheS1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgICAgICdvdmVybGF5LW9wYWNpdHknOiAwLjI1XG4gICAgICAgIH0pXG4gICAgICAuc2VsZWN0b3IoJ2NvcmUnKSAvLyBqdXN0IGNvcmUgcHJvcGVydGllc1xuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1jb2xvcic6ICcjZGRkJyxcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JzogMC42NSxcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InOiAnI2FhYScsXG4gICAgICAgICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJzogMSxcbiAgICAgICAgICAnYWN0aXZlLWJnLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAnYWN0aXZlLWJnLW9wYWNpdHknOiAwLjE1LFxuICAgICAgICAgICdhY3RpdmUtYmctc2l6ZSc6ICQkLmlzLnRvdWNoKCkgPyA0MCA6IDE1LFxuICAgICAgICAgICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JzogMC4xMjVcbiAgICAgICAgfSlcbiAgICA7XG5cbiAgICB0aGlzLmRlZmF1bHRMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgfTtcblxuICAvLyByZW1vdmUgYWxsIGNvbnRleHRzXG4gICQkLnN0eWZuLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9wcml2YXRlLm5ld1N0eWxlID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gICQkLnN0eWZuLnJlc2V0VG9EZWZhdWx0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gYnVpbGRzIGEgc3R5bGUgb2JqZWN0IGZvciB0aGUgJ2NvcmUnIHNlbGVjdG9yXG4gICQkLnN0eWZuLmNvcmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZTtcbiAgfTtcblxuICAvLyBwYXJzZSBhIHByb3BlcnR5OyByZXR1cm4gbnVsbCBvbiBpbnZhbGlkOyByZXR1cm4gcGFyc2VkIHByb3BlcnR5IG90aGVyd2lzZVxuICAvLyBmaWVsZHMgOlxuICAvLyAtIG5hbWUgOiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgLy8gLSB2YWx1ZSA6IHRoZSBwYXJzZWQsIG5hdGl2ZS10eXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgLy8gLSBzdHJWYWx1ZSA6IGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgdmFsdWUgaW4gdmFsaWQgY3NzXG4gIC8vIC0gYnlwYXNzIDogdHJ1ZSBpZmYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5XG4gICQkLnN0eWZuLnBhcnNlID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKXtcbiAgICBcbiAgICBuYW1lID0gJCQudXRpbC5jYW1lbDJkYXNoKCBuYW1lICk7IC8vIG1ha2Ugc3VyZSB0aGUgcHJvcGVydHkgbmFtZSBpcyBpbiBkYXNoIGZvcm0gKGUuZy4gJ3Byb3BlcnR5LW5hbWUnIG5vdCAncHJvcGVydHlOYW1lJylcbiAgICB2YXIgcHJvcGVydHkgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzWyBuYW1lIF07XG4gICAgdmFyIHBhc3NlZFZhbHVlID0gdmFsdWU7XG4gICAgXG4gICAgaWYoICFwcm9wZXJ0eSApeyByZXR1cm4gbnVsbDsgfSAvLyByZXR1cm4gbnVsbCBvbiBwcm9wZXJ0eSBvZiB1bmtub3duIG5hbWVcbiAgICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCApeyByZXR1cm4gbnVsbDsgfSAvLyBjYW4ndCBhc3NpZ24gbnVsbFxuXG4gICAgdmFyIHZhbHVlSXNTdHJpbmcgPSAkJC5pcy5zdHJpbmcodmFsdWUpO1xuICAgIGlmKCB2YWx1ZUlzU3RyaW5nICl7IC8vIHRyaW0gdGhlIHZhbHVlIHRvIG1ha2UgcGFyc2luZyBlYXNpZXJcbiAgICAgIHZhbHVlID0gJCQudXRpbC50cmltKCB2YWx1ZSApO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gcHJvcGVydHkudHlwZTtcbiAgICBpZiggIXR5cGUgKXsgcmV0dXJuIG51bGw7IH0gLy8gbm8gdHlwZSwgbm8gbHVja1xuXG4gICAgLy8gY2hlY2sgaWYgYnlwYXNzIGlzIG51bGwgb3IgZW1wdHkgc3RyaW5nIChpLmUuIGluZGljYXRpb24gdG8gZGVsZXRlIGJ5cGFzcyBwcm9wZXJ0eSlcbiAgICBpZiggcHJvcElzQnlwYXNzICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IG51bGwpICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGJ5cGFzczogdHJ1ZSxcbiAgICAgICAgZGVsZXRlQnlwYXNzOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIG1hcHBlZFxuICAgIHZhciBkYXRhLCBtYXBEYXRhLCBsYXlvdXREYXRhLCBtYXBMYXlvdXREYXRhO1xuICAgIGlmKCAhdmFsdWVJc1N0cmluZyB8fCBwcm9wSXNGbGF0ICl7XG4gICAgICAvLyB0aGVuIGRvbid0IGJvdGhlciB0byBkbyB0aGUgZXhwZW5zaXZlIHJlZ2V4IGNoZWNrc1xuXG4gICAgfSBlbHNlIGlmKFxuICAgICAgKCBkYXRhID0gbmV3IFJlZ0V4cCggJCQuc3R5bGUudHlwZXMuZGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKSB8fFxuICAgICAgKCBsYXlvdXREYXRhID0gbmV3IFJlZ0V4cCggJCQuc3R5bGUudHlwZXMubGF5b3V0RGF0YS5yZWdleCApLmV4ZWMoIHZhbHVlICkgKVxuICAgICl7XG4gICAgICBpZiggcHJvcElzQnlwYXNzICl7IHJldHVybiBmYWxzZTsgfSAvLyBtYXBwZXJzIG5vdCBhbGxvd2VkIGluIGJ5cGFzc1xuICAgICAgXG4gICAgICB2YXIgaXNMYXlvdXQgPSBsYXlvdXREYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgICBkYXRhID0gZGF0YSB8fCBsYXlvdXREYXRhO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogZGF0YSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgIG1hcHBlZDogaXNMYXlvdXQgPyAkJC5zdHlsZS50eXBlcy5sYXlvdXREYXRhIDogJCQuc3R5bGUudHlwZXMuZGF0YSxcbiAgICAgICAgZmllbGQ6IGRhdGFbMV0sXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgICBoYXNQaWU6IG5hbWUubWF0Y2goL3BpZS0oXFxkKyktYmFja2dyb3VuZC1zaXplLylcbiAgICAgIH07XG5cbiAgICB9IGVsc2UgaWYoXG4gICAgICAoIG1hcERhdGEgPSBuZXcgUmVnRXhwKCAkJC5zdHlsZS50eXBlcy5tYXBEYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApIHx8XG4gICAgICAoIG1hcExheW91dERhdGEgPSBuZXcgUmVnRXhwKCAkJC5zdHlsZS50eXBlcy5tYXBMYXlvdXREYXRhLnJlZ2V4ICkuZXhlYyggdmFsdWUgKSApXG4gICAgKXtcbiAgICAgIGlmKCBwcm9wSXNCeXBhc3MgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIG1hcHBlcnMgbm90IGFsbG93ZWQgaW4gYnlwYXNzXG5cbiAgICAgIHZhciBpc0xheW91dCA9IG1hcExheW91dERhdGEgIT09IHVuZGVmaW5lZDtcbiAgICAgIG1hcERhdGEgPSBtYXBEYXRhIHx8IG1hcExheW91dERhdGE7XG5cbiAgICAgIC8vIHdlIGNhbiBtYXAgb25seSBpZiB0aGUgdHlwZSBpcyBhIGNvbG91ciBvciBhIG51bWJlclxuICAgICAgaWYoICEodHlwZS5jb2xvciB8fCB0eXBlLm51bWJlcikgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgIHZhciB2YWx1ZU1pbiA9IHRoaXMucGFyc2UoIG5hbWUsIG1hcERhdGFbNF0pOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuICAgICAgaWYoICF2YWx1ZU1pbiB8fCB2YWx1ZU1pbi5tYXBwZWQgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG5cbiAgICAgIHZhciB2YWx1ZU1heCA9IHRoaXMucGFyc2UoIG5hbWUsIG1hcERhdGFbNV0pOyAvLyBwYXJzZSB0byB2YWxpZGF0ZVxuICAgICAgaWYoICF2YWx1ZU1heCB8fCB2YWx1ZU1heC5tYXBwZWQgKXsgcmV0dXJuIGZhbHNlOyB9IC8vIGNhbid0IGJlIGludmFsaWQgb3IgbWFwcGVkXG5cbiAgICAgIC8vIGNoZWNrIGlmIHZhbHVlTWluIGFuZCB2YWx1ZU1heCBhcmUgdGhlIHNhbWVcbiAgICAgIGlmKCB2YWx1ZU1pbi52YWx1ZSA9PT0gdmFsdWVNYXgudmFsdWUgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBjYW4ndCBtYWtlIG11Y2ggb2YgYSBtYXBwZXIgd2l0aG91dCBhIHJhbmdlXG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiggdHlwZS5jb2xvciApe1xuICAgICAgICB2YXIgYzEgPSB2YWx1ZU1pbi52YWx1ZTtcbiAgICAgICAgdmFyIGMyID0gdmFsdWVNYXgudmFsdWU7XG4gICAgICAgIFxuICAgICAgICB2YXIgc2FtZSA9IGMxWzBdID09PSBjMlswXSAvLyByZWRcbiAgICAgICAgICAmJiBjMVsxXSA9PT0gYzJbMV0gLy8gZ3JlZW5cbiAgICAgICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgICAgICYmICggLy8gb3B0aW9uYWwgYWxwaGFcbiAgICAgICAgICAgIGMxWzNdID09PSBjMlszXSAvLyBzYW1lIGFscGhhIG91dHJpZ2h0XG4gICAgICAgICAgICB8fCAoXG4gICAgICAgICAgICAgIChjMVszXSA9PSBudWxsIHx8IGMxWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAxP1xuICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAoYzJbM10gPT0gbnVsbCB8fCBjMlszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMj9cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIDtcblxuICAgICAgICBpZiggc2FtZSApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgbWFrZSBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IG1hcERhdGEsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBtYXBwZWQ6IGlzTGF5b3V0ID8gJCQuc3R5bGUudHlwZXMubWFwTGF5b3V0RGF0YSA6ICQkLnN0eWxlLnR5cGVzLm1hcERhdGEsXG4gICAgICAgIGZpZWxkOiBtYXBEYXRhWzFdLFxuICAgICAgICBmaWVsZE1pbjogcGFyc2VGbG9hdCggbWFwRGF0YVsyXSApLCAvLyBtaW4gJiBtYXggYXJlIG51bWVyaWNcbiAgICAgICAgZmllbGRNYXg6IHBhcnNlRmxvYXQoIG1hcERhdGFbM10gKSxcbiAgICAgICAgdmFsdWVNaW46IHZhbHVlTWluLnZhbHVlLFxuICAgICAgICB2YWx1ZU1heDogdmFsdWVNYXgudmFsdWUsXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgICBoYXNQaWU6IG5hbWUubWF0Y2goL3BpZS0oXFxkKyktYmFja2dyb3VuZC1zaXplLylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdGhlIHR5cGUgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgb2JqZWN0XG4gICAgaWYoIHR5cGUubnVtYmVyICl7IFxuICAgICAgdmFyIHVuaXRzO1xuICAgICAgdmFyIGltcGxpY2l0VW5pdHMgPSAncHgnOyAvLyBub3Qgc2V0ID0+IHB4XG5cbiAgICAgIGlmKCB0eXBlLnVuaXRzICl7IC8vIHVzZSBzcGVjaWZpZWQgdW5pdHMgaWYgc2V0XG4gICAgICAgIHVuaXRzID0gdHlwZS51bml0cztcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGUuaW1wbGljaXRVbml0cyApe1xuICAgICAgICBpbXBsaWNpdFVuaXRzID0gdHlwZS5pbXBsaWNpdFVuaXRzO1xuICAgICAgfVxuXG4gICAgICBpZiggIXR5cGUudW5pdGxlc3MgKXtcbiAgICAgICAgaWYoIHZhbHVlSXNTdHJpbmcgKXtcbiAgICAgICAgICB2YXIgdW5pdHNSZWdleCA9ICdweHxlbScgKyAodHlwZS5hbGxvd1BlcmNlbnQgPyAnfFxcXFwlJyA6ICcnKTtcbiAgICAgICAgICBpZiggdW5pdHMgKXsgdW5pdHNSZWdleCA9IHVuaXRzOyB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0IFxuICAgICAgICAgIHZhciBtYXRjaCA9IHZhbHVlLm1hdGNoKCAnXignICsgJCQudXRpbC5yZWdleC5udW1iZXIgKyAnKSgnICsgdW5pdHNSZWdleCArICcpPycgKyAnJCcgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB1bml0cyA9IG1hdGNoWzJdIHx8IGltcGxpY2l0VW5pdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB9IGVsc2UgaWYoICF1bml0cyB8fCB0eXBlLmltcGxpY2l0VW5pdHMgKSB7XG4gICAgICAgICAgdW5pdHMgPSBpbXBsaWNpdFVuaXRzOyAvLyBpbXBsaWNpdGx5IHB4IGlmIHVuc3BlY2lmaWVkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG4gICAgICAvLyBpZiBub3QgYSBudW1iZXIgYW5kIGVudW1zIG5vdCBhbGxvd2VkLCB0aGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkXG4gICAgICBpZiggaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgdGhpcyBudW1iZXIgdHlwZSBhbHNvIGFjY2VwdHMgc3BlY2lhbCBrZXl3b3JkcyBpbiBwbGFjZSBvZiBudW1iZXJzXG4gICAgICAvLyAoaS5lLiBgbGVmdGAsIGBhdXRvYCwgZXRjKVxuICAgICAgaWYoIGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdmFsdWUgPSBwYXNzZWRWYWx1ZTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHR5cGUuZW51bXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZW4gPSB0eXBlLmVudW1zW2ldO1xuXG4gICAgICAgICAgaWYoIGVuID09PSB2YWx1ZSApe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGZhaWxlZCBvbiBlbnVtIGFmdGVyIGZhaWxpbmcgb24gbnVtYmVyXG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlclxuICAgICAgaWYoIHR5cGUuaW50ZWdlciAmJiAhJCQuaXMuaW50ZWdlcih2YWx1ZSkgKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHZhbHVlIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYoICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgdHlwZS5taW4pIFxuICAgICAgfHwgKHR5cGUubWF4ICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPiB0eXBlLm1heClcbiAgICAgICl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlICsgKHVuaXRzID8gdW5pdHMgOiAnJyksXG4gICAgICAgIHVuaXRzOiB1bml0cyxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICAgIGhhc1BpZTogbmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKSAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAwICYmIHZhbHVlICE9PSAnJ1xuICAgICAgfTtcblxuICAgICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIHBpeGVsc1xuICAgICAgaWYoIHR5cGUudW5pdGxlc3MgfHwgKHVuaXRzICE9PSAncHgnICYmIHVuaXRzICE9PSAnZW0nKSApe1xuICAgICAgICAvLyB0aGVuIHB4VmFsdWUgZG9lcyBub3QgYXBwbHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5weFZhbHVlID0gKCB1bml0cyA9PT0gJ3B4JyB8fCAhdW5pdHMgPyAodmFsdWUpIDogKHRoaXMuZ2V0RW1TaXplSW5QaXhlbHMoKSAqIHZhbHVlKSApO1xuICAgICAgfVxuXG4gICAgICAvLyBub3JtYWxpc2UgdmFsdWUgaW4gbXNcbiAgICAgIGlmKCB1bml0cyA9PT0gJ21zJyB8fCB1bml0cyA9PT0gJ3MnICl7XG4gICAgICAgIHJldC5tc1ZhbHVlID0gdW5pdHMgPT09ICdtcycgPyB2YWx1ZSA6IDEwMDAgKiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5wcm9wTGlzdCApIHtcblxuICAgICAgdmFyIHByb3BzID0gW107XG4gICAgICB2YXIgcHJvcHNTdHIgPSAnJyArIHZhbHVlOyAgICAgIFxuIFxuICAgICAgaWYoIHByb3BzU3RyID09PSAnbm9uZScgKXtcbiAgICAgICAgLy8gbGVhdmUgZW1wdHlcblxuICAgICAgfSBlbHNlIHsgLy8gZ28gb3ZlciBlYWNoIHByb3BcblxuICAgICAgICB2YXIgcHJvcHNTcGxpdCA9IHByb3BzU3RyLnNwbGl0KCcsJyk7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHNTcGxpdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9ICQkLnV0aWwudHJpbSggcHJvcHNTcGxpdFtpXSApO1xuXG4gICAgICAgICAgaWYoICQkLnN0eWxlLnByb3BlcnRpZXNbcHJvcE5hbWVdICl7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKCBwcm9wTmFtZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwcm9wcy5sZW5ndGggPT09IDAgKXsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogcHJvcHMsXG4gICAgICAgIHN0clZhbHVlOiBwcm9wcy5sZW5ndGggPT09IDAgPyAnbm9uZScgOiBwcm9wcy5qb2luKCcsICcpLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5jb2xvciApe1xuICAgICAgdmFyIHR1cGxlID0gJCQudXRpbC5jb2xvcjJ0dXBsZSggdmFsdWUgKTtcblxuICAgICAgaWYoICF0dXBsZSApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdHVwbGUsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5lbnVtcyApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0eXBlLmVudW1zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbaV07XG5cbiAgICAgICAgaWYoIGVuID09PSB2YWx1ZSApe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9IGVsc2UgaWYoIHR5cGUucmVnZXggKXtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoIHR5cGUucmVnZXggKTsgLy8gbWFrZSBhIHJlZ2V4IGZyb20gdGhlIHR5cGVcbiAgICAgIHZhciBtID0gcmVnZXguZXhlYyggdmFsdWUgKTtcblxuICAgICAgaWYoIG0gKXsgLy8gcmVnZXggbWF0Y2hlc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IG0sXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7IC8vIHJlZ2V4IGRvZXNuJ3QgbWF0Y2hcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRpZG4ndCBtYXRjaCB0aGUgcmVnZXggc28gdGhlIHZhbHVlIGlzIGJvZ3VzXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoIHR5cGUuc3RyaW5nICl7XG4gICAgICAvLyBqdXN0IHJldHVyblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIG5vdCBhIHR5cGUgd2UgY2FuIGhhbmRsZVxuICAgIH1cblxuICB9O1xuXG4gIC8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZyb20gdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmcgYW5kIHN3aXRjaCB0byB0aGF0IGNvbnRleHRcbiAgJCQuc3R5Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsZWN0b3JTdHIgKXtcbiAgICAvLyAnY29yZScgaXMgYSBzcGVjaWFsIGNhc2UgYW5kIGRvZXMgbm90IG5lZWQgYSBzZWxlY3RvclxuICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3ICQkLlNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuXG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcbiAgICB0aGlzW2ldID0ge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgcHJvcGVydGllczogW10sXG4gICAgICBtYXBwZWRQcm9wZXJ0aWVzOiBbXSxcbiAgICAgIGluZGV4OiBpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGFkZCBvbmUgb3IgbWFueSBjc3MgcnVsZXMgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuICAkJC5zdHlmbi5jc3MgPSBmdW5jdGlvbigpe1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgc3dpdGNoKCBhcmdzLmxlbmd0aCApe1xuICAgIGNhc2UgMTpcbiAgICAgIHZhciBtYXAgPSBhcmdzWzBdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgbWFwVmFsID0gbWFwWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggbWFwVmFsID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBtYXBWYWwgPSBtYXBbICQkLnV0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiggbWFwVmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICB0aGlzLmNzc1J1bGUoIHByb3AubmFtZSwgbWFwVmFsICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICB0aGlzLmNzc1J1bGUoIGFyZ3NbMF0sIGFyZ3NbMV0gKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrOyAvLyBkbyBub3RoaW5nIGlmIGFyZ3MgYXJlIGludmFsaWRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvLyBhZGQgYSBzaW5nbGUgY3NzIHJ1bGUgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuICAkJC5zdHlmbi5jc3NSdWxlID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlICl7IFxuICAgIC8vIG5hbWUtdmFsdWUgcGFpclxuICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UoIG5hbWUsIHZhbHVlICk7XG5cbiAgICAvLyBhZGQgcHJvcGVydHkgdG8gY3VycmVudCBjb250ZXh0IGlmIHZhbGlkXG4gICAgaWYoIHByb3BlcnR5ICl7XG4gICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKCBwcm9wZXJ0eSApO1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzWyBwcm9wZXJ0eS5uYW1lIF0gPSBwcm9wZXJ0eTsgLy8gYWxsb3cgYWNjZXNzIGJ5IG5hbWUgYXMgd2VsbFxuXG4gICAgICBpZiggcHJvcGVydHkuaGFzUGllICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuaGFzUGllID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHByb3BlcnR5Lm1hcHBlZCApe1xuICAgICAgICB0aGlzW2ldLm1hcHBlZFByb3BlcnRpZXMucHVzaCggcHJvcGVydHkgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRvIGNvcmUgc3R5bGUgaWYgbmVjZXNzYXJ5XG4gICAgICB2YXIgY3VycmVudFNlbGVjdG9ySXNDb3JlID0gIXRoaXNbaV0uc2VsZWN0b3I7XG4gICAgICBpZiggY3VycmVudFNlbGVjdG9ySXNDb3JlICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlWyBwcm9wZXJ0eS5uYW1lIF0gPSBwcm9wZXJ0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyAocG90ZW50aWFsbHkgZXhwZW5zaXZlIGNhbGN1bGF0aW9uKVxuICAvLyBhcHBseSB0aGUgc3R5bGUgdG8gdGhlIGVsZW1lbnQgYmFzZWQgb25cbiAgLy8gLSBpdHMgYnlwYXNzXG4gIC8vIC0gd2hhdCBzZWxlY3RvcnMgbWF0Y2ggaXRcbiAgJCQuc3R5Zm4uYXBwbHkgPSBmdW5jdGlvbiggZWxlcyApe1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmKCBzZWxmLl9wcml2YXRlLm5ld1N0eWxlICl7IC8vIGNsZWFyIHN0eWxlIGNhY2hlc1xuICAgICAgdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0ge307XG4gICAgICB0aGlzLl9wcml2YXRlLnByb3BEaWZmcyA9IHt9O1xuICAgIH1cblxuICAgIGZvciggdmFyIGllID0gMDsgaWUgPCBlbGVzLmxlbmd0aDsgaWUrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaWVdO1xuICAgICAgdmFyIGN4dE1ldGEgPSBzZWxmLmdldENvbnRleHRNZXRhKCBlbGUgKTtcbiAgICAgIHZhciBjeHRTdHlsZSA9IHNlbGYuZ2V0Q29udGV4dFN0eWxlKCBjeHRNZXRhICk7XG4gICAgICB2YXIgYXBwID0gc2VsZi5hcHBseUNvbnRleHRTdHlsZSggY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSApO1xuXG4gICAgICBzZWxmLnVwZGF0ZVRyYW5zaXRpb25zKCBlbGUsIGFwcC5kaWZmUHJvcHMgKTtcbiAgICAgIHNlbGYudXBkYXRlU3R5bGVIaW50cyggZWxlICk7XG5cbiAgICB9IC8vIGZvciBlbGVtZW50c1xuXG4gICAgc2VsZi5fcHJpdmF0ZS5uZXdTdHlsZSA9IGZhbHNlO1xuICB9O1xuXG4gICQkLnN0eWZuLmdldFByb3BlcnRpZXNEaWZmID0gZnVuY3Rpb24oIG9sZEN4dEtleSwgbmV3Q3h0S2V5ICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWNoZSA9IHNlbGYuX3ByaXZhdGUucHJvcERpZmZzID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgfHwge307XG4gICAgdmFyIGR1YWxDeHRLZXkgPSBvbGRDeHRLZXkgKyAnLScgKyBuZXdDeHRLZXk7XG4gICAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2R1YWxDeHRLZXldO1xuXG4gICAgaWYoIGNhY2hlZFZhbCApe1xuICAgICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgICB9XG5cbiAgICB2YXIgZGlmZlByb3BzID0gW107XG4gICAgdmFyIGFkZGVkUHJvcCA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzZWxmLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY3h0ID0gc2VsZltpXTtcbiAgICAgIHZhciBvbGRIYXNDeHQgPSBvbGRDeHRLZXlbaV0gPT09ICd0JztcbiAgICAgIHZhciBuZXdIYXNDeHQgPSBuZXdDeHRLZXlbaV0gPT09ICd0JztcbiAgICAgIHZhciBjeHRIYXNEaWZmZWQgPSBvbGRIYXNDeHQgIT09IG5ld0hhc0N4dDtcbiAgICAgIHZhciBjeHRIYXNNYXBwZWRQcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzLmxlbmd0aCA+IDA7XG5cbiAgICAgIGlmKCBjeHRIYXNEaWZmZWQgfHwgY3h0SGFzTWFwcGVkUHJvcHMgKXtcbiAgICAgICAgdmFyIHByb3BzO1xuXG4gICAgICAgIGlmKCBjeHRIYXNEaWZmZWQgJiYgY3h0SGFzTWFwcGVkUHJvcHMgKXtcbiAgICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBzdWZmaWNlcyBiL2MgbWFwcGVkUHJvcGVydGllcyBpcyBhIHN1YnNldCBvZiBwcm9wZXJ0aWVzXG4gICAgICAgIH0gZWxzZSBpZiggY3h0SGFzRGlmZmVkICl7XG4gICAgICAgICAgcHJvcHMgPSBjeHQucHJvcGVydGllczsgLy8gbmVlZCB0byBjaGVjayB0aGVtIGFsbFxuICAgICAgICB9IGVsc2UgaWYoIGN4dEhhc01hcHBlZFByb3BzICl7XG4gICAgICAgICAgcHJvcHMgPSBjeHQubWFwcGVkUHJvcGVydGllczsgLy8gb25seSBuZWVkIHRvIGNoZWNrIG1hcHBlZFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgICAgdmFyIG5hbWUgPSBwcm9wLm5hbWU7XG5cbiAgICAgICAgICAvLyBpZiBhIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzIHRoaXMgcHJvcGVydHksIHRoZW4gdGhlIGZhY3QgdGhhdCB0aGlzIGNvbnRleHQgaGFzIHN3aXRjaGVkL2RpZmZlZCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAgIC8vIChzZW1pIGV4cGVuc2l2ZSBjaGVjayBzaW5jZSBpdCBtYWtlcyB0aGlzIGZ1bmN0aW9uIE8obl4yKSBvbiBjb250ZXh0IGxlbmd0aCwgYnV0IHdvcnRoIGl0IHNpbmNlIG92ZXJhbGwgcmVzdWx0XG4gICAgICAgICAgLy8gaXMgY2FjaGVkKVxuICAgICAgICAgIHZhciBsYXRlckN4dE92ZXJyaWRlcyA9IGZhbHNlOyBcbiAgICAgICAgICBmb3IoIHZhciBrID0gaSArIDE7IGsgPCBzZWxmLmxlbmd0aDsgaysrICl7XG4gICAgICAgICAgICB2YXIgbGF0ZXJDeHQgPSBzZWxmW2tdO1xuICAgICAgICAgICAgdmFyIGhhc0xhdGVyQ3h0ID0gbmV3Q3h0S2V5W2tdID09PSAndCc7XG5cbiAgICAgICAgICAgIGlmKCAhaGFzTGF0ZXJDeHQgKXsgY29udGludWU7IH0gLy8gY2FuJ3Qgb3ZlcnJpZGUgdW5sZXNzIHRoZSBjb250ZXh0IGlzIGFjdGl2ZVxuXG4gICAgICAgICAgICBsYXRlckN4dE92ZXJyaWRlcyA9IGxhdGVyQ3h0LnByb3BlcnRpZXNbIHByb3AubmFtZSBdICE9IG51bGw7XG5cbiAgICAgICAgICAgIGlmKCBsYXRlckN4dE92ZXJyaWRlcyApeyBicmVhazsgfSAvLyBleGl0IGVhcmx5IGFzIGxvbmcgYXMgb25lIGxhdGVyIGNvbnRleHQgb3ZlcnJpZGVzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFhZGRlZFByb3BbbmFtZV0gJiYgIWxhdGVyQ3h0T3ZlcnJpZGVzICl7XG4gICAgICAgICAgICBhZGRlZFByb3BbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgZGlmZlByb3BzLnB1c2goIG5hbWUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gZm9yIHByb3BzXG4gICAgICB9IC8vIGlmXG5cbiAgICB9IC8vIGZvciBjb250ZXh0c1xuXG4gICAgY2FjaGVbIGR1YWxDeHRLZXkgXSA9IGRpZmZQcm9wcztcbiAgICByZXR1cm4gZGlmZlByb3BzO1xuICB9O1xuXG4gICQkLnN0eWZuLmdldENvbnRleHRNZXRhID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3h0S2V5ID0gJyc7XG4gICAgdmFyIGRpZmZQcm9wcztcbiAgICB2YXIgcHJldktleSA9IGVsZS5fcHJpdmF0ZS5zdHlsZUN4dEtleSB8fCAnJztcblxuICAgIGlmKCBzZWxmLl9wcml2YXRlLm5ld1N0eWxlICl7XG4gICAgICBwcmV2S2V5ID0gJyc7IC8vIHNpbmNlIHdlIG5lZWQgdG8gYXBwbHkgYWxsIHN0eWxlIGlmIGEgZnJlc2ggc3R5bGVzaGVldFxuICAgIH1cblxuICAgIC8vIGdldCB0aGUgY3h0IGtleVxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNvbnRleHQgPSBzZWxmW2ldO1xuICAgICAgdmFyIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgPSBjb250ZXh0LnNlbGVjdG9yICYmIGNvbnRleHQuc2VsZWN0b3IubWF0Y2hlcyggZWxlICk7IC8vIE5COiBjb250ZXh0LnNlbGVjdG9yIG1heSBiZSBudWxsIGZvciAnY29yZSdcblxuICAgICAgaWYoIGNvbnRleHRTZWxlY3Rvck1hdGNoZXMgKXtcbiAgICAgICAgY3h0S2V5ICs9ICd0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN4dEtleSArPSAnZic7XG4gICAgICB9XG4gICAgfSAvLyBmb3IgY29udGV4dFxuXG4gICAgZGlmZlByb3BzID0gc2VsZi5nZXRQcm9wZXJ0aWVzRGlmZiggcHJldktleSwgY3h0S2V5ICk7XG5cbiAgICBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgPSBjeHRLZXk7XG5cbiAgICByZXR1cm4ge1xuICAgICAga2V5OiBjeHRLZXksXG4gICAgICBkaWZmUHJvcE5hbWVzOiBkaWZmUHJvcHNcbiAgICB9O1xuICB9O1xuXG4gIC8vIGdldHMgYSBjb21wdXRlZCBlbGUgc3R5bGUgb2JqZWN0IGJhc2VkIG9uIG1hdGNoZWQgY29udGV4dHNcbiAgJCQuc3R5Zm4uZ2V0Q29udGV4dFN0eWxlID0gZnVuY3Rpb24oIGN4dE1ldGEgKXtcbiAgICB2YXIgY3h0S2V5ID0gY3h0TWV0YS5rZXk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjeHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgfHwge307XG5cbiAgICAvLyBpZiBhbHJlYWR5IGNvbXB1dGVkIHN0eWxlLCByZXR1cm5lZCBjYWNoZWQgY29weVxuICAgIGlmKCBjeHRTdHlsZXNbY3h0S2V5XSApeyByZXR1cm4gY3h0U3R5bGVzW2N4dEtleV07IH1cblxuICAgIHZhciBzdHlsZSA9IHtcbiAgICAgIF9wcml2YXRlOiB7XG4gICAgICAgIGtleTogY3h0S2V5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGN4dCA9IHNlbGZbaV07XG4gICAgICB2YXIgaGFzQ3h0ID0gY3h0S2V5W2ldID09PSAndCc7XG5cbiAgICAgIGlmKCAhaGFzQ3h0ICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY3h0LnByb3BlcnRpZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBjeHQucHJvcGVydGllc1tqXTtcbiAgICAgICAgdmFyIHN0eVByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wO1xuXG4gICAgICAgIHN0eVByb3AuY29udGV4dCA9IGN4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjeHRTdHlsZXNbY3h0S2V5XSA9IHN0eWxlO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAkJC5zdHlmbi5hcHBseUNvbnRleHRTdHlsZSA9IGZ1bmN0aW9uKCBjeHRNZXRhLCBjeHRTdHlsZSwgZWxlICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkaWZmUHJvcHMgPSBjeHRNZXRhLmRpZmZQcm9wTmFtZXM7XG4gICAgdmFyIHJldERpZmZQcm9wcyA9IHt9O1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkaWZmUHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBkaWZmUHJvcE5hbWUgPSBkaWZmUHJvcHNbaV07XG4gICAgICB2YXIgY3h0UHJvcCA9IGN4dFN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcbiAgICAgIHZhciBlbGVQcm9wID0gZWxlLl9wcml2YXRlLnN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcblxuICAgICAgLy8gc2F2ZSBjeWNsZXMgd2hlbiB0aGUgY29udGV4dCBwcm9wIGRvZXNuJ3QgbmVlZCB0byBiZSBhcHBsaWVkXG4gICAgICBpZiggIWN4dFByb3AgfHwgZWxlUHJvcCA9PT0gY3h0UHJvcCApeyBjb250aW51ZTsgfVxuXG4gICAgICB2YXIgcmV0RGlmZlByb3AgPSByZXREaWZmUHJvcHNbIGRpZmZQcm9wTmFtZSBdID0ge1xuICAgICAgICBwcmV2OiBlbGVQcm9wXG4gICAgICB9O1xuXG4gICAgICBzZWxmLmFwcGx5UGFyc2VkUHJvcGVydHkoIGVsZSwgY3h0UHJvcCApO1xuXG4gICAgICByZXREaWZmUHJvcC5uZXh0ID0gZWxlLl9wcml2YXRlLnN0eWxlWyBkaWZmUHJvcE5hbWUgXTtcblxuICAgICAgaWYoIHJldERpZmZQcm9wLm5leHQgJiYgcmV0RGlmZlByb3AubmV4dC5ieXBhc3MgKXtcbiAgICAgICAgcmV0RGlmZlByb3AubmV4dCA9IHJldERpZmZQcm9wLm5leHQuYnlwYXNzZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpZmZQcm9wczogcmV0RGlmZlByb3BzXG4gICAgfTtcbiAgfTtcblxuICAkJC5zdHlmbi51cGRhdGVTdHlsZUhpbnRzID0gZnVuY3Rpb24oZWxlKXtcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdHlsZSA9IF9wLnN0eWxlO1xuXG4gICAgLy8gc2V0IHdoZXRoZXIgaGFzIHBpZSBvciBub3Q7IGZvciBncmVhdGVyIGVmZmljaWVuY3lcbiAgICB2YXIgaGFzUGllID0gZmFsc2U7XG4gICAgaWYoIF9wLmdyb3VwID09PSAnbm9kZXMnICYmIHNlbGYuX3ByaXZhdGUuaGFzUGllICl7XG4gICAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAkJC5zdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrICl7IC8vIDEuLk5cbiAgICAgICAgdmFyIHNpemUgPSBfcC5zdHlsZVsncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLXNpemUnXS52YWx1ZTtcblxuICAgICAgICBpZiggc2l6ZSA+IDAgKXtcbiAgICAgICAgICBoYXNQaWUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3AuaGFzUGllID0gaGFzUGllO1xuXG4gICAgdmFyIHRyYW5zZm9ybSA9IHN0eWxlWyd0ZXh0LXRyYW5zZm9ybSddLnN0clZhbHVlO1xuICAgIHZhciBjb250ZW50ID0gc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICB2YXIgZlN0eWxlID0gc3R5bGVbJ2ZvbnQtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgICB2YXIgc2l6ZSA9IHN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICsgJ3B4JztcbiAgICB2YXIgZmFtaWx5ID0gc3R5bGVbJ2ZvbnQtZmFtaWx5J10uc3RyVmFsdWU7XG4gICAgLy8gdmFyIHZhcmlhbnQgPSBzdHlsZVsnZm9udC12YXJpYW50J10uc3RyVmFsdWU7XG4gICAgdmFyIHdlaWdodCA9IHN0eWxlWydmb250LXdlaWdodCddLnN0clZhbHVlO1xuICAgIHZhciB2YWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgaGFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIG9XaWR0aCA9IHN0eWxlWyd0ZXh0LW91dGxpbmUtd2lkdGgnXS5weFZhbHVlO1xuICAgIF9wLmxhYmVsS2V5ID0gZlN0eWxlICsnJCcrIHNpemUgKyckJysgZmFtaWx5ICsnJCcrIHdlaWdodCArJyQnKyBjb250ZW50ICsnJCcrIHRyYW5zZm9ybSArJyQnKyB2YWxpZ24gKyckJysgaGFsaWduICsnJCcrIG9XaWR0aDtcbiAgICBfcC5mb250S2V5ID0gZlN0eWxlICsnJCcrIHdlaWdodCArJyQnKyBzaXplICsnJCcrIGZhbWlseTtcblxuICAgIHZhciB3aWR0aCA9IHN0eWxlWyd3aWR0aCddLnB4VmFsdWU7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlWydoZWlnaHQnXS5weFZhbHVlO1xuICAgIHZhciBib3JkZXJXID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG4gICAgX3AuYm91bmRpbmdCb3hLZXkgPSB3aWR0aCArJyQnKyBoZWlnaHQgKyckJysgYm9yZGVyVztcblxuICAgIGlmKCBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdlZGdlcycgKXtcbiAgICAgIHZhciBjcHNzID0gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJ10ucHhWYWx1ZTtcbiAgICAgIHZhciBjcGQgPSBzdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZSddID8gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnXS5weFZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGNwdyA9IHN0eWxlWydjb250cm9sLXBvaW50LXdlaWdodCddLnZhbHVlO1xuICAgICAgdmFyIGN1cnZlID0gc3R5bGVbJ2N1cnZlLXN0eWxlJ10uc3RyVmFsdWU7XG4gICAgICBcbiAgICAgIF9wLmJvdW5kaW5nQm94S2V5ICs9ICckJysgY3BzcyArJyQnKyBjcGQgKyckJysgY3B3ICsnJCcrIGN1cnZlO1xuICAgIH1cblxuICAgIF9wLnN0eWxlS2V5ID0gRGF0ZS5ub3coKTsgLy8gcHJvYmFibHkgc2FmZSB0byB1c2UgYXBwbGllZCB0aW1lIGFuZCBtdWNoIGZhc3RlclxuICAgIC8vIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgIC8vICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgIC8vICAgdmFyIGVsZVByb3AgPSBfcC5zdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgLy8gICB2YXIgdmFsID0gZWxlUHJvcCAmJiBlbGVQcm9wLnN0clZhbHVlID8gZWxlUHJvcC5zdHJWYWx1ZSA6ICd1bmRlZmluZWQnO1xuXG4gICAgLy8gICBfcC5zdHlsZUtleSArPSAnJCcgKyB2YWw7XG4gICAgLy8gfVxuICB9O1xuXG4gIC8vIGFwcGx5IGEgcHJvcGVydHkgdG8gdGhlIHN0eWxlIChmb3IgaW50ZXJuYWwgdXNlKVxuICAvLyByZXR1cm5zIHdoZXRoZXIgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgLy9cbiAgLy8gbm93LCB0aGlzIGZ1bmN0aW9uIGZsYXR0ZW5zIHRoZSBwcm9wZXJ0eSwgYW5kIGhlcmUncyBob3c6XG4gIC8vXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlLCBkZWxldGVCeXBhc3M6IHRydWUgfVxuICAvLyBubyBwcm9wZXJ0eSBpcyBnZW5lcmF0ZWQsIGluc3RlYWQgdGhlIGJ5cGFzcyBwcm9wZXJ0eSBpbiB0aGVcbiAgLy8gZWxlbWVudCdzIHN0eWxlIGlzIHJlcGxhY2VkIGJ5IHdoYXQncyBwb2ludGVkIHRvIGJ5IHRoZSBgYnlwYXNzZWRgXG4gIC8vIGZpZWxkIGluIHRoZSBieXBhc3MgcHJvcGVydHkgKGkuZS4gcmVzdG9yaW5nIHRoZSBwcm9wZXJ0eSB0aGVcbiAgLy8gYnlwYXNzIHdhcyBvdmVycmlkaW5nKVxuICAvL1xuICAvLyBmb3IgcGFyc2VkUHJvcDp7IG1hcHBlZDogdHJ1dGh5IH1cbiAgLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgbWFwcGluZzogcHJvcCB9XG4gIC8vIFxuICAvLyBmb3IgcGFyc2VkUHJvcDp7IGJ5cGFzczogdHJ1ZSB9XG4gIC8vIHRoZSBnZW5lcmF0ZWQgZmxhdHRlbmVkUHJvcDp7IGJ5cGFzc2VkOiBwYXJzZWRQcm9wIH0gXG4gICQkLnN0eWZuLmFwcGx5UGFyc2VkUHJvcGVydHkgPSBmdW5jdGlvbiggZWxlLCBwYXJzZWRQcm9wICl7XG4gICAgdmFyIHByb3AgPSBwYXJzZWRQcm9wO1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgZmllbGRWYWwsIGZsYXRQcm9wO1xuICAgIHZhciB0eXBlID0gJCQuc3R5bGUucHJvcGVydGllc1sgcHJvcC5uYW1lIF0udHlwZTtcbiAgICB2YXIgcHJvcElzQnlwYXNzID0gcHJvcC5ieXBhc3M7XG4gICAgdmFyIG9yaWdQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgIHZhciBvcmlnUHJvcElzQnlwYXNzID0gb3JpZ1Byb3AgJiYgb3JpZ1Byb3AuYnlwYXNzO1xuXG4gICAgLy8gY2FuJ3QgYXBwbHkgYXV0byB0byB3aWR0aCBvciBoZWlnaHQgdW5sZXNzIGl0J3MgYSBwYXJlbnQgbm9kZVxuICAgIGlmKCAocGFyc2VkUHJvcC5uYW1lID09PSAnaGVpZ2h0JyB8fCBwYXJzZWRQcm9wLm5hbWUgPT09ICd3aWR0aCcpICYmIHBhcnNlZFByb3AudmFsdWUgPT09ICdhdXRvJyAmJiBlbGUuaXNOb2RlKCkgJiYgIWVsZS5pc1BhcmVudCgpICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBkZWxldGUgdGhlIGN1cnJlbnQgYnlwYXNzXG4gICAgaWYoIHByb3BJc0J5cGFzcyAmJiBwcm9wLmRlbGV0ZUJ5cGFzcyApeyAvLyB0aGVuIHRoaXMgcHJvcGVydHkgaXMganVzdCBoZXJlIHRvIGluZGljYXRlIHdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICB2YXIgY3VycmVudFByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG5cbiAgICAgIC8vIGNhbiBvbmx5IGRlbGV0ZSBpZiB0aGUgY3VycmVudCBwcm9wIGlzIGEgYnlwYXNzIGFuZCBpdCBwb2ludHMgdG8gdGhlIHByb3BlcnR5IGl0IHdhcyBvdmVycmlkaW5nXG4gICAgICBpZiggIWN1cnJlbnRQcm9wICl7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBwcm9wZXJ0eSBpcyBhbHJlYWR5IG5vdCBkZWZpbmVkXG4gICAgICB9IGVsc2UgaWYoIGN1cnJlbnRQcm9wLmJ5cGFzcyAmJiBjdXJyZW50UHJvcC5ieXBhc3NlZCApeyAvLyB0aGVuIHJlcGxhY2UgdGhlIGJ5cGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBvcmlnaW5hbFxuICAgICAgICBcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYnlwYXNzZWQgcHJvcGVydHkgd2FzIGFscmVhZHkgYXBwbGllZCAoYW5kIHRoZXJlZm9yZSBwYXJzZWQpLCB3ZSBjYW4ganVzdCByZXBsYWNlIGl0IChubyByZWFwcGx5aW5nIG5lY2Vzc2FyeSlcbiAgICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gY3VycmVudFByb3AuYnlwYXNzZWQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uKCl7XG4gICAgICAkJC51dGlsLmVycm9yKCdEbyBub3QgYXNzaWduIG1hcHBpbmdzIHRvIGVsZW1lbnRzIHdpdGhvdXQgY29ycmVzcG9uZGluZyBkYXRhIChlLmcuIGVsZSBgJysgZWxlLmlkKCkgKydgIGZvciBwcm9wZXJ0eSBgJysgcHJvcC5uYW1lICsnYCB3aXRoIGRhdGEgZmllbGQgYCcrIHByb3AuZmllbGQgKydgKTsgdHJ5IGEgYFsnKyBwcm9wLmZpZWxkICsnXWAgc2VsZWN0b3IgdG8gbGltaXQgc2NvcGUgdG8gZWxlbWVudHMgd2l0aCBgJysgcHJvcC5maWVsZCArJ2AgZGVmaW5lZCcpO1xuICAgIH07XG5cbiAgICAvLyBwdXQgdGhlIHByb3BlcnR5IGluIHRoZSBzdHlsZSBvYmplY3RzXG4gICAgc3dpdGNoKCBwcm9wLm1hcHBlZCApeyAvLyBmbGF0dGVuIHRoZSBwcm9wZXJ0eSBpZiBtYXBwZWRcbiAgICBjYXNlICQkLnN0eWxlLnR5cGVzLm1hcERhdGE6XG4gICAgY2FzZSAkJC5zdHlsZS50eXBlcy5tYXBMYXlvdXREYXRhOlxuICAgICAgXG4gICAgICB2YXIgaXNMYXlvdXQgPSBwcm9wLm1hcHBlZCA9PT0gJCQuc3R5bGUudHlwZXMubWFwTGF5b3V0RGF0YTtcblxuICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoXCIuXCIpO1xuICAgICAgdmFyIGZpZWxkVmFsID0gaXNMYXlvdXQgPyBlbGUuX3ByaXZhdGUubGF5b3V0RGF0YSA6IGVsZS5fcHJpdmF0ZS5kYXRhO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoICYmIGZpZWxkVmFsOyBpKysgKXtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICBmaWVsZFZhbCA9IGZpZWxkVmFsWyBmaWVsZCBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGVyY2VudDtcbiAgICAgIGlmKCAhJCQuaXMubnVtYmVyKGZpZWxkVmFsKSApeyAvLyB0aGVuIGtlZXAgdGhlIG1hcHBpbmcgYnV0IGFzc3VtZSAwJSBmb3Igbm93XG4gICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVyY2VudCA9IChmaWVsZFZhbCAtIHByb3AuZmllbGRNaW4pIC8gKHByb3AuZmllbGRNYXggLSBwcm9wLmZpZWxkTWluKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIHRvIGJvdW5kIHBlcmNlbnQgdmFsdWVcbiAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICAgIHZhciByMSA9IHByb3AudmFsdWVNaW5bMF07XG4gICAgICAgIHZhciByMiA9IHByb3AudmFsdWVNYXhbMF07XG4gICAgICAgIHZhciBnMSA9IHByb3AudmFsdWVNaW5bMV07XG4gICAgICAgIHZhciBnMiA9IHByb3AudmFsdWVNYXhbMV07XG4gICAgICAgIHZhciBiMSA9IHByb3AudmFsdWVNaW5bMl07XG4gICAgICAgIHZhciBiMiA9IHByb3AudmFsdWVNYXhbMl07XG4gICAgICAgIHZhciBhMSA9IHByb3AudmFsdWVNaW5bM10gPT0gbnVsbCA/IDEgOiBwcm9wLnZhbHVlTWluWzNdO1xuICAgICAgICB2YXIgYTIgPSBwcm9wLnZhbHVlTWF4WzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1heFszXTtcblxuICAgICAgICB2YXIgY2xyID0gW1xuICAgICAgICAgIE1hdGgucm91bmQoIHIxICsgKHIyIC0gcjEpKnBlcmNlbnQgKSxcbiAgICAgICAgICBNYXRoLnJvdW5kKCBnMSArIChnMiAtIGcxKSpwZXJjZW50ICksXG4gICAgICAgICAgTWF0aC5yb3VuZCggYjEgKyAoYjIgLSBiMSkqcGVyY2VudCApLFxuICAgICAgICAgIE1hdGgucm91bmQoIGExICsgKGEyIC0gYTEpKnBlcmNlbnQgKVxuICAgICAgICBdO1xuXG4gICAgICAgIGZsYXRQcm9wID0geyAvLyBjb2xvdXJzIGFyZSBzaW1wbGUsIHNvIGp1c3QgY3JlYXRlIHRoZSBmbGF0IHByb3BlcnR5IGluc3RlYWQgb2YgZXhwZW5zaXZlIHN0cmluZyBwYXJzaW5nXG4gICAgICAgICAgYnlwYXNzOiBwcm9wLmJ5cGFzcywgLy8gd2UncmUgYSBieXBhc3MgaWYgdGhlIG1hcHBpbmcgcHJvcGVydHkgaXMgYSBieXBhc3NcbiAgICAgICAgICBuYW1lOiBwcm9wLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IGNscixcbiAgICAgICAgICBzdHJWYWx1ZTogJ3JnYignICsgY2xyWzBdICsgJywgJyArIGNsclsxXSArICcsICcgKyBjbHJbMl0gKyAnKSdcbiAgICAgICAgfTtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCB0eXBlLm51bWJlciApe1xuICAgICAgICB2YXIgY2FsY1ZhbHVlID0gcHJvcC52YWx1ZU1pbiArIChwcm9wLnZhbHVlTWF4IC0gcHJvcC52YWx1ZU1pbikgKiBwZXJjZW50O1xuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgY2FsY1ZhbHVlLCBwcm9wLmJ5cGFzcywgdHJ1ZSApO1xuICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbiBvbmx5IG1hcCB0byBjb2xvdXJzIGFuZCBudW1iZXJzXG4gICAgICB9XG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gdXNlIHRoZSBvcmlnUHJvcCBzbyB3ZSBzdGlsbCBrZWVwIHRoZSBtYXBwaW5nIGl0c2VsZlxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgb3JpZ1Byb3Auc3RyVmFsdWUsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgICB9IFxuXG4gICAgICBpZiggIWZsYXRQcm9wICl7IHByaW50TWFwcGluZ0VycigpOyB9XG4gICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICBicmVhaztcblxuICAgIC8vIGRpcmVjdCBtYXBwaW5nICBcbiAgICBjYXNlICQkLnN0eWxlLnR5cGVzLmRhdGE6IFxuICAgIGNhc2UgJCQuc3R5bGUudHlwZXMubGF5b3V0RGF0YTogXG5cbiAgICAgIHZhciBpc0xheW91dCA9IHByb3AubWFwcGVkID09PSAkJC5zdHlsZS50eXBlcy5sYXlvdXREYXRhO1xuXG4gICAgICAvLyBmbGF0dGVuIHRoZSBmaWVsZCAoZS5nLiBkYXRhLmZvby5iYXIpXG4gICAgICB2YXIgZmllbGRzID0gcHJvcC5maWVsZC5zcGxpdChcIi5cIik7XG4gICAgICB2YXIgZmllbGRWYWwgPSBpc0xheW91dCA/IGVsZS5fcHJpdmF0ZS5sYXlvdXREYXRhIDogZWxlLl9wcml2YXRlLmRhdGE7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGggJiYgZmllbGRWYWw7IGkrKyApe1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIGZpZWxkVmFsID0gZmllbGRWYWxbIGZpZWxkIF07XG4gICAgICB9XG5cbiAgICAgIGZsYXRQcm9wID0gdGhpcy5wYXJzZSggcHJvcC5uYW1lLCBmaWVsZFZhbCwgcHJvcC5ieXBhc3MsIHRydWUgKTtcblxuICAgICAgaWYoICFmbGF0UHJvcCApeyAvLyBpZiB3ZSBjYW4ndCBmbGF0dGVuIHRoZSBwcm9wZXJ0eSwgdGhlbiB1c2UgdGhlIG9yaWdQcm9wIHNvIHdlIHN0aWxsIGtlZXAgdGhlIG1hcHBpbmcgaXRzZWxmXG4gICAgICAgIHZhciBmbGF0UHJvcFZhbCA9IG9yaWdQcm9wID8gb3JpZ1Byb3Auc3RyVmFsdWUgOiAnJztcblxuICAgICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZmxhdFByb3BWYWwsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgcHJpbnRNYXBwaW5nRXJyKCk7IH1cbiAgICAgIGZsYXRQcm9wLm1hcHBpbmcgPSBwcm9wOyAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBtYXBwaW5nXG4gICAgICBwcm9wID0gZmxhdFByb3A7IC8vIHRoZSBmbGF0dGVuZWQgKG1hcHBlZCkgcHJvcGVydHkgaXMgdGhlIG9uZSB3ZSB3YW50XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgYnJlYWs7IC8vIGp1c3Qgc2V0IHRoZSBwcm9wZXJ0eVxuXG4gICAgZGVmYXVsdDogXG4gICAgICByZXR1cm4gZmFsc2U7IC8vIG5vdCBhIHZhbGlkIG1hcHBpbmdcbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgcHJvcGVydHkgaXMgYSBieXBhc3MgcHJvcGVydHksIHRoZW4gbGluayB0aGUgcmVzdWx0YW50IHByb3BlcnR5IHRvIHRoZSBvcmlnaW5hbCBvbmVcbiAgICBpZiggcHJvcElzQnlwYXNzICl7XG4gICAgICBpZiggb3JpZ1Byb3BJc0J5cGFzcyApeyAvLyB0aGVuIHRoaXMgYnlwYXNzIG92ZXJyaWRlcyB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcC5ieXBhc3NlZDsgLy8gc3RlYWwgYnlwYXNzZWQgcHJvcCBmcm9tIG9sZCBieXBhc3NcbiAgICAgIH0gZWxzZSB7IC8vIHRoZW4gbGluayB0aGUgb3JpZyBwcm9wIHRvIHRoZSBuZXcgYnlwYXNzXG4gICAgICAgIHByb3AuYnlwYXNzZWQgPSBvcmlnUHJvcDtcbiAgICAgIH1cblxuICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcDsgLy8gYW5kIHNldFxuICAgIFxuICAgIH0gZWxzZSB7IC8vIHByb3AgaXMgbm90IGJ5cGFzc1xuICAgICAgaWYoIG9yaWdQcm9wSXNCeXBhc3MgKXsgLy8gdGhlbiBrZWVwIHRoZSBvcmlnIHByb3AgKHNpbmNlIGl0J3MgYSBieXBhc3MpIGFuZCBsaW5rIHRvIHRoZSBuZXcgcHJvcFxuICAgICAgICBvcmlnUHJvcC5ieXBhc3NlZCA9IHByb3A7XG4gICAgICB9IGVsc2UgeyAvLyB0aGVuIGp1c3QgcmVwbGFjZSB0aGUgb2xkIHByb3Agd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wOyBcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyB1cGRhdGVzIHRoZSB2aXN1YWwgc3R5bGUgZm9yIGFsbCBlbGVtZW50cyAodXNlZnVsIGZvciBtYW51YWwgc3R5bGUgbW9kaWZpY2F0aW9uIGFmdGVyIGluaXQpXG4gICQkLnN0eWZuLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG5cbiAgICBlbGVzLnVwZGF0ZVN0eWxlKCk7XG4gIH07XG5cbiAgLy8ganVzdCB1cGRhdGUgdGhlIGZ1bmN0aW9uYWwgcHJvcGVydGllcyAoaS5lLiBtYXBwaW5ncykgaW4gdGhlIGVsZW1lbnRzJ1xuICAvLyBzdHlsZXMgKGxlc3MgZXhwZW5zaXZlIHRoYW4gcmVjYWxjdWxhdGlvbilcbiAgJCQuc3R5Zm4udXBkYXRlTWFwcGVycyA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7IC8vIGZvciBlYWNoIGVsZVxuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGorKyApeyAvLyBmb3IgZWFjaCBwcm9wXG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tqXTtcbiAgICAgICAgdmFyIHByb3BJblN0eWxlID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBwcm9wSW5TdHlsZSAmJiBwcm9wSW5TdHlsZS5tYXBwaW5nICl7XG4gICAgICAgICAgdmFyIG1hcHBpbmcgPSBwcm9wSW5TdHlsZS5tYXBwaW5nO1xuICAgICAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eSggZWxlLCBtYXBwaW5nICk7IC8vIHJlYXBwbHkgdGhlIG1hcHBpbmcgcHJvcGVydHlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuICAgIH1cbiAgfTtcblxuICAvLyBkaWZmUHJvcHMgOiB7IG5hbWUgPT4geyBwcmV2LCBuZXh0IH0gfVxuICAkJC5zdHlmbi51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgdmFyIHByb3BzID0gc3R5bGVbJ3RyYW5zaXRpb24tcHJvcGVydHknXS52YWx1ZTtcbiAgICB2YXIgZHVyYXRpb24gPSBzdHlsZVsndHJhbnNpdGlvbi1kdXJhdGlvbiddLm1zVmFsdWU7XG4gICAgdmFyIGRlbGF5ID0gc3R5bGVbJ3RyYW5zaXRpb24tZGVsYXknXS5tc1ZhbHVlO1xuICAgIHZhciBjc3MgPSB7fTtcblxuICAgIGlmKCBwcm9wcy5sZW5ndGggPiAwICYmIGR1cmF0aW9uID4gMCApe1xuXG4gICAgICAvLyBidWlsZCB1cCB0aGUgc3R5bGUgdG8gYW5pbWF0ZSB0b3dhcmRzXG4gICAgICB2YXIgYW55UHJldiA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgc3R5UHJvcCA9IHN0eWxlWyBwcm9wIF07XG4gICAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcCBdO1xuXG4gICAgICAgIGlmKCAhZGlmZlByb3AgKXsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgcHJldlByb3AgPSBkaWZmUHJvcC5wcmV2O1xuICAgICAgICB2YXIgZnJvbVByb3AgPSBwcmV2UHJvcDtcbiAgICAgICAgdmFyIHRvUHJvcCA9IGRpZmZQcm9wLm5leHQgIT0gbnVsbCA/IGRpZmZQcm9wLm5leHQgOiBzdHlQcm9wO1xuICAgICAgICB2YXIgZGlmZiA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCAhZnJvbVByb3AgKXsgY29udGludWU7IH0gXG5cbiAgICAgICAgLy8gY29uc2lkZXIgcHggdmFsdWVzXG4gICAgICAgIGlmKCAkJC5pcy5udW1iZXIoIGZyb21Qcm9wLnB4VmFsdWUgKSAmJiAkJC5pcy5udW1iZXIoIHRvUHJvcC5weFZhbHVlICkgKXtcbiAgICAgICAgICBkaWZmID0gZnJvbVByb3AucHhWYWx1ZSAhPT0gdG9Qcm9wLnB4VmFsdWU7XG5cbiAgICAgICAgLy8gY29uc2lkZXIgbnVtZXJpY2FsIHZhbHVlc1xuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlciggZnJvbVByb3AudmFsdWUgKSAmJiAkJC5pcy5udW1iZXIoIHRvUHJvcC52YWx1ZSApICl7XG4gICAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlICE9PSB0b1Byb3AudmFsdWU7XG5cbiAgICAgICAgLy8gY29uc2lkZXIgY29sb3VyIHZhbHVlc1xuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLmFycmF5KCBmcm9tUHJvcC52YWx1ZSApICYmICQkLmlzLmFycmF5KCB0b1Byb3AudmFsdWUgKSApe1xuICAgICAgICAgIGRpZmYgPSBmcm9tUHJvcC52YWx1ZVswXSAhPT0gdG9Qcm9wLnZhbHVlWzBdXG4gICAgICAgICAgICB8fCBmcm9tUHJvcC52YWx1ZVsxXSAhPT0gdG9Qcm9wLnZhbHVlWzFdXG4gICAgICAgICAgICB8fCBmcm9tUHJvcC52YWx1ZVsyXSAhPT0gdG9Qcm9wLnZhbHVlWzJdXG4gICAgICAgICAgO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIHByZXZpb3VzIHZhbHVlIGlzIGdvb2QgZm9yIGFuIGFuaW1hdGlvbiBvbmx5IGlmIGl0J3MgZGlmZmVyZW50XG4gICAgICAgIGlmKCBkaWZmICl7XG4gICAgICAgICAgY3NzWyBwcm9wIF0gPSB0b1Byb3Auc3RyVmFsdWU7IC8vIHRvIHZhbFxuICAgICAgICAgIHRoaXMuYXBwbHlCeXBhc3MoZWxlLCBwcm9wLCBmcm9tUHJvcC5zdHJWYWx1ZSk7IC8vIGZyb20gdmFsXG4gICAgICAgICAgYW55UHJldiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IC8vIGVuZCBpZiBwcm9wcyBhbGxvdyBhbmlcblxuICAgICAgLy8gY2FuJ3QgdHJhbnNpdGlvbiBpZiB0aGVyZSdzIG5vdGhpbmcgcHJldmlvdXMgdG8gdHJhbnNpdGlvbiBmcm9tXG4gICAgICBpZiggIWFueVByZXYgKXsgcmV0dXJuOyB9XG4gICAgICBcbiAgICAgIGVsZS5fcHJpdmF0ZS50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgICAgZWxlLnN0b3AoKTtcblxuICAgICAgaWYoIGRlbGF5ID4gMCApe1xuICAgICAgICBlbGUuZGVsYXkoIGRlbGF5ICk7XG4gICAgICB9XG5cbiAgICAgIGVsZS5hbmltYXRlKHtcbiAgICAgICAgY3NzOiBjc3NcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpeyBcbiAgICAgICAgICBpZiggIWlzQnlwYXNzICl7XG4gICAgICAgICAgICBzZWxmLnJlbW92ZUJ5cGFzc2VzKCBlbGUsIHByb3BzICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlLl9wcml2YXRlLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYoIGVsZS5fcHJpdmF0ZS50cmFuc2l0aW9uaW5nICl7XG4gICAgICBlbGUuc3RvcCgpO1xuXG4gICAgICB0aGlzLnJlbW92ZUJ5cGFzc2VzKCBlbGUsIHByb3BzICk7XG5cbiAgICAgIGVsZS5fcHJpdmF0ZS50cmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9OyBcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBieXBhc3NlcyBhcmUgYXBwbGllZCB0byBhbiBleGlzdGluZyBzdHlsZSBvbiBhbiBlbGVtZW50LCBhbmQganVzdCB0YWNrZWQgb24gdGVtcG9yYXJpbHlcbiAgLy8gcmV0dXJucyB0cnVlIGlmZiBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bCBmb3IgYXQgbGVhc3QgMSBzcGVjaWZpZWQgcHJvcGVydHlcbiAgJCQuc3R5Zm4uYXBwbHlCeXBhc3MgPSBmdW5jdGlvbiggZWxlcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG4gICAgaWYoIG5hbWUgPT09IFwiKlwiIHx8IG5hbWUgPT09IFwiKipcIiApeyAvLyBhcHBseSB0byBhbGwgcHJvcGVydHkgbmFtZXNcblxuICAgICAgaWYoIHZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggcGFyc2VkUHJvcCApe1xuICAgICAgICAgICAgcHJvcHMucHVzaCggcGFyc2VkUHJvcCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcobmFtZSkgKXsgLy8gdGhlbiBwYXJzZSB0aGUgc2luZ2xlIHByb3BlcnR5XG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuXG4gICAgICBpZiggcGFyc2VkUHJvcCApe1xuICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdChuYW1lKSApeyAvLyB0aGVuIHBhcnNlIGVhY2ggcHJvcGVydHlcbiAgICAgIHZhciBzcGVjaWZpZWRQcm9wcyA9IG5hbWU7XG4gICAgICB1cGRhdGVUcmFuc2l0aW9ucyA9IHZhbHVlO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIHZhbHVlID0gc3BlY2lmaWVkUHJvcHNbIG5hbWUgXTtcblxuICAgICAgICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCApeyAvLyB0cnkgY2FtZWwgY2FzZSBuYW1lIHRvb1xuICAgICAgICAgIHZhbHVlID0gc3BlY2lmaWVkUHJvcHNbICQkLnV0aWwuZGFzaDJjYW1lbChuYW1lKSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gY2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCB3ZWxsIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdlJ3ZlIGZhaWxlZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgcHJvcGVydGllc1xuICAgIGlmKCBwcm9wcy5sZW5ndGggPT09IDAgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBub3csIGFwcGx5IHRoZSBieXBhc3MgcHJvcGVydGllcyBvbiB0aGUgZWxlbWVudHNcbiAgICB2YXIgcmV0ID0gZmFsc2U7IC8vIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzdWNjZXNmdWwgYnlwYXNzIGFwcGxpZWRcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGVhY2ggZWxlXG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICAgIHZhciBkaWZmUHJvcDtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKyApeyAvLyBmb3IgZWFjaCBwcm9wXG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG5cbiAgICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgICAgdmFyIHByZXZQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgICAgIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eSggZWxlLCBwcm9wICkgfHwgcmV0O1xuXG4gICAgICAgIGlmKCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICAgICAgICAgIGRpZmZQcm9wLm5leHQgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICAgIH1cblxuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZXNcblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgLy8gb25seSB1c2VmdWwgaW4gc3BlY2lmaWMgY2FzZXMgbGlrZSBhbmltYXRpb25cbiAgJCQuc3R5Zm4ub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiggZWxlcywgbmFtZSwgdmFsdWUgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHByb3AgPSBlbGUuX3ByaXZhdGUuc3R5bGVbICQkLnV0aWwuY2FtZWwyZGFzaChuYW1lKSBdO1xuXG4gICAgICBpZiggIXByb3AuYnlwYXNzICl7IC8vIG5lZWQgYSBieXBhc3MgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyggZWxlLCBuYW1lLCB2YWx1ZSApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcC52YWx1ZSA9IHZhbHVlO1xuICAgICAgcHJvcC5weFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gICQkLnN0eWZuLnJlbW92ZUFsbEJ5cGFzc2VzID0gZnVuY3Rpb24oIGVsZXMsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbal07XG4gICAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICB2YXIgcHJldlByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcC5uYW1lIF0gPSB7IHByZXY6IHByZXZQcm9wIH07XG5cbiAgICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgcGFyc2VkUHJvcCk7XG5cbiAgICAgICAgZGlmZlByb3AubmV4dCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICAgIGlmKCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBlbGVzXG4gIH07XG5cbiAgJCQuc3R5Zm4ucmVtb3ZlQnlwYXNzZXMgPSBmdW5jdGlvbiggZWxlcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbal07XG4gICAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXTtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzWyBuYW1lIF07XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcblxuICAgICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBwYXJzZWRQcm9wKTtcblxuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZXNcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGdldHMgd2hhdCBhbiBlbSBzaXplIGNvcnJlc3BvbmRzIHRvIGluIHBpeGVscyByZWxhdGl2ZSB0byBhIGRvbSBlbGVtZW50XG4gICQkLnN0eWZuLmdldEVtU2l6ZUluUGl4ZWxzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBkb21FbGVtZW50ID0gY3kuY29udGFpbmVyKCk7XG5cbiAgICBpZiggd2luZG93ICYmIGRvbUVsZW1lbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUgKXtcbiAgICAgIHZhciBweEFzU3RyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tRWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJyk7XG4gICAgICB2YXIgcHggPSBwYXJzZUZsb2F0KCBweEFzU3RyICk7XG4gICAgICByZXR1cm4gcHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxOyAvLyBpbiBjYXNlIHdlJ3JlIHJ1bm5pbmcgb3V0c2lkZSBvZiB0aGUgYnJvd3NlclxuICAgIH1cbiAgfTtcblxuICAvLyBnZXRzIGNzcyBwcm9wZXJ0eSBmcm9tIHRoZSBjb3JlIGNvbnRhaW5lclxuICAkJC5zdHlmbi5jb250YWluZXJDc3MgPSBmdW5jdGlvbiggcHJvcE5hbWUgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBkb21FbGVtZW50ID0gY3kuY29udGFpbmVyKCk7XG5cbiAgICBpZiggd2luZG93ICYmIGRvbUVsZW1lbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUgKXtcbiAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCBwcm9wTmFtZSApO1xuICAgIH1cbiAgfTtcblxuICAkJC5zdHlmbi5jb250YWluZXJQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBwcm9wTmFtZSApe1xuICAgIHZhciBwcm9wU3RyID0gdGhpcy5jb250YWluZXJDc3MoIHByb3BOYW1lICk7XG4gICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlKCBwcm9wTmFtZSwgcHJvcFN0ciApO1xuICAgIHJldHVybiBwcm9wO1xuICB9O1xuXG4gICQkLnN0eWZuLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcgPSBmdW5jdGlvbiggcHJvcE5hbWUgKXtcbiAgICB2YXIgcHJvcCA9IHRoaXMuY29udGFpbmVyUHJvcGVydHkoIHByb3BOYW1lICk7XG5cbiAgICBpZiggcHJvcCApe1xuICAgICAgcmV0dXJuIHByb3Auc3RyVmFsdWU7XG4gICAgfVxuICB9O1xuXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbiAgJCQuc3R5Zm4uZ2V0UmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICB2YXIgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB2YXIgcnN0eWxlID0ge307XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBzdHlsZVByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG5cbiAgICAgICAgaWYoIHN0eWxlUHJvcCApe1xuICAgICAgICAgIHZhciB2YWwgPSBzdHlsZVByb3AudW5pdGxlc3MgPyBzdHlsZVByb3Auc3RyVmFsdWUgOiAoc3R5bGVQcm9wLnB4VmFsdWUgKiB6b29tKSArICdweCc7XG4gICAgICAgICAgcnN0eWxlWyBwcm9wLm5hbWUgXSA9IHZhbDtcbiAgICAgICAgICByc3R5bGVbICQkLnV0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpIF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJzdHlsZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0cyB0aGUgcmF3IHN0eWxlIGZvciBhbiBlbGVtZW50XG4gICQkLnN0eWZuLmdldFJhd1N0eWxlID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciByc3R5bGUgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIHN0eWxlUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICAgICAgcnN0eWxlWyBwcm9wLm5hbWUgXSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcbiAgICAgICAgICByc3R5bGVbICQkLnV0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpIF0gPSBzdHlsZVByb3Auc3RyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJzdHlsZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0cyB0aGUgdmFsdWUgc3R5bGUgZm9yIGFuIGVsZW1lbnQgKHVzZWZ1bCBmb3IgdGhpbmdzIGxpa2UgYW5pbWF0aW9ucylcbiAgJCQuc3R5Zm4uZ2V0VmFsdWVTdHlsZSA9IGZ1bmN0aW9uKCBlbGUsIG9wdHMgKXtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciByc3R5bGUgPSBvcHRzLmFycmF5ID8gW10gOiB7fTsgXG4gICAgdmFyIHN0eWxlO1xuXG4gICAgaWYoICQkLmlzLmVsZW1lbnQoZWxlKSApe1xuICAgICAgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7ICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZSA9IGVsZTsgLy8ganVzdCBwYXNzZWQgdGhlIHN0eWxlIGl0c2VsZlxuICAgIH1cblxuICAgIGlmKCBzdHlsZSApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIHN0eWxlUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXSB8fCBzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcblxuICAgICAgICBpZiggc3R5bGVQcm9wICE9PSB1bmRlZmluZWQgJiYgISQkLmlzLnBsYWluT2JqZWN0KCBzdHlsZVByb3AgKSApeyAvLyB0aGVuIG1ha2UgYSBwcm9wIG9mIGl0XG4gICAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIHN0eWxlUHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICAgICAgaWYoIG9wdHMuYXJyYXkgKXtcbiAgICAgICAgICAgIHJzdHlsZS5wdXNoKCBzdHlsZVByb3AgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnN0eWxlWyBwcm9wLm5hbWUgXSA9IHN0eWxlUHJvcDtcbiAgICAgICAgICAgIHJzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHN0eWxlUHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnN0eWxlO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLnN0eWxlLmFwcGx5RnJvbUpzb24gPSBmdW5jdGlvbiggc3R5bGUsIGpzb24gKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjb250ZXh0ID0ganNvbltpXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgICB2YXIgcHJvcHMgPSBjb250ZXh0LmNzcztcblxuICAgICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgICBmb3IoIHZhciBuYW1lIGluIHByb3BzICl7XG4gICAgICAgIHZhciB2YWx1ZSA9IHByb3BzW25hbWVdO1xuXG4gICAgICAgIHN0eWxlLmNzcyggbmFtZSwgdmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLy8gc3RhdGljIGZ1bmN0aW9uXG4gICQkLnN0eWxlLmZyb21Kc29uID0gZnVuY3Rpb24oIGN5LCBqc29uICl7XG4gICAgdmFyIHN0eWxlID0gbmV3ICQkLlN0eWxlKGN5KTtcblxuICAgICQkLnN0eWxlLmFwcGx5RnJvbUpzb24oIHN0eWxlLCBqc29uICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLy8gYWNjZXNzaWJsZSBjeS5zdHlsZSgpIGZ1bmN0aW9uXG4gICQkLnN0eWZuLmZyb21Kc29uID0gZnVuY3Rpb24oIGpzb24gKXtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gICAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcblxuICAgICQkLnN0eWxlLmFwcGx5RnJvbUpzb24oIHN0eWxlLCBqc29uICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgLy8gZ2V0IGpzb24gZnJvbSBjeS5zdHlsZSgpIGFwaVxuICAkJC5zdHlmbi5qc29uID0gZnVuY3Rpb24oKXtcbiAgICB2YXIganNvbiA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IHRoaXMuZGVmYXVsdExlbmd0aDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjeHQgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY3h0LnNlbGVjdG9yO1xuICAgICAgdmFyIHByb3BzID0gY3h0LnByb3BlcnRpZXM7XG4gICAgICB2YXIgY3NzID0ge307XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgY3NzWyBwcm9wLm5hbWUgXSA9IHByb3Auc3RyVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGpzb24ucHVzaCh7XG4gICAgICAgIHNlbGVjdG9yOiAhc2VsZWN0b3IgPyAnY29yZScgOiBzZWxlY3Rvci50b1N0cmluZygpLFxuICAgICAgICBjc3M6IGNzc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuc3R5bGUuYXBwbHlGcm9tU3RyaW5nID0gZnVuY3Rpb24oIHN0eWxlLCBzdHJpbmcgKXtcbiAgICB2YXIgcmVtYWluaW5nID0gJycgKyBzdHJpbmc7XG4gICAgdmFyIHNlbEFuZEJsb2NrU3RyO1xuICAgIHZhciBibG9ja1JlbTtcbiAgICB2YXIgcHJvcEFuZFZhbFN0cjtcblxuICAgIC8vIHJlbW92ZSBjb21tZW50cyBmcm9tIHRoZSBzdHlsZSBzdHJpbmdcbiAgICByZW1haW5pbmcgPSByZW1haW5pbmcucmVwbGFjZSgvWy9dWypdKFxcc3wuKSs/WypdWy9dL2csICcnKTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpe1xuICAgICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgc2VsZWN0b3IgYW5kIGJsb2NrIGZyb20gdGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gICAgICBpZiggcmVtYWluaW5nLmxlbmd0aCA+IHNlbEFuZEJsb2NrU3RyLmxlbmd0aCApe1xuICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKCBzZWxBbmRCbG9ja1N0ci5sZW5ndGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbWFpbmluZyA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCl7XG4gICAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBwcm9wZXJ0eSBhbmQgdmFsdWUgZnJvbSB0aGUgcmVtYWluaW5nIGJsb2NrIHRleHQgdG8gcGFyc2VcbiAgICAgIGlmKCBibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCApe1xuICAgICAgICBibG9ja1JlbSA9IGJsb2NrUmVtLnN1YnN0ciggcHJvcEFuZFZhbFN0ci5sZW5ndGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrUmVtID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKTtcbiAgICAgIGlmKCBub3RoaW5nTGVmdFRvUGFyc2UgKXsgYnJlYWs7IH1cblxuICAgICAgdmFyIHNlbEFuZEJsb2NrID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKigoPzoufFxccykrPylcXHMqXFx7KCg/Oi58XFxzKSs/KVxcfS8pO1xuXG4gICAgICBpZiggIXNlbEFuZEJsb2NrICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0hhbHRpbmcgc3R5bGVzaGVldCBwYXJzaW5nOiBTdHJpbmcgc3R5bGVzaGVldCBjb250YWlucyBtb3JlIHRvIHBhcnNlIGJ1dCBubyBzZWxlY3RvciBhbmQgYmxvY2sgZm91bmQgaW46ICcgKyByZW1haW5pbmcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc2VsQW5kQmxvY2tTdHIgPSBzZWxBbmRCbG9ja1swXTtcblxuICAgICAgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG4gICAgICB2YXIgc2VsZWN0b3JTdHIgPSBzZWxBbmRCbG9ja1sxXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IG5ldyAkJC5TZWxlY3Rvciggc2VsZWN0b3JTdHIgKTtcbiAgICAgIGlmKCBzZWxlY3Rvci5fcHJpdmF0ZS5pbnZhbGlkICYmIHNlbGVjdG9yU3RyICE9PSAnY29yZScgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBzZWxlY3RvciBmb3VuZCBpbiBzdHJpbmcgc3R5bGVzaGVldDogJyArIHNlbGVjdG9yU3RyKTtcblxuICAgICAgICAvLyBza2lwIHRoaXMgc2VsZWN0b3IgYW5kIGJsb2NrXG4gICAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgICBjb250aW51ZTsgXG4gICAgICB9XG5cbiAgICAgIC8vIHBhcnNlIHRoZSBibG9jayBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICAgIHZhciBibG9ja1N0ciA9IHNlbEFuZEJsb2NrWzJdO1xuICAgICAgdmFyIGludmFsaWRCbG9jayA9IGZhbHNlO1xuICAgICAgYmxvY2tSZW0gPSBibG9ja1N0cjtcbiAgICAgIHZhciBwcm9wcyA9IFtdO1xuXG4gICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgdmFyIG5vdGhpbmdMZWZ0VG9QYXJzZSA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiQvKTtcbiAgICAgICAgaWYoIG5vdGhpbmdMZWZ0VG9QYXJzZSApeyBicmVhazsgfVxuXG4gICAgICAgIHZhciBwcm9wQW5kVmFsID0gYmxvY2tSZW0ubWF0Y2goL15cXHMqKC4rPylcXHMqOlxccyooLis/KVxccyo7Lyk7XG5cbiAgICAgICAgaWYoICFwcm9wQW5kVmFsICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignU2tpcHBpbmcgcGFyc2luZyBvZiBibG9jazogSW52YWxpZCBmb3JtYXR0aW5nIG9mIHN0eWxlIHByb3BlcnR5IGFuZCB2YWx1ZSBkZWZpbml0aW9ucyBmb3VuZCBpbjonICsgYmxvY2tTdHIpO1xuICAgICAgICAgIGludmFsaWRCbG9jayA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wQW5kVmFsU3RyID0gcHJvcEFuZFZhbFswXTtcbiAgICAgICAgdmFyIHByb3BTdHIgPSBwcm9wQW5kVmFsWzFdO1xuICAgICAgICB2YXIgdmFsU3RyID0gcHJvcEFuZFZhbFsyXTtcblxuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbIHByb3BTdHIgXTtcbiAgICAgICAgaWYoICFwcm9wICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgbmFtZSBpbjogJyArIHByb3BBbmRWYWxTdHIpO1xuXG4gICAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHN0eWxlLnBhcnNlKCBwcm9wU3RyLCB2YWxTdHIgKTtcblxuICAgICAgICBpZiggIXBhcnNlZFByb3AgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdTa2lwcGluZyBwcm9wZXJ0eTogSW52YWxpZCBwcm9wZXJ0eSBkZWZpbml0aW9uIGluOiAnICsgcHJvcEFuZFZhbFN0cik7XG5cbiAgICAgICAgICAvLyBza2lwIHRoaXMgcHJvcGVydHkgaW4gdGhlIGJsb2NrXG4gICAgICAgICAgcmVtb3ZlUHJvcEFuZFZhbEZyb21SZW0oKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHByb3BTdHIsXG4gICAgICAgICAgdmFsOiB2YWxTdHJcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBpbnZhbGlkQmxvY2sgKXtcbiAgICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBwdXQgdGhlIHBhcnNlZCBibG9jayBpbiB0aGUgc3R5bGVcbiAgICAgIHN0eWxlLnNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICBzdHlsZS5jc3MoIHByb3AubmFtZSwgcHJvcC52YWwgKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlU2VsQW5kQmxvY2tGcm9tUmVtYWluaW5nKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gICQkLnN0eWxlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiggY3ksIHN0cmluZyApe1xuICAgIHZhciBzdHlsZSA9IG5ldyAkJC5TdHlsZShjeSk7XG4gICAgXG4gICAgJCQuc3R5bGUuYXBwbHlGcm9tU3RyaW5nKCBzdHlsZSwgc3RyaW5nICk7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgJCQuc3R5Zm4uZnJvbVN0cmluZyA9IGZ1bmN0aW9uKCBzdHJpbmcgKXtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuXG4gICAgc3R5bGUucmVzZXRUb0RlZmF1bHQoKTtcblxuICAgICQkLnN0eWxlLmFwcGx5RnJvbVN0cmluZyggc3R5bGUsIHN0cmluZyApO1xuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gYSBkdW1teSBzdHlsZXNoZWV0IG9iamVjdCB0aGF0IGRvZXNuJ3QgbmVlZCBhIHJlZmVyZW5jZSB0byB0aGUgY29yZVxuICAvLyAodXNlZnVsIGZvciBpbml0KVxuICAkJC5zdHlsZXNoZWV0ID0gJCQuU3R5bGVzaGVldCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLlN0eWxlc2hlZXQpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLlN0eWxlc2hlZXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgLy8ganVzdCBzdG9yZSB0aGUgc2VsZWN0b3IgdG8gYmUgcGFyc2VkIGxhdGVyXG4gICQkLlN0eWxlc2hlZXQucHJvdG90eXBlLnNlbGVjdG9yID0gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrO1xuXG4gICAgdGhpc1tpXSA9IHtcbiAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGp1c3Qgc3RvcmUgdGhlIHByb3BlcnR5IHRvIGJlIHBhcnNlZCBsYXRlclxuICAkJC5TdHlsZXNoZWV0LnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgIGlmKCAkJC5pcy5zdHJpbmcobmFtZSkgKXtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG5hbWUpICl7XG4gICAgICB2YXIgbWFwID0gbmFtZTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tqXTtcbiAgICAgICAgdmFyIG1hcFZhbCA9IG1hcFsgcHJvcC5uYW1lIF07XG5cbiAgICAgICAgaWYoIG1hcFZhbCA9PT0gdW5kZWZpbmVkICl7IC8vIGFsc28gdHJ5IGNhbWVsIGNhc2UgbmFtZVxuICAgICAgICAgIG1hcFZhbCA9IG1hcFsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBtYXBWYWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG1hcFZhbDtcblxuICAgICAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGdlbmVyYXRlIGEgcmVhbCBzdHlsZSBvYmplY3QgZnJvbSB0aGUgZHVtbXkgc3R5bGVzaGVldFxuICAkJC5TdHlsZXNoZWV0LnByb3RvdHlwZS5nZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24oIGN5ICl7XG4gICAgdmFyIHN0eWxlID0gbmV3ICQkLlN0eWxlKGN5KTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICAgIHZhciBwcm9wcyA9IGNvbnRleHQucHJvcGVydGllcztcblxuICAgICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG5cbiAgICAgICAgc3R5bGUuY3NzKCBwcm9wLm5hbWUsIHByb3AudmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgaXNUb3VjaCA9ICQkLmlzLnRvdWNoKCk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICB9O1xuICBcbiAgdmFyIG9yaWdEZWZhdWx0cyA9ICQkLnV0aWwuY29weSggZGVmYXVsdHMgKTtcblxuICAkJC5kZWZhdWx0cyA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgZGVmYXVsdHMgPSAkJC51dGlsLmV4dGVuZCh7fSwgb3JpZ0RlZmF1bHRzLCBvcHRzKTtcbiAgfTtcblxuICAkJC5mbi5jb3JlID0gZnVuY3Rpb24oIGZuTWFwLCBvcHRpb25zICl7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbbmFtZV07XG4gICAgICAkJC5Db3JlLnByb3RvdHlwZVsgbmFtZSBdID0gZm47XG4gICAgfVxuICB9O1xuICBcbiAgJCQuQ29yZSA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLkNvcmUpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLkNvcmUob3B0cyk7XG4gICAgfVxuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBvcHRzID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRzKTtcblxuICAgIHZhciBjb250YWluZXIgPSBvcHRzLmNvbnRhaW5lcjtcbiAgICB2YXIgcmVnID0gY29udGFpbmVyID8gY29udGFpbmVyLl9jeXJlZyA6IG51bGw7IC8vIGUuZy4gYWxyZWFkeSByZWdpc3RlcmVkIHNvbWUgaW5mbyAoZS5nLiByZWFkaWVzKSB2aWEganF1ZXJ5XG4gICAgcmVnID0gcmVnIHx8IHt9O1xuXG4gICAgaWYoIHJlZyAmJiByZWcuY3kgKXsgXG4gICAgICBpZiggY29udGFpbmVyICl7XG4gICAgICAgIHdoaWxlKCBjb250YWluZXIuZmlyc3RDaGlsZCApeyAvLyBjbGVhbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKCBjb250YWluZXIuZmlyc3RDaGlsZCApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJlZy5jeS5ub3RpZnkoeyB0eXBlOiAnZGVzdHJveScgfSk7IC8vIGRlc3Ryb3kgdGhlIHJlbmRlcmVyXG5cbiAgICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICAgIH1cblxuICAgIHZhciByZWFkaWVzID0gcmVnLnJlYWRpZXMgPSByZWcucmVhZGllcyB8fCBbXTtcbiAgICBcbiAgICBpZiggY29udGFpbmVyICl7IGNvbnRhaW5lci5fY3lyZWcgPSByZWc7IH0gLy8gbWFrZSBzdXJlIGNvbnRhaW5lciBhc3NvYydkIHJlZyBwb2ludHMgdG8gdGhpcyBjeVxuICAgIHJlZy5jeSA9IGN5O1xuXG4gICAgdmFyIGhlYWQgPSB3aW5kb3cgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHM7XG4gICAgb3B0aW9ucy5sYXlvdXQgPSAkJC51dGlsLmV4dGVuZCggeyBuYW1lOiBoZWFkID8gJ2dyaWQnIDogJ251bGwnIH0sIG9wdGlvbnMubGF5b3V0ICk7XG4gICAgb3B0aW9ucy5yZW5kZXJlciA9ICQkLnV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJyB9LCBvcHRpb25zLnJlbmRlcmVyICk7XG4gICAgXG4gICAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uKCBkZWYsIHZhbCwgYWx0VmFsICl7XG4gICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0gZWxzZSBpZiggYWx0VmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIGFsdFZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjb250YWluZXI6IG9wdGlvbnMuY29udGFpbmVyLCAvLyBodG1sIGRvbSBlbGUgY29udGFpbmVyXG4gICAgICByZWFkeTogZmFsc2UsIC8vIHdoZXRoZXIgcmVhZHkgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICBpbml0cmVuZGVyOiBmYWxzZSwgLy8gaGFzIGluaXRyZW5kZXIgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICBvcHRpb25zOiBvcHRpb25zLCAvLyBjYWNoZWQgb3B0aW9uc1xuICAgICAgZWxlbWVudHM6IFtdLCAvLyBhcnJheSBvZiBlbGVtZW50c1xuICAgICAgaWQyaW5kZXg6IHt9LCAvLyBlbGVtZW50IGlkID0+IGluZGV4IGluIGVsZW1lbnRzIGFycmF5XG4gICAgICBsaXN0ZW5lcnM6IFtdLCAvLyBsaXN0IG9mIGxpc3RlbmVyc1xuICAgICAgYW5pRWxlczogJCQuQ29sbGVjdGlvbih0aGlzKSwgLy8gZWxlbWVudHMgYmVpbmcgYW5pbWF0ZWRcbiAgICAgIHNjcmF0Y2g6IHt9LCAvLyBzY3JhdGNoIG9iamVjdCBmb3IgY29yZVxuICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICBub3RpZmljYXRpb25zRW5hYmxlZDogdHJ1ZSwgLy8gd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IHRvIHRoZSByZW5kZXJlclxuICAgICAgbWluWm9vbTogMWUtNTAsXG4gICAgICBtYXhab29tOiAxZTUwLFxuICAgICAgem9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnpvb21pbmdFbmFibGVkKSxcbiAgICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclpvb21pbmdFbmFibGVkKSxcbiAgICAgIHBhbm5pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5wYW5uaW5nRW5hYmxlZCksXG4gICAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJQYW5uaW5nRW5hYmxlZCksXG4gICAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYm94U2VsZWN0aW9uRW5hYmxlZCksXG4gICAgICBhdXRvbG9jazogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMpLFxuICAgICAgYXV0b3VuZ3JhYmlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bmdyYWJpZnksIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeU5vZGVzKSxcbiAgICAgIGF1dG91bnNlbGVjdGlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bnNlbGVjdGlmeSksXG4gICAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgICB6b29tOiAkJC5pcy5udW1iZXIob3B0aW9ucy56b29tKSA/IG9wdGlvbnMuem9vbSA6IDEsXG4gICAgICBwYW46IHtcbiAgICAgICAgeDogJCQuaXMucGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmICQkLmlzLm51bWJlcihvcHRpb25zLnBhbi54KSA/IG9wdGlvbnMucGFuLnggOiAwLFxuICAgICAgICB5OiAkJC5pcy5wbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgJCQuaXMubnVtYmVyKG9wdGlvbnMucGFuLnkpID8gb3B0aW9ucy5wYW4ueSA6IDBcbiAgICAgIH0sXG4gICAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgICBxdWV1ZTogW11cbiAgICAgIH0sXG4gICAgICBoYXNDb21wb3VuZE5vZGVzOiBmYWxzZSxcbiAgICAgIGRlZmVycmVkRXhlY1F1ZXVlOiBbXVxuICAgIH07XG5cbiAgICAvLyBzZXQgc2VsZWN0aW9uIHR5cGVcbiAgICB2YXIgc2VsVHlwZSA9IG9wdGlvbnMuc2VsZWN0aW9uVHlwZTtcbiAgICBpZiggc2VsVHlwZSA9PT0gdW5kZWZpbmVkIHx8IChzZWxUeXBlICE9PSAnYWRkaXRpdmUnICYmIHNlbFR5cGUgIT09ICdzaW5nbGUnKSApe1xuICAgICAgLy8gdGhlbiBzZXQgZGVmYXVsdFxuXG4gICAgICBpZiggaXNUb3VjaCApe1xuICAgICAgICBfcC5zZWxlY3Rpb25UeXBlID0gJ2FkZGl0aXZlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSAnc2luZ2xlJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgX3Auc2VsZWN0aW9uVHlwZSA9IHNlbFR5cGU7XG4gICAgfVxuXG4gICAgLy8gaW5pdCB6b29tIGJvdW5kc1xuICAgIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5taW5ab29tKSAmJiAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhab29tKSAmJiBvcHRpb25zLm1pblpvb20gPCBvcHRpb25zLm1heFpvb20gKXtcbiAgICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgICBfcC5tYXhab29tID0gb3B0aW9ucy5tYXhab29tO1xuICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMubWluWm9vbSkgJiYgb3B0aW9ucy5tYXhab29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgIF9wLm1pblpvb20gPSBvcHRpb25zLm1pblpvb207XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5tYXhab29tKSAmJiBvcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCApe1xuICAgICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgICB9XG5cbiAgICAvLyBpbml0IHN0eWxlXG4gICAgaWYoIF9wLnN0eWxlRW5hYmxlZCApe1xuICAgICAgdGhpcy5zZXRTdHlsZSggb3B0aW9ucy5zdHlsZSApO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSB0aGUgcmVuZGVyZXJcbiAgICBjeS5pbml0UmVuZGVyZXIoICQkLnV0aWwuZXh0ZW5kKHtcbiAgICAgIGhpZGVFZGdlc09uVmlld3BvcnQ6IG9wdGlvbnMuaGlkZUVkZ2VzT25WaWV3cG9ydCxcbiAgICAgIGhpZGVMYWJlbHNPblZpZXdwb3J0OiBvcHRpb25zLmhpZGVMYWJlbHNPblZpZXdwb3J0LFxuICAgICAgdGV4dHVyZU9uVmlld3BvcnQ6IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQsXG4gICAgICB3aGVlbFNlbnNpdGl2aXR5OiAkJC5pcy5udW1iZXIob3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5KSAmJiBvcHRpb25zLndoZWVsU2Vuc2l0aXZpdHkgPiAwID8gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5IDogMSxcbiAgICAgIG1vdGlvbkJsdXI6IG9wdGlvbnMubW90aW9uQmx1cixcbiAgICAgIHBpeGVsUmF0aW86ICQkLmlzLm51bWJlcihvcHRpb25zLnBpeGVsUmF0aW8pICYmIG9wdGlvbnMucGl4ZWxSYXRpbyA+IDAgPyBvcHRpb25zLnBpeGVsUmF0aW8gOiAob3B0aW9ucy5waXhlbFJhdGlvID09PSAnYXV0bycgPyB1bmRlZmluZWQgOiAxKSxcbiAgICAgIHRhcFRocmVzaG9sZDogZGVmVmFsKCAkJC5pcy50b3VjaCgpID8gOCA6IDQsICQkLmlzLnRvdWNoKCkgPyBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkIDogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkIClcbiAgICB9LCBvcHRpb25zLnJlbmRlcmVyKSApO1xuXG4gICAgLy8gdHJpZ2dlciB0aGUgcGFzc2VkIGZ1bmN0aW9uIGZvciB0aGUgYGluaXRyZW5kZXJgIGV2ZW50XG4gICAgaWYoIG9wdGlvbnMuaW5pdHJlbmRlciApe1xuICAgICAgY3kub24oJ2luaXRyZW5kZXInLCBvcHRpb25zLmluaXRyZW5kZXIpO1xuICAgICAgY3kub24oJ2luaXRyZW5kZXInLCBmdW5jdGlvbigpe1xuICAgICAgICBjeS5fcHJpdmF0ZS5pbml0cmVuZGVyID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWwgbG9hZFxuICAgIGN5LmxvYWQob3B0aW9ucy5lbGVtZW50cywgZnVuY3Rpb24oKXsgLy8gb25yZWFkeVxuICAgICAgY3kuc3RhcnRBbmltYXRpb25Mb29wKCk7XG4gICAgICBjeS5fcHJpdmF0ZS5yZWFkeSA9IHRydWU7XG5cbiAgICAgIC8vIGlmIGEgcmVhZHkgY2FsbGJhY2sgaXMgc3BlY2lmaWVkIGFzIGFuIG9wdGlvbiwgdGhlIGJpbmQgaXRcbiAgICAgIGlmKCAkJC5pcy5mbiggb3B0aW9ucy5yZWFkeSApICl7XG4gICAgICAgIGN5Lm9uKCdyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgfVxuXG4gICAgICAvLyBiaW5kIGFsbCB0aGUgcmVhZHkgaGFuZGxlcnMgcmVnaXN0ZXJlZCBiZWZvcmUgY3JlYXRpbmcgdGhpcyBpbnN0YW5jZVxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCByZWFkaWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBmbiA9IHJlYWRpZXNbaV07XG4gICAgICAgIGN5Lm9uKCdyZWFkeScsIGZuKTtcbiAgICAgIH1cbiAgICAgIGlmKCByZWcgKXsgcmVnLnJlYWRpZXMgPSBbXTsgfSAvLyBjbGVhciBiL2Mgd2UndmUgYm91bmQgdGhlbSBhbGwgYW5kIGRvbid0IHdhbnQgdG8ga2VlcCBpdCBhcm91bmQgaW4gY2FzZSBhIG5ldyBjb3JlIHVzZXMgdGhlIHNhbWUgZGl2IGV0Y1xuICAgICAgXG4gICAgICBjeS50cmlnZ2VyKCdyZWFkeScpO1xuICAgIH0sIG9wdGlvbnMuZG9uZSk7XG4gIH07XG5cbiAgJCQuY29yZWZuID0gJCQuQ29yZS5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG4gIFxuXG4gICQkLmZuLmNvcmUoe1xuICAgIGlzUmVhZHk6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZWFkeTtcbiAgICB9LFxuXG4gICAgcmVhZHk6IGZ1bmN0aW9uKCBmbiApe1xuICAgICAgaWYoIHRoaXMuaXNSZWFkeSgpICl7XG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVhZHknLCBbXSwgZm4pOyAvLyBqdXN0IGNhbGxzIGZuIGFzIHRob3VnaCB0cmlnZ2VyZWQgdmlhIHJlYWR5IGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uKCdyZWFkeScsIGZuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5pdHJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmluaXRyZW5kZXI7XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLm5vdGlmeSh7IHR5cGU6ICdkZXN0cm95JyB9KTsgLy8gZGVzdHJveSB0aGUgcmVuZGVyZXJcblxuICAgICAgdmFyIGRvbUVsZSA9IHRoaXMuY29udGFpbmVyKCk7XG4gICAgICB2YXIgcGFyRWxlID0gZG9tRWxlLnBhcmVudE5vZGU7XG4gICAgICBpZiggcGFyRWxlICl7XG4gICAgICAgIHBhckVsZS5yZW1vdmVDaGlsZCggZG9tRWxlICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRFbGVtZW50QnlJZDogZnVuY3Rpb24oIGlkICl7XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9wcml2YXRlLmlkMmluZGV4WyBpZCBdO1xuICAgICAgaWYoIGluZGV4ICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuZWxlbWVudHNbIGluZGV4IF07XG4gICAgICB9XG5cbiAgICAgIC8vIHdvcnN0IGNhc2UsIHJldHVybiBhbiBlbXB0eSBjb2xsZWN0aW9uXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMgKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0aW9uVHlwZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnNlbGVjdGlvblR5cGU7XG4gICAgfSxcblxuICAgIGhhc0NvbXBvdW5kTm9kZXM6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzO1xuICAgIH0sXG5cbiAgICBzdHlsZUVuYWJsZWQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG4gICAgfSxcblxuICAgIGFkZFRvUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgICB2YXIgaWQyaW5kZXggPSB0aGlzLl9wcml2YXRlLmlkMmluZGV4O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbmRleCA9IGlkMmluZGV4WyBpZCBdO1xuICAgICAgICB2YXIgYWxyZWFkeUluUG9vbCA9IGluZGV4ICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYoICFhbHJlYWR5SW5Qb29sICl7XG4gICAgICAgICAgaW5kZXggPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlICk7XG4gICAgICAgICAgaWQyaW5kZXhbIGlkIF0gPSBpbmRleDtcbiAgICAgICAgICBlbGUuX3ByaXZhdGUuaW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgcmVtb3ZlRnJvbVBvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzO1xuICAgICAgdmFyIGlkMmluZGV4ID0gdGhpcy5fcHJpdmF0ZS5pZDJpbmRleDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgaW5kZXggPSBpZDJpbmRleFsgaWQgXTtcbiAgICAgICAgdmFyIGluUG9vbCA9IGluZGV4ICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYoIGluUG9vbCApe1xuICAgICAgICAgIHRoaXMuX3ByaXZhdGUuaWQyaW5kZXhbIGlkIF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgaW5kZXggb2YgYWxsIGVsZW1lbnRzIHBhc3QgdGhpcyBpbmRleFxuICAgICAgICAgIGZvciggdmFyIGogPSBpbmRleDsgaiA8IGVsZW1lbnRzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICB2YXIgamlkID0gZWxlbWVudHNbal0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgICAgIGlkMmluZGV4WyBqaWQgXS0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250YWluZXI6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG4gICAgfSxcblxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gJCQudXRpbC5jb3B5KCB0aGlzLl9wcml2YXRlLm9wdGlvbnMgKTtcbiAgICB9LFxuICAgIFxuICAgIGpzb246IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIFxuICAgICAganNvbi5lbGVtZW50cyA9IHt9O1xuICAgICAgY3kuZWxlbWVudHMoKS5lYWNoKGZ1bmN0aW9uKGksIGVsZSl7XG4gICAgICAgIHZhciBncm91cCA9IGVsZS5ncm91cCgpO1xuICAgICAgICBcbiAgICAgICAgaWYoICFqc29uLmVsZW1lbnRzW2dyb3VwXSApe1xuICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdLnB1c2goIGVsZS5qc29uKCkgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiggdGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQgKXtcbiAgICAgICAganNvbi5zdHlsZSA9IGN5LnN0eWxlKCkuanNvbigpO1xuICAgICAgfVxuXG4gICAgICBqc29uLnpvb21pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJab29taW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24uem9vbSA9IGN5Ll9wcml2YXRlLnpvb207XG4gICAgICBqc29uLm1pblpvb20gPSBjeS5fcHJpdmF0ZS5taW5ab29tO1xuICAgICAganNvbi5tYXhab29tID0gY3kuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICAgIGpzb24ucGFubmluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclBhbm5pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi5wYW4gPSBjeS5fcHJpdmF0ZS5wYW47XG4gICAgICBqc29uLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAganNvbi5sYXlvdXQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dDtcbiAgICAgIGpzb24ucmVuZGVyZXIgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAganNvbi5oaWRlRWRnZXNPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICAgICAganNvbi5oaWRlTGFiZWxzT25WaWV3cG9ydCA9IGN5Ll9wcml2YXRlLm9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQ7XG4gICAgICBqc29uLnRleHR1cmVPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICAgIGpzb24ud2hlZWxTZW5zaXRpdml0eSA9IGN5Ll9wcml2YXRlLm9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgIGpzb24ubW90aW9uQmx1ciA9IGN5Ll9wcml2YXRlLm9wdGlvbnMubW90aW9uQmx1cjtcbiAgICAgIFxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcblxuICAgIC8vIGRlZmVyIGV4ZWN1dGlvbiB1bnRpbCBub3QgYnVzeSBhbmQgZ3VhcmFudGVlIHJlbGF0aXZlIGV4ZWN1dGlvbiBvcmRlciBvZiBkZWZlcnJlZCBmdW5jdGlvbnNcbiAgICBkZWZlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgICB2YXIgcSA9IF9wLmRlZmVycmVkRXhlY1F1ZXVlO1xuXG4gICAgICBxLnB1c2goIGZuICk7XG5cbiAgICAgIGlmKCAhX3AuZGVmZXJyZWRUaW1lb3V0ICl7XG4gICAgICAgIF9wLmRlZmVycmVkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICB3aGlsZSggcS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICAoIHEuc2hpZnQoKSApKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3AuZGVmZXJyZWRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICB9KTsgIFxuICBcbn0pKCBjeXRvc2NhcGUsIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuXG4oZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiByZWFkeShmKSB7XG4gICAgdmFyIGZuID0gKCBkb2N1bWVudCAmJiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSApICA/IGYgOiByZWFkeTtcblxuICAgIHNldFRpbWVvdXQoZm4sIDksIGYpO1xuICB9XG5cbiAgJCQuZm4uY29yZSh7XG4gICAgYWRkOiBmdW5jdGlvbihvcHRzKXtcbiAgICAgIFxuICAgICAgdmFyIGVsZW1lbnRzO1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIFxuICAgICAgLy8gYWRkIHRoZSBlbGVtZW50c1xuICAgICAgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24ob3B0cykgKXtcbiAgICAgICAgdmFyIGVsZXMgPSBvcHRzO1xuXG4gICAgICAgIGlmKCBlbGVzLl9wcml2YXRlLmN5ID09PSBjeSApeyAvLyBzYW1lIGluc3RhbmNlID0+IGp1c3QgcmVzdG9yZVxuICAgICAgICAgIGVsZW1lbnRzID0gZWxlcy5yZXN0b3JlKCk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICAgIGpzb25zLnB1c2goIGVsZS5qc29uKCkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50cyA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwganNvbnMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBzcGVjaWZ5IGFuIGFycmF5IG9mIG9wdGlvbnNcbiAgICAgIGVsc2UgaWYoICQkLmlzLmFycmF5KG9wdHMpICl7XG4gICAgICAgIHZhciBqc29ucyA9IG9wdHM7XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBzcGVjaWZ5IHZpYSBvcHRzLm5vZGVzIGFuZCBvcHRzLmVkZ2VzXG4gICAgICBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdChvcHRzKSAmJiAoJCQuaXMuYXJyYXkob3B0cy5ub2RlcykgfHwgJCQuaXMuYXJyYXkob3B0cy5lZGdlcykpICl7XG4gICAgICAgIHZhciBlbGVzQnlHcm91cCA9IG9wdHM7XG4gICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICAgIGZvciggdmFyIGkgPSAwLCBpbCA9IGdycy5sZW5ndGg7IGkgPCBpbDsgaSsrICl7XG4gICAgICAgICAgdmFyIGdyb3VwID0gZ3JzW2ldO1xuICAgICAgICAgIHZhciBlbGVzQXJyYXkgPSBlbGVzQnlHcm91cFtncm91cF07XG5cbiAgICAgICAgICBpZiggJCQuaXMuYXJyYXkoZWxlc0FycmF5KSApe1xuXG4gICAgICAgICAgICBmb3IoIHZhciBqID0gMCwgamwgPSBlbGVzQXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKyApe1xuICAgICAgICAgICAgICB2YXIganNvbiA9IGVsZXNBcnJheVtqXTtcbiAgICAgICAgICAgICAganNvbi5ncm91cCA9IGdyb3VwO1xuXG4gICAgICAgICAgICAgIGpzb25zLnB1c2goIGpzb24gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IFxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBzcGVjaWZ5IG9wdGlvbnMgZm9yIG9uZSBlbGVtZW50XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGpzb24gPSBvcHRzO1xuICAgICAgICBlbGVtZW50cyA9IChuZXcgJCQuRWxlbWVudCggY3ksIGpzb24gKSkuY29sbGVjdGlvbigpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGNvbGxlY3Rpb24pe1xuICAgICAgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oY29sbGVjdGlvbikgKXtcbiAgICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhjb2xsZWN0aW9uKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBjb2xsZWN0aW9uO1xuICAgICAgICBjb2xsZWN0aW9uID0gdGhpcy4kKCBzZWxlY3RvciApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoKTtcbiAgICB9LFxuICAgIFxuICAgIGxvYWQ6IGZ1bmN0aW9uKGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgXG4gICAgICAvLyByZW1vdmUgb2xkIGVsZW1lbnRzXG4gICAgICB2YXIgb2xkRWxlcyA9IGN5LmVsZW1lbnRzKCk7XG4gICAgICBpZiggb2xkRWxlcy5sZW5ndGggPiAwICl7XG4gICAgICAgIG9sZEVsZXMucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGN5Lm5vdGlmaWNhdGlvbnMoZmFsc2UpO1xuICAgICAgXG4gICAgICBpZiggZWxlbWVudHMgIT0gbnVsbCApe1xuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoZWxlbWVudHMpIHx8ICQkLmlzLmFycmF5KGVsZW1lbnRzKSApe1xuICAgICAgICAgIGN5LmFkZCggZWxlbWVudHMgKTtcbiAgICAgICAgfSBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2soKXsgICAgICAgIFxuICAgICAgICBjeS5vbmUoJ2xheW91dHJlYWR5JywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgY3kubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgICAgICAgICBjeS50cmlnZ2VyKGUpOyAvLyB3ZSBtaXNzZWQgdGhpcyBldmVudCBieSB0dXJuaW5nIG5vdGlmaWNhdGlvbnMgb2ZmLCBzbyBwYXNzIGl0IG9uXG5cbiAgICAgICAgICBjeS5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICAgICAgY29sbGVjdGlvbjogY3kuZWxlbWVudHMoKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY3kub25lKCdsb2FkJywgb25sb2FkKTtcbiAgICAgICAgICBjeS50cmlnZ2VyKCdsb2FkJyk7XG4gICAgICAgIH0pLm9uZSgnbGF5b3V0c3RvcCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgY3kub25lKCdkb25lJywgb25kb25lKTtcbiAgICAgICAgICBjeS50cmlnZ2VyKCdkb25lJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxheW91dE9wdHMgPSAkJC51dGlsLmV4dGVuZCh7fSwgY3kuX3ByaXZhdGUub3B0aW9ucy5sYXlvdXQpO1xuICAgICAgICBsYXlvdXRPcHRzLmVsZXMgPSBjeS4kKCk7XG5cbiAgICAgICAgY3kubGF5b3V0KCBsYXlvdXRPcHRzICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHdpbmRvdyApe1xuICAgICAgICByZWFkeSggY2FsbGJhY2sgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIC8vIHB1bGwgaW4gYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICAgIGFuaW1hdGVkOiAkJC5kZWZpbmUuYW5pbWF0ZWQoKSxcbiAgICBjbGVhclF1ZXVlOiAkJC5kZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICAgIGRlbGF5OiAkJC5kZWZpbmUuZGVsYXkoKSxcbiAgICBhbmltYXRlOiAkJC5kZWZpbmUuYW5pbWF0ZSgpLFxuICAgIHN0b3A6ICQkLmRlZmluZS5zdG9wKCksXG5cbiAgICBhZGRUb0FuaW1hdGlvblBvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcbiAgICAgIFxuICAgICAgY3kuX3ByaXZhdGUuYW5pRWxlcy5tZXJnZSggZWxlcyApO1xuICAgIH0sXG5cbiAgICBzdGFydEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgICAgLy8gZG9uJ3QgZXhlY3V0ZSB0aGUgYW5pbWF0aW9uIGxvb3AgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzXG4gICAgICBpZiggIXdpbmRvdyApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGdsb2JhbEFuaW1hdGlvblN0ZXAoKXtcbiAgICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24obm93KXtcbiAgICAgICAgICBoYW5kbGVFbGVtZW50cyhub3cpO1xuICAgICAgICAgIGdsb2JhbEFuaW1hdGlvblN0ZXAoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGdsb2JhbEFuaW1hdGlvblN0ZXAoKTsgLy8gZmlyc3QgY2FsbFxuICAgICAgXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFbGVtZW50cyhub3cpe1xuICAgICAgICBub3cgPSArbmV3IERhdGUoKTtcblxuICAgICAgICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmFuaUVsZXM7XG4gICAgICAgIHZhciBkb25lRWxlcyA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoIGVsZSwgaXNDb3JlICl7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgICAgdmFyIHF1ZXVlID0gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZTtcbiAgICAgICAgICB2YXIgcmFuQW5pcyA9IGZhbHNlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGlmIG5vdGhpbmcgY3VycmVudGx5IGFuaW1hdGluZywgZ2V0IHNvbWV0aGluZyBmcm9tIHRoZSBxdWV1ZVxuICAgICAgICAgIGlmKCBjdXJyZW50Lmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgdmFyIG5leHQgPSBxdWV1ZS5sZW5ndGggPiAwID8gcXVldWUuc2hpZnQoKSA6IG51bGw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBuZXh0ICl7XG4gICAgICAgICAgICAgIG5leHQuY2FsbFRpbWUgPSBub3c7IC8vIHdhcyBxdWV1ZWQsIHNvIHVwZGF0ZSBjYWxsIHRpbWVcbiAgICAgICAgICAgICAgY3VycmVudC5wdXNoKCBuZXh0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIHN0ZXAgYW5kIHJlbW92ZSBpZiBkb25lXG4gICAgICAgICAgdmFyIGNvbXBsZXRlcyA9IFtdO1xuICAgICAgICAgIGZvcih2YXIgaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICAgICAgdmFyIGFuaSA9IGN1cnJlbnRbaV07XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IGlmIG5lZWQgYmVcbiAgICAgICAgICAgIGlmKCAhYW5pLnN0YXJ0ZWQgKXsgc3RhcnRBbmltYXRpb24oIGVsZSwgYW5pICk7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3RlcCggZWxlLCBhbmksIG5vdywgaXNDb3JlICk7XG5cbiAgICAgICAgICAgIGlmKCBhbmkuZG9uZSApe1xuICAgICAgICAgICAgICBjb21wbGV0ZXMucHVzaCggYW5pICk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyByZW1vdmUgY3VycmVudFtpXVxuICAgICAgICAgICAgICBjdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmFuQW5pcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGNhbGwgY29tcGxldGUgY2FsbGJhY2tzXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wbGV0ZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBhbmkgPSBjb21wbGV0ZXNbaV07XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBhbmkucGFyYW1zLmNvbXBsZXRlO1xuXG4gICAgICAgICAgICBpZiggJCQuaXMuZm4oY29tcGxldGUpICl7XG4gICAgICAgICAgICAgIGNvbXBsZXRlLmFwcGx5KCBlbGUsIFsgbm93IF0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICAgIGRvbmVFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYW5BbmlzO1xuICAgICAgICB9IC8vIGhhbmRsZUVsZW1lbnRzXG5cbiAgICAgICAgLy8gaGFuZGxlIGFsbCBlbGVzXG4gICAgICAgIGZvciggdmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuICAgICAgICAgIFxuICAgICAgICAgIGhhbmRsZUVsZW1lbnQoIGVsZSApO1xuICAgICAgICB9IC8vIGVhY2ggZWxlbWVudFxuXG4gICAgICAgIHZhciByYW5Db3JlQW5pID0gaGFuZGxlRWxlbWVudCggY3ksIHRydWUgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIG5vdGlmeSByZW5kZXJlclxuICAgICAgICBpZiggZWxlcy5sZW5ndGggPiAwIHx8IHJhbkNvcmVBbmkgKXtcbiAgICAgICAgICB2YXIgdG9Ob3RpZnk7XG5cbiAgICAgICAgICBpZiggZWxlcy5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgICB0b05vdGlmeSA9IHVwZGF0ZWRFbGVzLmxlbmd0aCA+IDAgPyBlbGVzLmFkZCggdXBkYXRlZEVsZXMgKSA6IGVsZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kubm90aWZ5KHtcbiAgICAgICAgICAgIHR5cGU6ICdkcmF3JyxcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IHRvTm90aWZ5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcbiAgICAgICAgZWxlcy51bm1lcmdlKCBkb25lRWxlcyApO1xuXG4gICAgICB9IC8vIGhhbmRsZUVsZW1lbnRzXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKCBzZWxmLCBhbmkgKXtcbiAgICAgICAgdmFyIGlzQ29yZSA9ICQkLmlzLmNvcmUoIHNlbGYgKTtcbiAgICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgICAgIHZhciBlbGUgPSBzZWxmO1xuICAgICAgICB2YXIgc3R5bGUgPSBjeS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgICAgeTogcG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBzdGFydFN0eWxlID0gc3R5bGUuZ2V0VmFsdWVTdHlsZSggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXNDb3JlICl7XG4gICAgICAgICAgdmFyIHBhbiA9IGN5Ll9wcml2YXRlLnBhbjtcbiAgICAgICAgICB2YXIgc3RhcnRQYW4gPSB7XG4gICAgICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgICAgIHk6IHBhbi55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBzdGFydFpvb20gPSBjeS5fcHJpdmF0ZS56b29tO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBhbmkuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYW5pLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICBhbmkuc3RhcnRTdHlsZSA9IHN0YXJ0U3R5bGU7XG4gICAgICAgIGFuaS5zdGFydFBhbiA9IHN0YXJ0UGFuO1xuICAgICAgICBhbmkuc3RhcnRab29tID0gc3RhcnRab29tO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwKCBzZWxmLCBhbmltYXRpb24sIG5vdywgaXNDb3JlICl7XG4gICAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGFuaW1hdGlvbi5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgcGFyYW1zID0gYW5pbWF0aW9uLnBhcmFtcztcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IGFuaW1hdGlvbi5zdGFydFRpbWU7XG4gICAgICAgIHZhciBwZXJjZW50O1xuICAgICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBhbmltYXRpb24uZHVyYXRpb24gPT09IDAgKXtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXJjZW50ID0gTWF0aC5taW4oMSwgKG5vdyAtIHN0YXJ0VGltZSkvYW5pbWF0aW9uLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLmRlbGF5ID09IG51bGwgKXsgLy8gdGhlbiB1cGRhdGVcblxuICAgICAgICAgIHZhciBzdGFydFBvcyA9IGFuaW1hdGlvbi5zdGFydFBvc2l0aW9uO1xuICAgICAgICAgIHZhciBlbmRQb3MgPSBwcm9wZXJ0aWVzLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwb3MgPSBzZWxmLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIGlmKCBlbmRQb3MgJiYgaXNFbGVzICl7XG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UG9zLngsIGVuZFBvcy54ICkgKXtcbiAgICAgICAgICAgICAgcG9zLnggPSBlYXNlKCBzdGFydFBvcy54LCBlbmRQb3MueCwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UG9zLnksIGVuZFBvcy55ICkgKXtcbiAgICAgICAgICAgICAgcG9zLnkgPSBlYXNlKCBzdGFydFBvcy55LCBlbmRQb3MueSwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydFBhbiA9IGFuaW1hdGlvbi5zdGFydFBhbjtcbiAgICAgICAgICB2YXIgZW5kUGFuID0gcHJvcGVydGllcy5wYW47XG4gICAgICAgICAgdmFyIHBhbiA9IHNlbGYuX3ByaXZhdGUucGFuO1xuICAgICAgICAgIHZhciBhbmltYXRpbmdQYW4gPSBlbmRQYW4gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiApe1xuICAgICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi54LCBlbmRQYW4ueCApICl7XG4gICAgICAgICAgICAgIHBhbi54ID0gZWFzZSggc3RhcnRQYW4ueCwgZW5kUGFuLngsIHBlcmNlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi55LCBlbmRQYW4ueSApICl7XG4gICAgICAgICAgICAgIHBhbi55ID0gZWFzZSggc3RhcnRQYW4ueSwgZW5kUGFuLnksIHBlcmNlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdwYW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnRab29tID0gYW5pbWF0aW9uLnN0YXJ0Wm9vbTtcbiAgICAgICAgICB2YXIgZW5kWm9vbSA9IHByb3BlcnRpZXMuem9vbTtcbiAgICAgICAgICB2YXIgYW5pbWF0aW5nWm9vbSA9IGVuZFpvb20gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgICAgICAgaWYoIGFuaW1hdGluZ1pvb20gKXtcbiAgICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRab29tLCBlbmRab29tICkgKXtcbiAgICAgICAgICAgICAgc2VsZi5fcHJpdmF0ZS56b29tID0gZWFzZSggc3RhcnRab29tLCBlbmRab29tLCBwZXJjZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignem9vbScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhbmltYXRpbmdQYW4gfHwgYW5pbWF0aW5nWm9vbSApe1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3cG9ydCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBwcm9wZXJ0aWVzLmNzcyAmJiBpc0VsZXMgKXtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHByb3BlcnRpZXMuY3NzO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gcHJvcHNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGVuZCA9IHByb3A7XG5cbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYW5pbWF0aW9uLnN0YXJ0U3R5bGVbIG5hbWUgXTtcbiAgICAgICAgICAgICAgdmFyIGVhc2VkVmFsID0gZWFzZSggc3RhcnQsIGVuZCwgcGVyY2VudCApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc3R5bGUub3ZlcnJpZGVCeXBhc3MoIHNlbGYsIG5hbWUsIGVhc2VkVmFsICk7XG4gICAgICAgICAgICB9IC8vIGZvciBwcm9wc1xuICAgICAgICAgIH0gLy8gaWYgXG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoICQkLmlzLmZuKHBhcmFtcy5zdGVwKSApe1xuICAgICAgICAgIHBhcmFtcy5zdGVwLmFwcGx5KCBzZWxmLCBbIG5vdyBdICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCBwZXJjZW50ID49IDEgKXtcbiAgICAgICAgICBhbmltYXRpb24uZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBwZXJjZW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiB2YWxpZChzdGFydCwgZW5kKXtcbiAgICAgICAgaWYoIHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCAkJC5pcy5udW1iZXIoc3RhcnQpICYmICQkLmlzLm51bWJlcihlbmQpICl7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiggKHN0YXJ0KSAmJiAoZW5kKSApe1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGVhc2Uoc3RhcnRQcm9wLCBlbmRQcm9wLCBwZXJjZW50KXtcbiAgICAgICAgaWYoIHBlcmNlbnQgPCAwICl7XG4gICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiggcGVyY2VudCA+IDEgKXtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydCwgZW5kO1xuXG4gICAgICAgIGlmKCBzdGFydFByb3AucHhWYWx1ZSAhPSBudWxsIHx8IHN0YXJ0UHJvcC52YWx1ZSAhPSBudWxsICl7XG4gICAgICAgICAgc3RhcnQgPSBzdGFydFByb3AucHhWYWx1ZSAhPSBudWxsID8gc3RhcnRQcm9wLnB4VmFsdWUgOiBzdGFydFByb3AudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnQgPSBzdGFydFByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZW5kUHJvcC5weFZhbHVlICE9IG51bGwgfHwgZW5kUHJvcC52YWx1ZSAhPSBudWxsICl7XG4gICAgICAgICAgZW5kID0gZW5kUHJvcC5weFZhbHVlICE9IG51bGwgPyBlbmRQcm9wLnB4VmFsdWUgOiBlbmRQcm9wLnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZCA9IGVuZFByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggJCQuaXMubnVtYmVyKHN0YXJ0KSAmJiAkJC5pcy5udW1iZXIoZW5kKSApe1xuICAgICAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBwZXJjZW50O1xuXG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKHN0YXJ0WzBdKSAmJiAkJC5pcy5udW1iZXIoZW5kWzBdKSApeyAvLyB0aGVuIGFzc3VtZSBhIGNvbG91clxuICAgICAgICAgIHZhciBjMSA9IHN0YXJ0O1xuICAgICAgICAgIHZhciBjMiA9IGVuZDtcblxuICAgICAgICAgIHZhciBjaCA9IGZ1bmN0aW9uKGNoMSwgY2gyKXtcbiAgICAgICAgICAgIHZhciBkaWZmID0gY2gyIC0gY2gxO1xuICAgICAgICAgICAgdmFyIG1pbiA9IGNoMTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKCBwZXJjZW50ICogZGlmZiArIG1pbiApO1xuICAgICAgICAgIH07XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIHIgPSBjaCggYzFbMF0sIGMyWzBdICk7XG4gICAgICAgICAgdmFyIGcgPSBjaCggYzFbMV0sIGMyWzFdICk7XG4gICAgICAgICAgdmFyIGIgPSBjaCggYzFbMl0sIGMyWzJdICk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgICBcbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cblxuICBcbiAgICBcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBkYXRhOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gICAgfSksXG5cbiAgICByZW1vdmVEYXRhOiAkJC5kZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgZXZlbnQ6ICdkYXRhJyxcbiAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgIHRyaWdnZXJFdmVudDogdHJ1ZVxuICAgIH0pLFxuXG4gICAgc2NyYXRjaDogJCQuZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIGFsbG93QmluZGluZzogZmFsc2UsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nVHJpZ2dlcnNFdmVudDogZmFsc2UsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgICB9KSxcblxuICAgIHJlbW92ZVNjcmF0Y2g6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IGZhbHNlXG4gICAgfSlcbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmNvcmUoe1xuICAgIG9uOiAkJC5kZWZpbmUub24oKSwgLy8gLm9uKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGRhdGFdLCBoYW5kbGVyKVxuICAgIG9uZTogJCQuZGVmaW5lLm9uKHsgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9KSxcbiAgICBvbmNlOiAkJC5kZWZpbmUub24oeyB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0pLFxuICAgIG9mZjogJCQuZGVmaW5lLm9mZigpLCAvLyAub2ZmKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGhhbmRsZXJdIClcbiAgICB0cmlnZ2VyOiAkJC5kZWZpbmUudHJpZ2dlcigpIC8vIC50cmlnZ2VyKCBldmVudHMgWywgZXh0cmFQYXJhbXNdIClcbiAgfSk7XG5cbiAgLy8gYWxpYXNlcyBmb3IgdGhvc2UgZm9sa3Mgd2hvIGxpa2Ugb2xkIHN0dWZmOlxuICAkJC5jb3JlZm4uYmluZCA9ICQkLmNvcmVmbi5vbjtcbiAgJCQuY29yZWZuLnVuYmluZCA9ICQkLmNvcmVmbi5vZmY7XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIHBuZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgcmV0dXJuIHJlbmRlcmVyLnBuZyggb3B0aW9ucyApOyAgICAgIFxuICAgIH1cbiAgICBcbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIGxheW91dDogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgdmFyIGxheW91dCA9IHRoaXMuX3ByaXZhdGUucHJldkxheW91dCA9ICggcGFyYW1zID09IG51bGwgPyB0aGlzLl9wcml2YXRlLnByZXZMYXlvdXQgOiB0aGlzLmluaXRMYXlvdXQoIHBhcmFtcyApICk7XG5cbiAgICAgIGxheW91dC5ydW4oKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHJldHVybiB0aGlzLmluaXRMYXlvdXQoIHBhcmFtcyApO1xuICAgIH0sXG4gICAgXG4gICAgaW5pdExheW91dDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIGlmKCBvcHRpb25zID09IG51bGwgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBvcHRpb25zLm5hbWUgPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdBIGBuYW1lYCBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICB2YXIgTGF5b3V0UHJvdG8gPSAkJC5leHRlbnNpb24oJ2xheW91dCcsIG5hbWUpO1xuICAgICAgXG4gICAgICBpZiggTGF5b3V0UHJvdG8gPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGFwcGx5IGxheW91dDogTm8gc3VjaCBsYXlvdXQgYCcgKyBuYW1lICsgJ2AgZm91bmQ7IGRpZCB5b3UgaW5jbHVkZSBpdHMgSlMgZmlsZT8nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmVsZXMgPSBvcHRpb25zLmVsZXMgIT0gbnVsbCA/IG9wdGlvbnMuZWxlcyA6IHRoaXMuJCgpO1xuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKCBvcHRpb25zLmVsZXMgKSApe1xuICAgICAgICBvcHRpb25zLmVsZXMgPSB0aGlzLiQoIG9wdGlvbnMuZWxlcyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgbGF5b3V0ID0gbmV3IExheW91dFByb3RvKCAkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBjeTogdGhpc1xuICAgICAgfSkgKTtcblxuICAgICAgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG4gICAgICBpZiggISQkLmlzLnBsYWluT2JqZWN0KGxheW91dC5fcHJpdmF0ZSkgKXtcbiAgICAgICAgbGF5b3V0Ll9wcml2YXRlID0ge307XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5fcHJpdmF0ZS5jeSA9IHRoaXM7XG4gICAgICBsYXlvdXQuX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgICBcbiAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfVxuICAgIFxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG4oZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBub3RpZnk6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIGlmKCB0aGlzLl9wcml2YXRlLmJhdGNoaW5nTm90aWZ5ICl7XG4gICAgICAgIHZhciBiRWxlcyA9IHRoaXMuX3ByaXZhdGUuYmF0Y2hOb3RpZnlFbGVzO1xuICAgICAgICB2YXIgYlR5cGVzID0gdGhpcy5fcHJpdmF0ZS5iYXRjaE5vdGlmeVR5cGVzO1xuXG4gICAgICAgIGlmKCBwYXJhbXMuY29sbGVjdGlvbiApeyBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmFtcy5jb2xsZWN0aW9uLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHBhcmFtcy5jb2xsZWN0aW9uW2ldO1xuXG4gICAgICAgICAgaWYoICFiRWxlcy5pZHNbIGVsZS5fcHJpdmF0ZS5pZCBdICl7XG4gICAgICAgICAgICBiRWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfVxuXG4gICAgICAgIGlmKCAhYlR5cGVzLmlkc1sgcGFyYW1zLnR5cGUgXSApe1xuICAgICAgICAgIGJUeXBlcy5wdXNoKCBwYXJhbXMudHlwZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuOyAvLyBub3RpZmljYXRpb25zIGFyZSBkaXNhYmxlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICAgIH1cblxuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLm5vdGlmaWNhdGlvbnNFbmFibGVkICl7IHJldHVybjsgfSAvLyBleGl0IG9uIGRpc2FibGVkXG5cbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIoKTtcbiAgICAgIFxuICAgICAgcmVuZGVyZXIubm90aWZ5KHBhcmFtcyk7XG4gICAgfSxcbiAgICBcbiAgICBub3RpZmljYXRpb25zOiBmdW5jdGlvbiggYm9vbCApe1xuICAgICAgdmFyIHAgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgXG4gICAgICBpZiggYm9vbCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiBwLm5vdGlmaWNhdGlvbnNFbmFibGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcC5ub3RpZmljYXRpb25zRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBub05vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCBjYWxsYmFjayApe1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zKGZhbHNlKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB0aGlzLm5vdGlmaWNhdGlvbnModHJ1ZSk7XG4gICAgfSxcblxuICAgIHN0YXJ0QmF0Y2g6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBfcC5iYXRjaGluZ1N0eWxlID0gX3AuYmF0Y2hpbmdOb3RpZnkgPSB0cnVlO1xuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMgPSBbXTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5RWxlcyA9IFtdO1xuICAgICAgX3AuYmF0Y2hOb3RpZnlUeXBlcyA9IFtdO1xuXG4gICAgICBfcC5iYXRjaFN0eWxlRWxlcy5pZHMgPSB7fTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5RWxlcy5pZHMgPSB7fTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMuaWRzID0ge307XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBlbmRCYXRjaDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG5cbiAgICAgIC8vIHVwZGF0ZSBzdHlsZSBmb3IgZGlydHkgZWxlc1xuICAgICAgX3AuYmF0Y2hpbmdTdHlsZSA9IGZhbHNlO1xuICAgICAgbmV3ICQkLkNvbGxlY3Rpb24odGhpcywgX3AuYmF0Y2hTdHlsZUVsZXMpLnVwZGF0ZVN0eWxlKCk7XG5cbiAgICAgIC8vIG5vdGlmeSB0aGUgcmVuZGVyZXIgb2YgcXVldWVkIGVsZXMgYW5kIGV2ZW50IHR5cGVzXG4gICAgICBfcC5iYXRjaGluZ05vdGlmeSA9IGZhbHNlO1xuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiBfcC5iYXRjaE5vdGlmeVR5cGVzLFxuICAgICAgICBjb2xsZWN0aW9uOiBfcC5iYXRjaE5vdGlmeUVsZXNcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYmF0Y2g6IGZ1bmN0aW9uKCBjYWxsYmFjayApe1xuICAgICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgdGhpcy5lbmRCYXRjaCgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgYmF0Y2hEYXRhOiBmdW5jdGlvbiggbWFwICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5iYXRjaChmdW5jdGlvbigpe1xuICAgICAgICBmb3IoIHZhciBpZCBpbiBtYXAgKXtcbiAgICAgICAgICB2YXIgZGF0YSA9IG1hcFtpZF07XG4gICAgICAgICAgdmFyIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuICAgICAgICAgIFxuICAgICAgICAgIGVsZS5kYXRhKCBkYXRhICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG4gICAgXG4gICAgcmVuZGVyVG86IGZ1bmN0aW9uKCBjb250ZXh0LCB6b29tLCBwYW4sIHB4UmF0aW8gKXtcbiAgICAgIHZhciByID0gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcblxuICAgICAgci5yZW5kZXJUbyggY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvICk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVuZGVyZXI6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5yZW5kZXJlcjtcbiAgICB9LFxuXG4gICAgZm9yY2VSZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdkcmF3J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6ICdyZXNpemUnXG4gICAgICB9KTtcblxuICAgICAgdGhpcy50cmlnZ2VyKCdyZXNpemUnKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBcbiAgICBpbml0UmVuZGVyZXI6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICB2YXIgUmVuZGVyZXJQcm90byA9ICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCBvcHRpb25zLm5hbWUpO1xuICAgICAgaWYoIFJlbmRlcmVyUHJvdG8gPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGluaXRpYWxpc2U6IE5vIHN1Y2ggcmVuZGVyZXIgYCVzYCBmb3VuZDsgZGlkIHlvdSBpbmNsdWRlIGl0cyBKUyBmaWxlPycsIG9wdGlvbnMubmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdGhpcy5fcHJpdmF0ZS5yZW5kZXJlciA9IG5ldyBSZW5kZXJlclByb3RvKFxuICAgICAgICAkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICBzdHlsZTogY3kuX3ByaXZhdGUuc3R5bGVcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICAgXG4gICAgfVxuICAgIFxuICB9KTsgIFxuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcblxuICAgIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgICAvLyAtIGVtcHR5IGNvbGxlY3Rpb24gb24gbm8gYXJnc1xuICAgIC8vIC0gY29sbGVjdGlvbiBvZiBlbGVtZW50cyBpbiB0aGUgZ3JhcGggb24gc2VsZWN0b3IgYXJnXG4gICAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgICBjb2xsZWN0aW9uOiBmdW5jdGlvbiggZWxlcyApe1xuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKCBlbGVzICkgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuJCggZWxlcyApO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIGVsZXMgKSApe1xuICAgICAgICByZXR1cm4gZWxlcy5jb2xsZWN0aW9uKCk7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuYXJyYXkoIGVsZXMgKSApe1xuICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMsIGVsZXMgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzICk7XG4gICAgfSxcbiAgICBcbiAgICBub2RlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLiQoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNOb2RlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9IFxuXG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfSxcbiAgICBcbiAgICBlZGdlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLiQoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9LFxuICAgICAgXG4gICAgLy8gc2VhcmNoIHRoZSBncmFwaCBsaWtlIGpRdWVyeVxuICAgICQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcywgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cyApO1xuXG4gICAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgICAgcmV0dXJuIGVsZXMuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlcztcbiAgICB9XG4gICAgXG4gIH0pOyAgXG5cbiAgLy8gYWxpYXNlc1xuICAkJC5jb3JlZm4uZWxlbWVudHMgPSAkJC5jb3JlZm4uZmlsdGVyID0gJCQuY29yZWZuLiQ7ICBcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBcbiAgICBzdHlsZTogZnVuY3Rpb24oIG5ld1N0eWxlICl7XG4gICAgICBpZiggbmV3U3R5bGUgKXtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNldFN0eWxlKCBuZXdTdHlsZSApO1xuXG4gICAgICAgIHMudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlO1xuICAgIH0sXG5cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oIHN0eWxlICl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiggJCQuaXMuc3R5bGVzaGVldChzdHlsZSkgKXtcbiAgICAgICAgX3Auc3R5bGUgPSBzdHlsZS5nZW5lcmF0ZVN0eWxlKHRoaXMpO1xuICAgICAgXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmFycmF5KHN0eWxlKSApIHtcbiAgICAgICAgX3Auc3R5bGUgPSAkJC5zdHlsZS5mcm9tSnNvbih0aGlzLCBzdHlsZSk7XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKHN0eWxlKSApe1xuICAgICAgICBfcC5zdHlsZSA9ICQkLnN0eWxlLmZyb21TdHJpbmcodGhpcywgc3R5bGUpO1xuICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcC5zdHlsZSA9IG5ldyAkJC5TdHlsZSggdGhpcyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Auc3R5bGU7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuXG4gICAgYXV0b2xvY2s6IGZ1bmN0aW9uKGJvb2wpe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLmF1dG9sb2NrID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG9sb2NrO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgYXV0b3VuZ3JhYmlmeTogZnVuY3Rpb24oYm9vbCl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbihib29sKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgcGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICB6b29taW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgcGFuOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICAgIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgICAgIGNhc2UgMDogLy8gLnBhbigpXG4gICAgICAgIHJldHVybiBwYW47XG5cbiAgICAgIGNhc2UgMTogXG5cbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyggYXJnc1swXSApICl7IC8vIC5wYW4oJ3gnKVxuICAgICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgICAgcmV0dXJuIHBhblsgZGltIF07XG5cbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdCggYXJnc1swXSApICkgeyAvLyAucGFuKHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKHgpICl7XG4gICAgICAgICAgICBwYW4ueCA9IHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICQkLmlzLm51bWJlcih5KSApe1xuICAgICAgICAgICAgcGFuLnkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjogLy8gLnBhbigneCcsIDEwMClcbiAgICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICB2YWwgPSBhcmdzWzFdO1xuXG4gICAgICAgIGlmKCAoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmICQkLmlzLm51bWJlcih2YWwpICl7XG4gICAgICAgICAgcGFuW2RpbV0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgcGFuQnk6IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gICAgICBjYXNlIDE6IFxuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdCggYXJnc1swXSApICkgeyAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKHgpICl7XG4gICAgICAgICAgICBwYW4ueCArPSB4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoeSkgKXtcbiAgICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOiAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgICAgaWYoIChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgJCQuaXMubnVtYmVyKHZhbCkgKXtcbiAgICAgICAgICBwYW5bZGltXSArPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgZml0OiBmdW5jdGlvbiggZWxlbWVudHMsIHBhZGRpbmcgKXtcbiAgICAgIHZhciB2aWV3cG9ydFN0YXRlID0gdGhpcy5nZXRGaXRWaWV3cG9ydCggZWxlbWVudHMsIHBhZGRpbmcgKTtcblxuICAgICAgaWYoIHZpZXdwb3J0U3RhdGUgKXtcbiAgICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgICAgX3Auem9vbSA9IHZpZXdwb3J0U3RhdGUuem9vbTtcbiAgICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gem9vbSB2aWV3cG9ydCcpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIGdldEZpdFZpZXdwb3J0OiBmdW5jdGlvbiggZWxlbWVudHMsIHBhZGRpbmcgKXtcbiAgICAgIGlmKCAkJC5pcy5udW1iZXIoZWxlbWVudHMpICYmIHBhZGRpbmcgPT09IHVuZGVmaW5lZCApeyAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgICBwYWRkaW5nID0gZWxlbWVudHM7XG4gICAgICAgIGVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmI7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcoZWxlbWVudHMpICl7XG4gICAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLiQoIHNlbCApO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmJvdW5kaW5nQm94KGVsZW1lbnRzKSApeyAvLyBhc3N1bWUgYmJcbiAgICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgICBiYiA9IHtcbiAgICAgICAgICB4MTogYmJlLngxLFxuICAgICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgICAgeDI6IGJiZS54MixcbiAgICAgICAgICB5MjogYmJlLnkyXG4gICAgICAgIH07XG5cbiAgICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuXG4gICAgICB9IGVsc2UgaWYoICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSApe1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgYmIgPSBiYiB8fCBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgIHZhciB6b29tO1xuICAgICAgcGFkZGluZyA9ICQkLmlzLm51bWJlcihwYWRkaW5nKSA/IHBhZGRpbmcgOiAwO1xuXG4gICAgICBpZiggIWlzTmFOKHcpICYmICFpc05hTihoKSAmJiB3ID4gMCAmJiBoID4gMCAmJiAhaXNOYU4oYmIudykgJiYgIWlzTmFOKGJiLmgpICYmICBiYi53ID4gMCAmJiBiYi5oID4gMCApe1xuICAgICAgICB6b29tID0gTWF0aC5taW4oICh3IC0gMipwYWRkaW5nKS9iYi53LCAoaCAtIDIqcGFkZGluZykvYmIuaCApO1xuXG4gICAgICAgIC8vIGNyb3Agem9vbVxuICAgICAgICB6b29tID0gem9vbSA+IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA/IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA6IHpvb207XG4gICAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgICAgICB2YXIgcGFuID0geyAvLyBub3cgcGFuIHRvIG1pZGRsZVxuICAgICAgICAgIHg6ICh3IC0gem9vbSooIGJiLngxICsgYmIueDIgKSkvMixcbiAgICAgICAgICB5OiAoaCAtIHpvb20qKCBiYi55MSArIGJiLnkyICkpLzJcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHpvb206IHpvb20sIFxuICAgICAgICAgIHBhbjogcGFuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIFxuICAgIG1pblpvb206IGZ1bmN0aW9uKCB6b29tICl7XG4gICAgICBpZiggem9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcih6b29tKSApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLm1pblpvb20gPSB6b29tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbWF4Wm9vbTogZnVuY3Rpb24oIHpvb20gKXtcbiAgICAgIGlmKCB6b29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKHpvb20pICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA9IHpvb207XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB6b29tOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuICAgICAgdmFyIHpvb207XG5cbiAgICAgIGlmKCBwYXJhbXMgPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIGdldCB0aGUgem9vbVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29tO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihwYXJhbXMpICl7IC8vIHRoZW4gc2V0IHRoZSB6b29tXG4gICAgICAgIHpvb20gPSBwYXJhbXM7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3QocGFyYW1zKSApeyAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuXG4gICAgICAgIGlmKCBwYXJhbXMucG9zaXRpb24gKXtcbiAgICAgICAgICB2YXIgcCA9IHBhcmFtcy5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICAgICAgdmFyIHogPSB0aGlzLl9wcml2YXRlLnpvb207XG5cbiAgICAgICAgICBwb3MgPSB7IC8vIGNvbnZlcnQgdG8gcmVuZGVyZWQgcHhcbiAgICAgICAgICAgIHg6IHAueCAqIHogKyBwYW4ueCxcbiAgICAgICAgICAgIHk6IHAueSAqIHogKyBwYW4ueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiggcGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gKXtcbiAgICAgICAgICBwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwb3MgJiYgIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgICByZXR1cm4gdGhpczsgLy8gcGFubmluZyBkaXNhYmxlZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gem9vbWluZyBkaXNhYmxlZFxuICAgICAgfVxuXG4gICAgICBpZiggISQkLmlzLm51bWJlcih6b29tKSB8fCAoIHBvcyAmJiAoISQkLmlzLm51bWJlcihwb3MueCkgfHwgISQkLmlzLm51bWJlcihwb3MueSkpICkgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuICAgICAgfVxuXG4gICAgICAvLyBjcm9wIHpvb21cbiAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgICAgaWYoIHBvcyApeyAvLyBzZXQgem9vbSBhYm91dCBwb3NpdGlvblxuICAgICAgICB2YXIgcGFuMSA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgICB2YXIgem9vbTEgPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgICAgIHZhciB6b29tMiA9IHpvb207XG4gICAgICAgIFxuICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICB4OiAtem9vbTIvem9vbTEgKiAocG9zLnggLSBwYW4xLngpICsgcG9zLngsXG4gICAgICAgICAgeTogLXpvb20yL3pvb20xICogKHBvcy55IC0gcGFuMS55KSArIHBvcy55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fcHJpdmF0ZS56b29tID0gem9vbTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW4yO1xuXG4gICAgICAgIHZhciBwb3NDaGFuZ2VkID0gcGFuMS54ICE9PSBwYW4yLnggfHwgcGFuMS55ICE9PSBwYW4yLnk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignIHpvb20gJyArIChwb3NDaGFuZ2VkID8gJyBwYW4gJyA6ICcnKSArICcgdmlld3BvcnQgJyApO1xuICAgICAgXG4gICAgICB9IGVsc2UgeyAvLyBqdXN0IHNldCB0aGUgem9vbVxuICAgICAgICB0aGlzLl9wcml2YXRlLnpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3pvb20gdmlld3BvcnQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICB2aWV3cG9ydDogZnVuY3Rpb24oIG9wdHMgKXsgXG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICAgIHZhciBwYW5EZWZkID0gdHJ1ZTtcbiAgICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuICAgICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICAgIHZhciBwYW5GYWlsZWQgPSBmYWxzZTtcblxuICAgICAgaWYoICFvcHRzICl7IHJldHVybiB0aGlzOyB9XG4gICAgICBpZiggISQkLmlzLm51bWJlcihvcHRzLnpvb20pICl7IHpvb21EZWZkID0gZmFsc2U7IH1cbiAgICAgIGlmKCAhJCQuaXMucGxhaW5PYmplY3Qob3B0cy5wYW4pICl7IHBhbkRlZmQgPSBmYWxzZTsgfVxuICAgICAgaWYoICF6b29tRGVmZCAmJiAhcGFuRGVmZCApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBpZiggem9vbURlZmQgKXtcbiAgICAgICAgdmFyIHogPSBvcHRzLnpvb207XG5cbiAgICAgICAgaWYoIHogPCBfcC5taW5ab29tIHx8IHogPiBfcC5tYXhab29tIHx8ICFfcC56b29taW5nRW5hYmxlZCApe1xuICAgICAgICAgIHpvb21GYWlsZWQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Auem9vbSA9IHo7XG5cbiAgICAgICAgICBldmVudHMucHVzaCgnem9vbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBwYW5EZWZkICYmICghem9vbUZhaWxlZCB8fCAhb3B0cy5jYW5jZWxPbkZhaWxlZFpvb20pICYmIF9wLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgIHZhciBwID0gb3B0cy5wYW47XG5cbiAgICAgICAgaWYoICQkLmlzLm51bWJlcihwLngpICl7XG4gICAgICAgICAgX3AucGFuLnggPSBwLng7XG4gICAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggJCQuaXMubnVtYmVyKHAueSkgKXtcbiAgICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhcGFuRmFpbGVkICl7XG4gICAgICAgICAgZXZlbnRzLnB1c2goJ3BhbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBldmVudHMubGVuZ3RoID4gMCApe1xuICAgICAgICBldmVudHMucHVzaCgndmlld3BvcnQnKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCBldmVudHMuam9pbignICcpICk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgY2VudGVyOiBmdW5jdGlvbiggZWxlbWVudHMgKXtcbiAgICAgIHZhciBwYW4gPSB0aGlzLmdldENlbnRlclBhbiggZWxlbWVudHMgKTtcblxuICAgICAgaWYoIHBhbiApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIGdldENlbnRlclBhbjogZnVuY3Rpb24oIGVsZW1lbnRzLCB6b29tICl7XG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKGVsZW1lbnRzKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCBzZWxlY3RvciApO1xuICAgICAgfSBlbHNlIGlmKCAhJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykgKXtcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYiA9IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9wcml2YXRlLnpvb20gOiB6b29tO1xuXG4gICAgICB2YXIgcGFuID0geyAvLyBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tKiggYmIueDEgKyBiYi54MiApKS8yLFxuICAgICAgICB5OiAoaCAtIHpvb20qKCBiYi55MSArIGJiLnkyICkpLzJcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJldHVybiBwYW47XG4gICAgfSxcbiAgICBcbiAgICByZXNldDogZnVuY3Rpb24oKXtcbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3cG9ydCh7XG4gICAgICAgIHBhbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIHpvb206IDFcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgd2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG5cbiAgICAgIGlmKCBjb250YWluZXIgKXtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7IC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgfSxcblxuICAgIGhlaWdodDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcblxuICAgICAgaWYoIGNvbnRhaW5lciApe1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7IC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgfSxcblxuICAgIGV4dGVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciB6b29tID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgICAgdmFyIHJiID0gdGhpcy5yZW5kZXJlZEV4dGVudCgpO1xuXG4gICAgICB2YXIgYiA9IHtcbiAgICAgICAgeDE6ICggcmIueDEgLSBwYW4ueCApL3pvb20sXG4gICAgICAgIHgyOiAoIHJiLngyIC0gcGFuLnggKS96b29tLFxuICAgICAgICB5MTogKCByYi55MSAtIHBhbi55ICkvem9vbSxcbiAgICAgICAgeTI6ICggcmIueTIgLSBwYW4ueSApL3pvb20sXG4gICAgICB9O1xuXG4gICAgICBiLncgPSBiLngyIC0gYi54MTtcbiAgICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuXG4gICAgICByZXR1cm4gYjtcbiAgICB9LFxuXG4gICAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IDAsXG4gICAgICAgIHkxOiAwLFxuICAgICAgICB4Mjogd2lkdGgsXG4gICAgICAgIHkyOiBoZWlnaHQsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gICQkLmNvcmVmbi5jZW50cmUgPSAkJC5jb3JlZm4uY2VudGVyO1xuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICQkLmNvcmVmbi5hdXRvbG9ja05vZGVzID0gJCQuY29yZWZuLmF1dG9sb2NrO1xuICAkJC5jb3JlZm4uYXV0b3VuZ3JhYmlmeU5vZGVzID0gJCQuY29yZWZuLmF1dG91bmdyYWJpZnk7XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIFVzZSB0aGlzIGludGVyZmFjZSB0byBkZWZpbmUgZnVuY3Rpb25zIGZvciBjb2xsZWN0aW9ucy9lbGVtZW50cy5cbiAgLy8gVGhpcyBpbnRlcmZhY2UgaXMgZ29vZCwgYmVjYXVzZSBpdCBmb3JjZXMgeW91IHRvIHRoaW5rIGluIHRlcm1zXG4gIC8vIG9mIHRoZSBjb2xsZWN0aW9ucyBjYXNlIChtb3JlIHRoYW4gMSBlbGVtZW50KSwgc28gd2UgZG9uJ3QgbmVlZFxuICAvLyBub3RpZmljYXRpb24gYmxvY2tpbmcgbm9uc2Vuc2UgZXZlcnl3aGVyZS5cbiAgLy9cbiAgLy8gT3RoZXIgY29sbGVjdGlvbi0qLmpzIGZpbGVzIGRlcGVuZCBvbiB0aGlzIGJlaW5nIGRlZmluZWQgZmlyc3QuXG4gIC8vIEl0J3MgYSB0cmFkZSBvZmY6IEl0IHNpbXBsaWZpZXMgdGhlIGNvZGUgZm9yIENvbGxlY3Rpb24gYW5kIFxuICAvLyBFbGVtZW50IGludGVncmF0aW9uIHNvIG11Y2ggdGhhdCBpdCdzIHdvcnRoIGl0IHRvIGNyZWF0ZSB0aGVcbiAgLy8gSlMgZGVwZW5kZW5jeS5cbiAgLy9cbiAgLy8gSGF2aW5nIHRoaXMgaW50ZWdyYXRpb24gZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiBjYWxsIGFueVxuICAvLyBjb2xsZWN0aW9uIGZ1bmN0aW9uIG9uIGFuIGVsZW1lbnQgYW5kIHZpY2UgdmVyc2EuXG5cbiAgLy8gZS5nLiAkJC5mbi5jb2xsZWN0aW9uKHsgc29tZUZ1bmM6IGZ1bmN0aW9uKCl7IC8qIC4uLiAqLyB9IH0pXG4gICQkLmZuLmNvbGxlY3Rpb24gPSAkJC5mbi5lbGVzID0gZnVuY3Rpb24oIGZuTWFwLCBvcHRpb25zICl7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbbmFtZV07XG5cbiAgICAgICQkLkNvbGxlY3Rpb24ucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBmYWN0b3J5IGZvciBnZW5lcmF0aW5nIGVkZ2UgaWRzIHdoZW4gbm8gaWQgaXMgc3BlY2lmaWVkIGZvciBhIG5ldyBlbGVtZW50XG4gIHZhciBpZEZhY3RvcnkgPSB7XG4gICAgcHJlZml4OiB7XG4gICAgICBub2RlczogJ24nLFxuICAgICAgZWRnZXM6ICdlJ1xuICAgIH0sXG4gICAgaWQ6IHtcbiAgICAgIG5vZGVzOiAwLFxuICAgICAgZWRnZXM6IDBcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihjeSwgZWxlbWVudCwgdHJ5VGhpc0lkKXtcbiAgICAgIHZhciBqc29uID0gJCQuaXMuZWxlbWVudCggZWxlbWVudCApID8gZWxlbWVudC5fcHJpdmF0ZSA6IGVsZW1lbnQ7XG4gICAgICB2YXIgZ3JvdXAgPSBqc29uLmdyb3VwO1xuICAgICAgdmFyIGlkID0gdHJ5VGhpc0lkICE9IG51bGwgPyB0cnlUaGlzSWQgOiB0aGlzLnByZWZpeFtncm91cF0gKyB0aGlzLmlkW2dyb3VwXTtcbiAgICAgIFxuICAgICAgaWYoIGN5LmdldEVsZW1lbnRCeUlkKGlkKS5lbXB0eSgpICl7XG4gICAgICAgIHRoaXMuaWRbZ3JvdXBdKys7IC8vIHdlJ3ZlIHVzZWQgdGhlIGN1cnJlbnQgaWQsIHNvIG1vdmUgaXQgdXBcbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBrZWVwIHRyeWluZyBzdWNjZXNzaXZlIHVudXNlZCBpZHNcbiAgICAgICAgd2hpbGUoICFjeS5nZXRFbGVtZW50QnlJZChpZCkuZW1wdHkoKSApe1xuICAgICAgICAgIGlkID0gdGhpcy5wcmVmaXhbZ3JvdXBdICsgKCArK3RoaXMuaWRbZ3JvdXBdICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIEVsZW1lbnRcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgLy8gcmVwcmVzZW50cyBhIG5vZGUgb3IgYW4gZWRnZVxuICAkJC5FbGVtZW50ID0gZnVuY3Rpb24oY3ksIHBhcmFtcywgcmVzdG9yZSl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLkVsZW1lbnQpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLkVsZW1lbnQoY3ksIHBhcmFtcywgcmVzdG9yZSk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJlc3RvcmUgPSAocmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgPyB0cnVlIDogZmFsc2UpO1xuICAgIFxuICAgIGlmKCBjeSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICEkJC5pcy5jb3JlKGN5KSApe1xuICAgICAgJCQudXRpbC5lcnJvcignQW4gZWxlbWVudCBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVycyBzZXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gdmFsaWRhdGUgZ3JvdXBcbiAgICBpZiggcGFyYW1zLmdyb3VwICE9PSAnbm9kZXMnICYmIHBhcmFtcy5ncm91cCAhPT0gJ2VkZ2VzJyApe1xuICAgICAgJCQudXRpbC5lcnJvcignQW4gZWxlbWVudCBtdXN0IGJlIG9mIHR5cGUgYG5vZGVzYCBvciBgZWRnZXNgOyB5b3Ugc3BlY2lmaWVkIGAnICsgcGFyYW1zLmdyb3VwICsgJ2AnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gbWFrZSB0aGUgZWxlbWVudCBhcnJheS1saWtlLCBqdXN0IGxpa2UgYSBjb2xsZWN0aW9uXG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIHRoaXNbMF0gPSB0aGlzO1xuICAgIFxuICAgIC8vIE5PVEU6IHdoZW4gc29tZXRoaW5nIGlzIGFkZGVkIGhlcmUsIGFkZCBhbHNvIHRvIGVsZS5qc29uKClcbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY3k6IGN5LFxuICAgICAgc2luZ2xlOiB0cnVlLCAvLyBpbmRpY2F0ZXMgdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgICBkYXRhOiBwYXJhbXMuZGF0YSB8fCB7fSwgLy8gZGF0YSBvYmplY3RcbiAgICAgIGxheW91dERhdGE6IHt9LCAvLyBwbGFjZSBmb3IgbGF5b3V0cyB0byBwdXQgY2FsY3VsYXRlZCBzdGF0cyBldGMgZm9yIG1hcHBlcnNcbiAgICAgIHBvc2l0aW9uOiBwYXJhbXMucG9zaXRpb24gfHwge30sIC8vICh4LCB5KSBwb3NpdGlvbiBwYWlyXG4gICAgICBhdXRvV2lkdGg6IHVuZGVmaW5lZCwgLy8gd2lkdGggYW5kIGhlaWdodCBvZiBub2RlcyBjYWxjdWxhdGVkIGJ5IHRoZSByZW5kZXJlciB3aGVuIHNldCB0byBzcGVjaWFsICdhdXRvJyB2YWx1ZVxuICAgICAgYXV0b0hlaWdodDogdW5kZWZpbmVkLCBcbiAgICAgIGxpc3RlbmVyczogW10sIC8vIGFycmF5IG9mIGJvdW5kIGxpc3RlbmVyc1xuICAgICAgZ3JvdXA6IHBhcmFtcy5ncm91cCwgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICAgIHN0eWxlOiB7fSwgLy8gcHJvcGVydGllcyBhcyBzZXQgYnkgdGhlIHN0eWxlXG4gICAgICByc3R5bGU6IHt9LCAvLyBwcm9wZXJ0aWVzIGZvciBzdHlsZSBzZW50IGZyb20gdGhlIHJlbmRlcmVyIHRvIHRoZSBjb3JlXG4gICAgICBzdHlsZUN4dHM6IFtdLCAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgICAgcmVtb3ZlZDogdHJ1ZSwgLy8gd2hldGhlciBpdCdzIGluc2lkZSB0aGUgdmlzOyB0cnVlIGlmIHJlbW92ZWQgKHNldCB0cnVlIGhlcmUgc2luY2Ugd2UgY2FsbCByZXN0b3JlKVxuICAgICAgc2VsZWN0ZWQ6IHBhcmFtcy5zZWxlY3RlZCA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGVkXG4gICAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICggcGFyYW1zLnNlbGVjdGFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICAgIGxvY2tlZDogcGFyYW1zLmxvY2tlZCA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBsb2NrZWQgKGNhbm5vdCBiZSBtb3ZlZClcbiAgICAgIGdyYWJiZWQ6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGdyYWJiZWQgYnkgdGhlIG1vdXNlOyByZW5kZXJlciBzZXRzIHRoaXMgcHJpdmF0ZWx5XG4gICAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAoIHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgICAgYWN0aXZlOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBhY3RpdmUgZnJvbSB1c2VyIGludGVyYWN0aW9uXG4gICAgICBjbGFzc2VzOiB7fSwgLy8gbWFwICggY2xhc3NOYW1lID0+IHRydWUgKVxuICAgICAgYW5pbWF0aW9uOiB7IC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgICBjdXJyZW50OiBbXSxcbiAgICAgICAgcXVldWU6IFtdXG4gICAgICB9LFxuICAgICAgcnNjcmF0Y2g6IHt9LCAvLyBvYmplY3QgaW4gd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiBzdG9yZSBpbmZvcm1hdGlvblxuICAgICAgc2NyYXRjaDoge30sIC8vIHNjcmF0Y2ggb2JqZWN0c1xuICAgICAgZWRnZXM6IFtdLCAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICAgIGNoaWxkcmVuOiBbXSAvLyBhcnJheSBvZiBjaGlsZHJlblxuICAgIH07XG4gICAgXG4gICAgLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG4gICAgaWYoIHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICl7XG4gICAgICB2YXIgcnBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgIHg6IChycG9zLnggLSBwYW4ueCkvem9vbSxcbiAgICAgICAgeTogKHJwb3MueSAtIHBhbi55KS96b29tXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBpZiggJCQuaXMuc3RyaW5nKHBhcmFtcy5jbGFzc2VzKSApe1xuICAgICAgdmFyIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgICAgaWYoICFjbHMgfHwgY2xzID09PSAnJyApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHNlbGYuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggcGFyYW1zLmNzcyApe1xuICAgICAgY3kuc3R5bGUoKS5hcHBseUJ5cGFzcyggdGhpcywgcGFyYW1zLmNzcyApO1xuICAgIH1cbiAgICBcbiAgICBpZiggcmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgKXtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICBcbiAgfTtcblxuICBcbiAgLy8gQ29sbGVjdGlvblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAvLyByZXByZXNlbnRzIGEgc2V0IG9mIG5vZGVzLCBlZGdlcywgb3IgYm90aCB0b2dldGhlclxuICAkJC5Db2xsZWN0aW9uID0gZnVuY3Rpb24oY3ksIGVsZW1lbnRzLCBvcHRpb25zKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuQ29sbGVjdGlvbikgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpO1xuICAgIH1cblxuICAgIGlmKCBjeSA9PT0gdW5kZWZpbmVkIHx8ICEkJC5pcy5jb3JlKGN5KSApe1xuICAgICAgJCQudXRpbC5lcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWRzID0ge307XG4gICAgdmFyIGluZGV4ZXMgPSB7fTtcbiAgICB2YXIgY3JlYXRlZEVsZW1lbnRzID0gZmFsc2U7XG4gICAgXG4gICAgaWYoICFlbGVtZW50cyApe1xuICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICB9IGVsc2UgaWYoIGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgJCQuaXMucGxhaW5PYmplY3QoIGVsZW1lbnRzWzBdICkgJiYgISQkLmlzLmVsZW1lbnQoIGVsZW1lbnRzWzBdICkgKXtcbiAgICAgIGNyZWF0ZWRFbGVtZW50cyA9IHRydWU7XG5cbiAgICAgIC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG4gICAgICB2YXIgZWxlcyA9IFtdO1xuICAgICAgdmFyIGVsZXNJZHMgPSB7fTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1tpXTtcblxuICAgICAgICBpZigganNvbi5kYXRhID09IG51bGwgKXtcbiAgICAgICAgICBqc29uLmRhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGRhdGEgPSBqc29uLmRhdGE7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcbiAgICAgICAgaWYoIGRhdGEuaWQgPT0gbnVsbCApe1xuICAgICAgICAgIGRhdGEuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoIGN5LCBqc29uICk7XG4gICAgICAgIH0gZWxzZSBpZiggY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuaWQgKS5sZW5ndGggIT09IDAgfHwgZWxlc0lkc1sgZGF0YS5pZCBdICl7XG4gICAgICAgICAgY29udGludWU7IC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIHByaW9yIGlkIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlID0gbmV3ICQkLkVsZW1lbnQoIGN5LCBqc29uLCBmYWxzZSApO1xuICAgICAgICBlbGVzLnB1c2goIGVsZSApO1xuICAgICAgICBlbGVzSWRzWyBkYXRhLmlkIF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50cyA9IGVsZXM7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYoICFlbGVtZW50ICl7ICBjb250aW51ZTsgfVxuICAgICAgXG4gICAgICB2YXIgaWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICBcbiAgICAgIGlmKCAhb3B0aW9ucyB8fCAob3B0aW9ucy51bmlxdWUgJiYgIWlkc1sgaWQgXSApICl7XG4gICAgICAgIGlkc1sgaWQgXSA9IGVsZW1lbnQ7XG4gICAgICAgIGluZGV4ZXNbIGlkIF0gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICB0aGlzWyB0aGlzLmxlbmd0aCBdID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGlkczogaWRzLFxuICAgICAgaW5kZXhlczogaW5kZXhlc1xuICAgIH07XG5cbiAgICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gICAgaWYoIGNyZWF0ZWRFbGVtZW50cyApe1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICB9O1xuICBcbiAgXG4gIC8vIEZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAvLyBrZWVwIHRoZSBwcm90b3R5cGVzIGluIHN5bmMgKGFuIGVsZW1lbnQgaGFzIHRoZSBzYW1lIGZ1bmN0aW9ucyBhcyBhIGNvbGxlY3Rpb24pXG4gIC8vIGFuZCB1c2UgJCQuZWxlZm4gYW5kICQkLmVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG4gICQkLmVsZWZuID0gJCQuZWxlc2ZuID0gJCQuRWxlbWVudC5wcm90b3R5cGUgPSAkJC5Db2xsZWN0aW9uLnByb3RvdHlwZTtcblxuICAkJC5lbGVzZm4uY3kgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xuICB9O1xuICBcbiAgJCQuZWxlc2ZuLmVsZW1lbnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzWzBdO1xuICB9O1xuICBcbiAgJCQuZWxlc2ZuLmNvbGxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgIGlmKCAkJC5pcy5jb2xsZWN0aW9uKHRoaXMpICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgeyAvLyBhbiBlbGVtZW50XG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIFt0aGlzXSApO1xuICAgIH1cbiAgfTtcblxuICAkJC5lbGVzZm4udW5pcXVlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHRoaXMsIHsgdW5pcXVlOiB0cnVlIH0gKTtcbiAgfTtcblxuICAkJC5lbGVzZm4uZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiggaWQgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlbGUgPSB0aGlzLl9wcml2YXRlLmlkc1sgaWQgXTtcblxuICAgIHJldHVybiBlbGUgPyBlbGUgOiAkJC5Db2xsZWN0aW9uKGN5KTsgLy8gZ2V0IGVsZSBvciBlbXB0eSBjb2xsZWN0aW9uXG4gIH07XG5cbiAgJCQuZWxlc2ZuLmpzb24gPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzLmVsZW1lbnQoKTtcbiAgICBpZiggZWxlID09IG51bGwgKXsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gICAgdmFyIHAgPSBlbGUuX3ByaXZhdGU7XG4gICAgXG4gICAgdmFyIGpzb24gPSAkJC51dGlsLmNvcHkoe1xuICAgICAgZGF0YTogcC5kYXRhLFxuICAgICAgcG9zaXRpb246IHAucG9zaXRpb24sXG4gICAgICBncm91cDogcC5ncm91cCxcbiAgICAgIGJ5cGFzczogcC5ieXBhc3MsXG4gICAgICByZW1vdmVkOiBwLnJlbW92ZWQsXG4gICAgICBzZWxlY3RlZDogcC5zZWxlY3RlZCxcbiAgICAgIHNlbGVjdGFibGU6IHAuc2VsZWN0YWJsZSxcbiAgICAgIGxvY2tlZDogcC5sb2NrZWQsXG4gICAgICBncmFiYmVkOiBwLmdyYWJiZWQsXG4gICAgICBncmFiYmFibGU6IHAuZ3JhYmJhYmxlLFxuICAgICAgY2xhc3NlczogJydcbiAgICB9KTtcbiAgICBcbiAgICB2YXIgY2xhc3NlcyA9IFtdO1xuICAgIGZvciggdmFyIGNscyBpbiBwLmNsYXNzZXMgKXtcbiAgICAgIGlmKCBwLmNsYXNzZXNbY2xzXSApe1xuICAgICAgICBjbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgIGpzb24uY2xhc3NlcyArPSBjbHMgKyAoIGkgPCBjbGFzc2VzLmxlbmd0aCAtIDEgPyAnICcgOiAnJyApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ganNvbjtcbiAgfTtcblxuICAkJC5lbGVzZm4uanNvbnMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcblxuICAgICAganNvbnMucHVzaCgganNvbiApO1xuICAgIH1cblxuICAgIHJldHVybiBqc29ucztcbiAgfTtcblxuICAkJC5lbGVzZm4uY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgZWxlc0FyciA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyAkJC5FbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgICAgZWxlc0Fyci5wdXNoKCBjbG9uZSApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZXNBcnIgKTtcbiAgfTtcblxuICAkJC5lbGVzZm4ucmVzdG9yZSA9IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVzdG9yZWQgPSBbXTtcbiAgICB2YXIgY3kgPSBzZWxmLmN5KCk7XG4gICAgXG4gICAgaWYoIG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgKXtcbiAgICAgIG5vdGlmeVJlbmRlcmVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcywgc2luY2Ugd2UgbmVlZCB0b1xuICAgIC8vIHJlc3RvcmUgdGhlIG5vZGVzIGZpcnN0XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIG5vZGVzID0gW10sIGVkZ2VzID0gW107XG4gICAgdmFyIG51bU5vZGVzID0gMDtcbiAgICB2YXIgbnVtRWRnZXMgPSAwO1xuICAgIGZvciggdmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuICAgICAgXG4gICAgICAvLyBrZWVwIG5vZGVzIGZpcnN0IGluIHRoZSBhcnJheSBhbmQgZWRnZXMgYWZ0ZXJcbiAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXsgLy8gcHV0IHRvIGZyb250IG9mIGFycmF5IGlmIG5vZGVcbiAgICAgICAgbm9kZXMucHVzaCggZWxlICk7XG4gICAgICAgIG51bU5vZGVzKys7XG4gICAgICB9IGVsc2UgeyAvLyBwdXQgdG8gZW5kIG9mIGFycmF5IGlmIGVkZ2VcbiAgICAgICAgZWRnZXMucHVzaCggZWxlICk7XG4gICAgICAgIG51bUVkZ2VzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudHMgPSBub2Rlcy5jb25jYXQoIGVkZ2VzICk7XG5cbiAgICAvLyBub3csIHJlc3RvcmUgZWFjaCBlbGVtZW50XG4gICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVtZW50c1tpXTtcblxuICAgICAgaWYoICFlbGUucmVtb3ZlZCgpICl7XG4gICAgICAgIC8vIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBfcHJpdmF0ZSA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBkYXRhID0gX3ByaXZhdGUuZGF0YTtcbiAgICAgIFxuICAgICAgLy8gc2V0IGlkIGFuZCB2YWxpZGF0ZVxuICAgICAgaWYoIGRhdGEuaWQgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICBkYXRhLmlkID0gaWRGYWN0b3J5LmdlbmVyYXRlKCBjeSwgZWxlICk7XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGRhdGEuaWQpIHx8ICEkJC5pcy5zdHJpbmcoZGF0YS5pZCkgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgZWxlbWVudCB3aXRoIGludmFsaWQgc3RyaW5nIElEIGAnICsgZGF0YS5pZCArICdgJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBpdCBoYXMgZW1wdHkgc3RyaW5nIGFzIGlkIG9yIG5vbi1zdHJpbmcgaWRcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYoIGN5LmdldEVsZW1lbnRCeUlkKCBkYXRhLmlkICkubGVuZ3RoICE9PSAwICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIHNlY29uZCBlbGVtZW50IHdpdGggSUQgYCcgKyBkYXRhLmlkICsgJ2AnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIG9uZSBhbHJlYWR5IGhhcyB0aGF0IGlkXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWQgPSBkYXRhLmlkOyAvLyBpZCBpcyBmaW5hbGlzZWQsIG5vdyBsZXQncyBrZWVwIGEgcmVmXG4gICAgICBcbiAgICAgIGlmKCBlbGUuaXNFZGdlKCkgKXsgLy8gZXh0cmEgY2hlY2tzIGZvciBlZGdlc1xuICAgICAgICBcbiAgICAgICAgdmFyIGVkZ2UgPSBlbGU7XG4gICAgICAgIHZhciBmaWVsZHMgPSBbJ3NvdXJjZScsICd0YXJnZXQnXTtcbiAgICAgICAgdmFyIGZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG4gICAgICAgIHZhciBiYWRTb3VyY2VPclRhcmdldCA9IGZhbHNlO1xuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgZmllbGRzTGVuZ3RoOyBqKyspe1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tqXTtcbiAgICAgICAgICB2YXIgdmFsID0gZGF0YVtmaWVsZF07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gJycgKXtcbiAgICAgICAgICAgIC8vIGNhbid0IGNyZWF0ZSBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGlzIG5vdCBkZWZpbmVkIHByb3Blcmx5XG4gICAgICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIHVuc3BlY2lmaWVkICcgKyBmaWVsZCk7XG4gICAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmKCBjeS5nZXRFbGVtZW50QnlJZCh2YWwpLmVtcHR5KCkgKXsgXG4gICAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWRnZSBpZiBvbmUgb2YgaXRzIG5vZGVzIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVkZ2UgYCcgKyBpZCArICdgIHdpdGggbm9uZXhpc3RhbnQgJyArIGZpZWxkICsgJyBgJyArIHZhbCArICdgJyk7XG4gICAgICAgICAgICBiYWRTb3VyY2VPclRhcmdldCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGJhZFNvdXJjZU9yVGFyZ2V0ICl7IGNvbnRpbnVlOyB9IC8vIGNhbid0IGNyZWF0ZSB0aGlzXG4gICAgICAgIFxuICAgICAgICB2YXIgc3JjID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuc291cmNlICk7XG4gICAgICAgIHZhciB0Z3QgPSBjeS5nZXRFbGVtZW50QnlJZCggZGF0YS50YXJnZXQgKTtcblxuICAgICAgICBzcmMuX3ByaXZhdGUuZWRnZXMucHVzaCggZWRnZSApO1xuICAgICAgICB0Z3QuX3ByaXZhdGUuZWRnZXMucHVzaCggZWRnZSApO1xuXG4gICAgICAgIGVkZ2UuX3ByaXZhdGUuc291cmNlID0gc3JjO1xuICAgICAgICBlZGdlLl9wcml2YXRlLnRhcmdldCA9IHRndDtcblxuICAgICAgfSAvLyBpZiBpcyBlZGdlXG4gICAgICAgXG4gICAgICAvLyBjcmVhdGUgbW9jayBpZHMgbWFwIGZvciBlbGVtZW50IHNvIGl0IGNhbiBiZSB1c2VkIGxpa2UgY29sbGVjdGlvbnNcbiAgICAgIF9wcml2YXRlLmlkcyA9IHt9O1xuICAgICAgX3ByaXZhdGUuaWRzWyBpZCBdID0gZWxlO1xuXG4gICAgICBfcHJpdmF0ZS5yZW1vdmVkID0gZmFsc2U7XG4gICAgICBjeS5hZGRUb1Bvb2woIGVsZSApO1xuICAgICAgXG4gICAgICByZXN0b3JlZC5wdXNoKCBlbGUgKTtcbiAgICB9IC8vIGZvciBlYWNoIGVsZW1lbnRcblxuICAgIC8vIGRvIGNvbXBvdW5kIG5vZGUgc2FuaXR5IGNoZWNrc1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKyApeyAvLyBlYWNoIG5vZGUgXG4gICAgICB2YXIgbm9kZSA9IGVsZW1lbnRzW2ldO1xuICAgICAgdmFyIGRhdGEgPSBub2RlLl9wcml2YXRlLmRhdGE7XG5cbiAgICAgIHZhciBwYXJlbnRJZCA9IG5vZGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQ7XG4gICAgICB2YXIgc3BlY2lmaWVkUGFyZW50ID0gcGFyZW50SWQgIT0gbnVsbDtcblxuICAgICAgaWYoIHNwZWNpZmllZFBhcmVudCApe1xuICAgICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHBhcmVudElkICk7XG5cbiAgICAgICAgaWYoIHBhcmVudC5lbXB0eSgpICl7XG4gICAgICAgICAgLy8gbm9uLWV4aXN0YW50IHBhcmVudDsganVzdCByZW1vdmUgaXRcbiAgICAgICAgICBkYXRhLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2VsZkFzUGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGFuY2VzdG9yID0gcGFyZW50O1xuICAgICAgICAgIHdoaWxlKCAhYW5jZXN0b3IuZW1wdHkoKSApe1xuICAgICAgICAgICAgaWYoIG5vZGUuc2FtZShhbmNlc3RvcikgKXtcbiAgICAgICAgICAgICAgLy8gbWFyayBzZWxmIGFzIHBhcmVudCBhbmQgcmVtb3ZlIGZyb20gZGF0YVxuICAgICAgICAgICAgICBzZWxmQXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICBkYXRhLnBhcmVudCA9IHVuZGVmaW5lZDsgLy8gcmVtb3ZlIHBhcmVudCByZWZlcmVuY2VcblxuICAgICAgICAgICAgICAvLyBleGl0IG9yIHdlIGxvb3AgZm9yZXZlclxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIXNlbGZBc1BhcmVudCApe1xuICAgICAgICAgICAgLy8gY29ubmVjdCB3aXRoIGNoaWxkcmVuXG4gICAgICAgICAgICBwYXJlbnRbMF0uX3ByaXZhdGUuY2hpbGRyZW4ucHVzaCggbm9kZSApO1xuICAgICAgICAgICAgbm9kZS5fcHJpdmF0ZS5wYXJlbnQgPSBwYXJlbnRbMF07XG5cbiAgICAgICAgICAgIC8vIGxldCB0aGUgY29yZSBrbm93IHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaFxuICAgICAgICAgICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGVsc2VcbiAgICAgIH0gLy8gaWYgc3BlY2lmaWVkIHBhcmVudFxuICAgIH0gLy8gZm9yIGVhY2ggbm9kZVxuICAgIFxuICAgIHJlc3RvcmVkID0gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCByZXN0b3JlZCApO1xuICAgIGlmKCByZXN0b3JlZC5sZW5ndGggPiAwICl7XG5cbiAgICAgIHZhciB0b1VwZGF0ZVN0eWxlID0gcmVzdG9yZWQuYWRkKCByZXN0b3JlZC5jb25uZWN0ZWROb2RlcygpICkuYWRkKCByZXN0b3JlZC5wYXJlbnQoKSApO1xuICAgICAgdG9VcGRhdGVTdHlsZS51cGRhdGVTdHlsZSggbm90aWZ5UmVuZGVyZXIgKTtcblxuICAgICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICAgIHJlc3RvcmVkLnJ0cmlnZ2VyKCdhZGQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3RvcmVkLnRyaWdnZXIoJ2FkZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc2VsZjsgLy8gY2hhaW5hYmlsaXR5XG4gIH07XG4gIFxuICAkJC5lbGVzZm4ucmVtb3ZlZCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAmJiBlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbiAgfTtcblxuICAkJC5lbGVzZm4uaW5zaWRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICByZXR1cm4gZWxlICYmICFlbGUuX3ByaXZhdGUucmVtb3ZlZDtcbiAgfTtcblxuICAkJC5lbGVzZm4ucmVtb3ZlID0gZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZW1vdmVkID0gW107XG4gICAgdmFyIGVsZXNUb1JlbW92ZSA9IFtdO1xuICAgIHZhciBlbGVzVG9SZW1vdmVJZHMgPSB7fTtcbiAgICB2YXIgY3kgPSBzZWxmLl9wcml2YXRlLmN5O1xuICAgIFxuICAgIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBub3RpZnlSZW5kZXJlciA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIGFkZCBjb25uZWN0ZWQgZWRnZXNcbiAgICBmdW5jdGlvbiBhZGRDb25uZWN0ZWRFZGdlcyhub2RlKXtcbiAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7IFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBhZGQoIGVkZ2VzW2ldICk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuXG4gICAgLy8gYWRkIGRlc2NlbmRhbnQgbm9kZXNcbiAgICBmdW5jdGlvbiBhZGRDaGlsZHJlbihub2RlKXtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuX3ByaXZhdGUuY2hpbGRyZW47XG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgYWRkKCBjaGlsZHJlbltpXSApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZCggZWxlICl7XG4gICAgICB2YXIgYWxyZWFkeUFkZGVkID0gIGVsZXNUb1JlbW92ZUlkc1sgZWxlLmlkKCkgXTtcbiAgICAgIGlmKCBhbHJlYWR5QWRkZWQgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlc1RvUmVtb3ZlSWRzWyBlbGUuaWQoKSBdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIGVsZS5pc05vZGUoKSApe1xuICAgICAgICBlbGVzVG9SZW1vdmUucHVzaCggZWxlICk7IC8vIG5vZGVzIGFyZSByZW1vdmVkIGxhc3RcblxuICAgICAgICBhZGRDb25uZWN0ZWRFZGdlcyggZWxlICk7XG4gICAgICAgIGFkZENoaWxkcmVuKCBlbGUgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZXNUb1JlbW92ZS51bnNoaWZ0KCBlbGUgKTsgLy8gZWRnZXMgYXJlIHJlbW92ZWQgZmlyc3RcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWtlIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICAgIC8vIChtYXkgYmUgcmVtb3ZpbmcgbW9yZSB0aGFuIHNwZWNpZmllZCBkdWUgdG8gY29ubmVjdGVkIGVkZ2VzIGV0YylcblxuICAgIGZvciggdmFyIGkgPSAwLCBsID0gc2VsZi5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuXG4gICAgICBhZGQoIGVsZSApO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiByZW1vdmVFZGdlUmVmKG5vZGUsIGVkZ2Upe1xuICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tqXTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBlZGdlID09PSBjb25uZWN0ZWRFZGdlICl7XG4gICAgICAgICAgY29ubmVjdGVkRWRnZXMuc3BsaWNlKCBqLCAxICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVDaGlsZFJlZihwYXJlbnQsIGVsZSl7XG4gICAgICBlbGUgPSBlbGVbMF07XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX3ByaXZhdGUuY2hpbGRyZW47XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgaWYoIGNoaWxkcmVuW2pdWzBdID09PSBlbGVbMF0gKXtcbiAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNUb1JlbW92ZVtpXTtcblxuICAgICAgLy8gbWFyayBhcyByZW1vdmVkXG4gICAgICBlbGUuX3ByaXZhdGUucmVtb3ZlZCA9IHRydWU7XG5cbiAgICAgIC8vIHJlbW92ZSBmcm9tIGNvcmUgcG9vbFxuICAgICAgY3kucmVtb3ZlRnJvbVBvb2woIGVsZSApO1xuXG4gICAgICAvLyBhZGQgdG8gbGlzdCBvZiByZW1vdmVkIGVsZW1lbnRzXG4gICAgICByZW1vdmVkLnB1c2goIGVsZSApO1xuXG4gICAgICBpZiggZWxlLmlzRWRnZSgpICl7IC8vIHJlbW92ZSByZWZlcmVuY2VzIHRvIHRoaXMgZWRnZSBpbiBpdHMgY29ubmVjdGVkIG5vZGVzXG4gICAgICAgIHZhciBzcmMgPSBlbGUuc291cmNlKClbMF07XG4gICAgICAgIHZhciB0Z3QgPSBlbGUudGFyZ2V0KClbMF07XG5cbiAgICAgICAgcmVtb3ZlRWRnZVJlZiggc3JjLCBlbGUgKTtcbiAgICAgICAgcmVtb3ZlRWRnZVJlZiggdGd0LCBlbGUgKTtcblxuICAgICAgfSBlbHNlIHsgLy8gcmVtb3ZlIHJlZmVyZW5jZSB0byBwYXJlbnQgXG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGUucGFyZW50KCk7XG5cbiAgICAgICAgaWYoIHBhcmVudC5sZW5ndGggIT09IDAgKXtcbiAgICAgICAgICByZW1vdmVDaGlsZFJlZihwYXJlbnQsIGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIGNvbXBvdW5kIGdyYXBoIG9yIG5vdFxuICAgIHZhciBlbGVzU3RpbGxJbnNpZGUgPSBjeS5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gZmFsc2U7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzU3RpbGxJbnNpZGUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzU3RpbGxJbnNpZGVbaV07XG5cbiAgICAgIGlmKCBlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgICBjeS5fcHJpdmF0ZS5oYXNDb21wb3VuZE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlbW92ZWRFbGVtZW50cyA9IG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCksIHJlbW92ZWQgKTtcbiAgICBpZiggcmVtb3ZlZEVsZW1lbnRzLnNpemUoKSA+IDAgKXtcbiAgICAgIC8vIG11c3QgbWFudWFsbHkgbm90aWZ5IHNpbmNlIHRyaWdnZXIgd29uJ3QgZG8gdGhpcyBhdXRvbWF0aWNhbGx5IG9uY2UgcmVtb3ZlZFxuICAgICAgXG4gICAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgICAgdGhpcy5jeSgpLm5vdGlmeSh7XG4gICAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgICAgY29sbGVjdGlvbjogcmVtb3ZlZEVsZW1lbnRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZW1vdmVkRWxlbWVudHMudHJpZ2dlcigncmVtb3ZlJyk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIGVtcHR5IHJlbWFpbmluZyBwYXJlbnQgbm9kZXNcbiAgICB2YXIgY2hlY2tlZFBhcmVudElkID0ge307XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9SZW1vdmUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzVG9SZW1vdmVbaV07XG4gICAgICB2YXIgaXNOb2RlID0gZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnO1xuICAgICAgdmFyIHBhcmVudElkID0gZWxlLl9wcml2YXRlLmRhdGEucGFyZW50O1xuXG4gICAgICBpZiggaXNOb2RlICYmIHBhcmVudElkICE9PSB1bmRlZmluZWQgJiYgIWNoZWNrZWRQYXJlbnRJZFsgcGFyZW50SWQgXSApe1xuICAgICAgICBjaGVja2VkUGFyZW50SWRbIHBhcmVudElkIF0gPSB0cnVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHBhcmVudElkICk7XG5cbiAgICAgICAgaWYoIHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoICE9PSAwICYmICFwYXJlbnQuX3ByaXZhdGUucmVtb3ZlZCAmJiBwYXJlbnQuY2hpbGRyZW4oKS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICBwYXJlbnQudXBkYXRlU3R5bGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gICQkLmVsZXNmbi5tb3ZlID0gZnVuY3Rpb24oIHN0cnVjdCApe1xuICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICBpZiggc3RydWN0LnNvdXJjZSAhPT0gdW5kZWZpbmVkIHx8IHN0cnVjdC50YXJnZXQgIT09IHVuZGVmaW5lZCApe1xuICAgICAgdmFyIHNyY0lkID0gc3RydWN0LnNvdXJjZTtcbiAgICAgIHZhciB0Z3RJZCA9IHN0cnVjdC50YXJnZXQ7XG4gICAgICB2YXIgc3JjRXhpc3RzID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHNyY0lkICkubGVuZ3RoID4gMDtcbiAgICAgIHZhciB0Z3RFeGlzdHMgPSBjeS5nZXRFbGVtZW50QnlJZCggdGd0SWQgKS5sZW5ndGggPiAwO1xuXG4gICAgICBpZiggc3JjRXhpc3RzIHx8IHRndEV4aXN0cyApe1xuICAgICAgICB2YXIganNvbnMgPSB0aGlzLmpzb25zKCk7XG5cbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGpzb25zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcblxuICAgICAgICAgIGlmKCBqc29uLmdyb3VwID09PSAnZWRnZXMnICl7XG4gICAgICAgICAgICBpZiggc3JjRXhpc3RzICl7IGpzb24uZGF0YS5zb3VyY2UgPSBzcmNJZDsgfVxuICAgICAgICAgICAgaWYoIHRndEV4aXN0cyApeyBqc29uLmRhdGEudGFyZ2V0ID0gdGd0SWQ7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY3kuYWRkKCBqc29ucyApO1xuICAgICAgfVxuIFxuICAgIH0gZWxzZSBpZiggc3RydWN0LnBhcmVudCAhPT0gdW5kZWZpbmVkICl7IC8vIG1vdmUgbm9kZSB0byBuZXcgcGFyZW50XG4gICAgICB2YXIgcGFyZW50SWQgPSBzdHJ1Y3QucGFyZW50O1xuICAgICAgdmFyIHBhcmVudEV4aXN0cyA9IHBhcmVudElkID09PSBudWxsIHx8IGN5LmdldEVsZW1lbnRCeUlkKCBwYXJlbnRJZCApLmxlbmd0aCA+IDA7XG4gICAgXG4gICAgICBpZiggcGFyZW50RXhpc3RzICl7XG4gICAgICAgIHZhciBqc29ucyA9IHRoaXMuanNvbnMoKTtcbiAgICAgICAgdmFyIGRlc2NzID0gdGhpcy5kZXNjZW5kYW50cygpO1xuICAgICAgICB2YXIgZGVzY3NFdGMgPSBkZXNjcy5tZXJnZSggZGVzY3MuYWRkKHRoaXMpLmNvbm5lY3RlZEVkZ2VzKCkgKTtcblxuICAgICAgICB0aGlzLnJlbW92ZSgpOyAvLyBOQjogYWxzbyByZW1vdmVzIGRlc2NlbmRhbnRzIGFuZCB0aGVpciBjb25uZWN0ZWQgZWRnZXNcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIganNvbiA9IGpzb25zW2ldO1xuXG4gICAgICAgICAgaWYoIGpzb24uZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgICAgIGpzb24uZGF0YS5wYXJlbnQgPSBwYXJlbnRJZCA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBhcmVudElkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3kuYWRkKCBqc29ucyApLm1lcmdlKCBkZXNjc0V0Yy5yZXN0b3JlKCkgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gaWYgbm90aGluZyBkb25lXG4gIH07XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gc2VhcmNoLCBzcGFubmluZyB0cmVlcywgZXRjXG4gICQkLmZuLmVsZXMoe1xuXG4gICAgLy8gc3RkIGZ1bmN0aW9uYWwgZWxlIGZpcnN0IGNhbGxiYWNrIHN0eWxlXG4gICAgc3RkQnJlYWR0aEZpcnN0U2VhcmNoOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgb3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKCB7fSwgb3B0aW9ucywge1xuICAgICAgICBzdGQ6IHRydWVcbiAgICAgIH0gKTtcblxuICAgICAgcmV0dXJuIHRoaXMuYnJlYWR0aEZpcnN0U2VhcmNoKCBvcHRpb25zICk7XG4gICAgfSxcblxuICAgIC8vIGRvIGEgYnJlYWR0aCBmaXJzdCBzZWFyY2ggZnJvbSB0aGUgbm9kZXMgaW4gdGhlIGNvbGxlY3Rpb25cbiAgICAvLyBmcm9tIHBzZXVkb2NvZGUgb24gd2lraXBlZGlhXG4gICAgYnJlYWR0aEZpcnN0U2VhcmNoOiBmdW5jdGlvbiggcm9vdHMsIGZuLCBkaXJlY3RlZCApe1xuICAgICAgdmFyIG9wdGlvbnM7XG4gICAgICB2YXIgc3RkO1xuICAgICAgdmFyIHRoaXNBcmc7XG4gICAgICBpZiggJCQuaXMucGxhaW5PYmplY3Qocm9vdHMpICYmICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKHJvb3RzKSApe1xuICAgICAgICBvcHRpb25zID0gcm9vdHM7XG4gICAgICAgIHJvb3RzID0gb3B0aW9ucy5yb290cztcbiAgICAgICAgZm4gPSBvcHRpb25zLnZpc2l0O1xuICAgICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICAgIHN0ZCA9IG9wdGlvbnMuc3RkO1xuICAgICAgICB0aGlzQXJnID0gb3B0aW9ucy50aGlzQXJnO1xuICAgICAgfVxuXG4gICAgICBkaXJlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgISQkLmlzLmZuKGZuKSA/IGZuIDogZGlyZWN0ZWQ7XG4gICAgICBmbiA9ICQkLmlzLmZuKGZuKSA/IGZuIDogZnVuY3Rpb24oKXt9O1xuICAgICAgXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHYgPSAkJC5pcy5zdHJpbmcocm9vdHMpID8gdGhpcy5maWx0ZXIocm9vdHMpIDogcm9vdHM7XG4gICAgICB2YXIgUSA9IFtdO1xuICAgICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gW107XG4gICAgICB2YXIgY29ubmVjdGVkQnkgPSB7fTtcbiAgICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgICAgdmFyIFYgPSB7fTtcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIHZhciBmb3VuZDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcblxuICAgICAgLy8gZW5xdWV1ZSB2XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIHZbaV0uaXNOb2RlKCkgKXtcbiAgICAgICAgICBRLnVuc2hpZnQoIHZbaV0gKTtcbiAgICAgICAgICBWWyB2W2ldLmlkKCkgXSA9IHRydWU7IFxuXG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdltpXSApO1xuICAgICAgICAgIGlkMmRlcHRoWyB2W2ldLmlkKCkgXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUoIFEubGVuZ3RoICE9PSAwICl7XG4gICAgICAgIHZhciB2ID0gUS5zaGlmdCgpO1xuICAgICAgICB2YXIgZGVwdGggPSBpZDJkZXB0aFsgdi5pZCgpIF07XG4gICAgICAgIHZhciBwcmV2RWRnZSA9IGNvbm5lY3RlZEJ5WyB2LmlkKCkgXTtcbiAgICAgICAgdmFyIHByZXZOb2RlID0gcHJldkVkZ2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHByZXZFZGdlLmNvbm5lY3RlZE5vZGVzKCkubm90KCB2IClbMF07XG4gICAgICAgIHZhciByZXQ7XG5cbiAgICAgICAgaWYoIHN0ZCApe1xuICAgICAgICAgIHJldCA9IGZuLmNhbGwodGhpc0FyZywgdiwgcHJldkVkZ2UsIHByZXZOb2RlLCBqKyssIGRlcHRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSBmbi5jYWxsKHYsIGorKywgZGVwdGgsIHYsIHByZXZFZGdlLCBwcmV2Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcmV0ID09PSB0cnVlICl7XG4gICAgICAgICAgZm91bmQgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2d0VkZ2VzID0gdi5jb25uZWN0ZWRFZGdlcyhkaXJlY3RlZCA/IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGEoJ3NvdXJjZScpID09PSB2LmlkKCk7IH0gOiB1bmRlZmluZWQpLmludGVyc2VjdCggZWRnZXMgKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGUgPSB2d0VkZ2VzW2ldO1xuICAgICAgICAgIHZhciB3ID0gZS5jb25uZWN0ZWROb2RlcyhmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5pZCgpICE9PSB2LmlkKCk7IH0pLmludGVyc2VjdCggbm9kZXMgKTtcblxuICAgICAgICAgIGlmKCB3Lmxlbmd0aCAhPT0gMCAmJiAhVlsgdy5pZCgpIF0gKXtcbiAgICAgICAgICAgIHcgPSB3WzBdO1xuXG4gICAgICAgICAgICBRLnB1c2goIHcgKTtcbiAgICAgICAgICAgIFZbIHcuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWQyZGVwdGhbIHcuaWQoKSBdID0gaWQyZGVwdGhbIHYuaWQoKSBdICsgMTtcblxuICAgICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdyApO1xuICAgICAgICAgICAgY29ubmVjdGVkQnlbIHcuaWQoKSBdID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9XG5cbiAgICAgIHZhciBjb25uZWN0ZWRFbGVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tpXTtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRCeVsgbm9kZS5pZCgpIF07XG5cbiAgICAgICAgaWYoIGVkZ2UgKXtcbiAgICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaCggbm9kZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGNvbm5lY3RlZEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgICAgZm91bmQ6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZm91bmQsIHsgdW5pcXVlOiB0cnVlIH0gKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gc3RkIGZ1bmN0aW9uYWwgZWxlIGZpcnN0IGNhbGxiYWNrIHN0eWxlXG4gICAgc3RkRGVwdGhGaXJzdFNlYXJjaDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIG9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtcbiAgICAgICAgc3RkOiB0cnVlXG4gICAgICB9ICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmRlcHRoRmlyc3RTZWFyY2goIG9wdGlvbnMgKTtcbiAgICB9LFxuXG4gICAgLy8gZG8gYSBkZXB0aCBmaXJzdCBzZWFyY2ggb24gdGhlIG5vZGVzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYSAoaXRlcmF0aXZlIGltcGwpXG4gICAgZGVwdGhGaXJzdFNlYXJjaDogZnVuY3Rpb24oIHJvb3RzLCBmbiwgZGlyZWN0ZWQgKXtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgdmFyIHN0ZDtcbiAgICAgIHZhciB0aGlzQXJnO1xuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHJvb3RzKSAmJiAhJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihyb290cykgKXtcbiAgICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gICAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgICBzdGQgPSBvcHRpb25zLnN0ZDtcbiAgICAgICAgdGhpc0FyZyA9IG9wdGlvbnMudGhpc0FyZztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICEkJC5pcy5mbihmbikgPyBmbiA6IGRpcmVjdGVkO1xuICAgICAgZm4gPSAkJC5pcy5mbihmbikgPyBmbiA6IGZ1bmN0aW9uKCl7fTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgdiA9ICQkLmlzLnN0cmluZyhyb290cykgPyB0aGlzLmZpbHRlcihyb290cykgOiByb290cztcbiAgICAgIHZhciBTID0gW107XG4gICAgICB2YXIgY29ubmVjdGVkTm9kZXMgPSBbXTtcbiAgICAgIHZhciBjb25uZWN0ZWRCeSA9IHt9O1xuICAgICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgICB2YXIgZGlzY292ZXJlZCA9IHt9O1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIGZvdW5kO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICAvLyBwdXNoIHZcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkrKyApe1xuICAgICAgICBpZiggdltpXS5pc05vZGUoKSApe1xuICAgICAgICAgIFMucHVzaCggdltpXSApO1xuXG4gICAgICAgICAgY29ubmVjdGVkTm9kZXMucHVzaCggdltpXSApO1xuICAgICAgICAgIGlkMmRlcHRoWyB2W2ldLmlkKCkgXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUoIFMubGVuZ3RoICE9PSAwICl7XG4gICAgICAgIHZhciB2ID0gUy5wb3AoKTtcblxuICAgICAgICBpZiggIWRpc2NvdmVyZWRbIHYuaWQoKSBdICl7XG4gICAgICAgICAgZGlzY292ZXJlZFsgdi5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHYuaWQoKSBdO1xuICAgICAgICAgIHZhciBwcmV2RWRnZSA9IGNvbm5lY3RlZEJ5WyB2LmlkKCkgXTtcbiAgICAgICAgICB2YXIgcHJldk5vZGUgPSBwcmV2RWRnZSA9PSBudWxsID8gdW5kZWZpbmVkIDogcHJldkVkZ2UuY29ubmVjdGVkTm9kZXMoKS5ub3QoIHYgKVswXTtcbiAgICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgICAgaWYoIHN0ZCApe1xuICAgICAgICAgICAgcmV0ID0gZm4uY2FsbCh0aGlzQXJnLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUsIGorKywgZGVwdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXQgPSBmbi5jYWxsKHYsIGorKywgZGVwdGgsIHYsIHByZXZFZGdlLCBwcmV2Tm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHJldCA9PT0gdHJ1ZSApe1xuICAgICAgICAgICAgZm91bmQgPSB2O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB2d0VkZ2VzID0gdi5jb25uZWN0ZWRFZGdlcyhkaXJlY3RlZCA/IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGEoJ3NvdXJjZScpID09PSB2LmlkKCk7IH0gOiB1bmRlZmluZWQpLmludGVyc2VjdCggZWRnZXMgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcbiAgICAgICAgICAgIHZhciB3ID0gZS5jb25uZWN0ZWROb2RlcyhmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5pZCgpICE9PSB2LmlkKCk7IH0pLmludGVyc2VjdCggbm9kZXMgKTtcblxuICAgICAgICAgICAgaWYoIHcubGVuZ3RoICE9PSAwICYmICFkaXNjb3ZlcmVkWyB3LmlkKCkgXSApe1xuICAgICAgICAgICAgICB3ID0gd1swXTtcblxuICAgICAgICAgICAgICBTLnB1c2goIHcgKTtcblxuICAgICAgICAgICAgICBpZDJkZXB0aFsgdy5pZCgpIF0gPSBpZDJkZXB0aFsgdi5pZCgpIF0gKyAxO1xuXG4gICAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHcgKTtcbiAgICAgICAgICAgICAgY29ubmVjdGVkQnlbIHcuaWQoKSBdID0gZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbm5lY3RlZEVsZXMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IGNvbm5lY3RlZE5vZGVzW2ldO1xuICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEJ5WyBub2RlLmlkKCkgXTtcblxuICAgICAgICBpZiggZWRnZSApe1xuICAgICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaCggZWRnZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBub2RlICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgY29ubmVjdGVkRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLFxuICAgICAgICBmb3VuZDogbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBmb3VuZCwgeyB1bmlxdWU6IHRydWUgfSApXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBrcnVza2FsJ3MgYWxnb3JpdGhtIChmaW5kcyBtaW4gc3Bhbm5pbmcgdHJlZSwgYXNzdW1pbmcgdW5kaXJlY3RlZCBncmFwaClcbiAgICAvLyBpbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcbiAgICBrcnVza2FsOiBmdW5jdGlvbiggd2VpZ2h0Rm4gKXtcbiAgICAgIHdlaWdodEZuID0gJCQuaXMuZm4od2VpZ2h0Rm4pID8gd2VpZ2h0Rm4gOiBmdW5jdGlvbigpeyByZXR1cm4gMTsgfTsgLy8gaWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuXG4gICAgICBmdW5jdGlvbiBmaW5kU2V0KGVsZSl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZm9yZXN0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZXMgPSBmb3Jlc3RbaV07XG5cbiAgICAgICAgICBpZiggZWxlcy5hbnlTYW1lKGVsZSkgKXtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVsZXM6IGVsZXMsXG4gICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgQSA9IG5ldyAkJC5Db2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIFtdKTtcbiAgICAgIHZhciBmb3Jlc3QgPSBbXTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBmb3Jlc3QucHVzaCggbm9kZXNbaV0uY29sbGVjdGlvbigpICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICAgIHZhciBTID0gZWRnZXMudG9BcnJheSgpLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgICAgIHZhciB3ZWlnaHRBID0gd2VpZ2h0Rm4uY2FsbChhLCBhKTtcbiAgICAgICAgdmFyIHdlaWdodEIgPSB3ZWlnaHRGbi5jYWxsKGIsIGIpO1xuXG4gICAgICAgIHJldHVybiB3ZWlnaHRBIC0gd2VpZ2h0QjtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgUy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlZGdlID0gU1tpXTtcbiAgICAgICAgdmFyIHUgPSBlZGdlLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgdiA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgICAgIHZhciBzZXRVID0gZmluZFNldCh1KTtcbiAgICAgICAgdmFyIHNldFYgPSBmaW5kU2V0KHYpO1xuXG4gICAgICAgIGlmKCBzZXRVLmluZGV4ICE9PSBzZXRWLmluZGV4ICl7XG4gICAgICAgICAgQSA9IEEuYWRkKCBlZGdlICk7XG5cbiAgICAgICAgICAvLyBjb21iaW5lIGZvcmVzdHMgZm9yIHUgYW5kIHZcbiAgICAgICAgICBmb3Jlc3RbIHNldFUuaW5kZXggXSA9IHNldFUuZWxlcy5hZGQoIHNldFYuZWxlcyApO1xuICAgICAgICAgIGZvcmVzdC5zcGxpY2UoIHNldFYuaW5kZXgsIDEgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZXMuYWRkKCBBICk7XG5cbiAgICB9LFxuXG4gICAgZGlqa3N0cmE6IGZ1bmN0aW9uKCByb290LCB3ZWlnaHRGbiwgZGlyZWN0ZWQgKXtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHJvb3QpICYmICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKHJvb3QpICl7XG4gICAgICAgIG9wdGlvbnMgPSByb290O1xuICAgICAgICByb290ID0gb3B0aW9ucy5yb290O1xuICAgICAgICB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgICBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICBkaXJlY3RlZCA9ICEkJC5pcy5mbih3ZWlnaHRGbikgPyB3ZWlnaHRGbiA6IGRpcmVjdGVkO1xuICAgICAgd2VpZ2h0Rm4gPSAkJC5pcy5mbih3ZWlnaHRGbikgPyB3ZWlnaHRGbiA6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9OyAvLyBpZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG5cbiAgICAgIHZhciBzb3VyY2UgPSAkJC5pcy5zdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KS5lcSgwKSA6IHJvb3QuZXEoMCk7XG4gICAgICB2YXIgZGlzdCA9IHt9O1xuICAgICAgdmFyIHByZXYgPSB7fTtcbiAgICAgIHZhciBrbm93bkRpc3QgPSB7fTtcblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLmZpbHRlcihmdW5jdGlvbigpeyByZXR1cm4gIXRoaXMuaXNMb29wKCk7IH0pO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIFEgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBkaXN0WyBub2Rlc1tpXS5pZCgpIF0gPSBub2Rlc1tpXS5zYW1lKCBzb3VyY2UgKSA/IDAgOiBJbmZpbml0eTtcbiAgICAgICAgUS5wdXNoKCBub2Rlc1tpXSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVGbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RbIG5vZGUuaWQoKSBdO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgUSA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBRKTtcbiAgICBcbiAgICAgIHZhciBoZWFwID0gJCQuTWluaGVhcChjeSwgUSwgdmFsdWVGbik7XG4gICAgXG4gICAgICB2YXIgZGlzdEJldHdlZW4gPSBmdW5jdGlvbih1LCB2KXtcbiAgICAgICAgdmFyIHV2cyA9ICggZGlyZWN0ZWQgPyB1LmVkZ2VzVG8odikgOiB1LmVkZ2VzV2l0aCh2KSApLmludGVyc2VjdChlZGdlcyk7XG4gICAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBzbWFsbGVzdEVkZ2U7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IHV2c1tpXTtcbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoIGVkZ2UsIFtlZGdlXSApO1xuXG4gICAgICAgICAgaWYoIHdlaWdodCA8IHNtYWxsZXN0RGlzdGFuY2UgfHwgIXNtYWxsZXN0RWRnZSApe1xuICAgICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IHdlaWdodDtcbiAgICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlZGdlOiBzbWFsbGVzdEVkZ2UsXG4gICAgICAgICAgZGlzdDogc21hbGxlc3REaXN0YW5jZVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgd2hpbGUoaGVhcC5zaXplKCkgPiAwKXtcbiAgICAgICAgdmFyIHNtYWxsZXN0RWwgPSBoZWFwLnBvcCgpLFxuICAgICAgICBzbWFsbGV0c0Rpc3QgPSBzbWFsbGVzdEVsLnZhbHVlLFxuICAgICAgICB1aWQgPSBzbWFsbGVzdEVsLmlkLFxuICAgICAgICB1ID0gY3kuZ2V0RWxlbWVudEJ5SWQodWlkKTtcbiAgICBcbiAgICAgICAga25vd25EaXN0W3VpZF0gPSBzbWFsbGV0c0Rpc3Q7XG4gICAgICBcbiAgICAgICAgaWYoIHNtYWxsZXRzRGlzdCA9PT0gTWF0aC5JbmZpbml0ZSApe1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KG5vZGVzKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgdiA9IG5laWdoYm9yc1tpXTtcbiAgICAgICAgICB2YXIgdmlkID0gdi5pZCgpO1xuICAgICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuXG4gICAgICAgICAgdmFyIGFsdCA9IHNtYWxsZXRzRGlzdCArIHZEaXN0LmRpc3Q7XG5cbiAgICAgICAgICBpZiggYWx0IDwgaGVhcC5nZXRWYWx1ZUJ5SWQodmlkKSApe1xuICAgICAgICAgICAgaGVhcC5lZGl0KHZpZCwgYWx0KTtcbiAgICAgICAgICAgIHByZXZbIHZpZCBdID0ge1xuICAgICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgICBlZGdlOiB2RGlzdC5lZGdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3IgXG4gICAgICB9IC8vIHdoaWxlXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgIHZhciB0YXJnZXQgPSAkJC5pcy5zdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSkuZXEoMCkgOiBub2RlLmVxKDApO1xuXG4gICAgICAgICAgcmV0dXJuIGtub3duRGlzdFsgdGFyZ2V0LmlkKCkgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXRoVG86IGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgIHZhciB0YXJnZXQgPSAkJC5pcy5zdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSkuZXEoMCkgOiBub2RlLmVxKDApO1xuICAgICAgICAgIHZhciBTID0gW107XG4gICAgICAgICAgdmFyIHUgPSB0YXJnZXQ7XG5cbiAgICAgICAgICBpZiggdGFyZ2V0Lmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIFMudW5zaGlmdCggdGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIHdoaWxlKCBwcmV2WyB1LmlkKCkgXSApe1xuICAgICAgICAgICAgICB2YXIgcCA9IHByZXZbIHUuaWQoKSBdO1xuXG4gICAgICAgICAgICAgIFMudW5zaGlmdCggcC5lZGdlICk7XG4gICAgICAgICAgICAgIFMudW5zaGlmdCggcC5ub2RlICk7XG5cbiAgICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBTICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAgXG4gIH0pO1xuXG4gIC8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbiAgJCQuZWxlc2ZuLmJmcyA9ICQkLmVsZXNmbi5icmVhZHRoRmlyc3RTZWFyY2g7XG4gICQkLmVsZXNmbi5kZnMgPSAkJC5lbGVzZm4uZGVwdGhGaXJzdFNlYXJjaDtcbiAgJCQuZWxlc2ZuLnN0ZEJmcyA9ICQkLmVsZXNmbi5zdGRCcmVhZHRoRmlyc3RTZWFyY2g7XG4gICQkLmVsZXNmbi5zdGREZnMgPSAkJC5lbGVzZm4uc3RkRGVwdGhGaXJzdFNlYXJjaDtcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKSB7IFxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gQWRkaXRpb25hbCBncmFwaCBhbmFseXNpcyBhbGdvcml0aG1zXG4gICQkLmZuLmVsZXMoe1xuXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG5cbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICByb290IC8vIHN0YXJ0aW5nIG5vZGUgKGVpdGhlciBlbGVtZW50IG9yIHNlbGVjdG9yIHN0cmluZylcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBoZXVyaXN0aWM6IGZ1bmN0aW9uKCBub2RlICl7fSAvLyBzcGVjaWZpZXMgaGV1cmlzdGljIHZhbHVlIGZvciBgbm9kZWAvYHRoaXNgXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gICBnb2FsIC8vIHRhcmdldCBub2RlIChlaXRoZXIgZWxlbWVudCBvciBzZWxlY3RvciBzdHJpbmcpLiBNYW5kYXRvcnkuXG5cbiAgICAvLyByZXRPYmogPT4gcmV0dXJuZWQgb2JqZWN0IGJ5IGZ1bmN0aW9uXG4gICAgLy8gICBmb3VuZCA6IHRydWUvZmFsc2UgLy8gd2hldGhlciBhIHBhdGggZnJvbSByb290IHRvIGdvYWwgaGFzIGJlZW4gZm91bmRcbiAgICAvLyAgIGRpc3RhbmNlIC8vIERpc3RhbmNlIGZvciB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIHJvb3QgdG8gZ29hbFxuICAgIC8vICAgcGF0aCAvLyBBcnJheSBvZiBpZHMgb2Ygbm9kZXMgaW4gc2hvcnRlc3QgcGF0aFxuICAgIGFTdGFyOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFJlY29uc3RydWN0cyB0aGUgcGF0aCBmcm9tIFN0YXJ0IHRvIEVuZCwgYWN1bXVsYXRpbmcgdGhlIHJlc3VsdCBpbiBwYXRoQWN1bVxuICAgICAgdmFyIHJlY29uc3RydWN0UGF0aCA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIGNhbWVGcm9tTWFwLCBwYXRoQWN1bSkge1xuICAgICAgICAvLyBCYXNlIGNhc2VcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZCkge1xuICAgICAgICAgIHBhdGhBY3VtLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKGVuZCkgKTtcbiAgICAgICAgICByZXR1cm4gcGF0aEFjdW07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChlbmQgaW4gY2FtZUZyb21NYXApIHtcbiAgICAgICAgICAvLyBXZSBrbm93IHdoaWNoIG5vZGUgaXMgYmVmb3JlIHRoZSBsYXN0IG9uZVxuICAgICAgICAgIHZhciBwcmV2aW91cyA9IGNhbWVGcm9tTWFwW2VuZF07XG4gICAgICAgICAgdmFyIHByZXZpb3VzRWRnZSA9IGNhbWVGcm9tRWRnZVtlbmRdO1xuXG4gICAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoZW5kKSApO1xuICAgICAgICAgIHBhdGhBY3VtLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKHByZXZpb3VzRWRnZSkgKTtcblxuXG4gICAgICAgICAgcmV0dXJuIHJlY29uc3RydWN0UGF0aChzdGFydCwgXG4gICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgY2FtZUZyb21NYXAsIFxuICAgICAgICAgICAgICAgICAgICAgICBwYXRoQWN1bSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHJlYWNoIGhlcmUhXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7ICAgICAgIFxuICAgICAgfTtcblxuICAgICAgLy8gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaW4gb3BlblNldCB3aGljaCBoYXMgbWluaW11bSBmU2NvcmVcbiAgICAgIHZhciBmaW5kTWluID0gZnVuY3Rpb24ob3BlblNldCwgZlNjb3JlKSB7XG4gICAgICAgIGlmIChvcGVuU2V0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIFNob3VsZCBuZXZlciBiZSB0aGUgY2FzZVxuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblBvcyA9IDA7XG4gICAgICAgIHZhciB0ZW1wU2NvcmUgPSBmU2NvcmVbb3BlblNldFswXV07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb3BlblNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzID0gZlNjb3JlW29wZW5TZXRbaV1dO1xuICAgICAgICAgIGlmIChzIDwgdGVtcFNjb3JlKSB7XG4gICAgICAgICAgICB0ZW1wU2NvcmUgPSBzO1xuICAgICAgICAgICAgbWluUG9zID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pblBvcztcbiAgICAgIH07XG5cbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIGFTdGFyLi4uXCIpOyBcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucm9vdCAhPSBudWxsKSB7ICAgICAgICBcbiAgICAgICAgdmFyIHNvdXJjZSA9ICQkLmlzLnN0cmluZyhvcHRpb25zLnJvb3QpID8gXG4gICAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjcm9vdElEXG4gICAgICAgICAgdGhpcy5maWx0ZXIob3B0aW9ucy5yb290KVswXSA6IFxuICAgICAgICAgIG9wdGlvbnMucm9vdFswXTtcbiAgICAgICAgbG9nRGVidWcoXCJTb3VyY2Ugbm9kZTogJXNcIiwgc291cmNlLmlkKCkpOyBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIGdvYWwgLSBtYW5kYXRvcnkhXG4gICAgICBpZiAob3B0aW9ucy5nb2FsICE9IG51bGwpIHsgICAgICAgXG4gICAgICAgIHZhciB0YXJnZXQgPSAkJC5pcy5zdHJpbmcob3B0aW9ucy5nb2FsKSA/IFxuICAgICAgICAgIC8vIHVzZSBpdCBhcyBhIHNlbGVjdG9yLCBlLmcuIFwiI2dvYWxJRFxuICAgICAgICAgIHRoaXMuZmlsdGVyKG9wdGlvbnMuZ29hbClbMF0gOiBcbiAgICAgICAgICBvcHRpb25zLmdvYWxbMF07XG4gICAgICAgIGxvZ0RlYnVnKFwiVGFyZ2V0IG5vZGU6ICVzXCIsIHRhcmdldC5pZCgpKTsgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICAvLyBIZXVyaXN0aWMgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuaGV1cmlzdGljICE9IG51bGwgJiYgJCQuaXMuZm4ob3B0aW9ucy5oZXVyaXN0aWMpKSB7ICAgICAgIFxuICAgICAgICB2YXIgaGV1cmlzdGljID0gb3B0aW9ucy5oZXVyaXN0aWM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGV1cmlzdGljID0gZnVuY3Rpb24oKXsgcmV0dXJuIDA7IH07IC8vIHVzZSBjb25zdGFudCBpZiB1bnNwZWNpZmllZFxuICAgICAgICAvLyAkJC51dGlsLmVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgKGhldXJpc3RpYykhIEFib3J0aW5nLlwiKTtcbiAgICAgICAgLy8gcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgJCQuaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7ICAgICAgIFxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oZSkge3JldHVybiAxO307XG4gICAgICB9XG5cbiAgICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHsgICAgICAgXG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsb3NlZFNldCA9IFtdO1xuICAgICAgdmFyIG9wZW5TZXQgPSBbc291cmNlLmlkKCldO1xuICAgICAgdmFyIGNhbWVGcm9tID0ge307XG4gICAgICB2YXIgY2FtZUZyb21FZGdlID0ge307XG4gICAgICB2YXIgZ1Njb3JlID0ge307XG4gICAgICB2YXIgZlNjb3JlID0ge307XG5cbiAgICAgIGdTY29yZVtzb3VyY2UuaWQoKV0gPSAwO1xuICAgICAgZlNjb3JlW3NvdXJjZS5pZCgpXSA9IGhldXJpc3RpYyhzb3VyY2UpO1xuICAgICAgXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkubm90KCc6bG9vcCcpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICAvLyBDb3VudGVyXG4gICAgICB2YXIgc3RlcHMgPSAwO1xuXG4gICAgICAvLyBNYWluIGxvb3AgXG4gICAgICB3aGlsZSAob3BlblNldC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBtaW5Qb3MgPSBmaW5kTWluKG9wZW5TZXQsIGZTY29yZSk7XG4gICAgICAgIHZhciBjTWluID0gdGhpcy5maWx0ZXIoXCIjXCIgKyBvcGVuU2V0W21pblBvc10pWzBdO1xuICAgICAgICBzdGVwcysrO1xuXG4gICAgICAgIGxvZ0RlYnVnKFwiXFxuU3RlcDogJXNcIiwgc3RlcHMpO1xuICAgICAgICBsb2dEZWJ1ZyhcIlByb2Nlc3Npbmcgbm9kZTogJXMsIGZTY29yZSA9ICVzXCIsIGNNaW4uaWQoKSwgZlNjb3JlW2NNaW4uaWQoKV0pO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UndmUgZm91bmQgb3VyIGdvYWwsIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgICAgaWYgKGNNaW4uaWQoKSA9PSB0YXJnZXQuaWQoKSkge1xuICAgICAgICAgIGxvZ0RlYnVnKFwiRm91bmQgZ29hbCBub2RlIVwiKTtcbiAgICAgICAgICB2YXIgclBhdGggPSByZWNvbnN0cnVjdFBhdGgoc291cmNlLmlkKCksIHRhcmdldC5pZCgpLCBjYW1lRnJvbSwgW10pO1xuICAgICAgICAgIHJQYXRoLnJldmVyc2UoKTtcbiAgICAgICAgICBsb2dEZWJ1ZyhcIlBhdGg6ICVzXCIsIHJQYXRoKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm91bmQgOiB0cnVlLFxuICAgICAgICAgICAgZGlzdGFuY2UgOiBnU2NvcmVbY01pbi5pZCgpXSxcbiAgICAgICAgICAgIHBhdGggOiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgclBhdGgpLFxuICAgICAgICAgICAgc3RlcHMgOiBzdGVwc1xuICAgICAgICAgIH07ICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBZGQgY01pbiB0byBwcm9jZXNzZWQgbm9kZXNcbiAgICAgICAgY2xvc2VkU2V0LnB1c2goY01pbi5pZCgpKTtcbiAgICAgICAgLy8gUmVtb3ZlIGNNaW4gZnJvbSBib3VuZGFyeSBub2Rlc1xuICAgICAgICBvcGVuU2V0LnNwbGljZShtaW5Qb3MsIDEpO1xuICAgICAgICBsb2dEZWJ1ZyhcIkFkZGVkIG5vZGUgdG8gY2xvc2VkU2V0LCByZW1vdmVkIGZyb20gb3BlblNldC5cIik7XG4gICAgICAgIGxvZ0RlYnVnKFwiUHJvY2Vzc2luZyBuZWlnaGJvcnMuLi5cIik7XG5cbiAgICAgICAgLy8gVXBkYXRlIHNjb3JlcyBmb3IgbmVpZ2hib3JzIG9mIGNNaW5cbiAgICAgICAgLy8gVGFrZSBpbnRvIGFjY291bnQgaWYgZ3JhcGggaXMgZGlyZWN0ZWQgb3Igbm90XG4gICAgICAgIHZhciB2d0VkZ2VzID0gY01pbi5jb25uZWN0ZWRFZGdlcyhkaXJlY3RlZCA/ICdbc291cmNlID0gXCInICsgY01pbi5pZCgpICsgJ1wiXScgXG4gICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpLmludGVyc2VjdChlZGdlcyk7ICAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcbiAgICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoJ1tpZCAhPSBcIicgKyBjTWluLmlkKCkgKyAnXCJdJykuaW50ZXJzZWN0KG5vZGVzKTtcblxuICAgICAgICAgIGxvZ0RlYnVnKFwiICAgcHJvY2Vzc2luZyBuZWlnaGJvcjogJXNcIiwgdy5pZCgpKTtcbiAgICAgICAgICAvLyBpZiBub2RlIGlzIGluIGNsb3NlZFNldCwgaWdub3JlIGl0XG4gICAgICAgICAgaWYgKGNsb3NlZFNldC5pbmRleE9mKHcuaWQoKSkgIT0gLTEpIHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKFwiICAgYWxyZWFkeSBpbiBjbG9zZWRTZXQsIGlnbm9yaW5nIGl0LlwiKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBOZXcgdGVudGF0aXZlIHNjb3JlIGZvciBub2RlIHdcbiAgICAgICAgICB2YXIgdGVtcFNjb3JlID0gZ1Njb3JlW2NNaW4uaWQoKV0gKyB3ZWlnaHRGbi5hcHBseShlLCBbZV0pO1xuICAgICAgICAgIGxvZ0RlYnVnKFwiICAgdGVudGF0aXZlIGdTY29yZTogJWRcIiwgdGVtcFNjb3JlKTtcblxuICAgICAgICAgIC8vIFVwZGF0ZSBnU2NvcmUgZm9yIG5vZGUgdyBpZjpcbiAgICAgICAgICAvLyAgIHcgbm90IHByZXNlbnQgaW4gb3BlblNldFxuICAgICAgICAgIC8vIE9SXG4gICAgICAgICAgLy8gICB0ZW50YXRpdmUgZ1Njb3JlIGlzIGxlc3MgdGhhbiBwcmV2aW91cyB2YWx1ZVxuXG4gICAgICAgICAgLy8gdyBub3QgaW4gb3BlblNldFxuICAgICAgICAgIGlmIChvcGVuU2V0LmluZGV4T2Yody5pZCgpKSA9PSAtMSkge1xuICAgICAgICAgICAgZ1Njb3JlW3cuaWQoKV0gPSB0ZW1wU2NvcmU7XG4gICAgICAgICAgICBmU2NvcmVbdy5pZCgpXSA9IHRlbXBTY29yZSArIGhldXJpc3RpYyh3KTtcbiAgICAgICAgICAgIG9wZW5TZXQucHVzaCh3LmlkKCkpOyAvLyBBZGQgbm9kZSB0byBvcGVuU2V0XG4gICAgICAgICAgICBjYW1lRnJvbVt3LmlkKCldID0gY01pbi5pZCgpO1xuICAgICAgICAgICAgY2FtZUZyb21FZGdlW3cuaWQoKV0gPSBlLmlkKCk7XG4gICAgICAgICAgICBsb2dEZWJ1ZyhcIiAgIG5vdCBpbiBvcGVuU2V0LCBhZGRpbmcgaXQuIFwiKTtcbiAgICAgICAgICAgIGxvZ0RlYnVnKFwiICAgZlNjb3JlKCVzKSA9ICVzXCIsIHcuaWQoKSwgdGVtcFNjb3JlKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3IGFscmVhZHkgaW4gb3BlblNldCwgYnV0IHdpdGggZ3JlYXRlciBnU2NvcmVcbiAgICAgICAgICBpZiAodGVtcFNjb3JlIDwgZ1Njb3JlW3cuaWQoKV0pIHtcbiAgICAgICAgICAgIGdTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlO1xuICAgICAgICAgICAgZlNjb3JlW3cuaWQoKV0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgICBjYW1lRnJvbVt3LmlkKCldID0gY01pbi5pZCgpO1xuICAgICAgICAgICAgbG9nRGVidWcoXCIgICBiZXR0ZXIgc2NvcmUsIHJlcGxhY2luZyBnU2NvcmUuIFwiKTtcbiAgICAgICAgICAgIGxvZ0RlYnVnKFwiICAgZlNjb3JlKCVzKSA9ICVzXCIsIHcuaWQoKSwgdGVtcFNjb3JlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSAvLyBFbmQgb2YgbmVpZ2hib3JzIHVwZGF0ZVxuXG4gICAgICB9IC8vIEVuZCBvZiBtYWluIGxvb3BcblxuICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCBoZXJlLCB0aGVuIHdlJ3ZlIG5vdCByZWFjaGVkIG91ciBnb2FsXG4gICAgICBsb2dEZWJ1ZyhcIlJlYWNoZWQgZW5kIG9mIGNvbXB1dGF0aW9uIHdpdGhvdXQgZmluZGluZyBvdXIgZ29hbFwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvdW5kIDogZmFsc2UsXG4gICAgICAgIGRpc3RhbmNlIDogdW5kZWZpbmVkLFxuICAgICAgICBwYXRoIDogdW5kZWZpbmVkLFxuICAgICAgICBzdGVwcyA6IHN0ZXBzXG4gICAgICB9O1xuICAgIH0sIC8vIGFTdGFyKClcblxuXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyByZXRPYmogPT4gcmV0dXJuZWQgb2JqZWN0IGJ5IGZ1bmN0aW9uXG4gICAgLy8gICBwYXRoVG8gOiBmdW5jdGlvbihmcm9tSWQsIHRvSWQpIC8vIFJldHVybnMgdGhlIHNob3J0ZXN0IHBhdGggZnJvbSBub2RlIHdpdGggSUQgXCJmcm9tSURcIiB0byBub2RlIHdpdGggSUQgXCJ0b0lkXCIsIGFzIGFuIGFycmF5IG9mIG5vZGUgSURzXG4gICAgLy8gICBkaXN0YW5jZVRvOiBmdW5jdGlvbihmcm9tSWQsIHRvSWQpIC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIG9mIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gbm9kZSB3aXRoIElEIFwiZnJvbUlEXCIgdG8gbm9kZSB3aXRoIElEIFwidG9JZFwiXG4gICAgZmxveWRXYXJzaGFsbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxvZ0RlYnVnKFwiU3RhcnRpbmcgZmxveWRXYXJzaGFsbC4uLlwiKTsgXG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHsgICAgICAgXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkubm90KCc6bG9vcCcpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuXG4gICAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgICB9ICAgICBcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIHZhciBkaXN0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld1JvdyA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykge1xuICAgICAgICAgIGlmIChpID09IGopIHtcbiAgICAgICAgICAgIG5ld1Jvd1tqXSA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1Jvd1tqXSA9IEluZmluaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkaXN0LnB1c2gobmV3Um93KTtcbiAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAvLyBJbml0aWFsaXplIG1hdHJpeCB1c2VkIGZvciBwYXRoIHJlY29uc3RydWN0aW9uXG4gICAgICAvLyBJbml0aWFsaXplIGRpc3RhbmNlIG1hdHJpeFxuICAgICAgdmFyIG5leHQgPSBbXTtcbiAgICAgIHZhciBlZGdlTmV4dCA9IFtdO1xuXG4gICAgICB2YXIgaW5pdE1hdHJpeCA9IGZ1bmN0aW9uKG5leHQpe1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICB2YXIgbmV3Um93ID0gbmV3IEFycmF5KG51bU5vZGVzKTtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICAgIG5ld1Jvd1tqXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dC5wdXNoKG5ld1Jvdyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGluaXRNYXRyaXgobmV4dCk7XG4gICAgICBpbml0TWF0cml4KGVkZ2VOZXh0KTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBlZGdlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGggOyBpKyspIHsgICAgIFxuICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0udGFyZ2V0KCkuaWQoKV07ICAgIFxuICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZXNbaV0sIFtlZGdlc1tpXV0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgYWxyZWFkeSBwcm9jZXNzIGFub3RoZXIgZWRnZSBiZXR3ZWVuIHNhbWUgMiBub2Rlc1xuICAgICAgICBpZiAoZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID4gd2VpZ2h0KSB7XG4gICAgICAgICAgZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gd2VpZ2h0O1xuICAgICAgICAgIG5leHRbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IHRhcmdldEluZGV4O1xuICAgICAgICAgIGVkZ2VOZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSBlZGdlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCBwcm9jZXNzICdyZXZlcnNlZCcgZWRnZXNcbiAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGggOyBpKyspIHsgICAgIFxuICAgICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnRhcmdldCgpLmlkKCldOyAgICBcbiAgICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZXNbaV0sIFtlZGdlc1tpXV0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgICAgICBpZiAoZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID4gd2VpZ2h0KSB7XG4gICAgICAgICAgICBkaXN0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB3ZWlnaHQ7XG4gICAgICAgICAgICBuZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICAgIGVkZ2VOZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSBlZGdlc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWFpbiBsb29wXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG51bU5vZGVzOyBrKyspIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7ICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZGlzdFtpXVtrXSArIGRpc3Rba11bal0gPCBkaXN0W2ldW2pdKSB7XG4gICAgICAgICAgICAgIGRpc3RbaV1bal0gPSBkaXN0W2ldW2tdICsgZGlzdFtrXVtqXTtcbiAgICAgICAgICAgICAgbmV4dFtpXVtqXSA9IG5leHRbaV1ba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIHJlc3VsdCBvYmplY3QgICAgICAgXG4gICAgICB2YXIgcG9zaXRpb24yaWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBwb3NpdGlvbjJpZC5wdXNoKG5vZGVzW2ldLmlkKCkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKGZyb20pKSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgZnJvbUlkID0gKGN5LmZpbHRlcihmcm9tKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciBmcm9tSWQgPSBmcm9tLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIodG8pWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGlzdFtpZDJwb3NpdGlvbltmcm9tSWRdXVtpZDJwb3NpdGlvblt0b0lkXV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGF0aDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoQXV4ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG5leHQsIHBvc2l0aW9uMmlkLCBlZGdlTmV4dCkge1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjeS5nZXRFbGVtZW50QnlJZCggcG9zaXRpb24yaWRbZnJvbV0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0W2Zyb21dW3RvXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwYXRoID0gWyBjeS5nZXRFbGVtZW50QnlJZChwb3NpdGlvbjJpZFtmcm9tXSkgXTtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gZnJvbTtcbiAgICAgICAgICAgIHdoaWxlIChmcm9tICE9PSB0bykge1xuICAgICAgICAgICAgICBwcmV2ID0gZnJvbTtcbiAgICAgICAgICAgICAgZnJvbSA9IG5leHRbZnJvbV1bdG9dO1xuXG4gICAgICAgICAgICAgIHZhciBlZGdlID0gZWRnZU5leHRbcHJldl1bZnJvbV07XG4gICAgICAgICAgICAgIHBhdGgucHVzaCggZWRnZSApO1xuXG4gICAgICAgICAgICAgIHBhdGgucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbZnJvbV0pICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhmcm9tKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIGZyb21JZCA9IChjeS5maWx0ZXIoZnJvbSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgZnJvbUlkID0gZnJvbS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcodG8pKSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHZhciBwYXRoQXJyID0gcmVjb25zdHJ1Y3RQYXRoQXV4KGlkMnBvc2l0aW9uW2Zyb21JZF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQycG9zaXRpb25bdG9JZF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uMmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZU5leHQpO1xuXG4gICAgICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcGF0aEFyciApO1xuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlcztcblxuICAgIH0sIC8vIGZsb3lkV2Fyc2hhbGxcblxuXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgcm9vdDogc3RhcnRpbmcgbm9kZSAoZWl0aGVyIGVsZW1lbnQgb3Igc2VsZWN0b3Igc3RyaW5nKVxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyByZXRPYmogPT4gcmV0dXJuZWQgb2JqZWN0IGJ5IGZ1bmN0aW9uXG4gICAgLy8gICBwYXRoVG8gOiBmdW5jdGlvbih0b0lkKSAvLyBSZXR1cm5zIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gcm9vdCBub2RlIHRvIG5vZGUgd2l0aCBJRCBcInRvSWRcIiwgYXMgYW4gYXJyYXkgb2Ygbm9kZSBJRHNcbiAgICAvLyAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKHRvSWQpIC8vIFJldHVybnMgdGhlIGRpc3RhbmNlIG9mIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gcm9vdCBub2RlIHRvIG5vZGUgd2l0aCBJRCBcInRvSWRcIlxuICAgIC8vICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogdHJ1ZS9mYWxzZSAoaWYgdHJ1ZSwgcGF0aFRvIGFuZCBkaXN0YW5jZVRvIHdpbGwgYmUgdW5kZWZpbmVkKVxuICAgIGJlbGxtYW5Gb3JkOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmRlYnVnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGRlYnVnID0gb3B0aW9ucy5kZWJ1ZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgbG9nRGVidWcoXCJTdGFydGluZyBiZWxsbWFuRm9yZC4uLlwiKTsgXG5cbiAgICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHsgICAgICAgXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyByb290IC0gbWFuZGF0b3J5IVxuICAgICAgaWYgKG9wdGlvbnMucm9vdCAhPSBudWxsKSB7ICAgICAgIFxuICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkpIHtcbiAgICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5maWx0ZXIob3B0aW9ucy5yb290KVswXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gb3B0aW9ucy5yb290WzBdO1xuICAgICAgICB9XG4gICAgICAgIGxvZ0RlYnVnKFwiU291cmNlIG5vZGU6ICVzXCIsIHNvdXJjZS5pZCgpKTsgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkJC51dGlsLmVycm9yKFwib3B0aW9ucy5yb290IHJlcXVpcmVkXCIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLm5vdCgnOmxvb3AnKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgICAgfSAgICAgXG5cbiAgICAgIC8vIEluaXRpYWxpemF0aW9uc1xuICAgICAgdmFyIGNvc3QgPSBbXTtcbiAgICAgIHZhciBwcmVkZWNlc3NvciA9IFtdO1xuICAgICAgdmFyIHByZWRFZGdlID0gW107XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBpZiAobm9kZXNbaV0uaWQoKSA9PT0gc291cmNlLmlkKCkpIHtcbiAgICAgICAgICBjb3N0W2ldID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3N0W2ldID0gSW5maW5pdHk7XG4gICAgICAgIH0gXG4gICAgICAgIHByZWRlY2Vzc29yW2ldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFZGdlcyByZWxheGF0aW9uICAgICAgXG4gICAgICB2YXIgZmxhZyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgZSA9IDA7IGUgPCBlZGdlcy5sZW5ndGg7IGUrKykge1xuICAgICAgICAgIHZhciBzb3VyY2VJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnNvdXJjZSgpLmlkKCldO1xuICAgICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2VdLnRhcmdldCgpLmlkKCldOyAgICBcbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoZWRnZXNbZV0sIFtlZGdlc1tlXV0pO1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciB0ZW1wID0gY29zdFtzb3VyY2VJbmRleF0gKyB3ZWlnaHQ7XG4gICAgICAgICAgaWYgKHRlbXAgPCBjb3N0W3RhcmdldEluZGV4XSkge1xuICAgICAgICAgICAgY29zdFt0YXJnZXRJbmRleF0gPSB0ZW1wO1xuICAgICAgICAgICAgcHJlZGVjZXNzb3JbdGFyZ2V0SW5kZXhdID0gc291cmNlSW5kZXg7XG4gICAgICAgICAgICBwcmVkRWRnZVt0YXJnZXRJbmRleF0gPSBlZGdlc1tlXTtcbiAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHVuZGlyZWN0ZWQgZ3JhcGgsIHdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlICdyZXZlcnNlJyBlZGdlXG4gICAgICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBjb3N0W3RhcmdldEluZGV4XSArIHdlaWdodDtcbiAgICAgICAgICAgIGlmICh0ZW1wIDwgY29zdFtzb3VyY2VJbmRleF0pIHtcbiAgICAgICAgICAgICAgY29zdFtzb3VyY2VJbmRleF0gPSB0ZW1wO1xuICAgICAgICAgICAgICBwcmVkZWNlc3Nvcltzb3VyY2VJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICAgICAgcHJlZEVkZ2Vbc291cmNlSW5kZXhdID0gZWRnZXNbZV07XG4gICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZmxhZykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9ICAgICAgXG4gICAgICAgICAgICBcbiAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBuZWdhdGl2ZSB3ZWlnaHQgY3ljbGVzXG4gICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS50YXJnZXQoKS5pZCgpXTsgICAgXG4gICAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2VdLCBbZWRnZXNbZV1dKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY29zdFtzb3VyY2VJbmRleF0gKyB3ZWlnaHQgPCBjb3N0W3RhcmdldEluZGV4XSkge1xuICAgICAgICAgICAgJCQudXRpbC5lcnJvcihcIkVycm9yOiBncmFwaCBjb250YWlucyBhIG5lZ2F0aXZlIHdlaWd0aCBjeWNsZSFcIik7IFxuICAgICAgICAgICAgcmV0dXJuIHsgcGF0aFRvOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgIGRpc3RhbmNlVG86IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgaGFzTmVnYXRpdmVXZWlnaHRDeWNsZTogdHJ1ZX07XG4gICAgICAgICAgfVxuICAgICAgICB9ICAgICBcbiAgICAgIH1cblxuICAgICAgLy8gQnVpbGQgcmVzdWx0IG9iamVjdCAgICAgICBcbiAgICAgIHZhciBwb3NpdGlvbjJpZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHBvc2l0aW9uMmlkLnB1c2gobm9kZXNbaV0uaWQoKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgdmFyIHJlcyA9IHsgICAgICAgXG4gICAgICAgIGRpc3RhbmNlVG8gOiBmdW5jdGlvbih0bykge1xuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcodG8pKSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNvc3RbaWQycG9zaXRpb25bdG9JZF1dO1xuICAgICAgICB9LCBcblxuICAgICAgICBwYXRoVG8gOiBmdW5jdGlvbih0bykge1xuXG4gICAgICAgICAgdmFyIHJlY29uc3RydWN0UGF0aEF1eCA9IGZ1bmN0aW9uKHByZWRlY2Vzc29yLCBmcm9tUG9zLCB0b1BvcywgcG9zaXRpb24yaWQsIGFjdW1QYXRoLCBwcmVkRWRnZSkge1xuICAgICAgICAgICAgZm9yKDs7KXtcbiAgICAgICAgICAgICAgLy8gQWRkIHRvSWQgdG8gcGF0aFxuICAgICAgICAgICAgICBhY3VtUGF0aC5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChwb3NpdGlvbjJpZFt0b1Bvc10pICk7XG4gICAgICAgICAgICAgIGFjdW1QYXRoLnB1c2goIHByZWRFZGdlW3RvUG9zXSApO1xuXG4gICAgICAgICAgICAgIGlmIChmcm9tUG9zID09PSB0b1Bvcykge1xuICAgICAgICAgICAgICAgIC8vIHJlYWNoZWQgc3RhcnRpbmcgbm9kZVxuICAgICAgICAgICAgICAgIHJldHVybiBhY3VtUGF0aDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIElmIG5vIHBhdGggZXhpc3RzLCBkaXNjYXJ0IGFjdW11bGF0ZWQgcGF0aCBhbmQgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICAgICAgICB2YXIgcHJlZFBvcyA9IHByZWRlY2Vzc29yW3RvUG9zXTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVkUG9zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRvUG9zID0gcHJlZFBvcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcGF0aCA9IFtdO1xuXG4gICAgICAgICAgLy8gVGhpcyByZXR1cm5zIGEgcmV2ZXJzZWQgcGF0aCBcbiAgICAgICAgICB2YXIgcmVzID0gIHJlY29uc3RydWN0UGF0aEF1eChwcmVkZWNlc3NvciwgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvbltzb3VyY2UuaWQoKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDJwb3NpdGlvblt0b0lkXSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjJpZCwgXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZEVkZ2UpO1xuXG4gICAgICAgICAgLy8gR2V0IGl0IGluIHRoZSBjb3JyZWN0IG9yZGVyIGFuZCByZXR1cm4gaXRcbiAgICAgICAgICBpZiAocmVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCByZXMpOyAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sIFxuXG4gICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gcmVzO1xuXG4gICAgfSwgLy8gYmVsbG1hbkZvcmRcblxuXG4gICAgLy8gQ29tcHV0ZXMgdGhlIG1pbmltdW0gY3V0IG9mIGFuIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgICAvLyBSZXR1cm5zIHRoZSBjb3JyZWN0IGFuc3dlciB3aXRoIGhpZ2ggcHJvYmFiaWxpdHlcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICAgY3V0IDogbGlzdCBvZiBJRHMgb2YgZWRnZXMgaW4gdGhlIGN1dCxcbiAgICAvLyAgIHBhcnRpdGlvbjE6IGxpc3Qgb2YgSURzIG9mIG5vZGVzIGluIG9uZSBwYXJ0aXRpb25cbiAgICAvLyAgIHBhcnRpdGlvbjI6IGxpc3Qgb2YgSURzIG9mIG5vZGVzIGluIHRoZSBvdGhlciBwYXJ0aXRpb25cbiAgICBrYXJnZXJTdGVpbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBcbiAgICAgIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBGdW5jdGlvbiB3aGljaCBjb2xhcHNlcyAyIChtZXRhKSBub2RlcyBpbnRvIG9uZVxuICAgICAgLy8gVXBkYXRlcyB0aGUgcmVtYWluaW5nIGVkZ2UgbGlzdHNcbiAgICAgIC8vIFJlY2VpdmVzIGFzIGEgcGFyYW1hdGVyIHRoZSBlZGdlIHdoaWNoIGNhdXNlcyB0aGUgY29sbGFwc2VcbiAgICAgIHZhciBjb2xhcHNlID0gZnVuY3Rpb24oZWRnZUluZGV4LCBub2RlTWFwLCByZW1haW5pbmdFZGdlcykge1xuICAgICAgICB2YXIgZWRnZUluZm8gPSByZW1haW5pbmdFZGdlc1tlZGdlSW5kZXhdO1xuICAgICAgICB2YXIgc291cmNlSW4gPSBlZGdlSW5mb1sxXTtcbiAgICAgICAgdmFyIHRhcmdldEluID0gZWRnZUluZm9bMl07XG4gICAgICAgIHZhciBwYXJ0aXRpb24xID0gbm9kZU1hcFtzb3VyY2VJbl07XG4gICAgICAgIHZhciBwYXJ0aXRpb24yID0gbm9kZU1hcFt0YXJnZXRJbl07XG5cbiAgICAgICAgLy8gRGVsZXRlIGFsbCBlZGdlcyBiZXR3ZWVuIHBhcnRpdGlvbjEgYW5kIHBhcnRpdGlvbjJcbiAgICAgICAgdmFyIG5ld0VkZ2VzID0gcmVtYWluaW5nRWRnZXMuZmlsdGVyKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgICAgICBpZiAobm9kZU1hcFtlZGdlWzFdXSA9PT0gcGFydGl0aW9uMSAmJiBub2RlTWFwW2VkZ2VbMl1dID09PSBwYXJ0aXRpb24yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlTWFwW2VkZ2VbMV1dID09PSBwYXJ0aXRpb24yICYmIG5vZGVNYXBbZWRnZVsyXV0gPT09IHBhcnRpdGlvbjEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQWxsIGVkZ2VzIHBvaW50aW5nIHRvIHBhcnRpdGlvbjIgc2hvdWxkIG5vdyBwb2ludCB0byBwYXJ0aXRpb24xXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5ld0VkZ2VzW2ldO1xuICAgICAgICAgIGlmIChlZGdlWzFdID09PSBwYXJ0aXRpb24yKSB7IC8vIENoZWNrIHNvdXJjZVxuICAgICAgICAgICAgbmV3RWRnZXNbaV0gPSBlZGdlLnNsaWNlKDApO1xuICAgICAgICAgICAgbmV3RWRnZXNbaV1bMV0gPSBwYXJ0aXRpb24xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWRnZVsyXSA9PT0gcGFydGl0aW9uMikgeyAvLyBDaGVjayB0YXJnZXRcbiAgICAgICAgICAgIG5ld0VkZ2VzW2ldID0gZWRnZS5zbGljZSgwKTtcbiAgICAgICAgICAgIG5ld0VkZ2VzW2ldWzJdID0gcGFydGl0aW9uMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIFxuICAgICAgICAvLyBNb3ZlIGFsbCBub2RlcyBmcm9tIHBhcnRpdGlvbjIgdG8gcGFydGl0aW9uMVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVNYXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAobm9kZU1hcFtpXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgICAgICAgbm9kZU1hcFtpXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3RWRnZXM7XG4gICAgICB9O1xuXG5cbiAgICAgIC8vIENvbnRyYWN0cyBhIGdyYXBoIHVudGlsIHdlIHJlYWNoIGEgY2VydGFpbiBudW1iZXIgb2YgbWV0YSBub2Rlc1xuICAgICAgdmFyIGNvbnRyYWN0VW50aWwgPSBmdW5jdGlvbihtZXRhTm9kZU1hcCwgXG4gICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdFZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgIHNpemUsIFxuICAgICAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0KSB7XG4gICAgICAgIC8vIFN0b3AgY29uZGl0aW9uXG4gICAgICAgIGlmIChzaXplIDw9IHNpemVMaW1pdCkge1xuICAgICAgICAgIHJldHVybiByZW1haW5pbmdFZGdlcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hvb3NlIGFuIGVkZ2UgcmFuZG9tbHlcbiAgICAgICAgdmFyIGVkZ2VJbmRleCA9IE1hdGguZmxvb3IoKE1hdGgucmFuZG9tKCkgKiByZW1haW5pbmdFZGdlcy5sZW5ndGgpKTtcblxuICAgICAgICAvLyBDb2xhcHNlIGdyYXBoIGJhc2VkIG9uIGVkZ2VcbiAgICAgICAgdmFyIG5ld0VkZ2VzID0gY29sYXBzZShlZGdlSW5kZXgsIG1ldGFOb2RlTWFwLCByZW1haW5pbmdFZGdlcyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgXG4gICAgICAgICAgICAgICAgICAgbmV3RWRnZXMsIFxuICAgICAgICAgICAgICAgICAgIHNpemUgLSAxLCBcbiAgICAgICAgICAgICAgICAgICBzaXplTGltaXQpOyAgICAgICAgXG4gICAgICB9O1xuXG5cbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxvZ0RlYnVnKFwiU3RhcnRpbmcga2FyZ2VyU3RlaW4uLi5cIik7IFxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLm5vdCgnOmxvb3AnKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICAgIHZhciBudW1FZGdlcyA9IGVkZ2VzLmxlbmd0aDtcbiAgICAgIHZhciBudW1JdGVyID0gTWF0aC5jZWlsKE1hdGgucG93KE1hdGgubG9nKG51bU5vZGVzKSAvIE1hdGguTE4yLCAyKSk7XG4gICAgICB2YXIgc3RvcFNpemUgPSBNYXRoLmZsb29yKG51bU5vZGVzIC8gTWF0aC5zcXJ0KDIpKTtcblxuICAgICAgaWYgKG51bU5vZGVzIDwgMikge1xuICAgICAgICAkJC51dGlsLmVycm9yKFwiQXQgbGVhc3QgMiBub2RlcyBhcmUgcmVxdWlyZWQgZm9yIEthcmdlclN0ZWluZyBhbGdvcml0aG0hXCIpOyBcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIG51bWVyaWNhbCBpZGVudGlmaWVycyBmb3IgZWFjaCBub2RlXG4gICAgICAvLyBtYXBwaW5nOiBub2RlIGlkIC0+IHBvc2l0aW9uIGluIG5vZGVzIGFycmF5XG4gICAgICAvLyBmb3IgcmV2ZXJzZSBtYXBwaW5nLCBzaW1wbHkgdXNlIG5vZGVzIGFycmF5XG4gICAgICB2YXIgaWQycG9zaXRpb24gPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBpZDJwb3NpdGlvbltub2Rlc1tpXS5pZCgpXSA9IGk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyBzdG9yZSBlZGdlIGRlc3RpbmF0aW9uIGFzIGluZGV4ZXNcbiAgICAgIC8vIEZvcm1hdCBmb3IgZWFjaCBlZGdlIChlZGdlIGluZGV4LCBzb3VyY2Ugbm9kZSBpbmRleCwgdGFyZ2V0IG5vZGUgaW5kZXgpXG4gICAgICB2YXIgZWRnZUluZGV4ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKykge1xuICAgICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgICBlZGdlSW5kZXhlcy5wdXNoKFtpLCBpZDJwb3NpdGlvbltlLnNvdXJjZSgpLmlkKCldLCBpZDJwb3NpdGlvbltlLnRhcmdldCgpLmlkKCldXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIHdpbGwgc3RvcmUgdGhlIGJlc3QgY3V0IGZvdW5kIGhlcmVcbiAgICAgIHZhciBtaW5DdXRTaXplID0gSW5maW5pdHk7XG4gICAgICB2YXIgbWluQ3V0OyAgICAgXG5cbiAgICAgIC8vIEluaXRpYWwgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgdmFyIG9yaWdpbmFsTWV0YU5vZGUgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBvcmlnaW5hbE1ldGFOb2RlLnB1c2goaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIE1haW4gbG9vcFxuICAgICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPD0gbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgbWV0YSBub2RlIHBhcnRpdGlvblxuICAgICAgICB2YXIgbWV0YU5vZGVNYXAgPSBvcmlnaW5hbE1ldGFOb2RlLnNsaWNlKDApO1xuXG4gICAgICAgIC8vIENvbnRyYWN0IHVudGlsIHN0b3AgcG9pbnQgKHN0b3BTaXplIG5vZGVzKVxuICAgICAgICB2YXIgZWRnZXNTdGF0ZSA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIGVkZ2VJbmRleGVzLCBudW1Ob2Rlcywgc3RvcFNpemUpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29weSBvZiB0aGUgY29sYXBzZWQgbm9kZXMgc3RhdGVcbiAgICAgICAgdmFyIG1ldGFOb2RlTWFwMiA9IG1ldGFOb2RlTWFwLnNsaWNlKDApO1xuXG4gICAgICAgIC8vIFJ1biAyIGl0ZXJhdGlvbnMgc3RhcnRpbmcgaW4gdGhlIHN0b3Agc3RhdGVcbiAgICAgICAgdmFyIHJlczEgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMik7XG4gICAgICAgIHZhciByZXMyID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcDIsIGVkZ2VzU3RhdGUsIHN0b3BTaXplLCAyKTtcblxuICAgICAgICAvLyBJcyBhbnkgb2YgdGhlIDIgcmVzdWx0cyB0aGUgYmVzdCBjdXQgc28gZmFyP1xuICAgICAgICBpZiAocmVzMS5sZW5ndGggPD0gcmVzMi5sZW5ndGggJiYgcmVzMS5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczEubGVuZ3RoO1xuICAgICAgICAgIG1pbkN1dCA9IFtyZXMxLCBtZXRhTm9kZU1hcF07XG4gICAgICAgIH0gZWxzZSBpZiAocmVzMi5sZW5ndGggPD0gcmVzMS5sZW5ndGggJiYgcmVzMi5sZW5ndGggPCBtaW5DdXRTaXplKSB7XG4gICAgICAgICAgbWluQ3V0U2l6ZSA9IHJlczIubGVuZ3RoO1xuICAgICAgICAgIG1pbkN1dCA9IFtyZXMyLCBtZXRhTm9kZU1hcDJdO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVuZCBvZiBtYWluIGxvb3BcblxuICAgICAgXG4gICAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgICB2YXIgcmVzRWRnZXMgPSAobWluQ3V0WzBdKS5tYXAoZnVuY3Rpb24oZSl7IHJldHVybiBlZGdlc1tlWzBdXTsgfSk7XG4gICAgICB2YXIgcGFydGl0aW9uMSA9IFtdO1xuICAgICAgdmFyIHBhcnRpdGlvbjIgPSBbXTtcblxuICAgICAgLy8gdHJhdmVyc2UgbWV0YU5vZGVNYXAgZm9yIGJlc3QgY3V0XG4gICAgICB2YXIgd2l0bmVzc05vZGVQYXJ0aXRpb24gPSBtaW5DdXRbMV1bMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkN1dFsxXS5sZW5ndGg7IGkrKykgeyBcbiAgICAgICAgdmFyIHBhcnRpdGlvbklkID0gbWluQ3V0WzFdW2ldOyBcbiAgICAgICAgaWYgKHBhcnRpdGlvbklkID09PSB3aXRuZXNzTm9kZVBhcnRpdGlvbikge1xuICAgICAgICAgIHBhcnRpdGlvbjEucHVzaChub2Rlc1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydGl0aW9uMi5wdXNoKG5vZGVzW2ldKTtcbiAgICAgICAgfSAgICAgICBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgY3V0OiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcmVzRWRnZXMpLFxuICAgICAgICBwYXJ0aXRpb24xOiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcGFydGl0aW9uMSksXG4gICAgICAgIHBhcnRpdGlvbjI6IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBwYXJ0aXRpb24yKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG5cbiAgICAvLyBcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICBkYW1waW5nRmFjdG9yOiBvcHRpb25hbFxuICAgIC8vICAgcHJlY2lzaW9uOiBvcHRpb25hbFxuICAgIC8vICAgaXRlcmF0aW9ucyA6IG9wdGlvbmFsXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICByYW5rIDogZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBwYWdlUmFuayBvZiBhIGdpdmVuIG5vZGUgKG9iamVjdCBvciBzZWxlY3RvciBzdHJpbmcpXG4gICAgcGFnZVJhbms6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgXG4gICAgICB2YXIgbm9ybWFsaXplVmVjdG9yID0gZnVuY3Rpb24odmVjdG9yKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB2ZWN0b3IubGVuZ3RoO1xuXG4gICAgICAgIC8vIEZpcnN0LCBnZXQgc3VtIG9mIGFsbCBlbGVtZW50c1xuICAgICAgICB2YXIgdG90YWwgPSAwOyBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRvdGFsICs9IHZlY3RvcltpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdywgZGl2aWRlIGVhY2ggYnkgdGhlIHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZlY3RvcltpXSA9IHZlY3RvcltpXSAvIHRvdGFsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBcbiAgICAgICAgb3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxvZ0RlYnVnKFwiU3RhcnRpbmcgcGFnZVJhbmsuLi5cIik7IFxuXG4gICAgICAvLyBkYW1waW5nRmFjdG9yIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAgIG9wdGlvbnMuZGFtcGluZ2ZhY3RvciAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkYW1waW5nRmFjdG9yID0gb3B0aW9ucy5kYW1waW5nRmFjdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRhbXBpbmdGYWN0b3IgPSAwLjg7IC8vIERlZmF1bHQgZGFtcGluZyBmYWN0b3JcbiAgICAgIH1cblxuICAgICAgLy8gZGVzaXJlZCBwcmVjaXNpb24gLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBcbiAgICAgICAgb3B0aW9ucy5wcmVjaXNpb24gIT0gbnVsbCkge1xuICAgICAgICB2YXIgZXBzaWxvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGVwc2lsb24gPSAwLjAwMDAwMTsgLy8gRGVmYXVsdCBwcmVjaXNpb25cbiAgICAgIH1cblxuICAgICAgLy8gTWF4IG51bWJlciBvZiBpdGVyYXRpb25zIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAgIG9wdGlvbnMuaXRlcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBudW1JdGVyID0gb3B0aW9ucy5pdGVyYXRpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG51bUl0ZXIgPSAyMDA7IC8vIERlZmF1bHQgbnVtYmVyIG9mIGl0ZXJhdGlvbnNcbiAgICAgIH1cblxuICAgICAgLy8gV2VpZ2h0IGZ1bmN0aW9uIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAgIG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgXG4gICAgICAgICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkgeyAgICAgICBcbiAgICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IGZ1bmN0aW9uKGUpIHtyZXR1cm4gMTt9OyBcbiAgICAgIH1cblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5ub3QoJzpsb29wJyk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgICAgLy8gZm9yIHJldmVyc2UgbWFwcGluZywgc2ltcGx5IHVzZSBub2RlcyBhcnJheVxuICAgICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb25zdHJ1Y3QgdHJhbnNwb3NlZCBhZGphY2VuY3kgbWF0cml4XG4gICAgICAvLyBGaXJzdCBsZXRzIGhhdmUgYSB6ZXJvZWQgbWF0cml4IG9mIHRoZSByaWdodCBzaXplXG4gICAgICAvLyBXZSdsbCBhbHNvIGtlZXAgdHJhY2sgb2YgdGhlIHN1bSBvZiBlYWNoIGNvbHVtblxuICAgICAgdmFyIG1hdHJpeCA9IFtdO1xuICAgICAgdmFyIGNvbHVtblN1bSA9IFtdO1xuICAgICAgdmFyIGFkZGl0aW9uYWxQcm9iID0gKDEgLSBkYW1waW5nRmFjdG9yKSAvIG51bU5vZGVzO1xuXG4gICAgICAvLyBDcmVhdGUgbnVsbCBtYXRyaWNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykgeyBcbiAgICAgICAgdmFyIG5ld1JvdyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICBuZXdSb3cucHVzaCgwLjApO1xuICAgICAgICB9XG4gICAgICAgIG1hdHJpeC5wdXNoKG5ld1Jvdyk7XG4gICAgICAgIGNvbHVtblN1bS5wdXNoKDAuMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdywgcHJvY2VzcyBlZGdlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1FZGdlczsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBzID0gaWQycG9zaXRpb25bZWRnZS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgdmFyIHQgPSBpZDJwb3NpdGlvbltlZGdlLnRhcmdldCgpLmlkKCldO1xuICAgICAgICB2YXIgdyA9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgbWF0cml4XG4gICAgICAgIG1hdHJpeFt0XVtzXSArPSB3O1xuXG4gICAgICAgIC8vIFVwZGF0ZSBjb2x1bW4gc3VtXG4gICAgICAgIGNvbHVtblN1bVtzXSArPSB3OyBcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgcHJvYmFiaWxpdHkgYmFzZWQgb24gZGFtcGluZyBmYWN0b3JcbiAgICAgIC8vIEFsc28sIHRha2UgaW50byBhY2NvdW50IGNvbHVtbnMgdGhhdCBoYXZlIHN1bSA9IDBcbiAgICAgIHZhciBwID0gMS4wIC8gbnVtTm9kZXMgKyBhZGRpdGlvbmFsUHJvYjsgLy8gU2hvcnRoYW5kXG4gICAgICAvLyBUcmF2ZXJzZSBtYXRyaXgsIGNvbHVtbiBieSBjb2x1bW5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykgeyBcbiAgICAgICAgaWYgKGNvbHVtblN1bVtqXSA9PT0gMCkge1xuICAgICAgICAgIC8vIE5vICdsaW5rcycgb3V0IGZyb20gbm9kZSBqdGgsIGFzc3VtZSBlcXVhbCBwcm9iYWJpbGl0eSBmb3IgZWFjaCBwb3NzaWJsZSBub2RlXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb2RlIGp0aCBoYXMgb3V0Z29pbmcgbGluaywgY29tcHV0ZSBub3JtYWxpemVkIHByb2JhYmlsaXRpZXNcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpXVtqXSAvIGNvbHVtblN1bVtqXSArIGFkZGl0aW9uYWxQcm9iO1xuICAgICAgICAgIH0gICAgICAgICBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wdXRlIGRvbWluYW50IGVpZ2VudmVjdG9yIHVzaW5nIHBvd2VyIG1ldGhvZFxuICAgICAgdmFyIGVpZ2VudmVjdG9yID0gW107XG4gICAgICB2YXIgbnVsbFZlY3RvciA9IFtdO1xuICAgICAgdmFyIHByZXZpb3VzO1xuXG4gICAgICAvLyBTdGFydCB3aXRoIGEgdmVjdG9yIG9mIGFsbCAxJ3NcbiAgICAgIC8vIEFsc28sIGluaXRpYWxpemUgYSBudWxsIHZlY3RvciB3aGljaCB3aWxsIGJlIHVzZWQgYXMgc2hvcnRoYW5kXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgZWlnZW52ZWN0b3IucHVzaCgxLjApO1xuICAgICAgICBudWxsVmVjdG9yLnB1c2goMC4wKTtcbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgZm9yICh2YXIgaXRlciA9IDA7IGl0ZXIgPCBudW1JdGVyOyBpdGVyKyspIHtcbiAgICAgICAgLy8gTmV3IGFycmF5IHdpdGggYWxsIDAnc1xuICAgICAgICB2YXIgdGVtcCA9IG51bGxWZWN0b3Iuc2xpY2UoMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBNdWx0aXBseSBtYXRyaXggd2l0aCBwcmV2aW91cyByZXN1bHRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7ICAgICAgICBcbiAgICAgICAgICAgIHRlbXBbaV0gKz0gbWF0cml4W2ldW2pdICogZWlnZW52ZWN0b3Jbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplVmVjdG9yKHRlbXApO1xuICAgICAgICBwcmV2aW91cyA9IGVpZ2VudmVjdG9yO1xuICAgICAgICBlaWdlbnZlY3RvciA9IHRlbXA7XG5cbiAgICAgICAgdmFyIGRpZmYgPSAwO1xuICAgICAgICAvLyBDb21wdXRlIGRpZmZlcmVuY2UgKHNxdWFyZWQgbW9kdWxlKSBvZiBib3RoIHZlY3RvcnNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgZGlmZiArPSBNYXRoLnBvdyhwcmV2aW91c1tpXSAtIGVpZ2VudmVjdG9yW2ldLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgZGlmZmVyZW5jZSBpcyBsZXNzIHRoYW4gdGhlIGRlc2lyZWQgdGhyZXNob2xkLCBzdG9wIGl0ZXJhdGluZ1xuICAgICAgICBpZiAoZGlmZiA8IGVwc2lsb24pIHtcbiAgICAgICAgICBsb2dEZWJ1ZyhcIlN0b3BlZCBhdCBpdGVyYXRpb24gJXNcIiwgaXRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgbG9nRGVidWcoXCJSZXN1bHQ6XFxuXCIgKyBlaWdlbnZlY3Rvcik7XG5cbiAgICAgIC8vIENvbnN0cnVjdCByZXN1bHRcbiAgICAgIHZhciByZXMgPSB7XG4gICAgICAgIHJhbmsgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSAoY3kuZmlsdGVyKG5vZGUpWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpcyBhIG5vZGUgb2JqZWN0XG4gICAgICAgICAgICB2YXIgbm9kZUlkID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWlnZW52ZWN0b3JbaWQycG9zaXRpb25bbm9kZUlkXV07XG4gICAgICAgIH1cbiAgICAgIH07XG5cblxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IC8vIHBhZ2VSYW5rXG5cbiAgfSk7IC8vICQkLmZuLmVsZXNcblxuXG59KSAoY3l0b3NjYXBlKTtcbjsoZnVuY3Rpb24oICQkICl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcbiAgICBhbmltYXRlZDogJCQuZGVmaW5lLmFuaW1hdGVkKCksXG4gICAgY2xlYXJRdWV1ZTogJCQuZGVmaW5lLmNsZWFyUXVldWUoKSxcbiAgICBkZWxheTogJCQuZGVmaW5lLmRlbGF5KCksXG4gICAgYW5pbWF0ZTogJCQuZGVmaW5lLmFuaW1hdGUoKSxcbiAgICBzdG9wOiAkJC5kZWZpbmUuc3RvcCgpXG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTsgIFxuXG47KGZ1bmN0aW9uKCAkJCApeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBjbGFzc2VzOiBmdW5jdGlvbihvcHRzKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBjaGFuZ2VkID0gW107XG4gICAgICB2YXIgZm47XG5cbiAgICAgIGlmKCAkJC5pcy5mbihvcHRzKSApe1xuICAgICAgICBmbiA9IG9wdHM7XG5cbiAgICAgIH0gZWxzZSBpZiggISQkLmlzLnBsYWluT2JqZWN0KG9wdHMpICl7XG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBuZWVkcyBvcHRzIG9yIGZuXG4gICAgICB9IFxuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgZWxlQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIG9wdHMgPSBmbiA/IGZuLmFwcGx5KGVsZSwgW2ksIGVsZV0pIDogb3B0cztcblxuICAgICAgICAvLyBhZGQgY2xhc3Nlc1xuICAgICAgICBpZiggb3B0cy5hZGQgKXsgZm9yKCB2YXIgaiA9IDA7IGogPCBvcHRzLmFkZC5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBjbHMgPSBvcHRzLmFkZFtqXTtcbiAgICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdO1xuXG4gICAgICAgICAgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXSA9IHRydWU7XG5cbiAgICAgICAgICBpZiggIWhhc0NsYXNzICYmICFlbGVDaGFuZ2VkICl7XG4gICAgICAgICAgICBjaGFuZ2VkLnB1c2goIGVsZSApO1xuICAgICAgICAgICAgZWxlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1cblxuICAgICAgICAvLyByZW1vdmUgY2xhc3Nlc1xuICAgICAgICBpZiggb3B0cy5yZW1vdmUgKXsgZm9yKCB2YXIgaiA9IDA7IGogPCBvcHRzLnJlbW92ZS5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBjbHMgPSBvcHRzLnJlbW92ZVtqXTtcbiAgICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdO1xuXG4gICAgICAgICAgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXSA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYoIGhhc0NsYXNzICYmICFlbGVDaGFuZ2VkICl7XG4gICAgICAgICAgICBjaGFuZ2VkLnB1c2goIGVsZSApO1xuICAgICAgICAgICAgZWxlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1cblxuICAgICAgICAvLyB0b2dnbGUgY2xhc3Nlc1xuICAgICAgICBpZiggb3B0cy50b2dnbGUgKXsgZm9yKCB2YXIgaiA9IDA7IGogPCBvcHRzLnRvZ2dsZS5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBjbHMgPSBvcHRzLnRvZ2dsZVtqXTtcbiAgICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdO1xuXG4gICAgICAgICAgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXSA9ICFoYXNDbGFzcztcblxuICAgICAgICAgIGlmKCAhZWxlQ2hhbmdlZCApe1xuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKCBlbGUgKTtcbiAgICAgICAgICAgIGVsZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBjaGFuZ2VkLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSwgY2hhbmdlZCApXG4gICAgICAgICAgLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgICAudHJpZ2dlcignY2xhc3MnKVxuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRDbGFzczogZnVuY3Rpb24oY2xhc3Nlcyl7XG4gICAgICBjbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNoYW5nZWQgPSBbXTtcbiAgICAgIFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2ldO1xuICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoY2xzKSApeyBjb250aW51ZTsgfVxuICAgICAgICBcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHNlbGZbal07XG4gICAgICAgICAgdmFyIGhhc0NsYXNzID0gZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXTtcbiAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcblxuICAgICAgICAgIGlmKCAhaGFzQ2xhc3MgKXsgLy8gaWYgZGlkbid0IGFscmVhZHkgaGF2ZSwgYWRkIHRvIGxpc3Qgb2YgY2hhbmdlZFxuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgICBpZiggY2hhbmdlZC5sZW5ndGggPiAwICl7XG4gICAgICAgIG5ldyAkJC5Db2xsZWN0aW9uKHRoaXMuX3ByaXZhdGUuY3ksIGNoYW5nZWQpXG4gICAgICAgICAgLnVwZGF0ZVN0eWxlKClcbiAgICAgICAgICAudHJpZ2dlcignY2xhc3MnKVxuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICBoYXNDbGFzczogZnVuY3Rpb24oY2xhc3NOYW1lKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgcmV0dXJuICggZWxlICE9IG51bGwgJiYgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xhc3NOYW1lXSApID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24oY2xhc3Nlc1N0ciwgdG9nZ2xlKXtcbiAgICAgIHZhciBjbGFzc2VzID0gY2xhc3Nlc1N0ci5zcGxpdCgvXFxzKy8pO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGNoYW5nZWQgPSBbXTsgLy8gZWxlcyB3aG8gaGFkIGNsYXNzZXMgY2hhbmdlZFxuICAgICAgXG4gICAgICBmb3IoIHZhciBpID0gMCwgaWwgPSBzZWxmLmxlbmd0aDsgaSA8IGlsOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbal07XG5cbiAgICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoY2xzKSApeyBjb250aW51ZTsgfVxuICAgICAgICAgIFxuICAgICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc107XG4gICAgICAgICAgdmFyIHNob3VsZEFkZCA9IHRvZ2dsZSB8fCAodG9nZ2xlID09PSB1bmRlZmluZWQgJiYgIWhhc0NsYXNzKTtcblxuICAgICAgICAgIGlmKCBzaG91bGRBZGQgKXtcbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiggIWhhc0NsYXNzICl7IGNoYW5nZWQucHVzaChlbGUpOyB9XG4gICAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZW1vdmVcbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYoIGhhc0NsYXNzICl7IGNoYW5nZWQucHVzaChlbGUpOyB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gLy8gZm9yIGogY2xhc3Nlc1xuICAgICAgfSAvLyBmb3IgaSBlbGVzXG4gICAgICBcbiAgICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgICBuZXcgJCQuQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCBjaGFuZ2VkKVxuICAgICAgICAgIC51cGRhdGVTdHlsZSgpXG4gICAgICAgICAgLnRyaWdnZXIoJ2NsYXNzJylcbiAgICAgICAgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzZXMpe1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjaGFuZ2VkID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc2VsZi5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gc2VsZltpXTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNsYXNzZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tqXTtcbiAgICAgICAgICBpZiggIWNscyB8fCBjbHMgPT09ICcnICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdO1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc10gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiggaGFzQ2xhc3MgKXsgLy8gdGhlbiB3ZSBjaGFuZ2VkIGl0cyBzZXQgb2YgY2xhc3Nlc1xuICAgICAgICAgICAgY2hhbmdlZC5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gdHJpZ2dlciB1cGRhdGUgc3R5bGUgb24gdGhvc2UgZWxlcyB0aGF0IGhhZCBjbGFzcyBjaGFuZ2VzXG4gICAgICBpZiggY2hhbmdlZC5sZW5ndGggPiAwICl7XG4gICAgICAgIG5ldyAkJC5Db2xsZWN0aW9uKHNlbGYuX3ByaXZhdGUuY3ksIGNoYW5nZWQpLnVwZGF0ZVN0eWxlKCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGYudHJpZ2dlcignY2xhc3MnKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH0sXG5cbiAgICBmbGFzaENsYXNzOiBmdW5jdGlvbihjbGFzc2VzLCBkdXJhdGlvbil7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIGlmKCBkdXJhdGlvbiA9PSBudWxsICl7XG4gICAgICAgIGR1cmF0aW9uID0gMjUwO1xuICAgICAgfSBlbHNlIGlmKCBkdXJhdGlvbiA9PT0gMCApe1xuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbm90aGluZyB0byBkbyByZWFsbHlcbiAgICAgIH1cblxuICAgICAgc2VsZi5hZGRDbGFzcyggY2xhc3NlcyApO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc2VzICk7XG4gICAgICB9LCBkdXJhdGlvbik7XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIGFsbEFyZTogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpLmxlbmd0aCA9PT0gdGhpcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihzZWxlY3RvcikubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgc29tZTogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHJldCA9IGZuLmFwcGx5KCB0aGlzQXJnLCBbIHRoaXNbaV0sIGksIHRoaXMgXSApO1xuXG4gICAgICAgIGlmKCByZXQgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIGV2ZXJ5OiBmdW5jdGlvbiggZm4sIHRoaXNBcmcgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcmV0ID0gZm4uYXBwbHkoIHRoaXNBcmcsIFsgdGhpc1tpXSwgaSwgdGhpcyBdICk7XG5cbiAgICAgICAgaWYoICFyZXQgKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIHNhbWU6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgICAgLy8gY2hlYXAgZXh0cmEgY2hlY2tcbiAgICAgIGlmKCB0aGlzLmxlbmd0aCAhPT0gY29sbGVjdGlvbi5sZW5ndGggKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3QoIGNvbGxlY3Rpb24gKS5sZW5ndGggPT09IHRoaXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBhbnlTYW1lOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdCggY29sbGVjdGlvbiApLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIGFsbEFyZU5laWdoYm9yczogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5pbnRlcnNlY3QoIGNvbGxlY3Rpb24gKS5sZW5ndGggPT09IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIENvbXBvdW5kIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAkJC5mbi5lbGVzKHtcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKCBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQgKTtcblxuICAgICAgICBpZiggcGFyZW50LnNpemUoKSA+IDAgKXtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goIHBhcmVudCApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHBhcmVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIHBhcmVudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIHBhcmVudHMgPSBbXTtcblxuICAgICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgd2hpbGUoIGVsZXMubm9uZW1wdHkoKSApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlcyA9IGVsZXMucGFyZW50KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCBwYXJlbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBjb21tb25BbmNlc3RvcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGFuY2VzdG9ycztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcGFyZW50cyA9IGVsZS5wYXJlbnRzKCk7XG4gICAgICAgIFxuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMgfHwgcGFyZW50cztcblxuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuaW50ZXJzZWN0KCBwYXJlbnRzICk7IC8vIGN1cnJlbnQgbGlzdCBtdXN0IGJlIGNvbW1vbiB3aXRoIGN1cnJlbnQgZWxlIHBhcmVudHMgc2V0XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbmNlc3RvcnMuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBvcnBoYW5zOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiB0aGlzLnN0ZEZpbHRlcihmdW5jdGlvbiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuaXNOb2RlKCkgJiYgZWxlLnBhcmVudCgpLmVtcHR5KCk7XG4gICAgICB9KS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIG5vbm9ycGhhbnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUucGFyZW50KCkubm9uZW1wdHkoKTtcbiAgICAgIH0pLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGNoaWxkcmVuID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5jb25jYXQoIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbiApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSwgY2hpbGRyZW4sIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkubm90KCB0aGlzICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBpc1BhcmVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0NoaWxkOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCAhPT0gdW5kZWZpbmVkICYmIGVsZS5wYXJlbnQoKS5sZW5ndGggIT09IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlc2NlbmRhbnRzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBhZGQoIGVsZXMgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcblxuICAgICAgICAgIGlmKCBlbGUuY2hpbGRyZW4oKS5ub25lbXB0eSgpICl7XG4gICAgICAgICAgICBhZGQoIGVsZS5jaGlsZHJlbigpICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkZCggdGhpcy5jaGlsZHJlbigpICk7XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGFsaWFzZXNcbiAgJCQuZWxlc2ZuLmFuY2VzdG9ycyA9ICQkLmVsZXNmbi5wYXJlbnRzO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgYm9yZGVyV2lkdGhNdWx0aXBsaWVyID0gMiAqIDAuNTtcbiAgdmFyIGJvcmRlcldpZHRoQWRqdXN0bWVudCA9IDA7XG5cbiAgJCQuZm4uZWxlcyh7XG5cbiAgICBkYXRhOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgICAnaWQnOiB0cnVlLFxuICAgICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcblxuICAgIHJlbW92ZURhdGE6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgICAnaWQnOiB0cnVlLFxuICAgICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcblxuICAgIHNjcmF0Y2g6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlXG4gICAgfSksXG5cbiAgICByZW1vdmVTY3JhdGNoOiAkJC5kZWZpbmUucmVtb3ZlRGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICAgIH0pLFxuXG4gICAgcnNjcmF0Y2g6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlUnNjcmF0Y2g6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICAgIH0pLFxuXG4gICAgaWQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHBvc2l0aW9uOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3Bvc2l0aW9uJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3J0cmlnZ2VyJyxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICAgIHZhbGlkS2V5czogWyd4JywgJ3knXSxcbiAgICAgIG9uU2V0OiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgIHVwZGF0ZWRFbGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgfSxcbiAgICAgIGNhblNldDogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIC8vIHBvc2l0aW9uIGJ1dCBubyBub3RpZmljYXRpb24gdG8gcmVuZGVyZXJcbiAgICBzaWxlbnRQb3NpdGlvbjogJCQuZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICAgICAgb25TZXQ6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICAgIGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIH0sXG4gICAgICBjYW5TZXQ6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gICAgICB9XG4gICAgfSksXG5cbiAgICBwb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MsIHNpbGVudCApe1xuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHBvcykgKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbihwb3MpO1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuZm4ocG9zKSApe1xuICAgICAgICB2YXIgZm4gPSBwb3M7XG4gICAgICAgIFxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAgIHZhciBwb3MgPSBmbi5hcHBseShlbGUsIFtpLCBlbGVdKTtcblxuICAgICAgICAgIGlmKCBwb3MgJiYgIWVsZS5sb2NrZWQoKSApe1xuICAgICAgICAgICAgdmFyIGVsZVBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGVsZVBvcy54ID0gcG9zLng7XG4gICAgICAgICAgICBlbGVQb3MueSA9IHBvcy55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cGRhdGVkRWxlcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgdmFyIHRvVHJpZ2dlciA9IHVwZGF0ZWRFbGVzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZEVsZXMgKSA6IHRoaXM7XG5cbiAgICAgICAgaWYoIHNpbGVudCApe1xuICAgICAgICAgIHRvVHJpZ2dlci50cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvVHJpZ2dlci5ydHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgc2lsZW50UG9zaXRpb25zOiBmdW5jdGlvbiggcG9zICl7XG4gICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnMoIHBvcywgdHJ1ZSApO1xuICAgIH0sXG5cbiAgICB1cGRhdGVDb21wb3VuZEJvdW5kczogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSB8fCAhY3kuaGFzQ29tcG91bmROb2RlcygpICl7IHJldHVybiBjeS5jb2xsZWN0aW9uKCk7IH0gLy8gc2F2ZSBjeWNsZXMgZm9yIG5vbiBjb21wb3VuZCBncmFwaHMgb3Igd2hlbiBzdHlsZSBkaXNhYmxlZFxuXG4gICAgICB2YXIgdXBkYXRlZCA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiB1cGRhdGUoIHBhcmVudCApe1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW4oKTtcbiAgICAgICAgdmFyIHN0eWxlID0gcGFyZW50Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgICB2YXIgYmIgPSBjaGlsZHJlbi5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IGZhbHNlLCBpbmNsdWRlRWRnZXM6IGZhbHNlIH0pO1xuICAgICAgICB2YXIgcGFkZGluZyA9IHtcbiAgICAgICAgICB0b3A6IHN0eWxlWydwYWRkaW5nLXRvcCddLnB4VmFsdWUsXG4gICAgICAgICAgYm90dG9tOiBzdHlsZVsncGFkZGluZy1ib3R0b20nXS5weFZhbHVlLFxuICAgICAgICAgIGxlZnQ6IHN0eWxlWydwYWRkaW5nLWxlZnQnXS5weFZhbHVlLFxuICAgICAgICAgIHJpZ2h0OiBzdHlsZVsncGFkZGluZy1yaWdodCddLnB4VmFsdWVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHBvcyA9IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIGRpZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCBzdHlsZVsnd2lkdGgnXS52YWx1ZSA9PT0gJ2F1dG8nICl7XG4gICAgICAgICAgcGFyZW50Ll9wcml2YXRlLmF1dG9XaWR0aCA9IGJiLncgKyBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICAgICAgICAgIHBvcy54ID0gKGJiLngxICsgYmIueDIgLSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0KS8yO1xuICAgICAgICAgIGRpZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggc3R5bGVbJ2hlaWdodCddLnZhbHVlID09PSAnYXV0bycgKXtcbiAgICAgICAgICBwYXJlbnQuX3ByaXZhdGUuYXV0b0hlaWdodCA9IGJiLmggKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tO1xuICAgICAgICAgIHBvcy55ID0gKGJiLnkxICsgYmIueTIgLSBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tKS8yO1xuICAgICAgICAgIGRpZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZGlkVXBkYXRlICl7XG4gICAgICAgICAgdXBkYXRlZC5wdXNoKCBwYXJlbnQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnbyB1cCwgbGV2ZWwgYnkgbGV2ZWxcbiAgICAgIHZhciBlbGVzID0gdGhpcy5wYXJlbnQoKTtcbiAgICAgIHdoaWxlKCBlbGVzLm5vbmVtcHR5KCkgKXtcblxuICAgICAgICAvLyB1cGRhdGUgZWFjaCBwYXJlbnQgbm9kZSBpbiB0aGlzIGxldmVsXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgICAgdXBkYXRlKCBlbGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5leHQgbGV2ZWxcbiAgICAgICAgZWxlcyA9IGVsZXMucGFyZW50KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybiBjaGFuZ2VkXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCB1cGRhdGVkICk7XG4gICAgfSxcblxuICAgIC8vIGdldC9zZXQgdGhlIHJlbmRlcmVkIChpLmUuIG9uIHNjcmVlbikgcG9zaXRvbiBvZiB0aGUgZWxlbWVudFxuICAgIHJlbmRlcmVkUG9zaXRpb246IGZ1bmN0aW9uKCBkaW0sIHZhbCApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciBycG9zID0gJCQuaXMucGxhaW5PYmplY3QoIGRpbSApID8gZGltIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIHNldHRpbmcgPSBycG9zICE9PSB1bmRlZmluZWQgfHwgKCB2YWwgIT09IHVuZGVmaW5lZCAmJiAkJC5pcy5zdHJpbmcoZGltKSApO1xuXG4gICAgICBpZiggZWxlICYmIGVsZS5pc05vZGUoKSApeyAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICAgIGlmKCBzZXR0aW5nICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcblxuICAgICAgICAgICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCBvbmUgZGltZW5zaW9uXG4gICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvbltkaW1dID0gKCB2YWwgLSBwYW5bZGltXSApL3pvb207XG4gICAgICAgICAgICB9IGVsc2UgaWYoIHJwb3MgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgd2hvbGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6ICggcnBvcy54IC0gcGFuLnggKSAvem9vbSxcbiAgICAgICAgICAgICAgICB5OiAoIHJwb3MueSAtIHBhbi55ICkgL3pvb21cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgICB9IGVsc2UgeyAvLyBnZXR0aW5nXG4gICAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICBycG9zID0ge1xuICAgICAgICAgICAgeDogcG9zLnggKiB6b29tICsgcGFuLngsXG4gICAgICAgICAgICB5OiBwb3MueSAqIHpvb20gKyBwYW4ueVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiggZGltID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiByZXR1cm4gdGhlIHdob2xlIHJlbmRlcmVkIHBvc2l0aW9uXG4gICAgICAgICAgICByZXR1cm4gcnBvcztcbiAgICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHJldHVybiB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvblxuICAgICAgICAgICAgcmV0dXJuIHJwb3NbIGRpbSBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKCAhc2V0dGluZyApe1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBmb3IgZW1wdHkgY29sbGVjdGlvbiBjYXNlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICAvLyBnZXQvc2V0IHRoZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgcGFyZW50XG4gICAgcGFyZW50UG9zaXRpb246IGZ1bmN0aW9uKCBkaW0sIHZhbCApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICB2YXIgcHBvcyA9ICQkLmlzLnBsYWluT2JqZWN0KCBkaW0gKSA/IGRpbSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBzZXR0aW5nID0gcHBvcyAhPT0gdW5kZWZpbmVkIHx8ICggdmFsICE9PSB1bmRlZmluZWQgJiYgJCQuaXMuc3RyaW5nKGRpbSkgKTtcbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgICBpZiggZWxlICYmIGVsZS5pc05vZGUoKSApeyAvLyBtdXN0IGhhdmUgYW4gZWxlbWVudCBhbmQgbXVzdCBiZSBhIG5vZGUgdG8gcmV0dXJuIHBvc2l0aW9uXG4gICAgICAgIGlmKCBzZXR0aW5nICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnBhcmVudCgpIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBoYXNQYXJlbnQgPSBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICAgICAgaWYoIGhhc1BhcmVudCApe1xuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbMF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW4gPSByZWxhdGl2ZVRvUGFyZW50ID8gcGFyZW50Ll9wcml2YXRlLnBvc2l0aW9uIDogeyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICAgIGlmKCB2YWwgIT09IHVuZGVmaW5lZCApeyAvLyBzZXQgb25lIGRpbWVuc2lvblxuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb25bZGltXSA9IHZhbCArIG9yaWdpbltkaW1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCBwcG9zICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IHdob2xlIHBvc2l0aW9uXG4gICAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5wb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBwcG9zLnggKyBvcmlnaW4ueCxcbiAgICAgICAgICAgICAgICB5OiBwcG9zLnkgKyBvcmlnaW4ueSxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuXG4gICAgICAgIH0gZWxzZSB7IC8vIGdldHRpbmdcbiAgICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBoYXNDb21wb3VuZE5vZGVzID8gZWxlLnBhcmVudCgpIDogbnVsbDtcbiAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICAgIHZhciByZWxhdGl2ZVRvUGFyZW50ID0gaGFzUGFyZW50O1xuXG4gICAgICAgICAgaWYoIGhhc1BhcmVudCApe1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBvcmlnaW4gPSByZWxhdGl2ZVRvUGFyZW50ID8gcGFyZW50Ll9wcml2YXRlLnBvc2l0aW9uIDogeyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICBwcG9zID0ge1xuICAgICAgICAgICAgeDogcG9zLnggLSBvcmlnaW4ueCxcbiAgICAgICAgICAgIHk6IHBvcy55IC0gb3JpZ2luLnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYoIGRpbSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gcmV0dXJuIHRoZSB3aG9sZSByZW5kZXJlZCBwb3NpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHBwb3M7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gdGhlbiByZXR1cm4gdGhlIHNwZWNpZmllZCBkaW1lbnNpb25cbiAgICAgICAgICAgIHJldHVybiBwcG9zWyBkaW0gXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiggIXNldHRpbmcgKXtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gZm9yIGVtcHR5IGNvbGxlY3Rpb24gY2FzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgLy8gY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gZ2V0IGEgbnVtZXJpY2FsIHZhbHVlIGZvciB0aGUgd2lkdGggb2YgdGhlIG5vZGUvZWRnZVxuICAgIHdpZHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgdyA9IGVsZS5fcHJpdmF0ZS5zdHlsZS53aWR0aDtcbiAgICAgICAgICByZXR1cm4gdy5zdHJWYWx1ZSA9PT0gJ2F1dG8nID8gZWxlLl9wcml2YXRlLmF1dG9XaWR0aCA6IHcucHhWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvdXRlcldpZHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGguc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvV2lkdGggOiBzdHlsZS53aWR0aC5weFZhbHVlO1xuICAgICAgICAgIHZhciBib3JkZXIgPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10gPyBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZSAqIGJvcmRlcldpZHRoTXVsdGlwbGllciArIGJvcmRlcldpZHRoQWRqdXN0bWVudCA6IDA7XG5cbiAgICAgICAgICByZXR1cm4gd2lkdGggKyBib3JkZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHZhciB3aWR0aCA9IGVsZS53aWR0aCgpO1xuICAgICAgICByZXR1cm4gd2lkdGggKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJlZE91dGVyV2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgb3dpZHRoID0gZWxlLm91dGVyV2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIG93aWR0aCAqIHRoaXMuY3koKS56b29tKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgdGhlIGhlaWdodCBvZiB0aGUgbm9kZVxuICAgIGhlaWdodDogZnVuY3Rpb24oKXsgXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IGVsZS5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgaCA9IGVsZS5fcHJpdmF0ZS5zdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuIGguc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvSGVpZ2h0IDogaC5weFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG91dGVySGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgICBpZiggZWxlICYmIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBzdHlsZS5oZWlnaHQuc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvSGVpZ2h0IDogc3R5bGUuaGVpZ2h0LnB4VmFsdWU7XG4gICAgICAgICAgdmFyIGJvcmRlciA9IHN0eWxlWydib3JkZXItd2lkdGgnXSA/IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlICogYm9yZGVyV2lkdGhNdWx0aXBsaWVyICsgYm9yZGVyV2lkdGhBZGp1c3RtZW50IDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWlnaHQgKyBib3JkZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIHZhciBoZWlnaHQgPSBlbGUuaGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBoZWlnaHQgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJlZE91dGVySGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIHZhciBvaGVpZ2h0ID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBvaGVpZ2h0ICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyZWRCb3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3goIG9wdGlvbnMgKTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuXG4gICAgICB2YXIgeDEgPSBiYi54MSAqIHpvb20gKyBwYW4ueDtcbiAgICAgIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICAgICAgdmFyIHkxID0gYmIueTEgKiB6b29tICsgcGFuLnk7XG4gICAgICB2YXIgeTIgPSBiYi55MiAqIHpvb20gKyBwYW4ueTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeTI6IHkyLFxuICAgICAgICB3OiB4MiAtIHgxLFxuICAgICAgICBoOiB5MiAtIHkxXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudHMgKGluIHJhdyBtb2RlbCBwb3NpdGlvbilcbiAgICBib3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBjeSA9IGVsZXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlO1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5X3Auc3R5bGVFbmFibGVkO1xuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIGluY2x1ZGVOb2RlcyA9IG9wdGlvbnMuaW5jbHVkZU5vZGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5pbmNsdWRlTm9kZXM7XG4gICAgICB2YXIgaW5jbHVkZUVkZ2VzID0gb3B0aW9ucy5pbmNsdWRlRWRnZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVFZGdlcztcbiAgICAgIHZhciBpbmNsdWRlTGFiZWxzID0gb3B0aW9ucy5pbmNsdWRlTGFiZWxzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5pbmNsdWRlTGFiZWxzO1xuXG4gICAgICAvLyByZWNhbGN1bGF0ZSBwcm9qZWN0aW9ucyBldGNcbiAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgY3lfcC5yZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoIHRoaXMgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHgxID0gSW5maW5pdHk7XG4gICAgICB2YXIgeDIgPSAtSW5maW5pdHk7XG4gICAgICB2YXIgeTEgPSBJbmZpbml0eTtcbiAgICAgIHZhciB5MiA9IC1JbmZpbml0eTtcblxuICAgICAgLy8gZmluZCBib3VuZHMgb2YgZWxlbWVudHNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgZGlzcGxheSA9IHN0eWxlRW5hYmxlZCA/IF9wLnN0eWxlWydkaXNwbGF5J10udmFsdWUgOiAnZWxlbWVudCc7XG4gICAgICAgIHZhciBpc05vZGUgPSBfcC5ncm91cCA9PT0gJ25vZGVzJztcbiAgICAgICAgdmFyIGV4MSwgZXgyLCBleTEsIGV5MiwgeCwgeTtcbiAgICAgICAgdmFyIGluY2x1ZGVkRWxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIGRpc3BsYXkgPT09ICdub25lJyApeyBjb250aW51ZTsgfSAvLyB0aGVuIGVsZSBkb2Vzbid0IHRha2UgdXAgc3BhY2UgICAgICBcblxuICAgICAgICBpZiggaXNOb2RlICYmIGluY2x1ZGVOb2RlcyApe1xuICAgICAgICAgIGluY2x1ZGVkRWxlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBwb3MgPSBfcC5wb3NpdGlvbjtcbiAgICAgICAgICB4ID0gcG9zLng7XG4gICAgICAgICAgeSA9IHBvcy55O1xuICAgICAgICAgIHZhciB3ID0gZWxlLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICB2YXIgaGFsZlcgPSB3LzI7XG4gICAgICAgICAgdmFyIGggPSBlbGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgICB2YXIgaGFsZkggPSBoLzI7XG5cbiAgICAgICAgICAvLyBoYW5kbGUgbm9kZSBkaW1lbnNpb25zXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgZXgxID0geCAtIGhhbGZXO1xuICAgICAgICAgIGV4MiA9IHggKyBoYWxmVztcbiAgICAgICAgICBleTEgPSB5IC0gaGFsZkg7XG4gICAgICAgICAgZXkyID0geSArIGhhbGZIO1xuXG4gICAgICAgICAgeDEgPSBleDEgPCB4MSA/IGV4MSA6IHgxO1xuICAgICAgICAgIHgyID0gZXgyID4geDIgPyBleDIgOiB4MjtcbiAgICAgICAgICB5MSA9IGV5MSA8IHkxID8gZXkxIDogeTE7XG4gICAgICAgICAgeTIgPSBleTIgPiB5MiA/IGV5MiA6IHkyO1xuXG4gICAgICAgIH0gZWxzZSBpZiggZWxlLmlzRWRnZSgpICYmIGluY2x1ZGVFZGdlcyApeyBcbiAgICAgICAgICBpbmNsdWRlZEVsZSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgbjFwb3MgPSBlbGUuX3ByaXZhdGUuc291cmNlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBuMnBvcyA9IGVsZS5fcHJpdmF0ZS50YXJnZXQuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgICAvLyBoYW5kbGUgZWRnZSBkaW1lbnNpb25zIChyb3VnaCBib3ggZXN0aW1hdGUpXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgdmFyIHJzdHlsZSA9IGVsZS5fcHJpdmF0ZS5yc3R5bGUgfHwge307XG5cbiAgICAgICAgICBleDEgPSBuMXBvcy54O1xuICAgICAgICAgIGV4MiA9IG4ycG9zLng7XG4gICAgICAgICAgZXkxID0gbjFwb3MueTtcbiAgICAgICAgICBleTIgPSBuMnBvcy55O1xuXG4gICAgICAgICAgaWYoIGV4MSA+IGV4MiApe1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBleDE7XG4gICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICBleDIgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBleTEgPiBleTIgKXtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gZXkxO1xuICAgICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgICAgZXkyID0gdGVtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICAgIHkxID0gZXkxIDwgeTEgPyBleTEgOiB5MTtcbiAgICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7XG5cbiAgICAgICAgICAvLyBoYW5kbGUgcG9pbnRzIGFsb25nIGVkZ2UgKHNhbml0eSBjaGVjaylcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICAgIHZhciBicHRzID0gcnN0eWxlLmJlemllclB0cyB8fCBbXTtcblxuICAgICAgICAgICAgdmFyIHcgPSBlbGUuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZTtcbiAgICAgICAgICAgIHZhciB3SGFsZiA9IHcvMjtcblxuICAgICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBicHRzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICAgIHZhciBicHQgPSBicHRzW2pdO1xuXG4gICAgICAgICAgICAgIGV4MSA9IGJwdC54IC0gd0hhbGY7XG4gICAgICAgICAgICAgIGV4MiA9IGJwdC54ICsgd0hhbGY7XG4gICAgICAgICAgICAgIGV5MSA9IGJwdC55IC0gd0hhbGY7XG4gICAgICAgICAgICAgIGV5MiA9IGJwdC55ICsgd0hhbGY7XG5cbiAgICAgICAgICAgICAgeDEgPSBleDEgPCB4MSA/IGV4MSA6IHgxO1xuICAgICAgICAgICAgICB4MiA9IGV4MiA+IHgyID8gZXgyIDogeDI7XG4gICAgICAgICAgICAgIHkxID0gZXkxIDwgeTEgPyBleTEgOiB5MTtcbiAgICAgICAgICAgICAgeTIgPSBleTIgPiB5MiA/IGV5MiA6IHkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IC8vIGVkZ2VzXG5cbiAgICAgICAgLy8gaGFuZGxlIGxhYmVsIGRpbWVuc2lvbnNcbiAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG5cbiAgICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgICAgdmFyIHJzdHlsZSA9IGVsZS5fcHJpdmF0ZS5yc3R5bGU7XG4gICAgICAgICAgdmFyIGxhYmVsID0gc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICAgICAgICB2YXIgZm9udFNpemUgPSBzdHlsZVsnZm9udC1zaXplJ107XG4gICAgICAgICAgdmFyIGhhbGlnbiA9IHN0eWxlWyd0ZXh0LWhhbGlnbiddO1xuICAgICAgICAgIHZhciB2YWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXTtcbiAgICAgICAgICB2YXIgbGFiZWxXaWR0aCA9IHJzdHlsZS5sYWJlbFdpZHRoO1xuICAgICAgICAgIHZhciBsYWJlbEhlaWdodCA9IHJzdHlsZS5sYWJlbEhlaWdodDtcbiAgICAgICAgICB2YXIgbGFiZWxYID0gcnN0eWxlLmxhYmVsWDtcbiAgICAgICAgICB2YXIgbGFiZWxZID0gcnN0eWxlLmxhYmVsWTtcblxuICAgICAgICAgIGlmKCBpbmNsdWRlZEVsZSAmJiBpbmNsdWRlTGFiZWxzICYmIGxhYmVsICYmIGZvbnRTaXplICYmIGxhYmVsSGVpZ2h0ICE9IG51bGwgJiYgbGFiZWxXaWR0aCAhPSBudWxsICYmIGxhYmVsWCAhPSBudWxsICYmIGxhYmVsWSAhPSBudWxsICYmIGhhbGlnbiAmJiB2YWxpZ24gKXtcbiAgICAgICAgICAgIHZhciBsaCA9IGxhYmVsSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGx3ID0gbGFiZWxXaWR0aDtcbiAgICAgICAgICAgIHZhciBseDEsIGx4MiwgbHkxLCBseTI7XG5cbiAgICAgICAgICAgIGlmKCBlbGUuaXNFZGdlKCkgKXtcbiAgICAgICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHcvMjtcbiAgICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHcvMjtcbiAgICAgICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGgvMjtcbiAgICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGgvMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3aXRjaCggaGFsaWduLnZhbHVlICl7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdztcbiAgICAgICAgICAgICAgICAgIGx4MiA9IGxhYmVsWDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3LzI7XG4gICAgICAgICAgICAgICAgICBseDIgPSBsYWJlbFggKyBsdy8yO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgICBseDEgPSBsYWJlbFg7XG4gICAgICAgICAgICAgICAgICBseDIgPSBsYWJlbFggKyBsdztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3dpdGNoKCB2YWxpZ24udmFsdWUgKXtcbiAgICAgICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGg7XG4gICAgICAgICAgICAgICAgICBseTIgPSBsYWJlbFk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICBseTEgPSBsYWJlbFkgLSBsaC8yO1xuICAgICAgICAgICAgICAgICAgbHkyID0gbGFiZWxZICsgbGgvMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgICAgIGx5MSA9IGxhYmVsWTtcbiAgICAgICAgICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeDEgPSBseDEgPCB4MSA/IGx4MSA6IHgxO1xuICAgICAgICAgICAgeDIgPSBseDIgPiB4MiA/IGx4MiA6IHgyO1xuICAgICAgICAgICAgeTEgPSBseTEgPCB5MSA/IGx5MSA6IHkxO1xuICAgICAgICAgICAgeTIgPSBseTIgPiB5MiA/IGx5MiA6IHkyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBzdHlsZSBlbmFibGVkXG4gICAgICB9IC8vIGZvclxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogeDEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHc6IHgyIC0geDEsXG4gICAgICAgIGg6IHkyIC0geTFcbiAgICAgIH07XG4gICAgfVxuICB9KTsgXG5cbiAgLy8gaW4gY2FzZSBzb21lIHVzZXJzIHdhbnQgdG8gYmUgZXhwbGljaXRcbiAgJCQuZWxlc2ZuLm1vZGVsUG9zaXRpb24gPSAkJC5lbGVzZm4ucG9zaXRpb247XG4gICQkLmVsZXNmbi5tb2RlbFBvc2l0aW9ucyA9ICQkLmVsZXNmbi5wb3NpdGlvbnM7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCAkJCApeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyBSZWd1bGFyIGRlZ3JlZSBmdW5jdGlvbnMgKHdvcmtzIG9uIHNpbmdsZSBlbGVtZW50KVxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICBmdW5jdGlvbiBkZWZpbmVEZWdyZWVGdW5jdGlvbihjYWxsYmFjayl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBpbmNsdWRlTG9vcHMgKXtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgaWYoIGluY2x1ZGVMb29wcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGluY2x1ZGVMb29wcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBzZWxmLmxlbmd0aCA9PT0gMCApeyByZXR1cm47IH1cblxuICAgICAgaWYoIHNlbGYuaXNOb2RlKCkgJiYgIXNlbGYucmVtb3ZlZCgpICl7XG4gICAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgICB2YXIgbm9kZSA9IHNlbGZbMF07XG4gICAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb25uZWN0ZWRFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkRWRnZXNbaV07XG5cbiAgICAgICAgICBpZiggIWluY2x1ZGVMb29wcyAmJiBlZGdlLmlzTG9vcCgpICl7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWdyZWUgKz0gY2FsbGJhY2soIG5vZGUsIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGRlZ3JlZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICBkZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uKG5vZGUsIGVkZ2Upe1xuICAgICAgaWYoIGVkZ2Uuc291cmNlKCkuc2FtZSggZWRnZS50YXJnZXQoKSApICl7XG4gICAgICAgIHJldHVybiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgfSksXG5cbiAgICBpbmRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24obm9kZSwgZWRnZSl7XG4gICAgICBpZiggZWRnZS50YXJnZXQoKS5zYW1lKG5vZGUpICl7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSksXG5cbiAgICBvdXRkZWdyZWU6IGRlZmluZURlZ3JlZUZ1bmN0aW9uKGZ1bmN0aW9uKG5vZGUsIGVkZ2Upe1xuICAgICAgaWYoIGVkZ2Uuc291cmNlKCkuc2FtZShub2RlKSApe1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0pXG4gIH0pO1xuICBcbiAgXG4gIC8vIENvbGxlY3Rpb24gZGVncmVlIHN0YXRzXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIGZ1bmN0aW9uIGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKGRlZ3JlZUZuLCBjYWxsYmFjayl7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBpbmNsdWRlTG9vcHMgKXtcbiAgICAgIHZhciByZXQ7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgZGVncmVlID0gZWxlW2RlZ3JlZUZuXSggaW5jbHVkZUxvb3BzICk7XG4gICAgICAgIGlmKCBkZWdyZWUgIT09IHVuZGVmaW5lZCAmJiAocmV0ID09PSB1bmRlZmluZWQgfHwgY2FsbGJhY2soZGVncmVlLCByZXQpKSApe1xuICAgICAgICAgIHJldCA9IGRlZ3JlZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gIH1cbiAgXG4gICQkLmZuLmVsZXMoe1xuICAgIG1pbkRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWluKXtcbiAgICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gICAgfSksXG5cbiAgICBtYXhEZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1heCl7XG4gICAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICAgIH0pLFxuXG4gICAgbWluSW5kZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdpbmRlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWluKXtcbiAgICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gICAgfSksXG5cbiAgICBtYXhJbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtYXgpe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA+IG1heDtcbiAgICB9KSxcblxuICAgIG1pbk91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWluKXtcbiAgICAgIHJldHVybiBkZWdyZWUgPCBtaW47XG4gICAgfSksXG5cbiAgICBtYXhPdXRkZWdyZWU6IGRlZmluZURlZ3JlZUJvdW5kc0Z1bmN0aW9uKCdvdXRkZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1heCl7XG4gICAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICAgIH0pXG4gIH0pO1xuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgdG90YWxEZWdyZWU6IGZ1bmN0aW9uKCBpbmNsdWRlTG9vcHMgKXtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdG90YWwgKz0gbm9kZXNbaV0uZGVncmVlKCBpbmNsdWRlTG9vcHMgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG4gIFxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIEZ1bmN0aW9ucyBmb3IgYmluZGluZyAmIHRyaWdnZXJpbmcgZXZlbnRzXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gICQkLmZuLmVsZXMoe1xuICAgIG9uOiAkJC5kZWZpbmUub24oKSwgLy8gLm9uKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGRhdGFdLCBoYW5kbGVyKVxuICAgIG9uZTogJCQuZGVmaW5lLm9uKHsgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9KSxcbiAgICBvbmNlOiAkJC5kZWZpbmUub24oeyB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiB0cnVlIH0pLFxuICAgIG9mZjogJCQuZGVmaW5lLm9mZigpLCAvLyAub2ZmKCBldmVudHMgWywgc2VsZWN0b3JdIFssIGhhbmRsZXJdIClcbiAgICB0cmlnZ2VyOiAkJC5kZWZpbmUudHJpZ2dlcigpLCAvLyAudHJpZ2dlciggZXZlbnRzIFssIGV4dHJhUGFyYW1zXSApXG5cbiAgICBydHJpZ2dlcjogZnVuY3Rpb24oZXZlbnQsIGV4dHJhUGFyYW1zKXsgLy8gZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICBpZiggdGhpcy5sZW5ndGggPT09IDAgKXsgcmV0dXJuOyB9IC8vIGVtcHR5IGNvbGxlY3Rpb25zIGRvbid0IG5lZWQgdG8gbm90aWZ5IGFueXRoaW5nXG5cbiAgICAgIC8vIG5vdGlmeSByZW5kZXJlclxuICAgICAgdGhpcy5jeSgpLm5vdGlmeSh7XG4gICAgICAgIHR5cGU6IGV2ZW50LFxuICAgICAgICBjb2xsZWN0aW9uOiB0aGlzXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50LCBleHRyYVBhcmFtcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGFsaWFzZXMgZm9yIHRob3NlIGZvbGtzIHdobyBsaWtlIG9sZCBzdHVmZjpcbiAgJCQuZWxlc2ZuLmJpbmQgPSAkJC5lbGVzZm4ub247XG4gICQkLmVsZXNmbi51bmJpbmQgPSAkJC5lbGVzZm4ub2ZmO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcbiAgICBub2RlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50LmlzTm9kZSgpO1xuICAgICAgfSkuZmlsdGVyKHNlbGVjdG9yKTtcbiAgICB9LFxuXG4gICAgZWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgICByZXR1cm4gZWxlbWVudC5pc0VkZ2UoKTtcbiAgICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIGZpbHRlcjogZnVuY3Rpb24oIGZpbHRlciApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIFxuICAgICAgaWYoICQkLmlzLmZuKGZpbHRlcikgKXtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICBpZiggZmlsdGVyLmFwcGx5KGVsZSwgW2ksIGVsZV0pICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIGVsZW1lbnRzKTtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcoZmlsdGVyKSB8fCAkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKGZpbHRlcikgKXtcbiAgICAgICAgcmV0dXJuIG5ldyAkJC5TZWxlY3RvcihmaWx0ZXIpLmZpbHRlcih0aGlzKTtcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCBmaWx0ZXIgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSApOyAvLyBpZiBub3QgaGFuZGxlZCBieSBhYm92ZSwgZ2l2ZSAnZW0gYW4gZW1wdHkgY29sbGVjdGlvblxuICAgIH0sXG5cbiAgICBub3Q6IGZ1bmN0aW9uKCB0b1JlbW92ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgaWYoICF0b1JlbW92ZSApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICBcbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyggdG9SZW1vdmUgKSApe1xuICAgICAgICAgIHRvUmVtb3ZlID0gdGhpcy5maWx0ZXIoIHRvUmVtb3ZlICk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgdmFyIHJlbW92ZSA9IHRvUmVtb3ZlLl9wcml2YXRlLmlkc1sgZWxlbWVudC5pZCgpIF07XG4gICAgICAgICAgaWYoICFyZW1vdmUgKXtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZW1lbnQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzICk7XG4gICAgICB9XG4gICAgICBcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0OiBmdW5jdGlvbiggb3RoZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICBcbiAgICAgIC8vIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGVuIGZpbHRlciBieSBpdCBpbnN0ZWFkXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKG90aGVyKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBvdGhlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBjb2wxID0gdGhpcztcbiAgICAgIHZhciBjb2wyID0gb3RoZXI7XG4gICAgICB2YXIgY29sMVNtYWxsZXIgPSB0aGlzLmxlbmd0aCA8IG90aGVyLmxlbmd0aDtcbiAgICAgIC8vIHZhciBpZHMxID0gY29sMVNtYWxsZXIgPyBjb2wxLl9wcml2YXRlLmlkcyA6IGNvbDIuX3ByaXZhdGUuaWRzO1xuICAgICAgdmFyIGlkczIgPSBjb2wxU21hbGxlciA/IGNvbDIuX3ByaXZhdGUuaWRzIDogY29sMS5fcHJpdmF0ZS5pZHM7XG4gICAgICB2YXIgY29sID0gY29sMVNtYWxsZXIgPyBjb2wxIDogY29sMjtcbiAgICAgIFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGlkID0gY29sW2ldLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBlbGUgPSBpZHMyWyBpZCBdO1xuXG4gICAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBlbGVtZW50cyApO1xuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKCB0b0FkZCApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTsgICAgXG4gICAgICBcbiAgICAgIGlmKCAhdG9BZGQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcodG9BZGQpICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgICB0b0FkZCA9IGN5LmVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBlbGVtZW50cy5wdXNoKCB0aGlzW2ldICk7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKysgKXtcblxuICAgICAgICB2YXIgYWRkID0gIXRoaXMuX3ByaXZhdGUuaWRzWyB0b0FkZFtpXS5pZCgpIF07XG4gICAgICAgIGlmKCBhZGQgKXtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCB0b0FkZFtpXSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBpbiBwbGFjZSBtZXJnZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgICBtZXJnZTogZnVuY3Rpb24oIHRvQWRkICl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIGN5ID0gX3AuY3k7ICAgIFxuICAgICAgXG4gICAgICBpZiggIXRvQWRkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKHRvQWRkKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0b0FkZDtcbiAgICAgICAgdG9BZGQgPSBjeS5lbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHRvQWRkRWxlID0gdG9BZGRbaV07XG4gICAgICAgIHZhciBpZCA9IHRvQWRkRWxlLmlkKCk7XG4gICAgICAgIHZhciBhZGQgPSAhX3AuaWRzWyBpZCBdO1xuXG4gICAgICAgIGlmKCBhZGQgKXtcbiAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmxlbmd0aCsrO1xuXG4gICAgICAgICAgdGhpc1sgaW5kZXggXSA9IHRvQWRkRWxlO1xuICAgICAgICAgIF9wLmlkc1sgaWQgXSA9IHRvQWRkRWxlO1xuICAgICAgICAgIF9wLmluZGV4ZXNbIGlkIF0gPSBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgLy8gcmVtb3ZlIHNpbmdsZSBlbGUgaW4gcGxhY2UgaW4gY2FsbGluZyBjb2xsZWN0aW9uXG4gICAgdW5tZXJnZU9uZTogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgZWxlID0gZWxlWzBdO1xuXG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIGlkID0gZWxlLmlkKCk7XG4gICAgICB2YXIgaSA9IF9wLmluZGV4ZXNbIGlkIF07XG5cbiAgICAgIGlmKCBpID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIG5vIG5lZWQgdG8gcmVtb3ZlXG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSBlbGVcbiAgICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICBfcC5pZHNbIGlkIF0gPSB1bmRlZmluZWQ7XG4gICAgICBfcC5pbmRleGVzWyBpZCBdID0gdW5kZWZpbmVkO1xuXG4gICAgICB2YXIgdW5tZXJnZWRMYXN0RWxlID0gaSA9PT0gdGhpcy5sZW5ndGggLSAxO1xuXG4gICAgICAvLyByZXBsYWNlIGVtcHR5IHNwb3Qgd2l0aCBsYXN0IGVsZSBpbiBjb2xsZWN0aW9uXG4gICAgICBpZiggdGhpcy5sZW5ndGggPiAxICYmICF1bm1lcmdlZExhc3RFbGUgKXtcbiAgICAgICAgdmFyIGxhc3RFbGVJID0gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgbGFzdEVsZSA9IHRoaXNbIGxhc3RFbGVJIF07XG5cbiAgICAgICAgdGhpc1sgbGFzdEVsZUkgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpc1tpXSA9IGxhc3RFbGU7XG4gICAgICAgIF9wLmluZGV4ZXNbIGxhc3RFbGUuaWQoKSBdID0gaTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIGNvbGxlY3Rpb24gaXMgbm93IDEgZWxlIHNtYWxsZXJcbiAgICAgIHRoaXMubGVuZ3RoLS07XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyByZW1vdmUgZWxlcyBpbiBwbGFjZSBvbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgICB1bm1lcmdlOiBmdW5jdGlvbiggdG9SZW1vdmUgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7ICAgIFxuICAgICAgXG4gICAgICBpZiggIXRvUmVtb3ZlICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKHRvUmVtb3ZlKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0b1JlbW92ZTtcbiAgICAgICAgdG9SZW1vdmUgPSBjeS5lbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdGhpcy51bm1lcmdlT25lKCB0b1JlbW92ZVtpXSApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgbWFwOiBmdW5jdGlvbiggbWFwRm4sIHRoaXNBcmcgKXtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgcmV0ID0gbWFwRm4uYXBwbHkoIHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdICk7XG5cbiAgICAgICAgYXJyLnB1c2goIHJldCApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBzdGRGaWx0ZXI6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgICAgdmFyIGZpbHRlckVsZXMgPSBbXTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIGluY2x1ZGUgPSBmbi5hcHBseSggdGhpc0FyZywgW2VsZSwgaSwgZWxlc10gKTtcblxuICAgICAgICBpZiggaW5jbHVkZSApe1xuICAgICAgICAgIGZpbHRlckVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZmlsdGVyRWxlcyApO1xuICAgIH0sXG5cbiAgICBtYXg6IGZ1bmN0aW9uKCB2YWxGbiwgdGhpc0FyZyApe1xuICAgICAgdmFyIG1heCA9IC1JbmZpbml0eTtcbiAgICAgIHZhciBtYXhFbGU7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IHZhbEZuLmFwcGx5KCB0aGlzQXJnLCBbIGVsZSwgaSwgZWxlcyBdICk7XG5cbiAgICAgICAgaWYoIHZhbCA+IG1heCApe1xuICAgICAgICAgIG1heCA9IHZhbDtcbiAgICAgICAgICBtYXhFbGUgPSBlbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG1heCxcbiAgICAgICAgZWxlOiBtYXhFbGVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIG1pbjogZnVuY3Rpb24oIHZhbEZuLCB0aGlzQXJnICl7XG4gICAgICB2YXIgbWluID0gSW5maW5pdHk7XG4gICAgICB2YXIgbWluRWxlO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciB2YWwgPSB2YWxGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApO1xuXG4gICAgICAgIGlmKCB2YWwgPCBtaW4gKXtcbiAgICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgICAgbWluRWxlID0gZWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBtaW4sXG4gICAgICAgIGVsZTogbWluRWxlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcbiAgICBpc05vZGU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnbm9kZXMnO1xuICAgIH0sXG5cbiAgICBpc0VkZ2U6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5ncm91cCgpID09PSAnZWRnZXMnO1xuICAgIH0sXG5cbiAgICBpc0xvb3A6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpLmlkKCkgPT09IHRoaXMudGFyZ2V0KCkuaWQoKTtcbiAgICB9LFxuXG4gICAgaXNTaW1wbGU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5pc0VkZ2UoKSAmJiB0aGlzLnNvdXJjZSgpLmlkKCkgIT09IHRoaXMudGFyZ2V0KCkuaWQoKTtcbiAgICB9LFxuXG4gICAgZ3JvdXA6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmdyb3VwO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyBGdW5jdGlvbnMgZm9yIGl0ZXJhdGluZyBvdmVyIGNvbGxlY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gICQkLmZuLmVsZXMoe1xuICAgIGVhY2g6IGZ1bmN0aW9uKGZuKXtcbiAgICAgIGlmKCAkJC5pcy5mbihmbikgKXtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICAgIHZhciByZXQgPSBmbi5hcHBseSggZWxlLCBbIGksIGVsZSBdICk7XG5cbiAgICAgICAgICBpZiggcmV0ID09PSBmYWxzZSApeyBicmVhazsgfSAvLyBleGl0IGVhY2ggZWFybHkgb24gcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihmbiwgdGhpc0FyZyl7XG4gICAgICBpZiggJCQuaXMuZm4oZm4pICl7XG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICAgIHZhciByZXQgPSBmbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIHRoaXMgXSApO1xuXG4gICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICBcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgYXJyYXkucHVzaCggdGhpc1tpXSApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihzdGFydCwgZW5kKXtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgdmFyIHRoaXNTaXplID0gdGhpcy5sZW5ndGg7XG4gICAgICBcbiAgICAgIGlmKCBlbmQgPT0gbnVsbCApe1xuICAgICAgICBlbmQgPSB0aGlzU2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHN0YXJ0ID09IG51bGwgKXtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggc3RhcnQgPCAwICl7XG4gICAgICAgIHN0YXJ0ID0gdGhpc1NpemUgKyBzdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYoIGVuZCA8IDAgKXtcbiAgICAgICAgZW5kID0gdGhpc1NpemUgKyBlbmQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKyl7XG4gICAgICAgIGFycmF5LnB1c2goIHRoaXNbaV0gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKHRoaXMuY3koKSwgYXJyYXkpO1xuICAgIH0sXG5cbiAgICBzaXplOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBlcTogZnVuY3Rpb24oaSl7XG4gICAgICByZXR1cm4gdGhpc1tpXSB8fCBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpICk7XG4gICAgfSxcblxuICAgIGZpcnN0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXNbMF0gfHwgbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSApO1xuICAgIH0sXG5cbiAgICBsYXN0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXNbIHRoaXMubGVuZ3RoIC0gMSBdIHx8IG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCkgKTtcbiAgICB9LFxuXG4gICAgZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gICAgfSxcblxuICAgIG5vbmVtcHR5OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICF0aGlzLmVtcHR5KCk7XG4gICAgfSxcblxuICAgIHNvcnQ6IGZ1bmN0aW9uKCBzb3J0Rm4gKXtcbiAgICAgIGlmKCAhJCQuaXMuZm4oIHNvcnRGbiApICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7ICAgICAgXG4gICAgICB2YXIgc29ydGVkID0gdGhpcy50b0FycmF5KCkuc29ydCggc29ydEZuICk7XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgc29ydGVkKTtcbiAgICB9LFxuXG4gICAgc29ydEJ5WkluZGV4OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuc29ydCggJCQuQ29sbGVjdGlvbi56SW5kZXhTb3J0ICk7XG4gICAgfSxcblxuICAgIHpEZXB0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgaWYoICFlbGUgKXsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgZ3JvdXAgPSBfcC5ncm91cDtcblxuICAgICAgaWYoIGdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIHJldHVybiBfcC5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkuc2l6ZSgpIDogMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNEZXB0aCA9IHNyYy5fcHJpdmF0ZS5kYXRhLnBhcmVudCA/IHNyYy5wYXJlbnRzKCkuc2l6ZSgpIDogMDtcbiAgICAgICAgdmFyIHRndERlcHRoID0gdGd0Ll9wcml2YXRlLmRhdGEucGFyZW50ID8gdGd0LnBhcmVudHMoKS5zaXplKCkgOiAwO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCggc3JjRGVwdGggLSAxLCB0Z3REZXB0aCAtIDEsIDAgKSArIDAuNTsgLy8gZGVwdGggb2YgZGVlcGVzdCBwYXJlbnQgYW5kIGp1c3QgYSBiaXQgYWJvdmVcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gICQkLkNvbGxlY3Rpb24uekluZGV4U29ydCA9IGZ1bmN0aW9uKGEsIGIpe1xuICAgIHZhciBjeSA9IGEuY3koKTtcbiAgICB2YXIgYV9wID0gYS5fcHJpdmF0ZTtcbiAgICB2YXIgYl9wID0gYi5fcHJpdmF0ZTtcbiAgICB2YXIgekRpZmYgPSBhX3Auc3R5bGVbJ3otaW5kZXgnXS52YWx1ZSAtIGJfcC5zdHlsZVsnei1pbmRleCddLnZhbHVlO1xuICAgIHZhciBkZXB0aEEgPSAwO1xuICAgIHZhciBkZXB0aEIgPSAwO1xuICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgIHZhciBhSXNOb2RlID0gYV9wLmdyb3VwID09PSAnbm9kZXMnO1xuICAgIHZhciBhSXNFZGdlID0gYV9wLmdyb3VwID09PSAnZWRnZXMnO1xuICAgIHZhciBiSXNOb2RlID0gYl9wLmdyb3VwID09PSAnbm9kZXMnO1xuICAgIHZhciBiSXNFZGdlID0gYl9wLmdyb3VwID09PSAnZWRnZXMnO1xuXG4gICAgLy8gbm8gbmVlZCB0byBjYWxjdWxhdGUgZWxlbWVudCBkZXB0aCBpZiB0aGVyZSBpcyBubyBjb21wb3VuZCBub2RlXG4gICAgaWYoIGhhc0NvbXBvdW5kTm9kZXMgKXtcbiAgICAgIGRlcHRoQSA9IGEuekRlcHRoKCk7XG4gICAgICBkZXB0aEIgPSBiLnpEZXB0aCgpO1xuICAgIH1cblxuICAgIHZhciBkZXB0aERpZmYgPSBkZXB0aEEgLSBkZXB0aEI7XG4gICAgdmFyIHNhbWVEZXB0aCA9IGRlcHRoRGlmZiA9PT0gMDtcblxuICAgIGlmKCBzYW1lRGVwdGggKXtcbiAgICAgIFxuICAgICAgaWYoIGFJc05vZGUgJiYgYklzRWRnZSApe1xuICAgICAgICByZXR1cm4gMTsgLy8gJ2EnIGlzIGEgbm9kZSwgaXQgc2hvdWxkIGJlIGRyYXduIGxhdGVyICAgICAgIFxuICAgICAgXG4gICAgICB9IGVsc2UgaWYoIGFJc0VkZ2UgJiYgYklzTm9kZSApe1xuICAgICAgICByZXR1cm4gLTE7IC8vICdhJyBpcyBhbiBlZGdlLCBpdCBzaG91bGQgYmUgZHJhd24gZmlyc3RcblxuICAgICAgfSBlbHNlIHsgLy8gYm90aCBub2RlcyBvciBib3RoIGVkZ2VzXG4gICAgICAgIGlmKCB6RGlmZiA9PT0gMCApeyAvLyBzYW1lIHotaW5kZXggPT4gY29tcGFyZSBpbmRpY2VzIGluIHRoZSBjb3JlIChvcmRlciBhZGRlZCB0byBncmFwaCB3LyBsYXN0IG9uIHRvcClcbiAgICAgICAgICByZXR1cm4gYV9wLmluZGV4IC0gYl9wLmluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB6RGlmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIFxuICAgIC8vIGVsZW1lbnRzIG9uIGRpZmZlcmVudCBsZXZlbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVwdGhEaWZmOyAvLyBkZWVwZXIgZWxlbWVudCBzaG91bGQgYmUgZHJhd24gbGF0ZXJcbiAgICB9XG5cbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyBGdW5jdGlvbnMgZm9yIGxheW91dHMgb24gbm9kZXNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgJCQuZm4uZWxlcyh7XG5cbiAgICAvLyB1c2luZyBzdGFuZGFyZCBsYXlvdXQgb3B0aW9ucywgYXBwbHkgcG9zaXRpb24gZnVuY3Rpb24gKHcvIG9yIHcvbyBhbmltYXRpb24pXG4gICAgbGF5b3V0UG9zaXRpb25zOiBmdW5jdGlvbiggbGF5b3V0LCBvcHRpb25zLCBmbiApe1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICBpZiggb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IGkgPT09IG5vZGVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICB2YXIgbmV3UG9zID0gZm4uY2FsbCggbm9kZSwgaSwgbm9kZSApO1xuICAgICAgICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgICBpZiggISQkLmlzLm51bWJlcihwb3MueCkgfHwgISQkLmlzLm51bWJlcihwb3MueSkgKXtcbiAgICAgICAgICAgIG5vZGUuc2lsZW50UG9zaXRpb24oeyB4OiAwLCB5OiAwIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUuYW5pbWF0ZSh7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3UG9zXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgICBzdGVwOiAhbGFzdE5vZGUgPyB1bmRlZmluZWQgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbXBsZXRlOiAhbGFzdE5vZGUgPyB1bmRlZmluZWQgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZiggb3B0aW9ucy56b29tICE9IG51bGwgKXtcbiAgICAgICAgICAgICAgICBjeS56b29tKCBvcHRpb25zLnpvb20gKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLnBhbiApe1xuICAgICAgICAgICAgICAgIGN5LnBhbiggb3B0aW9ucy5wYW4gKTtcbiAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoIGZuICk7XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRpb25zLnpvb20gIT0gbnVsbCApe1xuICAgICAgICAgIGN5Lnpvb20oIG9wdGlvbnMuem9vbSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMucGFuICl7XG4gICAgICAgICAgY3kucGFuKCBvcHRpb25zLnBhbiApO1xuICAgICAgICB9IFxuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICAgIFxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgbGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBjeS5sYXlvdXQoICQkLnV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGVsZXM6IHRoaXNcbiAgICAgIH0pICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtYWtlTGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICByZXR1cm4gY3kubWFrZUxheW91dCggJCQudXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgZWxlczogdGhpc1xuICAgICAgfSkgKTtcbiAgICB9XG5cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuXG4gICAgLy8gZnVsbHkgdXBkYXRlcyAocmVjYWxjdWxhdGVzKSB0aGUgc3R5bGUgZm9yIHRoZSBlbGVtZW50c1xuICAgIHVwZGF0ZVN0eWxlOiBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgaWYoIGN5Ll9wcml2YXRlLmJhdGNoaW5nU3R5bGUgKXtcbiAgICAgICAgdmFyIGJFbGVzID0gY3kuX3ByaXZhdGUuYmF0Y2hTdHlsZUVsZXM7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG5cbiAgICAgICAgICBpZiggIWJFbGVzLmlkc1sgZWxlLl9wcml2YXRlLmlkIF0gKXtcbiAgICAgICAgICAgIGJFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZyBhbmQgZXhpdCBlYXJseSB3aGVuIGJhdGNoaW5nXG4gICAgICB9XG5cbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgIHN0eWxlLmFwcGx5KCB0aGlzICk7XG5cbiAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG5cbiAgICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9Ob3RpZnkudHJpZ2dlcignc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGp1c3QgdXBkYXRlIHRoZSBtYXBwZXJzIGluIHRoZSBlbGVtZW50cycgc3R5bGVzOyBjaGVhcGVyIHRoYW4gZWxlcy51cGRhdGVTdHlsZSgpXG4gICAgdXBkYXRlTWFwcGVyczogZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIG5vdGlmeVJlbmRlcmVyID0gbm90aWZ5UmVuZGVyZXIgfHwgbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBzdHlsZS51cGRhdGVNYXBwZXJzKCB0aGlzICk7XG5cbiAgICAgIHZhciB1cGRhdGVkQ29tcG91bmRzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG5cbiAgICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHJlbmRlcmVyIGtub3cgd2UgY2hhbmdlZCBzdHlsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9Ob3RpZnkudHJpZ2dlcignc3R5bGUnKTsgLy8ganVzdCBmaXJlIHRoZSBldmVudFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGdldCB0aGUgc3BlY2lmaWVkIGNzcyBwcm9wZXJ0eSBhcyBhIHJlbmRlcmVkIHZhbHVlIChpLmUuIG9uLXNjcmVlbiB2YWx1ZSlcbiAgICAvLyBvciBnZXQgdGhlIHdob2xlIHJlbmRlcmVkIHN0eWxlIGlmIG5vIHByb3BlcnR5IHNwZWNpZmllZCAoTkIgZG9lc24ndCBhbGxvdyBzZXR0aW5nKVxuICAgIHJlbmRlcmVkQ3NzOiBmdW5jdGlvbiggcHJvcGVydHkgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdmFyIHJlbnN0eWxlID0gZWxlLmN5KCkuc3R5bGUoKS5nZXRSZW5kZXJlZFN0eWxlKCBlbGUgKTtcblxuICAgICAgICBpZiggcHJvcGVydHkgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHJldHVybiByZW5zdHlsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVuc3R5bGVbIHByb3BlcnR5IF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gcmVhZCB0aGUgY2FsY3VsYXRlZCBjc3Mgc3R5bGUgb2YgdGhlIGVsZW1lbnQgb3Igb3ZlcnJpZGUgdGhlIHN0eWxlICh2aWEgYSBieXBhc3MpXG4gICAgY3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIFxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG5cbiAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChuYW1lKSApeyAvLyB0aGVuIGV4dGVuZCB0aGUgYnlwYXNzXG4gICAgICAgIHZhciBwcm9wcyA9IG5hbWU7XG4gICAgICAgIHN0eWxlLmFwcGx5QnlwYXNzKCB0aGlzLCBwcm9wcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcblxuICAgICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG4gICAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApe1xuICBcbiAgICAgICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgKXsgLy8gdGhlbiBnZXQgdGhlIHByb3BlcnR5IGZyb20gdGhlIHN0eWxlXG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLnN0eWxlWyBuYW1lIF0uc3RyVmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gc2V0IHRoZSBieXBhc3Mgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgICAgICBzdHlsZS5hcHBseUJ5cGFzcyggdGhpcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG5cbiAgICAgICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYoIG5hbWUgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlLmdldFJhd1N0eWxlKCBlbGUgKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gZW1wdHkgY29sbGVjdGlvbiA9PiBjYW4ndCBnZXQgYW55IHZhbHVlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICByZW1vdmVDc3M6IGZ1bmN0aW9uKCBuYW1lcyApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHZhciB1cGRhdGVUcmFuc2l0aW9ucyA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gY3kuc3R5bGUoKTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcblxuICAgICAgaWYoIG5hbWVzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBzdHlsZS5yZW1vdmVBbGxCeXBhc3NlcyggZWxlLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lcyA9IG5hbWVzLnNwbGl0KC9cXHMrLyk7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBzdHlsZS5yZW1vdmVCeXBhc3NlcyggZWxlLCBuYW1lcywgdXBkYXRlVHJhbnNpdGlvbnMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBzaG93OiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnZWxlbWVudCcpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIGhpZGU6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLmNzcygnZGlzcGxheScsICdub25lJyk7XG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgdmlzaWJsZTogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRydWU7IH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgICAgaWYoXG4gICAgICAgICAgc3R5bGVbJ3Zpc2liaWxpdHknXS52YWx1ZSAhPT0gJ3Zpc2libGUnXG4gICAgICAgICAgfHwgc3R5bGVbJ2Rpc3BsYXknXS52YWx1ZSAhPT0gJ2VsZW1lbnQnXG4gICAgICAgICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgICB2YXIgcGFyZW50cyA9IGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCA/IGVsZS5wYXJlbnRzKCkgOiBudWxsO1xuXG4gICAgICAgICAgaWYoIHBhcmVudHMgKXtcbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgICAgdmFyIHBTdHlsZSA9IHBhcmVudC5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgICAgICAgICAgdmFyIHBWaXMgPSBwU3R5bGVbJ3Zpc2liaWxpdHknXS52YWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHBEaXMgPSBwU3R5bGVbJ2Rpc3BsYXknXS52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiggcFZpcyAhPT0gJ3Zpc2libGUnIHx8IHBEaXMgIT09ICdlbGVtZW50JyApe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcmMgPSBlbGUuX3ByaXZhdGUuc291cmNlO1xuICAgICAgICAgIHZhciB0Z3QgPSBlbGUuX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAgICAgcmV0dXJuIHNyYy52aXNpYmxlKCkgJiYgdGd0LnZpc2libGUoKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSxcblxuICAgIGhpZGRlbjogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiAhZWxlLnZpc2libGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWZmZWN0aXZlT3BhY2l0eTogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIDE7IH1cblxuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gX3Auc3R5bGUub3BhY2l0eS52YWx1ZTtcblxuICAgICAgICBpZiggIWhhc0NvbXBvdW5kTm9kZXMgKXsgcmV0dXJuIHBhcmVudE9wYWNpdHk7IH1cblxuICAgICAgICB2YXIgcGFyZW50cyA9ICFfcC5kYXRhLnBhcmVudCA/IG51bGwgOiBlbGUucGFyZW50cygpO1xuICAgICAgICBcbiAgICAgICAgaWYoIHBhcmVudHMgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGUub3BhY2l0eS52YWx1ZTtcblxuICAgICAgICAgICAgcGFyZW50T3BhY2l0eSA9IG9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJlbnRPcGFjaXR5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFuc3BhcmVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBlbGUuY3koKS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7XG4gICAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZS5vcGFjaXR5LnZhbHVlID09PSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlbGUuZWZmZWN0aXZlT3BhY2l0eSgpID09PSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzRnVsbEF1dG9QYXJlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgYXV0b1cgPSBlbGUuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10udmFsdWUgPT09ICdhdXRvJztcbiAgICAgICAgdmFyIGF1dG9IID0gZWxlLl9wcml2YXRlLnN0eWxlWydoZWlnaHQnXS52YWx1ZSA9PT0gJ2F1dG8nO1xuXG4gICAgICAgIHJldHVybiBlbGUuaXNQYXJlbnQoKSAmJiBhdXRvVyAmJiBhdXRvSDtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG5cblxuICAkJC5lbGVzZm4uc3R5bGUgPSAkJC5lbGVzZm4uY3NzO1xuICAkJC5lbGVzZm4ucmVuZGVyZWRTdHlsZSA9ICQkLmVsZXNmbi5yZW5kZXJlZENzcztcbiAgJCQuZWxlc2ZuLnJlbW92ZVN0eWxlID0gJCQuZWxlc2ZuLnJlbW92ZUNzcztcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gQ29sbGVjdGlvbiBmdW5jdGlvbnMgdGhhdCB0b2dnbGUgYSBib29sZWFuIHZhbHVlXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIFxuICBmdW5jdGlvbiBkZWZpbmVTd2l0Y2hGdW5jdGlvbihwYXJhbXMpe1xuICAgIHJldHVybiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBcbiAgICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuICAgICAgaWYoIGFyZ3MubGVuZ3RoID09PSAyICl7XG4gICAgICAgIHZhciBkYXRhID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBhcmdzWzFdO1xuICAgICAgICB0aGlzLmJpbmQoIHBhcmFtcy5ldmVudCwgZGF0YSwgaGFuZGxlciApO1xuICAgICAgfSBcbiAgICAgIFxuICAgICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggaGFuZGxlciApXG4gICAgICBlbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMSApe1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICAgIHRoaXMuYmluZCggcGFyYW1zLmV2ZW50LCBoYW5kbGVyICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgICAgZWxzZSBpZiggYXJncy5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIGFibGUgPSAhcGFyYW1zLmFibGVGaWVsZCB8fCBlbGUuX3ByaXZhdGVbcGFyYW1zLmFibGVGaWVsZF07XG5cbiAgICAgICAgICBpZiggcGFyYW1zLm92ZXJyaWRlQWJsZSApe1xuICAgICAgICAgICAgdmFyIG92ZXJyaWRlQWJsZSA9IHBhcmFtcy5vdmVycmlkZUFibGUoZWxlKTtcblxuICAgICAgICAgICAgaWYoIG92ZXJyaWRlQWJsZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICAgIGFibGUgPSBvdmVycmlkZUFibGU7XG5cbiAgICAgICAgICAgICAgaWYoICFvdmVycmlkZUFibGUgKXsgcmV0dXJuIHRoaXM7IH0gLy8gdG8gc2F2ZSBjeWNsZXMgYXNzdW1lIG5vdCBhYmxlIGZvciBhbGwgb24gb3ZlcnJpZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggYWJsZSApe1xuICAgICAgICAgICAgZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gPSBwYXJhbXMudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGUoKTsgLy8gY2hhbmdlIG9mIHN0YXRlID0+IHBvc3NpYmxlIGNoYW5nZSBvZiBzdHlsZVxuICAgICAgICB0aGlzLnRyaWdnZXIoIHBhcmFtcy5ldmVudCApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICB9XG4gIFxuICBmdW5jdGlvbiBkZWZpbmVTd2l0Y2hTZXQoIHBhcmFtcyApe1xuICAgICQkLmVsZXNmblsgcGFyYW1zLmZpZWxkIF0gPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgaWYoIHBhcmFtcy5vdmVycmlkZUZpZWxkICl7XG4gICAgICAgICAgdmFyIHZhbCA9IHBhcmFtcy5vdmVycmlkZUZpZWxkKGVsZSk7XG5cbiAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZVsgcGFyYW1zLmZpZWxkIF07XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAkJC5lbGVzZm5bIHBhcmFtcy5vbiBdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgICAgZXZlbnQ6IHBhcmFtcy5vbixcbiAgICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgJCQuZWxlc2ZuWyBwYXJhbXMub2ZmIF0gPSBkZWZpbmVTd2l0Y2hGdW5jdGlvbih7XG4gICAgICBldmVudDogcGFyYW1zLm9mZixcbiAgICAgIGZpZWxkOiBwYXJhbXMuZmllbGQsXG4gICAgICBhYmxlRmllbGQ6IHBhcmFtcy5hYmxlRmllbGQsXG4gICAgICBvdmVycmlkZUFibGU6IHBhcmFtcy5vdmVycmlkZUFibGUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ2xvY2tlZCcsXG4gICAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oZWxlKXtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvbG9jaygpID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnbG9jaycsXG4gICAgb2ZmOiAndW5sb2NrJ1xuICB9KTtcbiAgXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdncmFiYmFibGUnLFxuICAgIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uKGVsZSl7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3VuZ3JhYmlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ2dyYWJpZnknLFxuICAgIG9mZjogJ3VuZ3JhYmlmeSdcbiAgfSk7XG4gIFxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnc2VsZWN0ZWQnLFxuICAgIGFibGVGaWVsZDogJ3NlbGVjdGFibGUnLFxuICAgIG92ZXJyaWRlQWJsZTogZnVuY3Rpb24oZWxlKXtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdzZWxlY3QnLFxuICAgIG9mZjogJ3Vuc2VsZWN0J1xuICB9KTtcbiAgXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbihlbGUpe1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bnNlbGVjdGlmeSgpID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ3NlbGVjdGlmeScsXG4gICAgb2ZmOiAndW5zZWxlY3RpZnknXG4gIH0pO1xuICBcbiAgJCQuZWxlc2ZuLmdyYWJiZWQgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgICB9XG4gIH07XG5cbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ2FjdGl2ZScsXG4gICAgb246ICdhY3RpdmF0ZScsXG4gICAgb2ZmOiAndW5hY3RpdmF0ZSdcbiAgfSk7XG5cbiAgJCQuZWxlc2ZuLmluYWN0aXZlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICBpZiggZWxlICl7XG4gICAgICByZXR1cm4gIWVsZS5fcHJpdmF0ZS5hY3RpdmU7XG4gICAgfVxuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBEQUcgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgLy8gZ2V0IHRoZSByb290IG5vZGVzIGluIHRoZSBEQUdcbiAgICByb290czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgcm9vdHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBpZiggIWVsZS5pc05vZGUoKSApe1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhc0VkZ2VzUG9pbnRpbmdJbiA9IGVsZS5jb25uZWN0ZWRFZGdlcyhmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ3RhcmdldCcpID09PSBlbGUuaWQoKSAmJiB0aGlzLmRhdGEoJ3NvdXJjZScpICE9PSBlbGUuaWQoKTtcbiAgICAgICAgfSkubGVuZ3RoID4gMDtcblxuICAgICAgICBpZiggIWhhc0VkZ2VzUG9pbnRpbmdJbiApe1xuICAgICAgICAgIHJvb3RzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgcm9vdHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIC8vIGdldCB0aGUgbGVhZiBub2RlcyBpbiB0aGUgREFHXG4gICAgbGVhdmVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBsZWF2ZXMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICBpZiggIWVsZS5pc05vZGUoKSApe1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhc0VkZ2VzUG9pbnRpbmdPdXQgPSBlbGUuY29ubmVjdGVkRWRnZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCdzb3VyY2UnKSA9PT0gZWxlLmlkKCkgJiYgdGhpcy5kYXRhKCd0YXJnZXQnKSAhPT0gZWxlLmlkKCk7XG4gICAgICAgIH0pLmxlbmd0aCA+IDA7XG5cbiAgICAgICAgaWYoICFoYXNFZGdlc1BvaW50aW5nT3V0ICl7XG4gICAgICAgICAgbGVhdmVzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5fcHJpdmF0ZS5jeSwgbGVhdmVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICAvLyBub3JtYWxseSBjYWxsZWQgY2hpbGRyZW4gaW4gZ3JhcGggdGhlb3J5XG4gICAgLy8gdGhlc2Ugbm9kZXMgPWVkZ2VzPT4gb3V0Z29pbmcgbm9kZXNcbiAgICBvdXRnb2VyczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgb0VsZXMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgZWxlSWQgPSBlbGUuaWQoKTtcblxuICAgICAgICBpZiggIWVsZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBlZGdlcyA9IGVsZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgICAgdmFyIHNyY0lkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnNvdXJjZTtcbiAgICAgICAgICB2YXIgdGd0SWQgPSBlZGdlLl9wcml2YXRlLmRhdGEudGFyZ2V0O1xuXG4gICAgICAgICAgaWYoIHNyY0lkID09PSBlbGVJZCAmJiB0Z3RJZCAhPT0gZWxlSWQgKXtcbiAgICAgICAgICAgIG9FbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgICAgIG9FbGVzLnB1c2goIGVkZ2UudGFyZ2V0KClbMF0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBvRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgLy8gYWthIERBRyBkZXNjZW5kYW50c1xuICAgIHN1Y2Nlc3NvcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIHNFbGVzID0gW107XG4gICAgICB2YXIgc0VsZXNJZHMgPSB7fTtcblxuICAgICAgZm9yKDs7KXtcbiAgICAgICAgdmFyIG91dGdvZXJzID0gZWxlcy5vdXRnb2VycygpO1xuXG4gICAgICAgIGlmKCBvdXRnb2Vycy5sZW5ndGggPT09IDAgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiBubyBvdXRnb2VycyBsZWZ0XG5cbiAgICAgICAgdmFyIG5ld091dGdvZXJzID0gZmFsc2U7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3V0Z29lcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgb3V0Z29lciA9IG91dGdvZXJzW2ldO1xuICAgICAgICAgIHZhciBvdXRnb2VySWQgPSBvdXRnb2VyLmlkKCk7XG5cbiAgICAgICAgICBpZiggIXNFbGVzSWRzWyBvdXRnb2VySWQgXSApe1xuICAgICAgICAgICAgc0VsZXNJZHNbIG91dGdvZXJJZCBdID0gdHJ1ZTtcbiAgICAgICAgICAgIHNFbGVzLnB1c2goIG91dGdvZXIgKTtcbiAgICAgICAgICAgIG5ld091dGdvZXJzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIW5ld091dGdvZXJzICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgdG91Y2hlZCBhbGwgb3V0Z29lcnMgYWxyZWFkeVxuXG4gICAgICAgIGVsZXMgPSBvdXRnb2VycztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBzRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgLy8gbm9ybWFsbHkgY2FsbGVkIHBhcmVudHMgaW4gZ3JhcGggdGhlb3J5XG4gICAgLy8gdGhlc2Ugbm9kZXMgPD1lZGdlcz0gaW5jb21pbmcgbm9kZXNcbiAgICBpbmNvbWVyczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgb0VsZXMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICB2YXIgZWxlSWQgPSBlbGUuaWQoKTtcblxuICAgICAgICBpZiggIWVsZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBlZGdlcyA9IGVsZS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07XG4gICAgICAgICAgdmFyIHNyY0lkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnNvdXJjZTtcbiAgICAgICAgICB2YXIgdGd0SWQgPSBlZGdlLl9wcml2YXRlLmRhdGEudGFyZ2V0O1xuXG4gICAgICAgICAgaWYoIHRndElkID09PSBlbGVJZCAmJiBzcmNJZCAhPT0gZWxlSWQgKXtcbiAgICAgICAgICAgIG9FbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgICAgIG9FbGVzLnB1c2goIGVkZ2Uuc291cmNlKClbMF0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBvRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgLy8gYWthIERBRyBhbmNlc3RvcnNcbiAgICBwcmVkZWNlc3NvcnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIHBFbGVzID0gW107XG4gICAgICB2YXIgcEVsZXNJZHMgPSB7fTtcblxuICAgICAgZm9yKDs7KXtcbiAgICAgICAgdmFyIGluY29tZXJzID0gZWxlcy5pbmNvbWVycygpO1xuXG4gICAgICAgIGlmKCBpbmNvbWVycy5sZW5ndGggPT09IDAgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiBubyBpbmNvbWVycyBsZWZ0XG5cbiAgICAgICAgdmFyIG5ld0luY29tZXJzID0gZmFsc2U7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaW5jb21lcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgaW5jb21lciA9IGluY29tZXJzW2ldO1xuICAgICAgICAgIHZhciBpbmNvbWVySWQgPSBpbmNvbWVyLmlkKCk7XG5cbiAgICAgICAgICBpZiggIXBFbGVzSWRzWyBpbmNvbWVySWQgXSApe1xuICAgICAgICAgICAgcEVsZXNJZHNbIGluY29tZXJJZCBdID0gdHJ1ZTtcbiAgICAgICAgICAgIHBFbGVzLnB1c2goIGluY29tZXIgKTtcbiAgICAgICAgICAgIG5ld0luY29tZXJzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIW5ld0luY29tZXJzICl7IGJyZWFrOyB9IC8vIGRvbmUgaWYgdG91Y2hlZCBhbGwgaW5jb21lcnMgYWxyZWFkeVxuXG4gICAgICAgIGVsZXMgPSBpbmNvbWVycztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBwRWxlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9XG4gIH0pO1xuXG5cbiAgLy8gTmVpZ2hib3VyaG9vZCBmdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAkJC5mbi5lbGVzKHtcbiAgICBuZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApeyAvLyBmb3IgYWxsIG5vZGVzXG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuY29ubmVjdGVkRWRnZXMoKTtcblxuICAgICAgICAvLyBmb3IgZWFjaCBjb25uZWN0ZWQgZWRnZSwgYWRkIHRoZSBlZGdlIGFuZCB0aGUgb3RoZXIgbm9kZVxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tqXTtcbiAgICAgICAgICB2YXIgb3RoZXJOb2RlID0gZWRnZS5jb25uZWN0ZWROb2RlcygpLm5vdChub2RlKTtcblxuICAgICAgICAgIC8vIG5lZWQgY2hlY2sgaW4gY2FzZSBvZiBsb29wXG4gICAgICAgICAgaWYoIG90aGVyTm9kZS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKCBvdGhlck5vZGVbMF0gKTsgLy8gYWRkIG5vZGUgMSBob3AgYXdheVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBhZGQgY29ubmVjdGVkIGVkZ2VcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlZGdlWzBdICk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gKCBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGNsb3NlZE5laWdoYm9yaG9vZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCkuYWRkKCB0aGlzICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBvcGVuTmVpZ2hib3Job29kOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoIHNlbGVjdG9yICk7XG4gICAgfVxuICB9KTsgIFxuXG5cbiAgLy8gRWRnZSBmdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy9cblxuICAkJC5mbi5lbGVzKHtcbiAgICBzb3VyY2U6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgc3JjO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHNyYyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzcmMgJiYgc2VsZWN0b3IgPyBzcmMuZmlsdGVyKCBzZWxlY3RvciApIDogc3JjO1xuICAgIH0sXG5cbiAgICB0YXJnZXQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgdGd0O1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHRndCA9IGVsZS5fcHJpdmF0ZS50YXJnZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0Z3QgJiYgc2VsZWN0b3IgPyB0Z3QuZmlsdGVyKCBzZWxlY3RvciApIDogdGd0O1xuICAgIH0sXG5cbiAgICBzb3VyY2VzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgICBhdHRyOiAnc291cmNlJ1xuICAgIH0pLFxuXG4gICAgdGFyZ2V0czogZGVmaW5lU291cmNlRnVuY3Rpb24oe1xuICAgICAgYXR0cjogJ3RhcmdldCdcbiAgICB9KVxuICB9KTtcbiAgXG4gIGZ1bmN0aW9uIGRlZmluZVNvdXJjZUZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgc3JjID0gZWxlLl9wcml2YXRlWyBwYXJhbXMuYXR0ciBdO1xuXG4gICAgICAgIGlmKCBzcmMgKXtcbiAgICAgICAgICBzb3VyY2VzLnB1c2goIHNyYyApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHNvdXJjZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfTtcbiAgfVxuXG4gICQkLmZuLmVsZXMoe1xuICAgIGVkZ2VzV2l0aDogZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oKSxcblxuICAgIGVkZ2VzVG86IGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKHtcbiAgICAgIHRoaXNJczogJ3NvdXJjZSdcbiAgICB9KVxuICB9KTtcbiAgXG4gIGZ1bmN0aW9uIGRlZmluZUVkZ2VzV2l0aEZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24ob3RoZXJOb2Rlcyl7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgcCA9IHBhcmFtcyB8fCB7fTtcblxuICAgICAgLy8gZ2V0IGVsZW1lbnRzIGlmIGEgc2VsZWN0b3IgaXMgc3BlY2lmaWVkXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKG90aGVyTm9kZXMpICl7XG4gICAgICAgIG90aGVyTm9kZXMgPSBjeS4kKCBvdGhlck5vZGVzICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBlZGdlcyA9IG90aGVyTm9kZXMuY29ubmVjdGVkRWRnZXMoKTtcbiAgICAgIHZhciB0aGlzSWRzID0gdGhpcy5fcHJpdmF0ZS5pZHM7XG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgdmFyIGZvdW5kSWQ7XG4gICAgICAgIHZhciBlZGdlRGF0YSA9IGVkZ2UuX3ByaXZhdGUuZGF0YTtcblxuICAgICAgICBpZiggcC50aGlzSXMgKXtcbiAgICAgICAgICB2YXIgaWRUb0ZpbmQgPSBlZGdlRGF0YVsgcC50aGlzSXMgXTtcbiAgICAgICAgICBmb3VuZElkID0gdGhpc0lkc1sgaWRUb0ZpbmQgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3VuZElkID0gdGhpc0lkc1sgZWRnZURhdGEuc291cmNlIF0gfHwgdGhpc0lkc1sgZWRnZURhdGEudGFyZ2V0IF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCBmb3VuZElkICl7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICk7XG4gICAgfTtcbiAgfVxuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgY29ubmVjdGVkRWRnZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIHJldEVsZXMgPSBbXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICBcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IGVsZXNbaV07XG4gICAgICAgIGlmKCAhbm9kZS5pc05vZGUoKSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBlZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbal07ICAgICAgICAgIFxuICAgICAgICAgIHJldEVsZXMucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGNvbm5lY3RlZE5vZGVzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciByZXRFbGVzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlbGVzW2ldO1xuICAgICAgICBpZiggIWVkZ2UuaXNFZGdlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgICByZXRFbGVzLnB1c2goIGVkZ2Uuc291cmNlKClbMF0gKTtcbiAgICAgICAgcmV0RWxlcy5wdXNoKCBlZGdlLnRhcmdldCgpWzBdICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHJldEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIHBhcmFsbGVsRWRnZXM6IGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbigpLFxuXG4gICAgY29kaXJlY3RlZEVkZ2VzOiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oe1xuICAgICAgY29kaXJlY3RlZDogdHJ1ZVxuICAgIH0pXG4gIH0pO1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHBhcmFtcyl7XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgY29kaXJlY3RlZDogZmFsc2VcbiAgICB9O1xuICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgICAgLy8gbG9vayBhdCBhbGwgdGhlIGVkZ2VzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlMSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgc3JjMSA9IGVkZ2UxLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgc3JjaWQxID0gc3JjMS5pZCgpO1xuICAgICAgICB2YXIgdGd0MSA9IGVkZ2UxLnRhcmdldCgpWzBdO1xuICAgICAgICB2YXIgdGd0aWQxID0gdGd0MS5pZCgpO1xuICAgICAgICB2YXIgc3JjRWRnZXMxID0gc3JjMS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICAvLyBsb29rIGF0IGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgc3JjIG5vZGUgb2YgdGhpcyBlZGdlXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgc3JjRWRnZXMxLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVkZ2UyID0gc3JjRWRnZXMxW2pdO1xuICAgICAgICAgIHZhciBlZGdlMmRhdGEgPSBlZGdlMi5fcHJpdmF0ZS5kYXRhO1xuICAgICAgICAgIHZhciB0Z3RpZDIgPSBlZGdlMmRhdGEudGFyZ2V0O1xuICAgICAgICAgIHZhciBzcmNpZDIgPSBlZGdlMmRhdGEuc291cmNlO1xuXG4gICAgICAgICAgdmFyIGNvZGlyZWN0ZWQgPSB0Z3RpZDIgPT09IHRndGlkMSAmJiBzcmNpZDIgPT09IHNyY2lkMTtcbiAgICAgICAgICB2YXIgb3BwZGlyZWN0ZWQgPSBzcmNpZDEgPT09IHRndGlkMiAmJiB0Z3RpZDEgPT09IHNyY2lkMjtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggKHAuY29kaXJlY3RlZCAmJiBjb2RpcmVjdGVkKSB8fCAoIXAuY29kaXJlY3RlZCAmJiAoY29kaXJlY3RlZCB8fCBvcHBkaXJlY3RlZCkpICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlZGdlMiApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9O1xuICBcbiAgfVxuXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuXG4gICAgZml0OiBmdW5jdGlvbigpe30sXG4gICAgY2VudGVyOiBmdW5jdGlvbigpe31cblxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uICgkJCkge1xuICBcInVzZSBzdHJpY3RcIjtcblxuICAvKiAgTWluIGFuZCBNYXggaGVhcCBwcmVkZWZhdWx0cyAqL1xuICBcbiAgJCQuTWluaGVhcCA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdmFsdWVGbikge1xuICAgIHJldHVybiBuZXcgJCQuSGVhcChjeSwgZWxlcywgJCQuSGVhcC5taW5IZWFwQ29tcGFyYXRvciwgdmFsdWVGbik7XG4gIH07XG5cbiAgJCQuTWF4aGVhcCA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdmFsdWVGbikge1xuICAgIHJldHVybiBuZXcgJCQuSGVhcChjeSwgZWxlcywgJCQuSGVhcC5tYXhIZWFwQ29tcGFyYXRvciwgdmFsdWVGbik7XG4gIH07XG4gIFxuICAkJC5IZWFwID0gZnVuY3Rpb24gKGN5LCBlbGVzLCBjb21wYXJhdG9yLCB2YWx1ZUZuKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wYXJhdG9yID09PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBlbGVzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2YgdmFsdWVGbiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdmFsdWVGbiA9ICQkLkhlYXAuaWRGbjtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlSGVhcCA9IFtdLFxuICAgICAgcG9pbnRlcnMgPSB7fSxcbiAgICAgIGVsZW1lbnRzID0gW10sXG4gICAgICBpID0gMCxcbiAgICAgIGlkLFxuICAgICAgaGVhcCxcbiAgICAgIGVsZXNMZW47XG5cbiAgICBlbGVzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzLCBjeSk7XG4gICAgZWxlc0xlbiA9IGVsZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGVsZXNMZW47IGkgKz0gMSkge1xuICAgICAgc291cmNlSGVhcC5wdXNoKHZhbHVlRm4uY2FsbChjeSwgZWxlc1tpXSwgaSwgZWxlcykpO1xuXG4gICAgICBpZCA9IGVsZXNbaV0uaWQoKTtcbiAgICAgIFxuICAgICAgaWYgKHBvaW50ZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICB0aHJvdyBcIkVSUk9SOiBNdWx0aXBsZSBpdGVtcyB3aXRoIHRoZSBzYW1lIGlkIGZvdW5kOiBcIiArIGlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICBwb2ludGVyc1tpZF0gPSBpO1xuICAgICAgZWxlbWVudHMucHVzaChpZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGhlYXA6IHNvdXJjZUhlYXAsXG4gICAgICBwb2ludGVyczogcG9pbnRlcnMsXG4gICAgICBlbGVtZW50czogZWxlbWVudHMsXG4gICAgICBjb21wYXJhdG9yOiBjb21wYXJhdG9yLFxuICAgICAgZXh0cmFjdG9yOiB2YWx1ZUZuLFxuICAgICAgbGVuZ3RoOiBlbGVzTGVuXG4gICAgfTtcblxuICAgIGZvciAoaSA9IE1hdGguZmxvb3IoZWxlc0xlbiAvIDIpOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaGVhcCA9IHRoaXMuaGVhcGlmeShpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhcDtcbiAgfTtcblxuICAvKiBzdGF0aWMgbWV0aG9kcyAqL1xuICAkJC5IZWFwLmlkRm4gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlkKCk7XG4gIH07XG5cbiAgJCQuSGVhcC5taW5IZWFwQ29tcGFyYXRvciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPj0gYjtcbiAgfTtcblxuICAkJC5IZWFwLm1heEhlYXBDb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8PSBiO1xuICB9O1xuXG4gICQkLmZuLmhlYXAgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcbiAgICAgICQkLkhlYXAucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG5cbiAgJCQuaGVhcGZuID0gJCQuSGVhcC5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbiAgLyogb2JqZWN0IG1ldGhvZHMgKi9cbiAgJCQuaGVhcGZuLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubGVuZ3RoO1xuICB9O1xuXG4gICQkLmhlYXBmbi5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChlbGVzLCBjeSkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYodHlwZW9mIGN5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgfVxuXG4gICAgaWYgKCQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oZWxlcykpIHtcbiAgICAgIHJlc3VsdCA9IGVsZXM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdEFycmF5ID0gW10sXG4gICAgICAgIHNvdXJjZUVsZXMgPSBbXS5jb25jYXQuYXBwbHkoW10sIFtlbGVzXSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlRWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBzb3VyY2VFbGVzW2ldLFxuICAgICAgICAgIGVsZSA9IGN5LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICBpZihlbGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJlc3VsdEFycmF5LnB1c2goZWxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcmVzdWx0QXJyYXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgJCQuaGVhcGZuLmlzSGVhcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSB0aGlzLl9wcml2YXRlLmhlYXAsXG4gICAgICBhcnJsZW4gPSBhcnJheS5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgbENoZWNrLFxuICAgICAgckNoZWNrLFxuICAgICAgY29tcGFyYXRvciA9IHRoaXMuX3ByaXZhdGUuY29tcGFyYXRvcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnJsZW47IGkgKz0gMSkge1xuICAgICAgbGVmdCA9IDIgKiBpICsgMTtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIDE7XG4gICAgICBsQ2hlY2sgPSBsZWZ0IDwgYXJybGVuID8gY29tcGFyYXRvcihhcnJheVtsZWZ0XSwgYXJyYXlbaV0pIDogdHJ1ZTtcbiAgICAgIHJDaGVjayA9IHJpZ2h0IDwgYXJybGVuID8gY29tcGFyYXRvcihhcnJheVtyaWdodF0sIGFycmF5W2ldKSA6IHRydWU7XG5cbiAgICAgIGlmICghbENoZWNrIHx8ICFyQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gICQkLmhlYXBmbi5oZWFwU3dhcCA9IGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgdmFyIGhlYXAgPSB0aGlzLl9wcml2YXRlLmhlYXAsXG4gICAgICBwb2ludGVycyA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnMsXG4gICAgICBlbGVtZW50cyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHMsXG4gICAgICBzd2FwVmFsdWUgPSBoZWFwW2ldLFxuICAgICAgc3dhcEVsZW1zID0gZWxlbWVudHNbaV0sXG4gICAgICBpZEkgPSBlbGVtZW50c1tpXSxcbiAgICAgIGlkSiA9IGVsZW1lbnRzW2pdO1xuXG4gICAgaGVhcFtpXSA9IGhlYXBbal07XG4gICAgZWxlbWVudHNbaV0gPSBlbGVtZW50c1tqXTtcblxuICAgIHBvaW50ZXJzW2lkSV0gPSBqO1xuICAgIHBvaW50ZXJzW2lkSl0gPSBpO1xuXG4gICAgaGVhcFtqXSA9IHN3YXBWYWx1ZTtcbiAgICBlbGVtZW50c1tqXSA9IHN3YXBFbGVtcztcbiAgfTtcblxuICAkJC5oZWFwZm4uaGVhcGlmeSA9IGZ1bmN0aW9uIChpLCByb290VG9MZWFmKSB7XG4gICAgdmFyIHRyZWVMZW4gPSAwLFxuICAgICAgY29uZEhlYXAgPSBmYWxzZSxcbiAgICAgIGFycmF5LFxuICAgICAgY3VycmVudCxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGJlc3QsXG4gICAgICBjb21wYXJhdG9yLFxuICAgICAgcGFyZW50O1xuICAgIFxuICAgIGlmICh0eXBlb2Ygcm9vdFRvTGVhZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcm9vdFRvTGVhZiA9IHRydWU7XG4gICAgfVxuXG4gICAgYXJyYXkgPSB0aGlzLl9wcml2YXRlLmhlYXA7XG4gICAgdHJlZUxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb21wYXJhdG9yID0gdGhpcy5fcHJpdmF0ZS5jb21wYXJhdG9yO1xuICAgIGN1cnJlbnQgPSBpO1xuXG4gICAgd2hpbGUgKCFjb25kSGVhcCkge1xuXG4gICAgICBpZiAocm9vdFRvTGVhZikge1xuICAgICAgICBsZWZ0ID0gMiAqIGN1cnJlbnQgKyAxO1xuICAgICAgICByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgICBiZXN0ID0gY3VycmVudDtcbiAgICAgICAgXG4gICAgICAgIGlmIChsZWZ0IDwgdHJlZUxlbiAmJiAhY29tcGFyYXRvcihhcnJheVtsZWZ0XSwgYXJyYXlbYmVzdF0pKSB7XG4gICAgICAgICAgYmVzdCA9IGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChyaWdodCA8IHRyZWVMZW4gJiYgIWNvbXBhcmF0b3IoYXJyYXlbcmlnaHRdLCBhcnJheVtiZXN0XSkpIHtcbiAgICAgICAgICBiZXN0ID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbmRIZWFwID0gYmVzdCA9PT0gY3VycmVudDtcbiAgICAgICAgXG4gICAgICAgIGlmICghY29uZEhlYXApIHtcbiAgICAgICAgICB0aGlzLmhlYXBTd2FwKGJlc3QsIGN1cnJlbnQpO1xuICAgICAgICAgIGN1cnJlbnQgPSBiZXN0O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IE1hdGguZmxvb3IoKGN1cnJlbnQgLSAxKSAvIDIpO1xuICAgICAgICBiZXN0ID0gY3VycmVudDtcbiAgICAgICAgY29uZEhlYXAgPSBwYXJlbnQgPCAwIHx8IGNvbXBhcmF0b3IoYXJyYXlbYmVzdF0sIGFycmF5W3BhcmVudF0pO1xuXG4gICAgICAgIGlmICghY29uZEhlYXApIHtcbiAgICAgICAgICB0aGlzLmhlYXBTd2FwKGJlc3QsIHBhcmVudCk7XG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSAvLyB3aGlsZVxuICB9O1xuXG4gIC8qIGNvbGxlY3Rpb25PckVsZW1lbnQgKi9cbiAgJCQuaGVhcGZuLmluc2VydCA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzKSxcbiAgICAgIGVsc2l6ZSA9IGVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBlbGluZGV4LFxuICAgICAgZWx2YWx1ZSxcbiAgICAgIGVsaWQsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGVsc2l6ZTsgaSArPSAxKSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBlbGluZGV4ID0gdGhpcy5fcHJpdmF0ZS5oZWFwLmxlbmd0aDtcbiAgICAgIGVsdmFsdWUgPSB0aGlzLl9wcml2YXRlLmV4dHJhY3RvcihlbGVtZW50KTtcbiAgICAgIGVsaWQgPSBlbGVtZW50LmlkKCk7XG5cbiAgICAgIGlmICh0aGlzLl9wcml2YXRlLnBvaW50ZXJzLmhhc093blByb3BlcnR5KGVsaWQpKSB7XG4gICAgICAgIHRocm93IFwiRVJST1I6IE11bHRpcGxlIGl0ZW1zIHdpdGggdGhlIHNhbWUgaWQgZm91bmQ6IFwiICsgZWxpZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwLnB1c2goZWx2YWx1ZSk7XG4gICAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnB1c2goZWxpZCk7XG4gICAgICB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW2VsaWRdID0gZWxpbmRleDtcbiAgICAgIHRoaXMuaGVhcGlmeShlbGluZGV4LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZS5sZW5ndGggPSB0aGlzLl9wcml2YXRlLmhlYXAubGVuZ3RoO1xuICB9O1xuXG4gICQkLmhlYXBmbi5nZXRWYWx1ZUJ5SWQgPSBmdW5jdGlvbiAoZWxlbWVudElkKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGUucG9pbnRlcnMuaGFzT3duUHJvcGVydHkoZWxlbWVudElkKSkge1xuICAgICAgdmFyIGVsZW1lbnRJbmRleCA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxlbWVudElkXTtcblxuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaGVhcFtlbGVtZW50SW5kZXhdO1xuICAgIH1cbiAgfTtcbiAgXG4gICQkLmhlYXBmbi5jb250YWlucyA9IGZ1bmN0aW9uIChlbGVzKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5nZXRBcmd1bWVudEFzQ29sbGVjdGlvbihlbGVzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBlbGVtZW50SWQgPSBlbGVtZW50c1tpXS5pZCgpO1xuXG4gICAgICBpZighdGhpcy5fcHJpdmF0ZS5wb2ludGVycy5oYXNPd25Qcm9wZXJ0eShlbGVtZW50SWQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gICQkLmhlYXBmbi50b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGUubGVuZ3RoID4gMCkge1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdGhpcy5fcHJpdmF0ZS5oZWFwWzBdLFxuICAgICAgICBpZDogdGhpcy5fcHJpdmF0ZS5lbGVtZW50c1swXVxuICAgICAgfTtcblxuICAgIH1cbiAgfTtcblxuICAkJC5oZWFwZm4ucG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wcml2YXRlLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciB0b3AgPSB0aGlzLnRvcCgpLFxuICAgICAgICBsYXN0SW5kZXggPSB0aGlzLl9wcml2YXRlLmxlbmd0aCAtIDEsXG4gICAgICAgIHJlbW92ZUNhbmRpZGF0ZSxcbiAgICAgICAgcmVtb3ZlVmFsdWUsXG4gICAgICAgIHJlbUlkO1xuXG4gICAgICB0aGlzLmhlYXBTd2FwKDAsIGxhc3RJbmRleCk7XG5cbiAgICAgIHJlbW92ZUNhbmRpZGF0ZSA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHNbbGFzdEluZGV4XTtcbiAgICAgIHJlbW92ZVZhbHVlID0gdGhpcy5fcHJpdmF0ZS5oZWFwW2xhc3RJbmRleF07XG4gICAgICByZW1JZCA9IHJlbW92ZUNhbmRpZGF0ZTtcblxuICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwLnBvcCgpO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5wb3AoKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUubGVuZ3RoID0gdGhpcy5fcHJpdmF0ZS5oZWFwLmxlbmd0aDtcbiAgICAgIHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbcmVtSWRdID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLmhlYXBpZnkoMCk7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cbiAgfTtcblxuICAkJC5oZWFwZm4uZmluZERpcmVjdGlvbkhlYXBpZnkgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgcGFyZW50ID0gTWF0aC5mbG9vcigoaW5kZXggLSAxKSAvIDIpLFxuICAgICAgYXJyYXkgPSB0aGlzLl9wcml2YXRlLmhlYXAsXG4gICAgICBjb25kSGVhcCA9IHBhcmVudCA8IDAgfHwgdGhpcy5fcHJpdmF0ZS5jb21wYXJhdG9yKGFycmF5W2luZGV4XSwgYXJyYXlbcGFyZW50XSk7XG5cbiAgICB0aGlzLmhlYXBpZnkoaW5kZXgsIGNvbmRIZWFwKTtcbiAgfTtcblxuICAvKiBlZGl0IGlzIGEgbmV3IHZhbHVlIG9yIGZ1bmN0aW9uICovXG4gIC8vIG9ubHkgdmFsdWVzIGluIGhlYXAgYXJlIHVwZGF0ZWQuIGVsZW1lbnRzIHRoZW1zZWx2ZXMgYXJlIG5vdCFcbiAgJCQuaGVhcGZuLmVkaXQgPSBmdW5jdGlvbiAoZWxlcywgZWRpdCkge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24oZWxlcyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGVsZW1lbnRJZCA9IGVsZW1lbnRzW2ldLmlkKCksXG4gICAgICAgIGVsZW1lbnRJbmRleCA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxlbWVudElkXSxcbiAgICAgICAgZWxlbWVudFZhbHVlID0gdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF07XG4gICAgICBcbiAgICAgIGlmICgkJC5pcy5udW1iZXIoZWRpdCkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF0gPSBlZGl0O1xuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAoJCQuaXMuZm4oZWRpdCkpIHtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5oZWFwW2VsZW1lbnRJbmRleF0gPSBlZGl0LmNhbGwodGhpcy5fcHJpdmF0ZS5jeSwgZWxlbWVudFZhbHVlLCBlbGVtZW50SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbmREaXJlY3Rpb25IZWFwaWZ5KGVsZW1lbnRJbmRleCk7XG4gICAgfVxuICB9O1xuXG4gICQkLmhlYXBmbi5kZWxldGUgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24oZWxlcyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGVsZW1lbnRJZCA9IGVsZW1lbnRzW2ldLmlkKCksXG4gICAgICAgIGVsZW1lbnRJbmRleCA9IHRoaXMuX3ByaXZhdGUucG9pbnRlcnNbZWxlbWVudElkXSxcbiAgICAgICAgbGFzdEluZGV4ID0gdGhpcy5fcHJpdmF0ZS5sZW5ndGggLSAxLFxuICAgICAgICByZW1vdmVDYW5kaWRhdGUsXG4gICAgICAgIHJlbW92ZVZhbHVlLFxuICAgICAgICByZW1JZDtcblxuICAgICAgaWYgKGVsZW1lbnRJbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgIHRoaXMuaGVhcFN3YXAoZWxlbWVudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVDYW5kaWRhdGUgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzW2xhc3RJbmRleF07XG4gICAgICByZW1vdmVWYWx1ZSA9IHRoaXMuX3ByaXZhdGUuaGVhcFtsYXN0SW5kZXhdO1xuICAgICAgcmVtSWQgPSByZW1vdmVDYW5kaWRhdGU7XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuaGVhcC5wb3AoKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMucG9wKCk7XG4gICAgICB0aGlzLl9wcml2YXRlLmxlbmd0aCA9IHRoaXMuX3ByaXZhdGUuaGVhcC5sZW5ndGg7XG4gICAgICB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW3JlbUlkXSA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5maW5kRGlyZWN0aW9uSGVhcGlmeShlbGVtZW50SW5kZXgpO1xuICAgIH1cblxuICAgIHJldHVybiByZW1vdmVWYWx1ZTtcbiAgfTtcblxufSkoY3l0b3NjYXBlKTtcbi8qXG4gIFRoZSBjYW52YXMgcmVuZGVyZXIgd2FzIHdyaXR0ZW4gYnkgWXVlIERvbmcuXG5cbiAgTW9kaWZpY2F0aW9ucyB0cmFja2VkIG9uIEdpdGh1Yi5cbiovXG5cbihmdW5jdGlvbigkJCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIob3B0aW9ucykge1xuICAgIFxuICAgIENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlMgPSA1O1xuICAgIENhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1ggPSAwO1xuICAgIENhbnZhc1JlbmRlcmVyLkRSQUcgPSAyO1xuICAgIENhbnZhc1JlbmRlcmVyLk5PREUgPSA0O1xuICAgIENhbnZhc1JlbmRlcmVyLlRFWFRVUkVfQlVGRkVSID0gMDtcbiAgICBDYW52YXNSZW5kZXJlci5CVUZGRVJfQ09VTlQgPSAyO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgXG4gICAgICBzZWxlY3Q6IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDBdLCAvLyBDb29yZGluYXRlcyBmb3Igc2VsZWN0aW9uIGJveCwgcGx1cyBlbmFibGVkIGZsYWcgXG4gICAgICByZW5kZXJlcjogdGhpcywgY3k6IG9wdGlvbnMuY3ksIGNvbnRhaW5lcjogb3B0aW9ucy5jeS5jb250YWluZXIoKSxcbiAgICAgIFxuICAgICAgY2FudmFzZXM6IG5ldyBBcnJheShDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTKSxcbiAgICAgIGNvbnRleHRzOiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyksXG4gICAgICBjYW52YXNOZWVkc1JlZHJhdzogbmV3IEFycmF5KENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlMpLFxuICAgICAgXG4gICAgICBidWZmZXJDYW52YXNlczogbmV3IEFycmF5KENhbnZhc1JlbmRlcmVyLkJVRkZFUl9DT1VOVCksXG4gICAgICBidWZmZXJDb250ZXh0czogbmV3IEFycmF5KENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlMpXG5cbiAgICB9O1xuICAgIFxuICAgIC8vLS1Qb2ludGVyLXJlbGF0ZWQgZGF0YVxuICAgIHRoaXMuaG92ZXJEYXRhID0ge2Rvd246IG51bGwsIGxhc3Q6IG51bGwsIFxuICAgICAgICBkb3duVGltZTogbnVsbCwgdHJpZ2dlck1vZGU6IG51bGwsIFxuICAgICAgICBkcmFnZ2luZzogZmFsc2UsIFxuICAgICAgICBpbml0aWFsUGFuOiBbbnVsbCwgbnVsbF0sIGNhcHR1cmU6IGZhbHNlfTtcbiAgICBcbiAgICB0aGlzLnRpbWVvdXREYXRhID0ge3BhblRpbWVvdXQ6IG51bGx9O1xuICAgIFxuICAgIHRoaXMuZHJhZ0RhdGEgPSB7cG9zc2libGVEcmFnRWxlbWVudHM6IFtdfTtcbiAgICBcbiAgICB0aGlzLnRvdWNoRGF0YSA9IHtzdGFydDogbnVsbCwgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIC8vIFRoZXNlIDMgZmllbGRzIHJlbGF0ZWQgdG8gdGFwLCB0YXBob2xkIGV2ZW50c1xuICAgICAgICBzdGFydFBvc2l0aW9uOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgICAgICBzaW5nbGVUb3VjaE1vdmVkOiB0cnVlLFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIG5vdzogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLCBcbiAgICAgICAgZWFybGllcjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdIH07XG4gICAgLy8tLVxuICAgIFxuICAgIC8vLS1XaGVlbC1yZWxhdGVkIGRhdGEgXG4gICAgdGhpcy56b29tRGF0YSA9IHtmcmVlVG9ab29tOiBmYWxzZSwgbGFzdFBvaW50ZXJYOiBudWxsfTtcbiAgICAvLy0tXG4gICAgXG4gICAgdGhpcy5yZWRyYXdzID0gMDtcbiAgICB0aGlzLnNob3dGcHMgPSBvcHRpb25zLnNob3dGcHM7XG5cbiAgICB0aGlzLmJpbmRpbmdzID0gW107XG4gICAgXG4gICAgdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBjb250YWluZXJTdHlsZSA9IHRoaXMuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGU7XG4gICAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNvbnRhaW5lclN0eWxlLnpJbmRleCA9ICcwJztcbiAgICBjb250YWluZXJTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgdGhpcy5kYXRhLmNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lciApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgdGhpcy5kYXRhLmNvbnRleHRzW2ldID0gdGhpcy5kYXRhLmNhbnZhc2VzW2ldLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB0aGlzLmRhdGEuY2FudmFzZXNbaV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc2VzW2ldLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBpKTtcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNlc1tpXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyAtIGkpO1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRhdGEuY2FudmFzZXNbaV0pO1xuICAgICAgXG4gICAgICB0aGlzLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbaV0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnRvcENhbnZhcyA9IHRoaXMuZGF0YS5jYW52YXNlc1swXTtcblxuICAgIHRoaXMuZGF0YS5jYW52YXNlc1tDYW52YXNSZW5kZXJlci5OT0RFXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ2FudmFzUmVuZGVyZXIuTk9ERSArICctbm9kZScpO1xuICAgIHRoaXMuZGF0YS5jYW52YXNlc1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWCArICctc2VsZWN0Ym94Jyk7XG4gICAgdGhpcy5kYXRhLmNhbnZhc2VzW0NhbnZhc1JlbmRlcmVyLkRSQUddLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDYW52YXNSZW5kZXJlci5EUkFHICsgJy1kcmFnJyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDYW52YXNSZW5kZXJlci5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0aGlzLmRhdGEuYnVmZmVyQ29udGV4dHNbaV0gPSB0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2J1ZmZlcicgKyBpKTtcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoLWkgLSAxKTtcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAvL3RoaXMuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgdGhpcy5oaWRlTGFiZWxzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQ7XG4gICAgdGhpcy50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gICAgdGhpcy53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgIHRoaXMubW90aW9uQmx1ckVuYWJsZWQgPSBvcHRpb25zLm1vdGlvbkJsdXIgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIG9uIGJ5IGRlZmF1bHRcbiAgICB0aGlzLmZvcmNlZFBpeGVsUmF0aW8gPSBvcHRpb25zLnBpeGVsUmF0aW87XG4gICAgdGhpcy5tb3Rpb25CbHVyID0gdHJ1ZTsgLy8gZm9yIGluaXRpYWwga2ljayBvZmZcbiAgICB0aGlzLnRhcFRocmVzaG9sZCA9IG9wdGlvbnMudGFwVGhyZXNob2xkO1xuICAgIHRoaXMudGFwVGhyZXNob2xkMiA9IG9wdGlvbnMudGFwVGhyZXNob2xkICogb3B0aW9ucy50YXBUaHJlc2hvbGQ7XG4gICAgdGhpcy50YXBob2xkRHVyYXRpb24gPSA1MDA7XG5cbiAgICB0aGlzLmxvYWQoKTtcbiAgfVxuXG4gIENhbnZhc1JlbmRlcmVyLnBhbk9yQm94U2VsZWN0RGVsYXkgPSA0MDA7XG4gIENhbnZhc1JlbmRlcmVyLmlzVG91Y2ggPSAkJC5pcy50b3VjaCgpO1xuXG4gIC8vIHdoZXRoZXIgdG8gdXNlIFBhdGgyRCBjYWNoaW5nIGZvciBkcmF3aW5nXG4gIHZhciBwYXRoc0ltcGxkID0gdHlwZW9mIFBhdGgyRCAhPT0gJ3VuZGVmaW5lZCc7XG4gIENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gcGF0aHNJbXBsZDtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIHR5cGVzO1xuXG4gICAgaWYoICQkLmlzLmFycmF5KCBwYXJhbXMudHlwZSApICl7XG4gICAgICB0eXBlcyA9IHBhcmFtcy50eXBlO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVzID0gWyBwYXJhbXMudHlwZSBdO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG5cbiAgICAgIHN3aXRjaCggdHlwZSApe1xuICAgICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgY2FzZSAnbG9hZCc6XG4gICAgICAgICAgdGhpcy51cGRhdGVOb2Rlc0NhY2hlKCk7XG4gICAgICAgICAgdGhpcy51cGRhdGVFZGdlc0NhY2hlKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmlld3BvcnQnOlxuICAgICAgICAgIHRoaXMuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGUgPT09ICdsb2FkJyB8fCB0eXBlID09PSAncmVzaXplJyApe1xuICAgICAgICB0aGlzLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgICB0aGlzLm1hdGNoQ2FudmFzU2l6ZSh0aGlzLmRhdGEuY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvclxuICAgIFxuICAgIHRoaXMuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7XG4gICAgdGhpcy5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gdHJ1ZTtcblxuICAgIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5iaW5kaW5ncy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW2ldO1xuICAgICAgdmFyIGIgPSBiaW5kaW5nO1xuXG4gICAgICBiLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGIuZXZlbnQsIGIuaGFuZGxlciwgYi51c2VDYXB0dXJlKTtcbiAgICB9XG5cbiAgICBpZiggdGhpcy5yZW1vdmVPYnNlcnZlciApe1xuICAgICAgdGhpcy5yZW1vdmVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYoIHRoaXMubGFiZWxDYWxjRGl2ICl7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubGFiZWxDYWxjRGl2KTtcbiAgICB9XG4gIH07XG5cbiAgXG5cbiAgLy8gY29weSB0aGUgbWF0aCBmdW5jdGlvbnMgaW50byB0aGUgcmVuZGVyZXIgcHJvdG90eXBlXG4gIC8vIHVuZm9ydHVuYXRlbHkgdGhlc2UgZnVuY3Rpb25zIGFyZSB1c2VkIGludGVyc3BlcnNlZCB0L28gdGhlIGNvZGVcbiAgLy8gYW5kIHRoaXMgbWFrZXMgc3VyZSB0aGluZ3Mgd29yayBqdXN0IGluIGNhc2UgYSByZWYgd2FzIG1pc3NlZCBpbiByZWZhY3RvcmluZ1xuICAvLyBUT0RPIHJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbiAgZm9yKCB2YXIgZm5OYW1lIGluICQkLm1hdGggKXtcbiAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGVbIGZuTmFtZSBdID0gJCQubWF0aFsgZm5OYW1lIF07XG4gIH1cbiAgXG4gIFxuICAkJCgncmVuZGVyZXInLCAnY2FudmFzJywgQ2FudmFzUmVuZGVyZXIpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciByZW5kRnVuYyA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcbiAgdmFyIGFycm93U2hhcGVzID0gQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXMgPSB7fTtcblxuICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlSGVpZ2h0ID0gMC4zO1xuXG4gIC8vIENvbnRyYWN0IGZvciBhcnJvdyBzaGFwZXM6XG4gIC8vIDAsIDAgaXMgYXJyb3cgdGlwXG4gIC8vICgwLCAxKSBpcyBkaXJlY3Rpb24gdG93YXJkcyBub2RlXG4gIC8vICgxLCAwKSBpcyByaWdodFxuICAvL1xuICAvLyBmdW5jdGlvbmFsIGFwaTpcbiAgLy8gY29sbGlkZTogY2hlY2sgeCwgeSBpbiBzaGFwZVxuICAvLyByb3VnaENvbGxpZGU6IGNhbGxlZCBiZWZvcmUgY29sbGlkZSwgbm8gZmFsc2UgbmVnYXRpdmVzXG4gIC8vIGRyYXc6IGRyYXdcbiAgLy8gc3BhY2luZzogZGlzdChhcnJvd1RpcCwgbm9kZUJvdW5kYXJ5KVxuICAvLyBnYXA6IGRpc3QoZWRnZVRpcCwgbm9kZUJvdW5kYXJ5KSwgZWRnZVRpcCBtYXkgIT0gYXJyb3dUaXBcblxuICB2YXIgYmJDb2xsaWRlID0gZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKXtcbiAgICB2YXIgeDEgPSBjZW50ZXJYIC0gd2lkdGgvMjtcbiAgICB2YXIgeDIgPSBjZW50ZXJYICsgd2lkdGgvMjtcbiAgICB2YXIgeTEgPSBjZW50ZXJZIC0gaGVpZ2h0LzI7XG4gICAgdmFyIHkyID0gY2VudGVyWSArIGhlaWdodC8yO1xuXG4gICAgcmV0dXJuICh4MSA8PSB4ICYmIHggPD0geDIpICYmICh5MSA8PSB5ICYmIHkgPD0geTIpO1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pe1xuICAgIGFuZ2xlID0gLWFuZ2xlOyAvLyBiL2Mgb2Ygbm90YXRpb24gdXNlZCBpbiBhcnJvdyBkcmF3IGZuXG5cbiAgICB2YXIgeFJvdGF0ZWQgPSB4ICogTWF0aC5jb3MoYW5nbGUpIC0geSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgeVJvdGF0ZWQgPSB4ICogTWF0aC5zaW4oYW5nbGUpICsgeSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICBcbiAgICB2YXIgeFNjYWxlZCA9IHhSb3RhdGVkICogc2l6ZTtcbiAgICB2YXIgeVNjYWxlZCA9IHlSb3RhdGVkICogc2l6ZTtcblxuICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB4OiB4VHJhbnNsYXRlZCxcbiAgICAgIHk6IHlUcmFuc2xhdGVkXG4gICAgfTtcbiAgfTtcblxuICBhcnJvd1NoYXBlc1snYXJyb3cnXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zXG4gICAgXSxcbiAgICBcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snYXJyb3cnXS5fcG9pbnRzO1xuICAgICAgXG4vLyAgICAgIGNvbnNvbGUubG9nKFwiY29sbGlkZSgpOiBcIiArIGRpcmVjdGlvbik7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ2Fycm93J10uX3BvaW50cztcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cblxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcblxuICBhcnJvd1NoYXBlc1sndHJpYW5nbGUnXSA9IGFycm93U2hhcGVzWydhcnJvdyddO1xuICBcbiAgYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLWJhY2tjdXJ2ZSddID0ge1xuICAgIF9jdHJsUHQ6IFsgMCwgLTAuMTUgXSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZSddLl9wb2ludHM7XG4gICAgICBcbi8vICAgICAgY29uc29sZS5sb2coXCJjb2xsaWRlKCk6IFwiICsgZGlyZWN0aW9uKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUnXS5fcG9pbnRzO1xuICAgICAgdmFyIGZpcnN0UHQ7XG4gICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCBwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgaWYoIGkgPT09IDAgKXtcbiAgICAgICAgICBmaXJzdFB0ID0gcHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0cmxQdCA9IHRoaXMuX2N0cmxQdDtcbiAgICAgIHZhciBjdHJsUHRUcmFucyA9IHRyYW5zZm9ybSggY3RybFB0WzBdLCBjdHJsUHRbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oIGN0cmxQdFRyYW5zLngsIGN0cmxQdFRyYW5zLnksIGZpcnN0UHQueCwgZmlyc3RQdC55ICk7XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSAqIDI7XG4gICAgfVxuICB9O1xuICBcblxuICBhcnJvd1NoYXBlc1sndHJpYW5nbGUtdGVlJ10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjMsXG4gICAgICAwLCAwLFxuICAgICAgMC4xNSwgLTAuMyxcbiAgICAgIC0wLjE1LCAtMC4zXG4gICAgXSxcblxuICAgIF9wb2ludHNUZWU6IFtcbiAgICAgIC0wLjE1LCAtMC40LFxuICAgICAgLTAuMTUsIC0wLjUsXG4gICAgICAwLjE1LCAtMC41LFxuICAgICAgMC4xNSwgLTAuNFxuICAgIF0sXG4gICAgXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLXRlZSddLl9wb2ludHM7XG4gICAgICB2YXIgdGVlUHRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLXRlZSddLl9wb2ludHNUZWU7XG4gICAgICBcbiAgICAgIHZhciBpbnNpZGUgPSAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0ZWVQdHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykgXG4gICAgICAgIHx8ICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRyaVB0cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcblxuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHRyaVB0cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZS10ZWUnXS5fcG9pbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCB0cmlQdHNbIGkgKiAyIF0sICB0cmlQdHNbIGkgKiAyICsgMSBdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZWVQdHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUtdGVlJ10uX3BvaW50c1RlZTtcbiAgICAgIHZhciBmaXJzdFRlZVB0ID0gdHJhbnNmb3JtKCB0ZWVQdHNbMF0sIHRlZVB0c1sxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyggZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkgKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWVQdHMubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCB0ZWVQdHNbIGkgKiAyIF0sICB0ZWVQdHNbIGkgKiAyICsgMSBdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSAqIDI7XG4gICAgfVxuICB9O1xuXG4gIGFycm93U2hhcGVzWydoYWxmLXRyaWFuZ2xlLW92ZXJzaG90J10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgMCwgLTAuMjUsXG4gICAgICAtMC41LCAtMC4yNSxcbiAgICAgIDAuNSwgMC4yNVxuICAgIF0sXG4gICAgXG4gICAgbGVhdmVQYXRoT3BlbjogdHJ1ZSxcbiAgICBtYXRjaEVkZ2VXaWR0aDogdHJ1ZSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cztcbiAgICAgIFxuLy8gICAgICBjb25zb2xlLmxvZyhcImNvbGxpZGUoKTogXCIgKyBkaXJlY3Rpb24pO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cztcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG5cbiAgYXJyb3dTaGFwZXNbJ25vbmUnXSA9IHtcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICBcbiAgYXJyb3dTaGFwZXNbJ2NpcmNsZSddID0ge1xuICAgIF9iYXNlUmFkaXVzOiAwLjE1LFxuICAgIFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgLy8gVHJhbnNmb3JtIHgsIHkgdG8gZ2V0IG5vbi1yb3RhdGVkIGVsbGlwc2VcbiAgICAgIFxuICAgICAgaWYgKHdpZHRoICE9IGhlaWdodCkgeyAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSAoaGVpZ2h0ICsgcGFkZGluZykgLyAod2lkdGggKyBwYWRkaW5nKTtcbiAgICAgICAgeSAvPSBhc3BlY3RSYXRpbztcbiAgICAgICAgY2VudGVyWSAvPSBhc3BlY3RSYXRpbztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAoTWF0aC5wb3coY2VudGVyWCAtIHgsIDIpIFxuICAgICAgICAgICsgTWF0aC5wb3coY2VudGVyWSAtIHksIDIpIDw9IE1hdGgucG93KCh3aWR0aCArIHBhZGRpbmcpXG4gICAgICAgICAgICAqIGFycm93U2hhcGVzWydjaXJjbGUnXS5fYmFzZVJhZGl1cywgMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhjZW50ZXJYIC0geCwgMikgXG4gICAgICAgICAgKyBNYXRoLnBvdyhjZW50ZXJZIC0geSwgMikgPD0gTWF0aC5wb3coKHdpZHRoICsgcGFkZGluZylcbiAgICAgICAgICAgICogYXJyb3dTaGFwZXNbJ2NpcmNsZSddLl9iYXNlUmFkaXVzLCAyKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIGNvbnRleHQuYXJjKHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIGFycm93U2hhcGVzWydjaXJjbGUnXS5fYmFzZVJhZGl1cyAqIHNpemUsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gcmVuZEZ1bmMuZ2V0QXJyb3dXaWR0aChlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpXG4gICAgICAgICogYXJyb3dTaGFwZXNbJ2NpcmNsZSddLl9iYXNlUmFkaXVzO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG4gIFxuICBhcnJvd1NoYXBlc1snaW5oaWJpdG9yJ10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgLTAuMjUsIDAsXG4gICAgICAtMC4yNSwgLTAuMSxcbiAgICAgIDAuMjUsIC0wLjEsXG4gICAgICAwLjI1LCAwXG4gICAgXSxcbiAgICBcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snaW5oaWJpdG9yJ10uX3BvaW50cztcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snaW5oaWJpdG9yJ10uX3BvaW50cztcbiAgICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfTtcblxuICBhcnJvd1NoYXBlc1sndGVlJ10gPSBhcnJvd1NoYXBlc1snaW5oaWJpdG9yJ107XG5cbiAgYXJyb3dTaGFwZXNbJ3NxdWFyZSddID0ge1xuICAgIF9wb2ludHM6IFtcbiAgICAgIC0wLjE1LCAwLjAwLFxuICAgICAgMC4xNSwgMC4wMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAtMC4xNSwgLTAuM1xuICAgIF0sXG4gICAgXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ3NxdWFyZSddLl9wb2ludHM7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ3NxdWFyZSddLl9wb2ludHM7XG4gICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCBwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG5cbiAgYXJyb3dTaGFwZXNbJ2RpYW1vbmQnXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMTUsXG4gICAgICAwLCAtMC4zLFxuICAgICAgMC4xNSwgLTAuMTUsXG4gICAgICAwLCAwXG4gICAgXSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydkaWFtb25kJ10uX3BvaW50cztcbiAgICAgICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydkaWFtb25kJ10uX3BvaW50cztcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlO1xuICAgIH1cbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldENhY2hlZE5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7IHZhciBjeSA9IHRoaXMuZGF0YS5jeTtcbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZSA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgfVxuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlLmNhY2hlZE5vZGVzID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUuY2FjaGVkTm9kZXMgPSBjeS5ub2RlcygpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0YS5jYWNoZS5jYWNoZWROb2RlcztcbiAgfTtcbiAgXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVOb2Rlc0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7IHZhciBjeSA9IHRoaXMuZGF0YS5jeTtcbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZSA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgfVxuICAgIFxuICAgIGRhdGEuY2FjaGUuY2FjaGVkTm9kZXMgPSBjeS5ub2RlcygpO1xuICB9O1xuICBcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldENhY2hlZEVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7IHZhciBjeSA9IHRoaXMuZGF0YS5jeTtcbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZSA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgfVxuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlLmNhY2hlZEVkZ2VzID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUuY2FjaGVkRWRnZXMgPSBjeS5lZGdlcygpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0YS5jYWNoZS5jYWNoZWRFZGdlcztcbiAgfTtcbiAgXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVFZGdlc0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7IHZhciBjeSA9IHRoaXMuZGF0YS5jeTtcbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZSA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgfVxuICAgIFxuICAgIGRhdGEuY2FjaGUuY2FjaGVkRWRnZXMgPSBjeS5lZGdlcygpO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuXG4gIC8vIFByb2plY3QgbW91c2VcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnByb2plY3RJbnRvVmlld3BvcnQgPSBmdW5jdGlvbihjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgdmFyIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgXG4gICAgdmFyIHggPSBjbGllbnRYIC0gb2Zmc2V0TGVmdDsgXG4gICAgdmFyIHkgPSBjbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgIFxuICAgIHggLT0gdGhpcy5kYXRhLmN5LnBhbigpLng7IHkgLT0gdGhpcy5kYXRhLmN5LnBhbigpLnk7IHggLz0gdGhpcy5kYXRhLmN5Lnpvb20oKTsgeSAvPSB0aGlzLmRhdGEuY3kuem9vbSgpO1xuICAgIHJldHVybiBbeCwgeV07XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5kYXRhLmNvbnRhaW5lcjtcblxuICAgIHZhciBiYiA9IHRoaXMuY29udGFpbmVyQkIgPSB0aGlzLmNvbnRhaW5lckJCIHx8IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHJldHVybiBbYmIubGVmdCwgYmIudG9wLCBiYi5yaWdodCAtIGJiLmxlZnQsIGJiLmJvdHRvbSAtIGJiLnRvcF07XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG4gIH07XG5cbiAgLy8gRmluZCBuZWFyZXN0IGVsZW1lbnRcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmZpbmROZWFyZXN0RWxlbWVudCA9IGZ1bmN0aW9uKHgsIHksIHZpc2libGVFbGVtZW50c09ubHkpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICB2YXIgbmVhciA9IFtdO1xuICAgIHZhciBpc1RvdWNoID0gQ2FudmFzUmVuZGVyZXIuaXNUb3VjaDtcbiAgICB2YXIgem9vbSA9IHRoaXMuZGF0YS5jeS56b29tKCk7XG4gICAgdmFyIGhhc0NvbXBvdW5kcyA9IHRoaXMuZGF0YS5jeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGVkZ2VUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDI1NiA6IDMyKSAvIHpvb207XG4gICAgdmFyIG5vZGVUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDE2IDogMCkgLyAgem9vbTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrTm9kZShub2RlKXtcbiAgICAgIHZhciB3aWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICAgICAgdmFyIGhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcbiAgICAgIHZhciBodyA9IHdpZHRoLzI7XG4gICAgICB2YXIgaGggPSBoZWlnaHQvMjtcbiAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICBpZihcbiAgICAgICAgcG9zLnggLSBodyA8PSB4ICYmIHggPD0gcG9zLnggKyBodyAvLyBiYiBjaGVjayB4XG4gICAgICAgICAgJiZcbiAgICAgICAgcG9zLnkgLSBoaCA8PSB5ICYmIHkgPD0gcG9zLnkgKyBoaCAvLyBiYiBjaGVjayB5XG4gICAgICApe1xuICAgICAgICB2YXIgdmlzaWJsZSA9ICF2aXNpYmxlRWxlbWVudHNPbmx5IHx8ICggbm9kZS52aXNpYmxlKCkgJiYgIW5vZGUudHJhbnNwYXJlbnQoKSApO1xuXG4gICAgICAgIC8vIGV4aXQgZWFybHkgaWYgaW52aXNpYmxlIGVkZ2UgYW5kIG11c3QgYmUgdmlzaWJsZVxuICAgICAgICBpZiggdmlzaWJsZUVsZW1lbnRzT25seSAmJiAhdmlzaWJsZSApe1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaGFwZSA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbIHNlbGYuZ2V0Tm9kZVNoYXBlKG5vZGUpIF07XG4gICAgICAgIHZhciBib3JkZXJXTyA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWUgLyAyO1xuXG4gICAgICAgIGlmKFxuICAgICAgICAgIHNoYXBlLmNoZWNrUG9pbnQoeCwgeSwgYm9yZGVyV08sIHdpZHRoICsgbm9kZVRocmVzaG9sZCwgaGVpZ2h0ICsgbm9kZVRocmVzaG9sZCwgcG9zLngsIHBvcy55KVxuICAgICAgICApe1xuICAgICAgICAgICAgbmVhci5wdXNoKCBub2RlICk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrRWRnZShlZGdlKXtcbiAgICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB2YXIgc3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgdmFyIHdpZHRoID0gc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZTtcbiAgICAgIHZhciB3aWR0aFNxID0gd2lkdGggKiB3aWR0aDtcbiAgICAgIHZhciB3aWR0aDIgPSB3aWR0aCAqIDI7XG4gICAgICB2YXIgc3JjID0gZWRnZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gZWRnZS5fcHJpdmF0ZS50YXJnZXQ7XG4gICAgICB2YXIgaW5FZGdlQkIgPSBmYWxzZTtcblxuICAgICAgLy8gZXhpdCBlYXJseSBpZiBpbnZpc2libGUgZWRnZSBhbmQgbXVzdCBiZSB2aXNpYmxlXG4gICAgICB2YXIgcGFzc2VkVmlzaWJpbGl0eUNoZWNrO1xuICAgICAgdmFyIHBhc3Nlc1Zpc2liaWxpdHlDaGVjayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHJldHVybiBwYXNzZWRWaXNpYmlsaXR5Q2hlY2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIXZpc2libGVFbGVtZW50c09ubHkgKXtcbiAgICAgICAgICBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpc2libGUgPSBlZGdlLnZpc2libGUoKSAmJiAhZWRnZS50cmFuc3BhcmVudCgpO1xuICAgICAgICBpZiggdmlzaWJsZSApe1xuICAgICAgICAgIHBhc3NlZFZpc2liaWxpdHlDaGVjayA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09PSAnc2VsZicpIHtcbiAgICAgICAgaWYoXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIChpbkVkZ2VCQiA9ICQkLm1hdGguaW5CZXppZXJWaWNpbml0eSh4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuY3AyYXgsIHJzLmNwMmF5LCBycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWSwgd2lkdGhTcSkpXG4gICAgICAgICAgICAgICAgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiZcbiAgICAgICAgICAgICAgKCB3aWR0aFNxICsgZWRnZVRocmVzaG9sZCA+ICQkLm1hdGguc3FEaXN0YW5jZVRvUXVhZHJhdGljQmV6aWVyKHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJheCwgcnMuY3AyYXksIHJzLnNlbGZFZGdlTWlkWCwgcnMuc2VsZkVkZ2VNaWRZKSApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHx8XG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIChpbkVkZ2VCQiA9ICQkLm1hdGguaW5CZXppZXJWaWNpbml0eSh4LCB5LCBycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWSwgcnMuY3AyY3gsIHJzLmNwMmN5LCBycy5lbmRYLCBycy5lbmRZLCB3aWR0aFNxKSlcbiAgICAgICAgICAgICAgICAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJlxuICAgICAgICAgICAgICAoIHdpZHRoU3EgKyBlZGdlVGhyZXNob2xkID4gJCQubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFksIHJzLmNwMmN4LCBycy5jcDJjeSwgcnMuZW5kWCwgcnMuZW5kWSkgKVxuICAgICAgICAgICAgKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHN0eWxlWydoYXlzdGFjay1yYWRpdXMnXS52YWx1ZTtcbiAgICAgICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMvMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgICAgICB2YXIgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgdGd0VyA9IHRndC53aWR0aCgpO1xuICAgICAgICB2YXIgdGd0SCA9IHRndC5oZWlnaHQoKTtcbiAgICAgICAgdmFyIHNyY1BvcyA9IHNyYy5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNyY1cgPSBzcmMud2lkdGgoKTtcbiAgICAgICAgdmFyIHNyY0ggPSBzcmMuaGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIHN0YXJ0WCA9IHNyY1Bvcy54ICsgcnMuc291cmNlLnggKiBzcmNXICogaGFsZlJhZGl1cztcbiAgICAgICAgdmFyIHN0YXJ0WSA9IHNyY1Bvcy55ICsgcnMuc291cmNlLnkgKiBzcmNIICogaGFsZlJhZGl1cztcbiAgICAgICAgdmFyIGVuZFggPSB0Z3RQb3MueCArIHJzLnRhcmdldC54ICogdGd0VyAqIGhhbGZSYWRpdXM7XG4gICAgICAgIHZhciBlbmRZID0gdGd0UG9zLnkgKyBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzO1xuXG4gICAgICAgIGlmKCBcbiAgICAgICAgICAoaW5FZGdlQkIgPSAkJC5tYXRoLmluTGluZVZpY2luaXR5KHgsIHksIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCB3aWR0aDIpKVxuICAgICAgICAgICAgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiZcbiAgICAgICAgICB3aWR0aFNxICsgZWRnZVRocmVzaG9sZCA+ICQkLm1hdGguc3FEaXN0YW5jZVRvRmluaXRlTGluZSggeCwgeSwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFkgKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgaWYoXG4gICAgICAgICAgKGluRWRnZUJCID0gJCQubWF0aC5pbkxpbmVWaWNpbml0eSh4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWSwgd2lkdGgyKSlcbiAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgd2lkdGhTcSArIGVkZ2VUaHJlc2hvbGQgPiAkJC5tYXRoLnNxRGlzdGFuY2VUb0Zpbml0ZUxpbmUoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmVuZFgsIHJzLmVuZFkpXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicpIHtcbiAgICAgICAgaWYoXG4gICAgICAgICAgKGluRWRnZUJCID0gJCQubWF0aC5pbkJlemllclZpY2luaXR5KHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJ4LCBycy5jcDJ5LCBycy5lbmRYLCBycy5lbmRZLCB3aWR0aFNxKSlcbiAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgKHdpZHRoU3EgKyBlZGdlVGhyZXNob2xkID4gJCQubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMngsIHJzLmNwMnksIHJzLmVuZFgsIHJzLmVuZFkpKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBpbkVkZ2VCQiAmJiBwYXNzZXNWaXNpYmlsaXR5Q2hlY2soKSAmJiBuZWFyLmxlbmd0aCA9PT0gMCB8fCBuZWFyW25lYXIubGVuZ3RoIC0gMV0gIT09IGVkZ2UgKXtcbiAgICAgICAgdmFyIHNyY1NoYXBlID0gQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbIHN0eWxlWydzb3VyY2UtYXJyb3ctc2hhcGUnXS52YWx1ZSBdO1xuICAgICAgICB2YXIgdGd0U2hhcGUgPSBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1sgc3R5bGVbJ3RhcmdldC1hcnJvdy1zaGFwZSddLnZhbHVlIF07XG5cbiAgICAgICAgdmFyIHNyYyA9IHNyYyB8fCBlZGdlLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgICAgdmFyIHRndCA9IHRndCB8fCBlZGdlLl9wcml2YXRlLnRhcmdldDtcblxuICAgICAgICB2YXIgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgc3JjUG9zID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAgIHZhciBzcmNBclcgPSBzZWxmLmdldEFycm93V2lkdGgoIHN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKTtcbiAgICAgICAgdmFyIHNyY0FySCA9IHNlbGYuZ2V0QXJyb3dIZWlnaHQoIHN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKTtcblxuICAgICAgICB2YXIgdGd0QXJXID0gc3JjQXJXO1xuICAgICAgICB2YXIgdGd0QXJIID0gc3JjQXJIO1xuXG4gICAgICAgIGlmKFxuICAgICAgICAgIChcbiAgICAgICAgICAgIHNyY1NoYXBlLnJvdWdoQ29sbGlkZSh4LCB5LCBycy5hcnJvd1N0YXJ0WCwgcnMuYXJyb3dTdGFydFksIHNyY0FyVywgc3JjQXJILCBbcnMuYXJyb3dTdGFydFggLSBzcmNQb3MueCwgcnMuYXJyb3dTdGFydFkgLSBzcmNQb3MueV0sIDApXG4gICAgICAgICAgICAgICYmIFxuICAgICAgICAgICAgc3JjU2hhcGUuY29sbGlkZSh4LCB5LCBycy5hcnJvd1N0YXJ0WCwgcnMuYXJyb3dTdGFydFksIHNyY0FyVywgc3JjQXJILCBbcnMuYXJyb3dTdGFydFggLSBzcmNQb3MueCwgcnMuYXJyb3dTdGFydFkgLSBzcmNQb3MueV0sIDApXG4gICAgICAgICAgKVxuICAgICAgICAgICAgfHxcbiAgICAgICAgICAoXG4gICAgICAgICAgICB0Z3RTaGFwZS5yb3VnaENvbGxpZGUoeCwgeSwgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHRndEFyVywgdGd0QXJILCBbcnMuYXJyb3dFbmRYIC0gdGd0UG9zLngsIHJzLmFycm93RW5kWSAtIHRndFBvcy55XSwgMClcbiAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgIHRndFNoYXBlLmNvbGxpZGUoeCwgeSwgcnMuYXJyb3dFbmRYLCBycy5hcnJvd0VuZFksIHRndEFyVywgdGd0QXJILCBbcnMuYXJyb3dFbmRYIC0gdGd0UG9zLngsIHJzLmFycm93RW5kWSAtIHRndFBvcy55XSwgMClcbiAgICAgICAgICApXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZm9yIGNvbXBvdW5kIGdyYXBocywgaGl0dGluZyBlZGdlIG1heSBhY3R1YWxseSB3YW50IGEgY29ubmVjdGVkIG5vZGUgaW5zdGVhZCAoYi9jIGVkZ2UgbWF5IGhhdmUgZ3JlYXRlciB6LWluZGV4IHByZWNlZGVuY2UpXG4gICAgICBpZiggaGFzQ29tcG91bmRzICYmICBuZWFyLmxlbmd0aCA+IDAgJiYgbmVhclsgbmVhci5sZW5ndGggLSAxIF0gPT09IGVkZ2UgKXtcbiAgICAgICAgY2hlY2tOb2RlKCBzcmMgKTtcbiAgICAgICAgY2hlY2tOb2RlKCB0Z3QgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gZWxlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApeyAvLyByZXZlcnNlIG9yZGVyIGZvciBwcmVjZWRlbmNlXG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgaWYoIG5lYXIubGVuZ3RoID4gMCApeyBicmVhazsgfSAvLyBzaW5jZSB3ZSBjaGVjayBpbiB6LW9yZGVyLCBmaXJzdCBmb3VuZCBpcyB0b3AgYW5kIGJlc3QgcmVzdWx0ID0+IGV4aXQgZWFybHlcblxuICAgICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApeyBcbiAgICAgICAgY2hlY2tOb2RlKCBlbGVzW2ldICk7XG5cbiAgICAgIH0gZWxzZSAgeyAvLyB0aGVuIGVkZ2VcbiAgICAgICAgY2hlY2tFZGdlKCBlbGVzW2ldICk7XG4gICAgICB9XG5cbiAgICB9XG4gIFxuICAgIFxuICAgIGlmKCBuZWFyLmxlbmd0aCA+IDAgKXtcbiAgICAgIHJldHVybiBuZWFyWyBuZWFyLmxlbmd0aCAtIDEgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9OyBcblxuICAvLyAnR2l2ZSBtZSBldmVyeXRoaW5nIGZyb20gdGhpcyBib3gnXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXRBbGxJbkJveCA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5nZXRDYWNoZWROb2RlcygpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICB2YXIgYm94ID0gW107XG4gICAgXG4gICAgdmFyIHgxYyA9IE1hdGgubWluKHgxLCB4Mik7XG4gICAgdmFyIHgyYyA9IE1hdGgubWF4KHgxLCB4Mik7XG4gICAgdmFyIHkxYyA9IE1hdGgubWluKHkxLCB5Mik7XG4gICAgdmFyIHkyYyA9IE1hdGgubWF4KHkxLCB5Mik7IFxuXG4gICAgeDEgPSB4MWM7IFxuICAgIHgyID0geDJjOyBcbiAgICB5MSA9IHkxYzsgXG4gICAgeTIgPSB5MmM7IFxuXG4gICAgdmFyIGhldXI7XG4gICAgXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBwb3MgPSBub2Rlc1tpXS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciBuU2hhcGUgPSB0aGlzLmdldE5vZGVTaGFwZShub2Rlc1tpXSk7XG4gICAgICB2YXIgdyA9IHRoaXMuZ2V0Tm9kZVdpZHRoKG5vZGVzW2ldKTtcbiAgICAgIHZhciBoID0gdGhpcy5nZXROb2RlSGVpZ2h0KG5vZGVzW2ldKTtcbiAgICAgIHZhciBib3JkZXIgPSBub2Rlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZSAvIDI7XG4gICAgICB2YXIgc2hhcGVPYmogPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzWyBuU2hhcGUgXTtcblxuICAgICAgaWYgKCBzaGFwZU9iai5pbnRlcnNlY3RCb3goeDEsIHkxLCB4MiwgeTIsIHcsIGgsIHBvcy54LCBwb3MueSwgYm9yZGVyKSApe1xuICAgICAgICBib3gucHVzaChub2Rlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcnMgPSBlZGdlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaDtcblxuICAgICAgaWYgKGVkZ2VzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmVkZ2VUeXBlID09ICdzZWxmJykge1xuICAgICAgICBpZiAoKGhldXIgPSAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkoeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgIHJzLmNwMmF4LCBycy5jcDJheSxcbiAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKVxuICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgKGhldXIgPT0gMiB8fCAoaGV1ciA9PSAxICYmICQkLm1hdGguY2hlY2tCZXppZXJJbkJveCh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICAgIHJzLmNwMmF4LCBycy5jcDJheSxcbiAgICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpKVxuICAgICAgICAgICAgICAgIHx8XG4gICAgICAgICAgKGhldXIgPSAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkoeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgIHJzLmNwMmN4LCBycy5jcDJjeSxcbiAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKVxuICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgKGhldXIgPT0gMiB8fCAoaGV1ciA9PSAxICYmICQkLm1hdGguY2hlY2tCZXppZXJJbkJveCh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICAgIHJzLmNwMmN4LCBycy5jcDJjeSxcbiAgICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpKVxuICAgICAgICAgIClcbiAgICAgICAgeyBib3gucHVzaChlZGdlc1tpXSk7IH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09ICdiZXppZXInICYmXG4gICAgICAgIChoZXVyID0gJCQubWF0aC5ib3hJbkJlemllclZpY2luaXR5KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICBycy5jcDJ4LCBycy5jcDJ5LFxuICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpXG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICAoaGV1ciA9PSAyIHx8IChoZXVyID09IDEgJiYgJCQubWF0aC5jaGVja0JlemllckluQm94KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgICAgcnMuY3AyeCwgcnMuY3AyeSxcbiAgICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpKSlcbiAgICAgICAgeyBib3gucHVzaChlZGdlc1tpXSk7IH1cbiAgICBcbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PSAnc3RyYWlnaHQnICYmXG4gICAgICAgIChoZXVyID0gJCQubWF0aC5ib3hJbkJlemllclZpY2luaXR5KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICBycy5zdGFydFggKiAwLjUgKyBycy5lbmRYICogMC41LCBcbiAgICAgICAgICAgIHJzLnN0YXJ0WSAqIDAuNSArIHJzLmVuZFkgKiAwLjUsIFxuICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpXG4gICAgICAgICAgICAgICYmIC8qIGNvbnNvbGUubG9nKCd0ZXN0JywgaGV1cikgPT0gdW5kZWZpbmVkICYmICovXG4gICAgICAgICAgICAoaGV1ciA9PSAyIHx8IChoZXVyID09IDEgJiYgJCQubWF0aC5jaGVja1N0cmFpZ2h0RWRnZUluQm94KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgICBycy5zdGFydFgsIHJzLnN0YXJ0WSxcbiAgICAgICAgICAgICAgcnMuZW5kWCwgcnMuZW5kWSwgZWRnZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSkpKSlcbiAgICAgICAgeyBib3gucHVzaChlZGdlc1tpXSk7IH1cblxuXG4gICAgICBpZiAocnMuZWRnZVR5cGUgPT0gJ2hheXN0YWNrJyl7XG4gICAgICAgIHZhciB0Z3QgPSBlZGdlc1tpXS50YXJnZXQoKVswXTtcbiAgICAgICAgdmFyIHRndFBvcyA9IHRndC5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgc3JjID0gZWRnZXNbaV0uc291cmNlKClbMF07XG4gICAgICAgIHZhciBzcmNQb3MgPSBzcmMucG9zaXRpb24oKTtcblxuICAgICAgICB2YXIgc3RhcnRYID0gc3JjUG9zLnggKyBycy5zb3VyY2UueDtcbiAgICAgICAgdmFyIHN0YXJ0WSA9IHNyY1Bvcy55ICsgcnMuc291cmNlLnk7XG4gICAgICAgIHZhciBlbmRYID0gdGd0UG9zLnggKyBycy50YXJnZXQueDtcbiAgICAgICAgdmFyIGVuZFkgPSB0Z3RQb3MueSArIHJzLnRhcmdldC55O1xuXG4gICAgICAgIHZhciBzdGFydEluQm94ID0gKHgxIDw9IHN0YXJ0WCAmJiBzdGFydFggPD0geDIpICYmICh5MSA8PSBzdGFydFkgJiYgc3RhcnRZIDw9IHkyKTtcbiAgICAgICAgdmFyIGVuZEluQm94ID0gKHgxIDw9IGVuZFggJiYgZW5kWCA8PSB4MikgJiYgKHkxIDw9IGVuZFkgJiYgZW5kWSA8PSB5Mik7XG5cbiAgICAgICAgaWYoIHN0YXJ0SW5Cb3ggJiYgZW5kSW5Cb3ggKXtcbiAgICAgICAgICBib3gucHVzaCggZWRnZXNbaV0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBib3g7XG4gIH07XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSB3aWR0aCBpcyBzZXQgdG8gYXV0byxcbiAgICogcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGF1dG9XaWR0aCBmaWVsZC5cbiAgICpcbiAgICogQHBhcmFtIG5vZGUgICAgICAgICAgYSBub2RlXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgIHdpZHRoIG9mIHRoZSBub2RlXG4gICAqL1xuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0Tm9kZVdpZHRoID0gZnVuY3Rpb24obm9kZSlcbiAge1xuICAgIHJldHVybiBub2RlLndpZHRoKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIGhlaWdodCBpcyBzZXQgdG8gYXV0byxcbiAgICogcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGF1dG9IZWlnaHQgZmllbGQuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlICAgICAgICAgIGEgbm9kZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICB3aWR0aCBvZiB0aGUgbm9kZVxuICAgKi9cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldE5vZGVIZWlnaHQgPSBmdW5jdGlvbihub2RlKVxuICB7XG4gICAgcmV0dXJuIG5vZGUuaGVpZ2h0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNoYXBlIG9mIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgaGVpZ2h0IG9yIHdpZHRoIG9mIHRoZSBnaXZlbiBub2RlXG4gICAqIGlzIHNldCB0byBhdXRvLCB0aGUgbm9kZSBpcyBjb25zaWRlcmVkIHRvIGJlIGEgY29tcG91bmQuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlICAgICAgICAgIGEgbm9kZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICBzaGFwZSBvZiB0aGUgbm9kZVxuICAgKi9cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldE5vZGVTaGFwZSA9IGZ1bmN0aW9uKG5vZGUpXG4gIHtcbiAgICAvLyBUT0RPIG9ubHkgYWxsb3cgcmVjdGFuZ2xlIGZvciBhIGNvbXBvdW5kIG5vZGU/XG4vLyAgICBpZiAobm9kZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS52YWx1ZSA9PSAnYXV0bycgfHxcbi8vICAgICAgICBub2RlLl9wcml2YXRlLnN0eWxlWydoZWlnaHQnXS52YWx1ZSA9PSAnYXV0bycpXG4vLyAgICB7XG4vLyAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbi8vICAgIH1cblxuICAgIHZhciBzaGFwZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3NoYXBlJ10udmFsdWU7XG5cbiAgICBpZiggbm9kZS5pc1BhcmVudCgpICl7XG4gICAgICBpZiggc2hhcGUgPT09ICdyZWN0YW5nbGUnIHx8IHNoYXBlID09PSAncm91bmRyZWN0YW5nbGUnICl7XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAncmVjdGFuZ2xlJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGU7XG4gIH07XG5cblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0Tm9kZVBhZGRpbmcgPSBmdW5jdGlvbihub2RlKVxuICB7XG4gICAgdmFyIGxlZnQgPSBub2RlLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLWxlZnQnXS5weFZhbHVlO1xuICAgIHZhciByaWdodCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctcmlnaHQnXS5weFZhbHVlO1xuICAgIHZhciB0b3AgPSBub2RlLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLXRvcCddLnB4VmFsdWU7XG4gICAgdmFyIGJvdHRvbSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BhZGRpbmctYm90dG9tJ10ucHhWYWx1ZTtcblxuICAgIGlmIChpc05hTihsZWZ0KSlcbiAgICB7XG4gICAgICBsZWZ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4ocmlnaHQpKVxuICAgIHtcbiAgICAgIHJpZ2h0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4odG9wKSlcbiAgICB7XG4gICAgICB0b3AgPSAwO1xuICAgIH1cblxuICAgIGlmIChpc05hTihib3R0b20pKVxuICAgIHtcbiAgICAgIGJvdHRvbSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtsZWZ0IDogbGVmdCxcbiAgICAgIHJpZ2h0IDogcmlnaHQsXG4gICAgICB0b3AgOiB0b3AsXG4gICAgICBib3R0b20gOiBib3R0b219O1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS56T3JkZXJTb3J0ID0gJCQuQ29sbGVjdGlvbi56SW5kZXhTb3J0O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS51cGRhdGVDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5nZXRDYWNoZWRaU29ydGVkRWxlcyggdHJ1ZSApO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXRDYWNoZWRaU29ydGVkRWxlcyA9IGZ1bmN0aW9uKCBmb3JjZVJlY2FsYyApe1xuICAgIHZhciBsYXN0Tm9kZXMgPSB0aGlzLmxhc3RaT3JkZXJDYWNoZWROb2RlcztcbiAgICB2YXIgbGFzdEVkZ2VzID0gdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkRWRnZXM7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5nZXRDYWNoZWROb2RlcygpO1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICB2YXIgZWxlcyA9IFtdO1xuXG4gICAgaWYoIGZvcmNlUmVjYWxjIHx8ICFsYXN0Tm9kZXMgfHwgIWxhc3RFZGdlcyB8fCBsYXN0Tm9kZXMgIT09IG5vZGVzIHx8IGxhc3RFZGdlcyAhPT0gZWRnZXMgKXsgXG4gICAgICAvL2NvbnNvbGUudGltZSgnY2FjaGV6b3JkZXInKVxuICAgICAgXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCBub2Rlc1tpXS52aXNpYmxlKCkgJiYgIW5vZGVzW2ldLnRyYW5zcGFyZW50KCkgKXtcbiAgICAgICAgICBlbGVzLnB1c2goIG5vZGVzW2ldICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBpZiggZWRnZXNbaV0udmlzaWJsZSgpICYmICFlZGdlc1tpXS50cmFuc3BhcmVudCgpICl7XG4gICAgICAgICAgZWxlcy5wdXNoKCBlZGdlc1tpXSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsZXMuc29ydCggdGhpcy56T3JkZXJTb3J0ICk7XG4gICAgICB0aGlzLmNhY2hlZFpTb3J0ZWRFbGVzID0gZWxlcztcbiAgICAgIC8vY29uc29sZS5sb2coJ21ha2UgY2FjaGUnKVxuXG4gICAgICAvL2NvbnNvbGUudGltZUVuZCgnY2FjaGV6b3JkZXInKVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVzID0gdGhpcy5jYWNoZWRaU29ydGVkRWxlcztcbiAgICAgIC8vY29uc29sZS5sb2coJ3JlYWQgY2FjaGUnKVxuICAgIH1cblxuICAgIHRoaXMubGFzdFpPcmRlckNhY2hlZE5vZGVzID0gbm9kZXM7XG4gICAgdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkRWRnZXMgPSBlZGdlcztcblxuICAgIHJldHVybiBlbGVzO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5wcm9qZWN0QmV6aWVyID0gZnVuY3Rpb24oZWRnZSl7XG4gICAgdmFyIHFiZXppZXJBdCA9ICQkLm1hdGgucWJlemllckF0O1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGJwdHMgPSBlZGdlLl9wcml2YXRlLnJzdHlsZS5iZXppZXJQdHMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIHB1c2hCZXppZXJQdHMocHRzKXtcbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4wNSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuMDUgKVxuICAgICAgfSk7XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC4yNSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuMjUgKVxuICAgICAgfSk7XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC40ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC40IClcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbWlkID0ge1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuNSApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuNSApXG4gICAgICB9O1xuXG4gICAgICBicHRzLnB1c2goIG1pZCApO1xuXG4gICAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdzZWxmJyApe1xuICAgICAgICBycy5taWRYID0gcnMuc2VsZkVkZ2VNaWRYO1xuICAgICAgICBycy5taWRZID0gcnMuc2VsZkVkZ2VNaWRZO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMubWlkWCA9IG1pZC54O1xuICAgICAgICBycy5taWRZID0gbWlkLnk7XG4gICAgICB9XG5cbiAgICAgIGJwdHMucHVzaCh7XG4gICAgICAgIHg6IHFiZXppZXJBdCggcHRzWzBdLCBwdHNbMl0sIHB0c1s0XSwgMC42ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC42IClcbiAgICAgIH0pO1xuXG4gICAgICBicHRzLnB1c2goe1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuNzUgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjc1IClcbiAgICAgIH0pO1xuXG4gICAgICBicHRzLnB1c2goe1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuOTUgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjk1IClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ3NlbGYnICl7XG4gICAgICBwdXNoQmV6aWVyUHRzKCBbcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMmF4LCBycy5jcDJheSwgcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFldICk7XG4gICAgICBwdXNoQmV6aWVyUHRzKCBbcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFksIHJzLmNwMmN4LCBycy5jcDJjeSwgcnMuZW5kWCwgcnMuZW5kWV0gKTtcbiAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyApe1xuICAgICAgcHVzaEJlemllclB0cyggW3JzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJ4LCBycy5jcDJ5LCBycy5lbmRYLCBycy5lbmRZXSApO1xuICAgIH1cbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uID0gZnVuY3Rpb24oIG5vZGUgKXtcbiAgICB2YXIgY29udGVudCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICBpZiggIWNvbnRlbnQgfHwgY29udGVudC5tYXRjaCgvXlxccyskLykgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdGV4dFgsIHRleHRZO1xuICAgIHZhciBub2RlV2lkdGggPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgICB2YXIgbm9kZUhlaWdodCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcbiAgICB2YXIgbm9kZVBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgdmFyIHRleHRIYWxpZ24gPSBub2RlLl9wcml2YXRlLnN0eWxlWyd0ZXh0LWhhbGlnbiddLnN0clZhbHVlO1xuICAgIHZhciB0ZXh0VmFsaWduID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciByc3R5bGUgPSBub2RlLl9wcml2YXRlLnJzdHlsZTtcblxuICAgIHN3aXRjaCggdGV4dEhhbGlnbiApe1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIHRleHRYID0gbm9kZVBvcy54IC0gbm9kZVdpZHRoIC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgdGV4dFggPSBub2RlUG9zLnggKyBub2RlV2lkdGggLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgICAgdGV4dFggPSBub2RlUG9zLng7XG4gICAgfVxuXG4gICAgc3dpdGNoKCB0ZXh0VmFsaWduICl7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICB0ZXh0WSA9IG5vZGVQb3MueSAtIG5vZGVIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgdGV4dFkgPSBub2RlUG9zLnkgKyBub2RlSGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6IC8vIGUuZy4gbWlkZGxlXG4gICAgICAgIHRleHRZID0gbm9kZVBvcy55O1xuICAgIH1cbiAgXG4gICAgcnMubGFiZWxYID0gdGV4dFg7XG4gICAgcnMubGFiZWxZID0gdGV4dFk7XG4gICAgcnN0eWxlLmxhYmVsWCA9IHRleHRYO1xuICAgIHJzdHlsZS5sYWJlbFkgPSB0ZXh0WTtcblxuICAgIHRoaXMuYXBwbHlMYWJlbERpbWVuc2lvbnMoIG5vZGUgKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uID0gZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICB2YXIgY29udGVudCA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICBpZiggIWNvbnRlbnQgfHwgY29udGVudC5tYXRjaCgvXlxccyskLykgKXsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdGV4dFgsIHRleHRZOyAgXG4gICAgdmFyIGVkZ2VDZW50ZXJYLCBlZGdlQ2VudGVyWTtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciByc3R5bGUgPSBlZGdlLl9wcml2YXRlLnJzdHlsZTtcbiAgICBcbiAgICBpZiAocnMuZWRnZVR5cGUgPT0gJ3NlbGYnKSB7XG4gICAgICBlZGdlQ2VudGVyWCA9IHJzLnNlbGZFZGdlTWlkWDtcbiAgICAgIGVkZ2VDZW50ZXJZID0gcnMuc2VsZkVkZ2VNaWRZO1xuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgZWRnZUNlbnRlclggPSAocnMuc3RhcnRYICsgcnMuZW5kWCkgLyAyO1xuICAgICAgZWRnZUNlbnRlclkgPSAocnMuc3RhcnRZICsgcnMuZW5kWSkgLyAyO1xuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ2JlemllcicpIHtcbiAgICAgIGVkZ2VDZW50ZXJYID0gJCQubWF0aC5xYmV6aWVyQXQoIHJzLnN0YXJ0WCwgcnMuY3AyeCwgcnMuZW5kWCwgMC41ICk7XG4gICAgICBlZGdlQ2VudGVyWSA9ICQkLm1hdGgucWJlemllckF0KCBycy5zdGFydFksIHJzLmNwMnksIHJzLmVuZFksIDAuNSApO1xuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ2hheXN0YWNrJykge1xuICAgICAgdmFyIHNyY1BvcyA9IGVkZ2UuX3ByaXZhdGUuc291cmNlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIHRndFBvcyA9IGVkZ2UuX3ByaXZhdGUudGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICBlZGdlQ2VudGVyWCA9IChzcmNQb3MueCArIHJzLnNvdXJjZS54ICsgdGd0UG9zLnggKyBycy50YXJnZXQueCkvMjtcbiAgICAgIGVkZ2VDZW50ZXJZID0gKHNyY1Bvcy55ICsgcnMuc291cmNlLnkgKyB0Z3RQb3MueSArIHJzLnRhcmdldC55KS8yO1xuICAgIH1cbiAgICBcbiAgICB0ZXh0WCA9IGVkZ2VDZW50ZXJYO1xuICAgIHRleHRZID0gZWRnZUNlbnRlclk7XG5cbiAgICAvLyBhZGQgY2VudGVyIHBvaW50IHRvIHN0eWxlIHNvIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbnMgY2FuIHVzZSBpdFxuICAgIHJzLmxhYmVsWCA9IHRleHRYO1xuICAgIHJzLmxhYmVsWSA9IHRleHRZO1xuICAgIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgICByc3R5bGUubGFiZWxZID0gdGV4dFk7XG5cbiAgICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKCBlZGdlICk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmFwcGx5TGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcblxuICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoIGVsZSApO1xuICAgIHZhciBsYWJlbERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyggZWxlLCB0ZXh0ICk7XG4gXG4gICAgcnN0eWxlLmxhYmVsV2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG4gICAgcnMubGFiZWxXaWR0aCA9IGxhYmVsRGltcy53aWR0aDtcbiBcbiAgICByc3R5bGUubGFiZWxIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0O1xuICAgIHJzLmxhYmVsSGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodDtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0TGFiZWxUZXh0ID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgdGV4dCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuICAgIHZhciB0ZXh0VHJhbnNmb3JtID0gc3R5bGVbJ3RleHQtdHJhbnNmb3JtJ10udmFsdWU7XG4gICAgXG4gICAgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ25vbmUnKSB7XG4gICAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xuICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24oIGVsZSwgdGV4dCApe1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGZTdHlsZSA9IHN0eWxlWydmb250LXN0eWxlJ10uc3RyVmFsdWU7XG4gICAgdmFyIHNpemUgPSBzdHlsZVsnZm9udC1zaXplJ10ucHhWYWx1ZSArICdweCc7XG4gICAgdmFyIGZhbWlseSA9IHN0eWxlWydmb250LWZhbWlseSddLnN0clZhbHVlO1xuICAgIC8vIHZhciB2YXJpYW50ID0gc3R5bGVbJ2ZvbnQtdmFyaWFudCddLnN0clZhbHVlO1xuICAgIHZhciB3ZWlnaHQgPSBzdHlsZVsnZm9udC13ZWlnaHQnXS5zdHJWYWx1ZTtcblxuICAgIHZhciBjYWNoZUtleSA9IGVsZS5fcHJpdmF0ZS5sYWJlbEtleTtcbiAgICB2YXIgY2FjaGUgPSByLmxhYmVsRGltQ2FjaGUgfHwgKHIubGFiZWxEaW1DYWNoZSA9IHt9KTtcblxuICAgIGlmKCBjYWNoZVtjYWNoZUtleV0gKXtcbiAgICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG4gICAgfVxuXG4gICAgdmFyIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2O1xuXG4gICAgaWYoICFkaXYgKXtcbiAgICAgIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBkaXYgKTtcbiAgICB9XG5cbiAgICB2YXIgZHMgPSBkaXYuc3R5bGU7XG5cbiAgICAvLyBmcm9tIGVsZSBzdHlsZVxuICAgIGRzLmZvbnRGYW1pbHkgPSBmYW1pbHk7XG4gICAgZHMuZm9udFN0eWxlID0gZlN0eWxlO1xuICAgIGRzLmZvbnRTaXplID0gc2l6ZTtcbiAgICAvLyBkcy5mb250VmFyaWFudCA9IHZhcmlhbnQ7XG4gICAgZHMuZm9udFdlaWdodCA9IHdlaWdodDtcblxuICAgIC8vIGZvcmNlZCBzdHlsZVxuICAgIGRzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkcy5sZWZ0ID0gJy05OTk5cHgnO1xuICAgIGRzLnRvcCA9ICctOTk5OXB4JztcbiAgICBkcy56SW5kZXggPSAnLTEnO1xuICAgIGRzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICBkcy5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIGRzLnBhZGRpbmcgPSAnMCc7XG4gICAgZHMubGluZUhlaWdodCA9ICcxJztcblxuICAgIC8vIHB1dCBsYWJlbCBjb250ZW50IGluIGRpdlxuICAgIGRpdi50ZXh0Q29udGVudCA9IHRleHQ7XG5cbiAgICBjYWNoZVtjYWNoZUtleV0gPSB7XG4gICAgICB3aWR0aDogZGl2LmNsaWVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBkaXYuY2xpZW50SGVpZ2h0XG4gICAgfTtcblxuICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG4gIH07ICBcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVjYWxjdWxhdGVSZW5kZXJlZFN0eWxlID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICB2YXIgZWRnZXMgPSBbXTtcbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICB2YXIgaGFuZGxlZEVkZ2UgPSB7fTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgICB2YXIgaWQgPSBfcC5kYXRhLmlkO1xuICAgICAgdmFyIGJiU3R5bGVTYW1lID0gcnMuYm91bmRpbmdCb3hLZXkgIT0gbnVsbCAmJiBfcC5ib3VuZGluZ0JveEtleSA9PT0gcnMuYm91bmRpbmdCb3hLZXk7XG4gICAgICB2YXIgbGFiZWxTdHlsZVNhbWUgPSBycy5sYWJlbEtleSAhPSBudWxsICYmIF9wLmxhYmVsS2V5ID09PSBycy5sYWJlbEtleTtcbiAgICAgIHZhciBzdHlsZVNhbWUgPSBiYlN0eWxlU2FtZSAmJiBsYWJlbFN0eWxlU2FtZTtcblxuICAgICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG4gICAgICAgIHZhciBwb3NTYW1lID0gcnN0eWxlLm5vZGVYICE9IG51bGwgJiYgcnN0eWxlLm5vZGVZICE9IG51bGwgJiYgcG9zLnggPT09IHJzdHlsZS5ub2RlWCAmJiBwb3MueSA9PT0gcnN0eWxlLm5vZGVZO1xuXG4gICAgICAgIGlmKCAhcG9zU2FtZSB8fCAhc3R5bGVTYW1lICl7XG4gICAgICAgICAgbm9kZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICByc3R5bGUubm9kZVggPSBwb3MueDtcbiAgICAgICAgcnN0eWxlLm5vZGVZID0gcG9zLnk7XG4gICAgICB9IGVsc2UgeyAvLyBlZGdlc1xuXG4gICAgICAgIHZhciBzcmNQb3MgPSBlbGUuX3ByaXZhdGUuc291cmNlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgdGd0UG9zID0gZWxlLl9wcml2YXRlLnRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNyY1NhbWUgPSByc3R5bGUuc3JjWCAhPSBudWxsICYmIHJzdHlsZS5zcmNZICE9IG51bGwgJiYgc3JjUG9zLnggPT09IHJzdHlsZS5zcmNYICYmIHNyY1Bvcy55ID09PSByc3R5bGUuc3JjWTtcbiAgICAgICAgdmFyIHRndFNhbWUgPSByc3R5bGUudGd0WCAhPSBudWxsICYmIHJzdHlsZS50Z3RZICE9IG51bGwgJiYgdGd0UG9zLnggPT09IHJzdHlsZS50Z3RYICYmIHRndFBvcy55ID09PSByc3R5bGUudGd0WTtcbiAgICAgICAgdmFyIHBvc2l0aW9uc1NhbWUgPSBzcmNTYW1lICYmIHRndFNhbWU7XG5cbiAgICAgICAgaWYoICFwb3NpdGlvbnNTYW1lIHx8ICFzdHlsZVNhbWUgKXtcbiAgICAgICAgICB2YXIgY3VydmVUeXBlID0gX3Auc3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWU7XG5cbiAgICAgICAgICBpZiggY3VydmVUeXBlID09PSAnYmV6aWVyJyApe1xuICAgICAgICAgICAgaWYoICFoYW5kbGVkRWRnZVsgaWQgXSApe1xuICAgICAgICAgICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICAgICAgaGFuZGxlZEVkZ2VbIGlkIF0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgIHZhciBwYXJhbGxlbEVkZ2VzID0gZWxlLnBhcmFsbGVsRWRnZXMoKTtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJhbGxlbEVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgICAgdmFyIHBFZGdlID0gcGFyYWxsZWxFZGdlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgcElkID0gcEVkZ2UuX3ByaXZhdGUuZGF0YS5pZDtcblxuICAgICAgICAgICAgICAgIGlmKCAhaGFuZGxlZEVkZ2VbIHBJZCBdICl7XG4gICAgICAgICAgICAgICAgICBlZGdlcy5wdXNoKCBwRWRnZSApO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlZEVkZ2VbIHBJZCBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRnZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGlmIHBvc2l0aW9ucyBkaWZmXG5cbiAgICAgICAgLy8gdXBkYXRlIHJzdHlsZSBwb3NpdGlvbnNcbiAgICAgICAgcnN0eWxlLnNyY1ggPSBzcmNQb3MueDtcbiAgICAgICAgcnN0eWxlLnNyY1kgPSBzcmNQb3MueTtcbiAgICAgICAgcnN0eWxlLnRndFggPSB0Z3RQb3MueDtcbiAgICAgICAgcnN0eWxlLnRndFkgPSB0Z3RQb3MueTtcblxuICAgICAgfSAvLyBpZiBlZGdlc1xuXG4gICAgICBycy5ib3VuZGluZ0JveEtleSA9IF9wLmJvdW5kaW5nQm94S2V5O1xuICAgICAgcnMubGFiZWxLZXkgPSBfcC5sYWJlbEtleTtcbiAgICB9XG5cbiAgICB0aGlzLnJlY2FsY3VsYXRlRWRnZVByb2plY3Rpb25zKCBlZGdlcyApO1xuICAgIHRoaXMucmVjYWxjdWxhdGVMYWJlbFByb2plY3Rpb25zKCBub2RlcywgZWRnZXMgKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVjYWxjdWxhdGVMYWJlbFByb2plY3Rpb25zID0gZnVuY3Rpb24oIG5vZGVzLCBlZGdlcyApe1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKCBub2Rlc1tpXSApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uKCBlZGdlc1tpXSApO1xuICAgIH1cbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMgPSBmdW5jdGlvbiggZWRnZXMgKXtcbiAgICB0aGlzLmZpbmRFZGdlQ29udHJvbFBvaW50cyggZWRnZXMgKTtcbiAgfTtcblxuXG4gIC8vIEZpbmQgZWRnZSBjb250cm9sIHBvaW50c1xuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZmluZEVkZ2VDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oZWRnZXMpIHtcbiAgICBpZiggIWVkZ2VzIHx8IGVkZ2VzLmxlbmd0aCA9PT0gMCApeyByZXR1cm47IH1cblxuICAgIHZhciBoYXNoVGFibGUgPSB7fTtcbiAgICB2YXIgcGFpcklkcyA9IFtdO1xuICAgIHZhciBoYXlzdGFja0VkZ2VzID0gW107XG5cbiAgICAvLyBjcmVhdGUgYSB0YWJsZSBvZiBlZGdlIChzcmMsIHRndCkgPT4gbGlzdCBvZiBlZGdlcyBiZXR3ZWVuIHRoZW1cbiAgICB2YXIgcGFpcklkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gc3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJztcblxuICAgICAgLy8gaWdub3JlIGVkZ2VzIHdobyBhcmUgbm90IHRvIGJlIGRpc3BsYXllZFxuICAgICAgLy8gdGhleSBzaG91bGRuJ3QgdGFrZSB1cCBzcGFjZVxuICAgICAgaWYoIHN0eWxlLmRpc3BsYXkudmFsdWUgPT09ICdub25lJyApe1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHN0eWxlWydjdXJ2ZS1zdHlsZSddLnZhbHVlID09PSAnaGF5c3RhY2snICl7XG4gICAgICAgIGhheXN0YWNrRWRnZXMucHVzaCggZWRnZSApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNyY0lkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnNvdXJjZTtcbiAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS50YXJnZXQ7XG5cbiAgICAgIHBhaXJJZCA9IHNyY0lkID4gdGd0SWQgP1xuICAgICAgICB0Z3RJZCArICctJyArIHNyY0lkIDpcbiAgICAgICAgc3JjSWQgKyAnLScgKyB0Z3RJZCA7XG5cbiAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgcGFpcklkID0gJ3VuYnVuZGxlZCcgKyBlZGdlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNoVGFibGVbcGFpcklkXSA9PSBudWxsKSB7XG4gICAgICAgIGhhc2hUYWJsZVtwYWlySWRdID0gW107XG4gICAgICAgIHBhaXJJZHMucHVzaCggcGFpcklkICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGhhc2hUYWJsZVtwYWlySWRdLnB1c2goIGVkZ2UgKTtcblxuICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICBoYXNoVGFibGVbcGFpcklkXS5oYXNVbmJ1bmRsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzcmMsIHRndCwgc3JjUG9zLCB0Z3RQb3MsIHNyY1csIHNyY0gsIHRndFcsIHRndEgsIHNyY1NoYXBlLCB0Z3RTaGFwZSwgc3JjQm9yZGVyLCB0Z3RCb3JkZXI7XG4gICAgdmFyIHZlY3Rvck5vcm1JbnZlcnNlO1xuICAgIHZhciBiYWRCZXppZXI7XG4gICAgXG4gICAgLy8gZm9yIGVhY2ggcGFpciAoc3JjLCB0Z3QpLCBjcmVhdGUgdGhlIGN0cmwgcHRzXG4gICAgLy8gTmVzdGVkIGZvciBsb29wIGlzIE9LOyB0b3RhbCBudW1iZXIgb2YgaXRlcmF0aW9ucyBmb3IgYm90aCBsb29wcyA9IGVkZ2VDb3VudCAgXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBwYWlySWRzLmxlbmd0aDsgcCsrKSB7XG4gICAgICBwYWlySWQgPSBwYWlySWRzW3BdO1xuICAgICAgdmFyIHBhaXJFZGdlcyA9IGhhc2hUYWJsZVtwYWlySWRdO1xuICAgIFxuICAgICAgLy8gZm9yIGVhY2ggcGFpciBpZCwgdGhlIGVkZ2VzIHNob3VsZCBiZSBzb3J0ZWQgYnkgaW5kZXhcbiAgICAgIHBhaXJFZGdlcy5zb3J0KGZ1bmN0aW9uKGVkZ2UxLCBlZGdlMil7XG4gICAgICAgIHJldHVybiBlZGdlMS5fcHJpdmF0ZS5pbmRleCAtIGVkZ2UyLl9wcml2YXRlLmluZGV4O1xuICAgICAgfSk7XG5cbiAgICAgIHNyYyA9IHBhaXJFZGdlc1swXS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICB0Z3QgPSBwYWlyRWRnZXNbMF0uX3ByaXZhdGUudGFyZ2V0O1xuXG4gICAgICAvLyBtYWtlIHN1cmUgc3JjL3RndCBkaXN0aW5jdGlvbiBpcyBjb25zaXN0ZW50XG4gICAgICAvLyAoc3JjL3RndCBpbiB0aGlzIGNhc2UgYXJlIGp1c3QgZm9yIGN0cmxwdHMgYW5kIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gYmUgdHJ1ZSBzcmMvdGd0KVxuICAgICAgaWYoIHNyYy5fcHJpdmF0ZS5kYXRhLmlkID4gdGd0Ll9wcml2YXRlLmRhdGEuaWQgKXtcbiAgICAgICAgdmFyIHRlbXAgPSBzcmM7XG4gICAgICAgIHNyYyA9IHRndDtcbiAgICAgICAgdGd0ID0gdGVtcDtcbiAgICAgIH1cblxuICAgICAgc3JjUG9zID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICBzcmNXID0gdGhpcy5nZXROb2RlV2lkdGgoc3JjKTtcbiAgICAgIHNyY0ggPSB0aGlzLmdldE5vZGVIZWlnaHQoc3JjKTtcblxuICAgICAgdGd0VyA9IHRoaXMuZ2V0Tm9kZVdpZHRoKHRndCk7XG4gICAgICB0Z3RIID0gdGhpcy5nZXROb2RlSGVpZ2h0KHRndCk7XG5cbiAgICAgIHNyY1NoYXBlID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1sgdGhpcy5nZXROb2RlU2hhcGUoc3JjKSBdO1xuICAgICAgdGd0U2hhcGUgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZSh0Z3QpIF07XG5cbiAgICAgIHNyY0JvcmRlciA9IHNyYy5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcbiAgICAgIHRndEJvcmRlciA9IHRndC5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcblxuICAgICAgYmFkQmV6aWVyID0gZmFsc2U7XG4gICAgICBcblxuICAgICAgaWYoIChwYWlyRWRnZXMubGVuZ3RoID4gMSAmJiBzcmMgIT09IHRndCkgfHwgcGFpckVkZ2VzLmhhc1VuYnVuZGxlZCApe1xuXG4gICAgICAgIC8vIHB0IG91dHNpZGUgc3JjIHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgICB2YXIgc3JjT3V0c2lkZSA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgICAgc3JjUG9zLngsXG4gICAgICAgICAgc3JjUG9zLnksXG4gICAgICAgICAgc3JjVyxcbiAgICAgICAgICBzcmNILFxuICAgICAgICAgIHRndFBvcy54LFxuICAgICAgICAgIHRndFBvcy55LFxuICAgICAgICAgIHNyY0JvcmRlciAvIDJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBwdCBvdXRzaWRlIHRndCBzaGFwZSB0byBjYWxjIGRpc3RhbmNlL2Rpc3BsYWNlbWVudCBmcm9tIHNyYyB0byB0Z3RcbiAgICAgICAgdmFyIHRndE91dHNpZGUgPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgIHRndFBvcy54LFxuICAgICAgICAgIHRndFBvcy55LFxuICAgICAgICAgIHRndFcsXG4gICAgICAgICAgdGd0SCxcbiAgICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgICBzcmNQb3MueSxcbiAgICAgICAgICB0Z3RCb3JkZXIgLyAyXG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIG1pZHB0U3JjUHRzID0ge1xuICAgICAgICAgIHgxOiBzcmNPdXRzaWRlWzBdLFxuICAgICAgICAgIHgyOiB0Z3RPdXRzaWRlWzBdLFxuICAgICAgICAgIHkxOiBzcmNPdXRzaWRlWzFdLFxuICAgICAgICAgIHkyOiB0Z3RPdXRzaWRlWzFdXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGR5ID0gKCB0Z3RPdXRzaWRlWzFdIC0gc3JjT3V0c2lkZVsxXSApO1xuICAgICAgICB2YXIgZHggPSAoIHRndE91dHNpZGVbMF0gLSBzcmNPdXRzaWRlWzBdICk7XG4gICAgICAgIHZhciBsID0gTWF0aC5zcXJ0KCBkeCpkeCArIGR5KmR5ICk7XG5cbiAgICAgICAgdmFyIHZlY3RvciA9IHtcbiAgICAgICAgICB4OiBkeCxcbiAgICAgICAgICB5OiBkeVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIHZlY3Rvck5vcm0gPSB7XG4gICAgICAgICAgeDogdmVjdG9yLngvbCxcbiAgICAgICAgICB5OiB2ZWN0b3IueS9sXG4gICAgICAgIH07XG4gICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0ge1xuICAgICAgICAgIHg6IC12ZWN0b3JOb3JtLnksXG4gICAgICAgICAgeTogdmVjdG9yTm9ybS54XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gaWYgc3JjIGludGVyc2VjdGlvbiBpcyBpbnNpZGUgdGd0IG9yIHRndCBpbnRlcnNlY3Rpb24gaXMgaW5zaWRlIHNyYywgdGhlbiBubyBjdHJsIHB0cyB0byBkcmF3XG4gICAgICAgIGlmKCBcbiAgICAgICAgICB0Z3RTaGFwZS5jaGVja1BvaW50KCBzcmNPdXRzaWRlWzBdLCBzcmNPdXRzaWRlWzFdLCB0Z3RCb3JkZXIvMiwgdGd0VywgdGd0SCwgdGd0UG9zLngsIHRndFBvcy55ICkgIHx8XG4gICAgICAgICAgc3JjU2hhcGUuY2hlY2tQb2ludCggdGd0T3V0c2lkZVswXSwgdGd0T3V0c2lkZVsxXSwgc3JjQm9yZGVyLzIsIHNyY1csIHNyY0gsIHNyY1Bvcy54LCBzcmNQb3MueSApIFxuICAgICAgICApe1xuICAgICAgICAgIHZlY3Rvck5vcm1JbnZlcnNlID0ge307XG4gICAgICAgICAgYmFkQmV6aWVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGVkZ2U7XG4gICAgICB2YXIgcnM7XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpckVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2UgPSBwYWlyRWRnZXNbaV07XG4gICAgICAgIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgICAgXG4gICAgICAgIHZhciBlZGdlSW5kZXgxID0gcnMubGFzdEVkZ2VJbmRleDtcbiAgICAgICAgdmFyIGVkZ2VJbmRleDIgPSBpO1xuXG4gICAgICAgIHZhciBudW1FZGdlczEgPSBycy5sYXN0TnVtRWRnZXM7XG4gICAgICAgIHZhciBudW1FZGdlczIgPSBwYWlyRWRnZXMubGVuZ3RoO1xuXG4gICAgICAgIHZhciBlU3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICB2YXIgc3RlcFNpemUgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJ10ucHhWYWx1ZTtcbiAgICAgICAgdmFyIHN0ZXBEaXN0ID0gZVN0eWxlWydjb250cm9sLXBvaW50LWRpc3RhbmNlJ10gIT09IHVuZGVmaW5lZCA/IGVTdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZSddLnB4VmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBzdGVwV2VpZ2h0ID0gZVN0eWxlWydjb250cm9sLXBvaW50LXdlaWdodCddLnZhbHVlO1xuICAgICAgICB2YXIgZWRnZUlzVW5idW5kbGVkID0gZVN0eWxlWydjdXJ2ZS1zdHlsZSddLnZhbHVlID09PSAndW5idW5kbGVkLWJlemllcic7XG5cbiAgICAgICAgdmFyIHNyY1gxID0gcnMubGFzdFNyY0N0bFB0WDtcbiAgICAgICAgdmFyIHNyY1gyID0gc3JjUG9zLng7XG4gICAgICAgIHZhciBzcmNZMSA9IHJzLmxhc3RTcmNDdGxQdFk7XG4gICAgICAgIHZhciBzcmNZMiA9IHNyY1Bvcy55O1xuICAgICAgICB2YXIgc3JjVzEgPSBycy5sYXN0U3JjQ3RsUHRXO1xuICAgICAgICB2YXIgc3JjVzIgPSBzcmMub3V0ZXJXaWR0aCgpO1xuICAgICAgICB2YXIgc3JjSDEgPSBycy5sYXN0U3JjQ3RsUHRIO1xuICAgICAgICB2YXIgc3JjSDIgPSBzcmMub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgICB2YXIgdGd0WDEgPSBycy5sYXN0VGd0Q3RsUHRYO1xuICAgICAgICB2YXIgdGd0WDIgPSB0Z3RQb3MueDtcbiAgICAgICAgdmFyIHRndFkxID0gcnMubGFzdFRndEN0bFB0WTtcbiAgICAgICAgdmFyIHRndFkyID0gdGd0UG9zLnk7XG4gICAgICAgIHZhciB0Z3RXMSA9IHJzLmxhc3RUZ3RDdGxQdFc7XG4gICAgICAgIHZhciB0Z3RXMiA9IHRndC5vdXRlcldpZHRoKCk7XG4gICAgICAgIHZhciB0Z3RIMSA9IHJzLmxhc3RUZ3RDdGxQdEg7XG4gICAgICAgIHZhciB0Z3RIMiA9IHRndC5vdXRlckhlaWdodCgpO1xuXG4gICAgICAgIHZhciB3aWR0aDEgPSBycy5sYXN0VztcbiAgICAgICAgdmFyIHdpZHRoMiA9IGVTdHlsZVsnY29udHJvbC1wb2ludC1zdGVwLXNpemUnXS5weFZhbHVlO1xuXG4gICAgICAgIGlmKCBiYWRCZXppZXIgKXtcbiAgICAgICAgICBycy5iYWRCZXppZXIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJzLmJhZEJlemllciA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHNyY1gxID09PSBzcmNYMiAmJiBzcmNZMSA9PT0gc3JjWTIgJiYgc3JjVzEgPT09IHNyY1cyICYmIHNyY0gxID09PSBzcmNIMlxuICAgICAgICAmJiAgdGd0WDEgPT09IHRndFgyICYmIHRndFkxID09PSB0Z3RZMiAmJiB0Z3RXMSA9PT0gdGd0VzIgJiYgdGd0SDEgPT09IHRndEgyXG4gICAgICAgICYmICB3aWR0aDEgPT09IHdpZHRoMlxuICAgICAgICAmJiAgKChlZGdlSW5kZXgxID09PSBlZGdlSW5kZXgyICYmIG51bUVkZ2VzMSA9PT0gbnVtRWRnZXMyKSB8fCBlZGdlSXNVbmJ1bmRsZWQpICl7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2VkZ2UgY3RybCBwdCBjYWNoZSBISVQnKVxuICAgICAgICAgIGNvbnRpbnVlOyAvLyB0aGVuIHRoZSBjb250cm9sIHBvaW50cyBoYXZlbid0IGNoYW5nZWQgYW5kIHdlIGNhbiBza2lwIGNhbGN1bGF0aW5nIHRoZW1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBycy5sYXN0U3JjQ3RsUHRYID0gc3JjWDI7XG4gICAgICAgICAgcnMubGFzdFNyY0N0bFB0WSA9IHNyY1kyO1xuICAgICAgICAgIHJzLmxhc3RTcmNDdGxQdFcgPSBzcmNXMjtcbiAgICAgICAgICBycy5sYXN0U3JjQ3RsUHRIID0gc3JjSDI7XG4gICAgICAgICAgcnMubGFzdFRndEN0bFB0WCA9IHRndFgyO1xuICAgICAgICAgIHJzLmxhc3RUZ3RDdGxQdFkgPSB0Z3RZMjtcbiAgICAgICAgICBycy5sYXN0VGd0Q3RsUHRXID0gdGd0VzI7XG4gICAgICAgICAgcnMubGFzdFRndEN0bFB0SCA9IHRndEgyO1xuICAgICAgICAgIHJzLmxhc3RFZGdlSW5kZXggPSBlZGdlSW5kZXgyO1xuICAgICAgICAgIHJzLmxhc3ROdW1FZGdlcyA9IG51bUVkZ2VzMjtcbiAgICAgICAgICBycy5sYXN0V2lkdGggPSB3aWR0aDI7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2VkZ2UgY3RybCBwdCBjYWNoZSBNSVNTJylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlbGYtZWRnZVxuICAgICAgICBpZiAoIHNyYyA9PT0gdGd0ICkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgcnMuZWRnZVR5cGUgPSAnc2VsZic7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGogPSBpO1xuICAgICAgICAgIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gICAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICBsb29wRGlzdCA9IHN0ZXBEaXN0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5ldyAtLSBmaXggZm9yIGxhcmdlIG5vZGVzXG4gICAgICAgICAgcnMuY3AyYXggPSBzcmNQb3MueDtcbiAgICAgICAgICBycy5jcDJheSA9IHNyY1Bvcy55IC0gKDEgKyBNYXRoLnBvdyhzcmNILCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpO1xuICAgICAgICAgIFxuICAgICAgICAgIHJzLmNwMmN4ID0gc3JjLl9wcml2YXRlLnBvc2l0aW9uLnggLSAoMSArIE1hdGgucG93KHNyY1csIDEuMTIpIC8gMTAwKSAqIGxvb3BEaXN0ICogKGogLyAzICsgMSk7XG4gICAgICAgICAgcnMuY3AyY3kgPSBzcmNQb3MueTtcbiAgICAgICAgICBcbiAgICAgICAgICBycy5zZWxmRWRnZU1pZFggPSAocnMuY3AyYXggKyBycy5jcDJjeCkgLyAyLjA7XG4gICAgICAgICAgcnMuc2VsZkVkZ2VNaWRZID0gKHJzLmNwMmF5ICsgcnMuY3AyY3kpIC8gMi4wO1xuICAgICAgICAgIFxuICAgICAgICAvLyBTdHJhaWdodCBlZGdlXG4gICAgICAgIH0gZWxzZSBpZiAocGFpckVkZ2VzLmxlbmd0aCAlIDIgPT09IDFcbiAgICAgICAgICAmJiBpID09PSBNYXRoLmZsb29yKHBhaXJFZGdlcy5sZW5ndGggLyAyKVxuICAgICAgICAgICYmICFlZGdlSXNVbmJ1bmRsZWQgKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcnMuZWRnZVR5cGUgPSAnc3RyYWlnaHQnO1xuICAgICAgICAgIFxuICAgICAgICAvLyBCZXppZXIgZWRnZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBub3JtU3RlcERpc3QgPSAoMC41IC0gcGFpckVkZ2VzLmxlbmd0aCAvIDIgKyBpKSAqIHN0ZXBTaXplO1xuICAgICAgICAgIHZhciBtYW5TdGVwRGlzdDtcbiAgICAgICAgICB2YXIgc2lnbiA9ICQkLm1hdGguc2lnbnVtKCBub3JtU3RlcERpc3QgKTtcblxuICAgICAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgICAgIG1hblN0ZXBEaXN0ID0gc3RlcERpc3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hblN0ZXBEaXN0ID0gc3RlcERpc3QgIT09IHVuZGVmaW5lZCA/IHNpZ24gKiBzdGVwRGlzdCA6IHVuZGVmaW5lZDsgXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuU3RlcERpc3QgIT09IHVuZGVmaW5lZCA/IG1hblN0ZXBEaXN0IDogbm9ybVN0ZXBEaXN0O1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciB3MSA9ICgxIC0gc3RlcFdlaWdodCk7XG4gICAgICAgICAgdmFyIHcyID0gc3RlcFdlaWdodDtcblxuICAgICAgICAgIHZhciBzd2FwcGVkRGlyZWN0aW9uID0gZWRnZS5fcHJpdmF0ZS5zb3VyY2UgIT09IHNyYztcbiAgICAgICAgICBpZiggc3dhcHBlZERpcmVjdGlvbiApe1xuICAgICAgICAgICAgdzEgPSBzdGVwV2VpZ2h0O1xuICAgICAgICAgICAgdzIgPSAoMSAtIHN0ZXBXZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhZGp1c3RlZE1pZHB0ID0ge1xuICAgICAgICAgICAgeDogbWlkcHRTcmNQdHMueDEgKiB3MSArIG1pZHB0U3JjUHRzLngyICogdzIsXG4gICAgICAgICAgICB5OiBtaWRwdFNyY1B0cy55MSAqIHcxICsgbWlkcHRTcmNQdHMueTIgKiB3MlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBycy5lZGdlVHlwZSA9ICdiZXppZXInO1xuICAgICAgICAgIFxuICAgICAgICAgIHJzLmNwMnggPSBhZGp1c3RlZE1pZHB0LnggKyB2ZWN0b3JOb3JtSW52ZXJzZS54ICogZGlzdGFuY2VGcm9tTWlkcG9pbnQ7XG4gICAgICAgICAgcnMuY3AyeSA9IGFkanVzdGVkTWlkcHQueSArIHZlY3Rvck5vcm1JbnZlcnNlLnkgKiBkaXN0YW5jZUZyb21NaWRwb2ludDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhlZGdlLCBtaWRQb2ludFgsIGRpc3BsYWNlbWVudFgsIGRpc3RhbmNlRnJvbU1pZHBvaW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgZW5kcHRzIGZvciBlZGdlXG4gICAgICAgIHRoaXMuZmluZEVuZHBvaW50cyggZWRnZSApO1xuXG4gICAgICAgIHZhciBiYWRTdGFydCA9ICEkJC5pcy5udW1iZXIoIHJzLnN0YXJ0WCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLnN0YXJ0WSApO1xuICAgICAgICB2YXIgYmFkQVN0YXJ0ID0gISQkLmlzLm51bWJlciggcnMuYXJyb3dTdGFydFggKSB8fCAhJCQuaXMubnVtYmVyKCBycy5hcnJvd1N0YXJ0WSApO1xuICAgICAgICB2YXIgYmFkRW5kID0gISQkLmlzLm51bWJlciggcnMuZW5kWCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLmVuZFkgKTtcbiAgICAgICAgdmFyIGJhZEFFbmQgPSAhJCQuaXMubnVtYmVyKCBycy5hcnJvd0VuZFggKSB8fCAhJCQuaXMubnVtYmVyKCBycy5hcnJvd0VuZFkgKTtcblxuICAgICAgICB2YXIgbWluQ3BBRGlzdEZhY3RvciA9IDM7XG4gICAgICAgIHZhciBhcnJvd1cgPSB0aGlzLmdldEFycm93V2lkdGgoIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSApICogQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZUhlaWdodDtcbiAgICAgICAgdmFyIG1pbkNwQURpc3QgPSBtaW5DcEFEaXN0RmFjdG9yICogYXJyb3dXO1xuICAgICAgICB2YXIgc3RhcnRBQ3BEaXN0ID0gJCQubWF0aC5kaXN0YW5jZSggeyB4OiBycy5jcDJ4LCB5OiBycy5jcDJ5IH0sIHsgeDogcnMuc3RhcnRYLCB5OiBycy5zdGFydFkgfSApO1xuICAgICAgICB2YXIgY2xvc2VTdGFydEFDcCA9IHN0YXJ0QUNwRGlzdCA8IG1pbkNwQURpc3Q7XG4gICAgICAgIHZhciBlbmRBQ3BEaXN0ID0gJCQubWF0aC5kaXN0YW5jZSggeyB4OiBycy5jcDJ4LCB5OiBycy5jcDJ5IH0sIHsgeDogcnMuZW5kWCwgeTogcnMuZW5kWSB9ICk7XG4gICAgICAgIHZhciBjbG9zZUVuZEFDcCA9IGVuZEFDcERpc3QgPCBtaW5DcEFEaXN0O1xuXG4gICAgICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgKXtcbiAgICAgICAgICB2YXIgb3ZlcmxhcHBpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmKCBiYWRTdGFydCB8fCBiYWRBU3RhcnQgfHwgY2xvc2VTdGFydEFDcCApe1xuICAgICAgICAgICAgb3ZlcmxhcHBpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBwcm9qZWN0IGNvbnRyb2wgcG9pbnQgYWxvbmcgbGluZSBmcm9tIHNyYyBjZW50cmUgdG8gb3V0c2lkZSB0aGUgc3JjIHNoYXBlXG4gICAgICAgICAgICAvLyAob3RoZXJ3aXNlIGludGVyc2VjdGlvbiB3aWxsIHlpZWxkIG5vdGhpbmcpXG4gICAgICAgICAgICB2YXIgY3BEID0geyAvLyBkZWx0YVxuICAgICAgICAgICAgICB4OiBycy5jcDJ4IC0gc3JjUG9zLngsXG4gICAgICAgICAgICAgIHk6IHJzLmNwMnkgLSBzcmNQb3MueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjcEwgPSBNYXRoLnNxcnQoIGNwRC54KmNwRC54ICsgY3BELnkqY3BELnkgKTsgLy8gbGVuZ3RoIG9mIGxpbmVcbiAgICAgICAgICAgIHZhciBjcE0gPSB7IC8vIG5vcm1hbGlzZWQgZGVsdGFcbiAgICAgICAgICAgICAgeDogY3BELnggLyBjcEwsXG4gICAgICAgICAgICAgIHk6IGNwRC55IC8gY3BMXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJhZGl1cyA9IE1hdGgubWF4KHNyY1csIHNyY0gpO1xuICAgICAgICAgICAgdmFyIGNwUHJvaiA9IHsgLy8gKjIgcmFkaXVzIGd1YXJhbnRlZXMgb3V0c2lkZSBzaGFwZVxuICAgICAgICAgICAgICB4OiBycy5jcDJ4ICsgY3BNLnggKiAyICogcmFkaXVzLFxuICAgICAgICAgICAgICB5OiBycy5jcDJ5ICsgY3BNLnkgKiAyICogcmFkaXVzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgc3JjQ3RybFB0SW50biA9IHNyY1NoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgICAgICBzcmNQb3MueSxcbiAgICAgICAgICAgICAgc3JjVyxcbiAgICAgICAgICAgICAgc3JjSCxcbiAgICAgICAgICAgICAgY3BQcm9qLngsXG4gICAgICAgICAgICAgIGNwUHJvai55LFxuICAgICAgICAgICAgICBzcmNCb3JkZXIgLyAyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiggY2xvc2VTdGFydEFDcCApe1xuICAgICAgICAgICAgICBycy5jcDJ4ID0gcnMuY3AyeCArIGNwTS54ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpOyBcbiAgICAgICAgICAgICAgcnMuY3AyeSA9IHJzLmNwMnkgKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gc3RhcnRBQ3BEaXN0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJzLmNwMnggPSBzcmNDdHJsUHRJbnRuWzBdICsgY3BNLnggKiBtaW5DcEFEaXN0OyBcbiAgICAgICAgICAgICAgcnMuY3AyeSA9IHNyY0N0cmxQdEludG5bMV0gKyBjcE0ueSAqIG1pbkNwQURpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGJhZEVuZCB8fCBiYWRBRW5kIHx8IGNsb3NlRW5kQUNwICl7XG4gICAgICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gdGd0IGNlbnRyZSB0byBvdXRzaWRlIHRoZSB0Z3Qgc2hhcGVcbiAgICAgICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgICAgICAgIHZhciBjcEQgPSB7IC8vIGRlbHRhXG4gICAgICAgICAgICAgIHg6IHJzLmNwMnggLSB0Z3RQb3MueCxcbiAgICAgICAgICAgICAgeTogcnMuY3AyeSAtIHRndFBvcy55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNwTCA9IE1hdGguc3FydCggY3BELngqY3BELnggKyBjcEQueSpjcEQueSApOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgICAgICAgdmFyIGNwTSA9IHsgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICAgICAgICB2YXIgY3BQcm9qID0geyAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgICAgICAgIHg6IHJzLmNwMnggKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgICAgIHk6IHJzLmNwMnkgKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0Z3RDdHJsUHRJbnRuID0gdGd0U2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgICAgdGd0UG9zLngsXG4gICAgICAgICAgICAgIHRndFBvcy55LFxuICAgICAgICAgICAgICB0Z3RXLFxuICAgICAgICAgICAgICB0Z3RILFxuICAgICAgICAgICAgICBjcFByb2oueCxcbiAgICAgICAgICAgICAgY3BQcm9qLnksXG4gICAgICAgICAgICAgIHRndEJvcmRlciAvIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmKCBjbG9zZUVuZEFDcCApe1xuICAgICAgICAgICAgICBycy5jcDJ4ID0gcnMuY3AyeCArIGNwTS54ICogKG1pbkNwQURpc3QgLSBlbmRBQ3BEaXN0KTsgXG4gICAgICAgICAgICAgIHJzLmNwMnkgPSBycy5jcDJ5ICsgY3BNLnkgKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcnMuY3AyeCA9IHRndEN0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7IFxuICAgICAgICAgICAgICBycy5jcDJ5ID0gdGd0Q3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBvdmVybGFwcGluZyApe1xuICAgICAgICAgICAgLy8gcmVjYWxjIGVuZHB0c1xuICAgICAgICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKCBlZGdlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIHJzLmVkZ2VUeXBlID09PSAnc3RyYWlnaHQnICl7XG4gICAgICAgICAgcnMubWlkWCA9ICggc3JjWDIgKyB0Z3RYMiApLzI7XG4gICAgICAgICAgcnMubWlkWSA9ICggc3JjWTIgKyB0Z3RZMiApLzI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcm9qZWN0IHRoZSBlZGdlIGludG8gcnN0eWxlXG4gICAgICAgIHRoaXMucHJvamVjdEJlemllciggZWRnZSApO1xuXG4gICAgICB9XG4gICAgfVxuICAgICAgXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBoYXlzdGFja0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWRnZSA9IGhheXN0YWNrRWRnZXNbaV07XG4gICAgICB2YXIgcnNjcmF0Y2ggPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuXG4gICAgICBpZiggIXJzY3JhdGNoLmhheXN0YWNrICl7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgICByc2NyYXRjaC5zb3VyY2UgPSB7XG4gICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgICByc2NyYXRjaC50YXJnZXQgPSB7XG4gICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgICB9O1xuICAgICAgfSAgXG5cbiAgICAgIC8vIGFsd2F5cyBvdmVycmlkZSBhcyBoYXlzdGFjayBpbiBjYXNlIHNldCB0byBkaWZmZXJlbnQgdHlwZSBwcmV2aW91c2x5XG4gICAgICByc2NyYXRjaC5lZGdlVHlwZSA9ICdoYXlzdGFjayc7XG4gICAgICByc2NyYXRjaC5oYXlzdGFjayA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhhc2hUYWJsZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZmluZEVuZHBvaW50cyA9IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICB2YXIgaW50ZXJzZWN0O1xuXG4gICAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgdmFyIHRhcmdldCA9IGVkZ2UudGFyZ2V0KClbMF07XG4gICAgXG4gICAgdmFyIHRndEFyU2hhcGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWyd0YXJnZXQtYXJyb3ctc2hhcGUnXS52YWx1ZTtcbiAgICB2YXIgc3JjQXJTaGFwZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3NvdXJjZS1hcnJvdy1zaGFwZSddLnZhbHVlO1xuXG4gICAgdmFyIHRndEJvcmRlclcgPSB0YXJnZXQuX3ByaXZhdGUuc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG4gICAgdmFyIHNyY0JvcmRlclcgPSBzb3VyY2UuX3ByaXZhdGUuc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG5cbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIFxuICAgIGlmIChlZGdlLl9wcml2YXRlLnJzY3JhdGNoLmVkZ2VUeXBlID09ICdzZWxmJykge1xuICAgICAgXG4gICAgICB2YXIgY3AgPSBbcnMuY3AyY3gsIHJzLmNwMmN5XTtcbiAgICAgIFxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHRhcmdldCksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodCh0YXJnZXQpLFxuICAgICAgICBjcFswXSxcbiAgICAgICAgY3BbMV0sIFxuICAgICAgICB0Z3RCb3JkZXJXIC8gMlxuICAgICAgKTtcbiAgICAgIFxuICAgICAgdmFyIGFycm93RW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLnNwYWNpbmcoZWRnZSkpO1xuICAgICAgdmFyIGVkZ2VFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uZ2FwKGVkZ2UpKTtcbiAgICAgIFxuICAgICAgcnMuZW5kWCA9IGVkZ2VFbmRbMF07XG4gICAgICBycy5lbmRZID0gZWRnZUVuZFsxXTtcbiAgICAgIFxuICAgICAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gICAgICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcbiAgICAgIFxuICAgICAgdmFyIGNwID0gW3JzLmNwMmF4LCBycy5jcDJheV07XG5cbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICB0aGlzLmdldE5vZGVXaWR0aChzb3VyY2UpLFxuICAgICAgICB0aGlzLmdldE5vZGVIZWlnaHQoc291cmNlKSxcbiAgICAgICAgY3BbMF0sIC8vaGFsZlBvaW50WCxcbiAgICAgICAgY3BbMV0sIC8vaGFsZlBvaW50WVxuICAgICAgICBzcmNCb3JkZXJXIC8gMlxuICAgICAgKTtcbiAgICAgIFxuICAgICAgdmFyIGFycm93U3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKSk7XG4gICAgICB2YXIgZWRnZVN0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLmdhcChlZGdlKSk7XG4gICAgICBcbiAgICAgIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgICAgIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcblxuXG4gICAgICBycy5hcnJvd1N0YXJ0WCA9IGFycm93U3RhcnRbMF07XG4gICAgICBycy5hcnJvd1N0YXJ0WSA9IGFycm93U3RhcnRbMV07XG4gICAgICBcbiAgICB9IGVsc2UgaWYgKHJzLmVkZ2VUeXBlID09ICdzdHJhaWdodCcpIHtcbiAgICBcbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUodGFyZ2V0KV0uaW50ZXJzZWN0TGluZShcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgIHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICB0aGlzLmdldE5vZGVXaWR0aCh0YXJnZXQpLFxuICAgICAgICB0aGlzLmdldE5vZGVIZWlnaHQodGFyZ2V0KSxcbiAgICAgICAgc291cmNlLnBvc2l0aW9uKCkueCxcbiAgICAgICAgc291cmNlLnBvc2l0aW9uKCkueSxcbiAgICAgICAgdGd0Qm9yZGVyVyAvIDIpO1xuICAgICAgICBcbiAgICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJzLm5vQXJyb3dQbGFjZW1lbnQgPSB0cnVlO1xuICAvLyAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLm5vQXJyb3dQbGFjZW1lbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGFycm93RW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCxcbiAgICAgICAgW3NvdXJjZS5wb3NpdGlvbigpLngsIHNvdXJjZS5wb3NpdGlvbigpLnldLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgICAgIHZhciBlZGdlRW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCxcbiAgICAgICAgW3NvdXJjZS5wb3NpdGlvbigpLngsIHNvdXJjZS5wb3NpdGlvbigpLnldLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5nYXAoZWRnZSkpO1xuXG4gICAgICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgICAgIHJzLmVuZFkgPSBlZGdlRW5kWzFdO1xuICAgICAgXG4gICAgICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgICAgIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuICAgIFxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShzb3VyY2UpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHNvdXJjZSksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodChzb3VyY2UpLFxuICAgICAgICB0YXJnZXQucG9zaXRpb24oKS54LFxuICAgICAgICB0YXJnZXQucG9zaXRpb24oKS55LFxuICAgICAgICBzcmNCb3JkZXJXIC8gMik7XG4gICAgICBcbiAgICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJzLm5vQXJyb3dQbGFjZW1lbnQgPSB0cnVlO1xuICAvLyAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLm5vQXJyb3dQbGFjZW1lbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLypcbiAgICAgIGNvbnNvbGUubG9nKFwiMTogXCJcbiAgICAgICAgKyBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXSxcbiAgICAgICAgICBzcmNBclNoYXBlKTtcbiAgICAgICovXG4gICAgICB2YXIgYXJyb3dTdGFydCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsXG4gICAgICAgIFt0YXJnZXQucG9zaXRpb24oKS54LCB0YXJnZXQucG9zaXRpb24oKS55XSxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKSk7XG4gICAgICB2YXIgZWRnZVN0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCxcbiAgICAgICAgW3RhcmdldC5wb3NpdGlvbigpLngsIHRhcmdldC5wb3NpdGlvbigpLnldLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5nYXAoZWRnZSkpO1xuXG4gICAgICBycy5zdGFydFggPSBlZGdlU3RhcnRbMF07XG4gICAgICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG4gICAgICBcbiAgICAgIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgICAgIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcbiAgICAgICAgICAgIFxuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ2JlemllcicpIHtcbiAgICAgIC8vIGlmKCB3aW5kb3cuYmFkQXJyb3cpIGRlYnVnZ2VyO1xuICAgICAgdmFyIGNwID0gW3JzLmNwMngsIHJzLmNwMnldO1xuICAgICAgXG4gICAgICBpbnRlcnNlY3QgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW1xuICAgICAgICB0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHRhcmdldCksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodCh0YXJnZXQpLFxuICAgICAgICBjcFswXSwgLy9oYWxmUG9pbnRYLFxuICAgICAgICBjcFsxXSwgLy9oYWxmUG9pbnRZXG4gICAgICAgIHRndEJvcmRlclcgLyAyXG4gICAgICApO1xuICAgICAgXG4gICAgICAvKlxuICAgICAgY29uc29sZS5sb2coXCIyOiBcIlxuICAgICAgICArIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLFxuICAgICAgICAgIHNyY0FyU2hhcGUpO1xuICAgICAgKi9cbiAgICAgIHZhciBhcnJvd0VuZCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgICAgIHZhciBlZGdlRW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLmdhcChlZGdlKSk7XG4gICAgICBcbiAgICAgIHJzLmVuZFggPSBlZGdlRW5kWzBdO1xuICAgICAgcnMuZW5kWSA9IGVkZ2VFbmRbMV07XG4gICAgICBcbiAgICAgIHJzLmFycm93RW5kWCA9IGFycm93RW5kWzBdO1xuICAgICAgcnMuYXJyb3dFbmRZID0gYXJyb3dFbmRbMV07XG4gICAgICBcbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVNoYXBlKHNvdXJjZSldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgoc291cmNlKSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHNvdXJjZSksXG4gICAgICAgIGNwWzBdLCAvL2hhbGZQb2ludFgsXG4gICAgICAgIGNwWzFdLCAvL2hhbGZQb2ludFlcbiAgICAgICAgc3JjQm9yZGVyVyAvIDJcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHZhciBhcnJvd1N0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKFxuICAgICAgICBpbnRlcnNlY3QsIFxuICAgICAgICBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKVxuICAgICAgKTtcbiAgICAgIHZhciBlZGdlU3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oXG4gICAgICAgIGludGVyc2VjdCwgXG4gICAgICAgIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5nYXAoZWRnZSlcbiAgICAgICk7XG4gICAgXG4gICAgICBycy5zdGFydFggPSBlZGdlU3RhcnRbMF07XG4gICAgICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG4gICAgICBcbiAgICAgIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgICAgIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcbiAgICAgIFxuICAgICAgLy8gaWYoIGlzTmFOKHJzLnN0YXJ0WCkgfHwgaXNOYU4ocnMuc3RhcnRZKSApe1xuICAgICAgLy8gICBkZWJ1Z2dlcjtcbiAgICAgIC8vIH1cblxuICAgIH0gZWxzZSBpZiAocnMuaXNBcmNFZGdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIC8vIEZpbmQgYWRqYWNlbnQgZWRnZXNcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmZpbmRFZGdlcyA9IGZ1bmN0aW9uKG5vZGVTZXQpIHtcbiAgICBcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldENhY2hlZEVkZ2VzKCk7XG4gICAgXG4gICAgdmFyIGhhc2hUYWJsZSA9IHt9O1xuICAgIHZhciBhZGphY2VudEVkZ2VzID0gW107XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoVGFibGVbbm9kZVNldFtpXS5fcHJpdmF0ZS5kYXRhLmlkXSA9IG5vZGVTZXRbaV07XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChoYXNoVGFibGVbZWRnZXNbaV0uX3ByaXZhdGUuZGF0YS5zb3VyY2VdXG4gICAgICAgIHx8IGhhc2hUYWJsZVtlZGdlc1tpXS5fcHJpdmF0ZS5kYXRhLnRhcmdldF0pIHtcbiAgICAgICAgXG4gICAgICAgIGFkamFjZW50RWRnZXMucHVzaChlZGdlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBhZGphY2VudEVkZ2VzO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXRBcnJvd1dpZHRoID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldEFycm93SGVpZ2h0ID0gZnVuY3Rpb24oZWRnZVdpZHRoKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5hcnJvd1dpZHRoQ2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSB8fCB7fTtcblxuICAgIHZhciBjYWNoZWRWYWwgPSBjYWNoZVtlZGdlV2lkdGhdO1xuICAgIGlmKCBjYWNoZWRWYWwgKXtcbiAgICAgIHJldHVybiBjYWNoZWRWYWw7XG4gICAgfVxuXG4gICAgY2FjaGVkVmFsID0gIE1hdGgubWF4KE1hdGgucG93KGVkZ2VXaWR0aCAqIDEzLjM3LCAwLjkpLCAyOSk7XG4gICAgY2FjaGVbZWRnZVdpZHRoXSA9IGNhY2hlZFZhbDtcblxuICAgIHJldHVybiBjYWNoZWRWYWw7XG4gIH07XG5cblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcblxuLy8gRHJhdyBlZGdlXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kcmF3RWRnZSA9IGZ1bmN0aW9uKGNvbnRleHQsIGVkZ2UsIGRyYXdPdmVybGF5SW5zdGVhZCkge1xuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcblxuICAgIC8vIGlmIGJlemllciBjdHJsIHB0cyBjYW4gbm90IGJlIGNhbGN1bGF0ZWQsIHRoZW4gZGllXG4gICAgaWYoIHJzLmJhZEJlemllciB8fCAoIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgfHwgcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpICYmIGlzTmFOKHJzLnN0YXJ0WCkpICl7IC8vIGV4dHJhIGlzTmFOKCkgZm9yIHNhZmFyaSA3LjEgYi9jIGl0IG1hbmdsZXMgY3RybHB0IGNhbGNzXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICBcbiAgICAvLyBFZGdlIGxpbmUgd2lkdGhcbiAgICBpZiAoc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSA8PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG92ZXJsYXlQYWRkaW5nID0gc3R5bGVbJ292ZXJsYXktcGFkZGluZyddLnB4VmFsdWU7XG4gICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gc3R5bGVbJ292ZXJsYXktb3BhY2l0eSddLnZhbHVlO1xuICAgIHZhciBvdmVybGF5Q29sb3IgPSBzdHlsZVsnb3ZlcmxheS1jb2xvciddLnZhbHVlO1xuXG4gICAgLy8gRWRnZSBjb2xvciAmIG9wYWNpdHlcbiAgICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkICl7XG5cbiAgICAgIGlmKCBvdmVybGF5T3BhY2l0eSA9PT0gMCApeyAvLyBleGl0IGVhcmx5IGlmIG5vIG92ZXJsYXlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIG92ZXJsYXlDb2xvclswXSwgb3ZlcmxheUNvbG9yWzFdLCBvdmVybGF5Q29sb3JbMl0sIG92ZXJsYXlPcGFjaXR5KTtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdyb3VuZCc7XG5cbiAgICAgIGlmKCBlZGdlLl9wcml2YXRlLnJzY3JhdGNoLmVkZ2VUeXBlID09ICdzZWxmJyAmJiAhdXNlUGF0aHMgKXtcbiAgICAgICAgY29udGV4dC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsaW5lQ29sb3IgPSBzdHlsZVsnbGluZS1jb2xvciddLnZhbHVlO1xuXG4gICAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIGxpbmVDb2xvclswXSwgbGluZUNvbG9yWzFdLCBsaW5lQ29sb3JbMl0sIHN0eWxlLm9wYWNpdHkudmFsdWUpO1xuICAgICAgXG4gICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7IFxuICAgIH1cbiAgICBcbiAgICB2YXIgc3RhcnROb2RlLCBlbmROb2RlLCBzb3VyY2UsIHRhcmdldDtcbiAgICBzb3VyY2UgPSBzdGFydE5vZGUgPSBlZGdlLl9wcml2YXRlLnNvdXJjZTtcbiAgICB0YXJnZXQgPSBlbmROb2RlID0gZWRnZS5fcHJpdmF0ZS50YXJnZXQ7XG5cbiAgICB2YXIgdGFyZ2V0UG9zID0gdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgIHZhciB0YXJnZXRXID0gdGFyZ2V0LndpZHRoKCk7XG4gICAgdmFyIHRhcmdldEggPSB0YXJnZXQuaGVpZ2h0KCk7XG4gICAgdmFyIHNvdXJjZVBvcyA9IHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICB2YXIgc291cmNlVyA9IHNvdXJjZS53aWR0aCgpO1xuICAgIHZhciBzb3VyY2VIID0gc291cmNlLmhlaWdodCgpO1xuXG5cbiAgICB2YXIgZWRnZVdpZHRoID0gc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSArIChkcmF3T3ZlcmxheUluc3RlYWQgPyAyICogb3ZlcmxheVBhZGRpbmcgOiAwKTtcbiAgICB2YXIgbGluZVN0eWxlID0gZHJhd092ZXJsYXlJbnN0ZWFkID8gJ3NvbGlkJyA6IHN0eWxlWydsaW5lLXN0eWxlJ10udmFsdWU7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBlZGdlV2lkdGg7XG4gICAgXG4gICAgaWYoIHJzLmVkZ2VUeXBlICE9PSAnaGF5c3RhY2snICl7XG4gICAgICAvL3RoaXMuZmluZEVuZHBvaW50cyhlZGdlKTtcbiAgICB9XG4gICAgXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snICl7XG4gICAgICB2YXIgcmFkaXVzID0gc3R5bGVbJ2hheXN0YWNrLXJhZGl1cyddLnZhbHVlO1xuICAgICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMvMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgICAgdGhpcy5kcmF3U3R5bGVkRWRnZShcbiAgICAgICAgZWRnZSwgXG4gICAgICAgIGNvbnRleHQsIFxuICAgICAgICBycy5oYXlzdGFja1B0cyA9IFtcbiAgICAgICAgICBycy5zb3VyY2UueCAqIHNvdXJjZVcgKiBoYWxmUmFkaXVzICsgc291cmNlUG9zLngsXG4gICAgICAgICAgcnMuc291cmNlLnkgKiBzb3VyY2VIICogaGFsZlJhZGl1cyArIHNvdXJjZVBvcy55LFxuICAgICAgICAgIHJzLnRhcmdldC54ICogdGFyZ2V0VyAqIGhhbGZSYWRpdXMgKyB0YXJnZXRQb3MueCxcbiAgICAgICAgICBycy50YXJnZXQueSAqIHRhcmdldEggKiBoYWxmUmFkaXVzICsgdGFyZ2V0UG9zLnlcbiAgICAgICAgXSxcbiAgICAgICAgbGluZVN0eWxlLFxuICAgICAgICBlZGdlV2lkdGhcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlbGYnKSB7XG4gICAgICBcbiAgICAgIHZhciBkZXRhaWxzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBwb2ludHMgPSBbZGV0YWlscy5zdGFydFgsIGRldGFpbHMuc3RhcnRZLCBkZXRhaWxzLmNwMmF4LFxuICAgICAgICBkZXRhaWxzLmNwMmF5LCBkZXRhaWxzLnNlbGZFZGdlTWlkWCwgZGV0YWlscy5zZWxmRWRnZU1pZFksXG4gICAgICAgIGRldGFpbHMuc2VsZkVkZ2VNaWRYLCBkZXRhaWxzLnNlbGZFZGdlTWlkWSxcbiAgICAgICAgZGV0YWlscy5jcDJjeCwgZGV0YWlscy5jcDJjeSwgZGV0YWlscy5lbmRYLCBkZXRhaWxzLmVuZFldO1xuXG4gICAgICB2YXIgZGV0YWlscyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgICB0aGlzLmRyYXdTdHlsZWRFZGdlKGVkZ2UsIGNvbnRleHQsIHBvaW50cywgbGluZVN0eWxlLCBlZGdlV2lkdGgpO1xuICAgICAgXG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgXG4gICAgICB2YXIgbm9kZURpcmVjdGlvblggPSBlbmROb2RlLl9wcml2YXRlLnBvc2l0aW9uLnggLSBzdGFydE5vZGUuX3ByaXZhdGUucG9zaXRpb24ueDtcbiAgICAgIHZhciBub2RlRGlyZWN0aW9uWSA9IGVuZE5vZGUuX3ByaXZhdGUucG9zaXRpb24ueSAtIHN0YXJ0Tm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi55O1xuICAgICAgXG4gICAgICB2YXIgZWRnZURpcmVjdGlvblggPSBycy5lbmRYIC0gcnMuc3RhcnRYO1xuICAgICAgdmFyIGVkZ2VEaXJlY3Rpb25ZID0gcnMuZW5kWSAtIHJzLnN0YXJ0WTtcbiAgICAgIFxuICAgICAgaWYgKG5vZGVEaXJlY3Rpb25YICogZWRnZURpcmVjdGlvblhcbiAgICAgICAgKyBub2RlRGlyZWN0aW9uWSAqIGVkZ2VEaXJlY3Rpb25ZIDwgMCkge1xuICAgICAgICBcbiAgICAgICAgcnMuc3RyYWlnaHRFZGdlVG9vU2hvcnQgPSB0cnVlOyAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBcbiAgICAgICAgdmFyIGRldGFpbHMgPSBycztcbiAgICAgICAgdGhpcy5kcmF3U3R5bGVkRWRnZShlZGdlLCBjb250ZXh0LCBbZGV0YWlscy5zdGFydFgsIGRldGFpbHMuc3RhcnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLmVuZFgsIGRldGFpbHMuZW5kWV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVdpZHRoKTtcbiAgICAgICAgXG4gICAgICAgIHJzLnN0cmFpZ2h0RWRnZVRvb1Nob3J0ID0gZmFsc2U7ICBcbiAgICAgIH0gIFxuICAgIH0gZWxzZSB7XG4gICAgICBcbiAgICAgIHZhciBkZXRhaWxzID0gcnM7XG4gICAgICBcbiAgICAgIHRoaXMuZHJhd1N0eWxlZEVkZ2UoZWRnZSwgY29udGV4dCwgW2RldGFpbHMuc3RhcnRYLCBkZXRhaWxzLnN0YXJ0WSxcbiAgICAgICAgZGV0YWlscy5jcDJ4LCBkZXRhaWxzLmNwMnksIGRldGFpbHMuZW5kWCwgZGV0YWlscy5lbmRZXSxcbiAgICAgICAgbGluZVN0eWxlLFxuICAgICAgICBlZGdlV2lkdGgpO1xuICAgICAgXG4gICAgfVxuICAgIFxuICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyApe1xuICAgICAgdGhpcy5kcmF3QXJyb3doZWFkcyhjb250ZXh0LCBlZGdlLCBkcmF3T3ZlcmxheUluc3RlYWQpO1xuICAgIH0gZWxzZSBpZiAoIHJzLm5vQXJyb3dQbGFjZW1lbnQgIT09IHRydWUgJiYgcnMuc3RhcnRYICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuZHJhd0Fycm93aGVhZHMoY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkKTtcbiAgICB9XG5cbiAgfTtcbiAgXG4gIFxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd1N0eWxlZEVkZ2UgPSBmdW5jdGlvbihcbiAgICAgIGVkZ2UsIGNvbnRleHQsIHB0cywgdHlwZSwgd2lkdGgpIHtcblxuICAgIC8vIDMgcG9pbnRzIGdpdmVuIC0+IGFzc3VtZSBCZXppZXJcbiAgICAvLyAyIC0+IGFzc3VtZSBzdHJhaWdodFxuICAgIFxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNhbnZhc0N4dCA9IGNvbnRleHQ7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuICAgIHZhciB1c2VQYXRocyA9IENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzKCk7XG5cblxuICAgIGlmKCB1c2VQYXRocyApe1xuXG4gICAgICB2YXIgcGF0aENhY2hlS2V5ID0gcHRzO1xuICAgICAgdmFyIGtleUxlbmd0aE1hdGNoZXMgPSBycy5wYXRoQ2FjaGVLZXkgJiYgcGF0aENhY2hlS2V5Lmxlbmd0aCA9PT0gcnMucGF0aENhY2hlS2V5Lmxlbmd0aDtcbiAgICAgIHZhciBrZXlNYXRjaGVzID0ga2V5TGVuZ3RoTWF0Y2hlcztcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGtleU1hdGNoZXMgJiYgaSA8IHBhdGhDYWNoZUtleS5sZW5ndGg7IGkrKyApe1xuICAgICAgICBpZiggcnMucGF0aENhY2hlS2V5W2ldICE9PSBwYXRoQ2FjaGVLZXlbaV0gKXtcbiAgICAgICAgICBrZXlNYXRjaGVzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGtleU1hdGNoZXMgKXtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5wYXRoQ2FjaGU7XG4gICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYoIGNhbnZhc0N4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIHN3aXRjaCggdHlwZSApe1xuICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIDEsIDEgXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goWyA2LCAzIF0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICBjYW52YXNDeHQuc2V0TGluZURhc2goWyBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggIXBhdGhDYWNoZUhpdCApe1xuICAgICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cbiAgICAgIGNvbnRleHQubW92ZVRvKHB0c1swXSwgcHRzWzFdKTtcbiAgICAgIFxuICAgICAgaWYgKHB0cy5sZW5ndGggPT09IDMgKiAyKSB7IC8vIGJlemllclxuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcbiAgICAgIH0gZWxzZSBpZiggcHRzLmxlbmd0aCA9PT0gMyAqIDIgKiAyICl7IC8vIGRvdWJsZSBiZXppZXIgbG9vcFxuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHB0c1s4XSwgcHRzWzldLCBwdHNbMTBdLCBwdHNbMTFdKTtcbiAgICAgIH0gZWxzZSB7IC8vIGxpbmVcbiAgICAgICAgY29udGV4dC5saW5lVG8ocHRzWzJdLCBwdHNbM10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQgPSBjYW52YXNDeHQ7XG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICBjb250ZXh0LnN0cm9rZSggcGF0aCApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgXG4gICAgLy8gcmVzZXQgYW55IGxpbmUgZGFzaGVzXG4gICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgfVxuXG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRyYXdBcnJvd2hlYWRzID0gZnVuY3Rpb24oY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG4gICAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCApeyByZXR1cm47IH0gLy8gZG9uJ3QgZG8gYW55dGhpbmcgZm9yIG92ZXJsYXlzIFxuXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGlzSGF5c3RhY2sgPSBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJztcblxuICAgIC8vIERpc3BsYWNlbWVudCBnaXZlcyBkaXJlY3Rpb24gZm9yIGFycm93aGVhZCBvcmllbnRhdGlvblxuICAgIHZhciBkaXNwWCwgZGlzcFk7XG4gICAgdmFyIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZO1xuXG4gICAgdmFyIHNyY1BvcyA9IGVkZ2Uuc291cmNlKCkucG9zaXRpb24oKTtcbiAgICB2YXIgdGd0UG9zID0gZWRnZS50YXJnZXQoKS5wb3NpdGlvbigpO1xuXG4gICAgaWYoIGlzSGF5c3RhY2sgKXtcbiAgICAgIHN0YXJ0WCA9IHJzLmhheXN0YWNrUHRzWzBdO1xuICAgICAgc3RhcnRZID0gcnMuaGF5c3RhY2tQdHNbMV07XG4gICAgICBlbmRYID0gcnMuaGF5c3RhY2tQdHNbMl07XG4gICAgICBlbmRZID0gcnMuaGF5c3RhY2tQdHNbM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0WCA9IHJzLmFycm93U3RhcnRYO1xuICAgICAgc3RhcnRZID0gcnMuYXJyb3dTdGFydFk7XG4gICAgICBlbmRYID0gcnMuYXJyb3dFbmRYO1xuICAgICAgZW5kWSA9IHJzLmFycm93RW5kWTtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgIFxuICAgIGZ1bmN0aW9uIGRyYXdBcnJvd2hlYWQoIHByZWZpeCwgeCwgeSwgZGlzcFgsIGRpc3BZICl7XG4gICAgICB2YXIgYXJyb3dTaGFwZSA9IHN0eWxlW3ByZWZpeCArICctYXJyb3ctc2hhcGUnXS52YWx1ZTtcblxuICAgICAgaWYoIGFycm93U2hhcGUgPT09ICdub25lJyApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBnY28gPSBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbjtcblxuICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgIFxuICAgICAgc2VsZi5maWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG5cblxuICAgICAgdmFyIGFycm93Q2xlYXJGaWxsID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1maWxsJ10udmFsdWUgPT09ICdob2xsb3cnID8gJ2JvdGgnIDogJ2ZpbGxlZCc7XG4gICAgICB2YXIgYXJyb3dGaWxsID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1maWxsJ10udmFsdWU7XG5cbiAgICAgIGlmKCBhcnJvd1NoYXBlID09PSAnaGFsZi10cmlhbmdsZS1vdmVyc2hvdCcgKXtcbiAgICAgICAgYXJyb3dGaWxsID0gJ2hvbGxvdyc7XG4gICAgICAgIGFycm93Q2xlYXJGaWxsID0gJ2hvbGxvdyc7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuZHJhd0Fycm93U2hhcGUoIGVkZ2UsIHByZWZpeCwgY29udGV4dCwgXG4gICAgICAgIGFycm93Q2xlYXJGaWxsLCBzdHlsZVsnd2lkdGgnXS5weFZhbHVlLCBzdHlsZVtwcmVmaXggKyAnLWFycm93LXNoYXBlJ10udmFsdWUsIFxuICAgICAgICB4LCB5LCBkaXNwWCwgZGlzcFlcbiAgICAgICk7XG5cbiAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuXG4gICAgICB2YXIgY29sb3IgPSBzdHlsZVtwcmVmaXggKyAnLWFycm93LWNvbG9yJ10udmFsdWU7XG4gICAgICBzZWxmLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBzdHlsZS5vcGFjaXR5LnZhbHVlKTtcblxuICAgICAgc2VsZi5kcmF3QXJyb3dTaGFwZSggZWRnZSwgcHJlZml4LCBjb250ZXh0LCBcbiAgICAgICAgYXJyb3dGaWxsLCBzdHlsZVsnd2lkdGgnXS5weFZhbHVlLCBzdHlsZVtwcmVmaXggKyAnLWFycm93LXNoYXBlJ10udmFsdWUsIFxuICAgICAgICB4LCB5LCBkaXNwWCwgZGlzcFlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZGlzcFggPSBzdGFydFggLSBzcmNQb3MueDtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIHNyY1Bvcy55O1xuXG4gICAgaWYoICFpc0hheXN0YWNrICYmICFpc05hTihzdGFydFgpICYmICFpc05hTihzdGFydFkpICYmICFpc05hTihkaXNwWCkgJiYgIWlzTmFOKGRpc3BZKSApe1xuICAgICAgZHJhd0Fycm93aGVhZCggJ3NvdXJjZScsIHN0YXJ0WCwgc3RhcnRZLCBkaXNwWCwgZGlzcFkgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aW5kb3cuYmFkQXJyb3cgPSB0cnVlO1xuICAgICAgLy8gZGVidWdnZXI7XG4gICAgfVxuICAgIFxuICAgIHZhciBtaWRYID0gcnMubWlkWDtcbiAgICB2YXIgbWlkWSA9IHJzLm1pZFk7XG5cbiAgICBpZiggaXNIYXlzdGFjayApe1xuICAgICAgbWlkWCA9ICggc3RhcnRYICsgZW5kWCApLzI7XG4gICAgICBtaWRZID0gKCBzdGFydFkgKyBlbmRZICkvMjtcbiAgICB9XG5cbiAgICBkaXNwWCA9IHN0YXJ0WCAtIGVuZFg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBlbmRZO1xuXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnc2VsZicgKXtcbiAgICAgIGRpc3BYID0gMTtcbiAgICAgIGRpc3BZID0gLTE7XG4gICAgfVxuXG4gICAgaWYoICFpc05hTihtaWRYKSAmJiAhaXNOYU4obWlkWSkgKXtcbiAgICAgIGRyYXdBcnJvd2hlYWQoICdtaWQtdGFyZ2V0JywgbWlkWCwgbWlkWSwgZGlzcFgsIGRpc3BZICk7XG4gICAgfVxuXG4gICAgZGlzcFggKj0gLTE7XG4gICAgZGlzcFkgKj0gLTE7XG5cbiAgICBpZiggIWlzTmFOKG1pZFgpICYmICFpc05hTihtaWRZKSApe1xuICAgICAgZHJhd0Fycm93aGVhZCggJ21pZC1zb3VyY2UnLCBtaWRYLCBtaWRZLCBkaXNwWCwgZGlzcFkgKTtcbiAgICB9XG4gICAgXG4gICAgZGlzcFggPSBlbmRYIC0gdGd0UG9zLng7XG4gICAgZGlzcFkgPSBlbmRZIC0gdGd0UG9zLnk7XG4gICAgXG4gICAgaWYoICFpc0hheXN0YWNrICYmICFpc05hTihlbmRYKSAmJiAhaXNOYU4oZW5kWSkgJiYgIWlzTmFOKGRpc3BYKSAmJiAhaXNOYU4oZGlzcFkpICl7XG4gICAgICBkcmF3QXJyb3doZWFkKCAndGFyZ2V0JywgZW5kWCwgZW5kWSwgZGlzcFgsIGRpc3BZICk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRHJhdyBhcnJvd3NoYXBlXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uKGVkZ2UsIGFycm93VHlwZSwgY29udGV4dCwgZmlsbCwgZWRnZVdpZHRoLCBzaGFwZSwgeCwgeSwgZGlzcFgsIGRpc3BZKSB7XG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgY2FudmFzQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdmFyIHRyYW5zbGF0aW9uID0geyB4OiB4LCB5OiB5IH07XG5cbiAgICAvLyBOZWdhdGl2ZSBvZiB0aGUgYW5nbGVcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZGlzcFkgLyAoTWF0aC5zcXJ0KGRpc3BYICogZGlzcFggKyBkaXNwWSAqIGRpc3BZKSkpO1xuICBcbiAgICBpZiAoZGlzcFggPCAwKSB7XG4gICAgICBhbmdsZSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gLSAoTWF0aC5QSSAvIDIgKyBhbmdsZSk7XG4gICAgfVxuICAgIFxuICAgIHZhciBzaXplID0gdGhpcy5nZXRBcnJvd1dpZHRoKCBlZGdlV2lkdGggKTtcbiAgICB2YXIgc2hhcGVJbXBsID0gQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc2hhcGVdO1xuXG4gICAgLy8gY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG5cbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBzaXplICsgJyQnICsgc2hhcGUgKyAnJCcgKyBhbmdsZSArICckJyArIHggKyAnJCcgKyB5O1xuICAgICAgcnMuYXJyb3dQYXRoQ2FjaGVLZXkgPSBycy5hcnJvd1BhdGhDYWNoZUtleSB8fCB7fTtcbiAgICAgIHJzLmFycm93UGF0aENhY2hlID0gcnMuYXJyb3dQYXRoQ2FjaGUgfHwge307XG5cbiAgICAgIHZhciBhbHJlYWR5Q2FjaGVkID0gcnMuYXJyb3dQYXRoQ2FjaGVLZXlbYXJyb3dUeXBlXSA9PT0gcGF0aENhY2hlS2V5O1xuICAgICAgaWYoIGFscmVhZHlDYWNoZWQgKXtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5hcnJvd1BhdGhDYWNoZVthcnJvd1R5cGVdO1xuICAgICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIHJzLmFycm93UGF0aENhY2hlS2V5W2Fycm93VHlwZV0gPSBwYXRoQ2FjaGVLZXk7XG4gICAgICAgIHJzLmFycm93UGF0aENhY2hlW2Fycm93VHlwZV0gPSBwYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICBpZiggIXBhdGhDYWNoZUhpdCApe1xuICAgICAgc2hhcGVJbXBsLmRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgaWYoICFzaGFwZUltcGwubGVhdmVQYXRoT3BlbiAmJiBjb250ZXh0LmNsb3NlUGF0aCApe1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBjb250ZXh0ID0gY2FudmFzQ29udGV4dDtcblxuICAgIGlmKCBmaWxsID09PSAnZmlsbGVkJyB8fCBmaWxsID09PSAnYm90aCcgKXtcbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBmaWxsID09PSAnaG9sbG93JyB8fCBmaWxsID09PSAnYm90aCcgKXtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gKCBzaGFwZUltcGwubWF0Y2hFZGdlV2lkdGggPyBlZGdlV2lkdGggOiAxICk7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJztcblxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuXG4gICAgLy8gY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmdldENhY2hlZEltYWdlID0gZnVuY3Rpb24odXJsLCBvbkxvYWQpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIGltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgPSByLmltYWdlQ2FjaGUgfHwge307XG5cbiAgICBpZiggaW1hZ2VDYWNoZVt1cmxdICYmIGltYWdlQ2FjaGVbdXJsXS5pbWFnZSApe1xuICAgICAgcmV0dXJuIGltYWdlQ2FjaGVbdXJsXS5pbWFnZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGNhY2hlID0gaW1hZ2VDYWNoZVt1cmxdID0gaW1hZ2VDYWNoZVt1cmxdIHx8IHt9O1xuXG4gICAgdmFyIGltYWdlID0gY2FjaGUuaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgb25Mb2FkKTtcbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gICAgXG4gICAgcmV0dXJuIGltYWdlO1xuICB9O1xuICAgIFxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd0luc2NyaWJlZEltYWdlID0gZnVuY3Rpb24oY29udGV4dCwgaW1nLCBub2RlKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBub2RlWCA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueDtcbiAgICB2YXIgbm9kZVkgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnk7XG4gICAgdmFyIHN0eWxlID0gbm9kZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgZml0ID0gc3R5bGVbJ2JhY2tncm91bmQtZml0J10udmFsdWU7XG4gICAgdmFyIHhQb3MgPSBzdHlsZVsnYmFja2dyb3VuZC1wb3NpdGlvbi14J107XG4gICAgdmFyIHlQb3MgPSBzdHlsZVsnYmFja2dyb3VuZC1wb3NpdGlvbi15J107XG4gICAgdmFyIHJlcGVhdCA9IHN0eWxlWydiYWNrZ3JvdW5kLXJlcGVhdCddLnZhbHVlO1xuICAgIHZhciBub2RlVyA9IG5vZGUud2lkdGgoKTtcbiAgICB2YXIgbm9kZUggPSBub2RlLmhlaWdodCgpO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIGNsaXAgPSBzdHlsZVsnYmFja2dyb3VuZC1jbGlwJ10udmFsdWU7XG4gICAgdmFyIHNob3VsZENsaXAgPSBjbGlwID09PSAnbm9kZSc7XG4gICAgdmFyIGltZ09wYWNpdHkgPSBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5J10udmFsdWU7XG4gICAgXG4gICAgdmFyIHcgPSBpbWcud2lkdGg7XG4gICAgdmFyIGggPSBpbWcuaGVpZ2h0O1xuXG4gICAgaWYoIHcgPT09IDAgfHwgaCA9PT0gMCApe1xuICAgICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gICAgfVxuXG4gICAgaWYoIGZpdCA9PT0gJ2NvbnRhaW4nICl7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1pbiggbm9kZVcvdywgbm9kZUgvaCApO1xuXG4gICAgICB3ICo9IHNjYWxlO1xuICAgICAgaCAqPSBzY2FsZTtcblxuICAgIH0gZWxzZSBpZiggZml0ID09PSAnY292ZXInICl7XG4gICAgICB2YXIgc2NhbGUgPSBNYXRoLm1heCggbm9kZVcvdywgbm9kZUgvaCApO1xuXG4gICAgICB3ICo9IHNjYWxlO1xuICAgICAgaCAqPSBzY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IChub2RlWCAtIG5vZGVXLzIpOyAvLyBsZWZ0XG4gICAgaWYoIHhQb3MudW5pdHMgPT09ICclJyApe1xuICAgICAgeCArPSAobm9kZVcgLSB3KSAqIHhQb3MudmFsdWUvMTAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IHhQb3MucHhWYWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgeSA9IChub2RlWSAtIG5vZGVILzIpOyAvLyB0b3BcbiAgICBpZiggeVBvcy51bml0cyA9PT0gJyUnICl7XG4gICAgICB5ICs9IChub2RlSCAtIGgpICogeVBvcy52YWx1ZS8xMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgKz0geVBvcy5weFZhbHVlO1xuICAgIH1cblxuICAgIGlmKCBycy5wYXRoQ2FjaGUgKXtcbiAgICAgIHggLT0gbm9kZVg7XG4gICAgICB5IC09IG5vZGVZO1xuXG4gICAgICBub2RlWCA9IDA7XG4gICAgICBub2RlWSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGdBbHBoYSA9IGNvbnRleHQuZ2xvYmFsQWxwaGE7XG5cbiAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gaW1nT3BhY2l0eTtcblxuICAgIGlmKCByZXBlYXQgPT09ICduby1yZXBlYXQnICl7XG5cbiAgICAgIGlmKCBzaG91bGRDbGlwICl7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAgIGlmKCBycy5wYXRoQ2FjaGUgKXtcbiAgICAgICAgICBjb250ZXh0LmNsaXAoIHJzLnBhdGhDYWNoZSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbci5nZXROb2RlU2hhcGUobm9kZSldLmRyYXdQYXRoKFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIG5vZGVYLCBub2RlWSwgXG4gICAgICAgICAgICBub2RlVywgbm9kZUgpO1xuXG4gICAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGltZywgMCwgMCwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0LCB4LCB5LCB3LCBoICk7XG5cbiAgICAgIGlmKCBzaG91bGRDbGlwICl7XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGF0dGVybiA9IGNvbnRleHQuY3JlYXRlUGF0dGVybiggaW1nLCByZXBlYXQgKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcblxuICAgICAgQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhd1BhdGgoXG4gICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICBub2RlWCwgbm9kZVksIFxuICAgICAgICAgIG5vZGVXLCBub2RlSCk7XG5cbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgIH1cblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBnQWxwaGE7XG4gICAgXG4gIH07XG5cbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcblxuICAvLyBEcmF3IGVkZ2UgdGV4dFxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd0VkZ2VUZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgZWRnZSkge1xuICAgIHZhciB0ZXh0ID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuXG4gICAgaWYoICF0ZXh0IHx8IHRleHQubWF0Y2goL15cXHMrJC8pICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoIHRoaXMuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiAodGhpcy5kcmFnRGF0YS5kaWREcmFnIHx8IHRoaXMucGluY2hpbmcgfHwgdGhpcy5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgdGhpcy5kYXRhLndoZWVsIHx8IHRoaXMuc3dpcGVQYW5uaW5nKSApeyByZXR1cm47IH0gLy8gc2F2ZSBjeWNsZXMgb24gcGluY2hpbmdcblxuICAgIHZhciBjb21wdXRlZFNpemUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICogZWRnZS5jeSgpLnpvb20oKTtcbiAgICB2YXIgbWluU2l6ZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ21pbi16b29tZWQtZm9udC1zaXplJ10ucHhWYWx1ZTtcblxuICAgIGlmKCBjb21wdXRlZFNpemUgPCBtaW5TaXplICl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICBcbiAgICAvLyBDYWxjdWxhdGUgdGV4dCBkcmF3IHBvc2l0aW9uXG4gICAgXG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIFxuICAgIC8vIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uKCBlZGdlICk7XG4gICAgXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB0aGlzLmRyYXdUZXh0KGNvbnRleHQsIGVkZ2UsIHJzLmxhYmVsWCwgcnMubGFiZWxZKTtcbiAgfTtcblxuICAvLyBEcmF3IG5vZGUgdGV4dFxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd05vZGVUZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgbm9kZSkge1xuICAgIHZhciB0ZXh0ID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuXG4gICAgaWYgKCAhdGV4dCB8fCB0ZXh0Lm1hdGNoKC9eXFxzKyQvKSApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29tcHV0ZWRTaXplID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnZm9udC1zaXplJ10ucHhWYWx1ZSAqIG5vZGUuY3koKS56b29tKCk7XG4gICAgdmFyIG1pblNpemUgPSBub2RlLl9wcml2YXRlLnN0eWxlWydtaW4tem9vbWVkLWZvbnQtc2l6ZSddLnB4VmFsdWU7XG5cbiAgICBpZiggY29tcHV0ZWRTaXplIDwgbWluU2l6ZSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAgIFxuICAgIC8vIHRoaXMucmVjYWxjdWxhdGVOb2RlTGFiZWxQcm9qZWN0aW9uKCBub2RlICk7XG5cbiAgICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtaGFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIHRleHRWYWxpZ24gPSBub2RlLl9wcml2YXRlLnN0eWxlWyd0ZXh0LXZhbGlnbiddLnN0clZhbHVlO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICBzd2l0Y2goIHRleHRIYWxpZ24gKXtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICBzd2l0Y2goIHRleHRWYWxpZ24gKXtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICB9XG5cbiAgICB0aGlzLmRyYXdUZXh0KGNvbnRleHQsIG5vZGUsIHJzLmxhYmVsWCwgcnMubGFiZWxZKTtcbiAgfTtcbiAgXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5nZXRGb250Q2FjaGUgPSBmdW5jdGlvbihjb250ZXh0KXtcbiAgICB2YXIgY2FjaGU7XG5cbiAgICB0aGlzLmZvbnRDYWNoZXMgPSB0aGlzLmZvbnRDYWNoZXMgfHwgW107XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMuZm9udENhY2hlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgY2FjaGUgPSB0aGlzLmZvbnRDYWNoZXNbaV07XG5cbiAgICAgIGlmKCBjYWNoZS5jb250ZXh0ID09PSBjb250ZXh0ICl7XG4gICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWNoZSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICB9O1xuICAgIHRoaXMuZm9udENhY2hlcy5wdXNoKGNhY2hlKTtcblxuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICAvLyBzZXQgdXAgY2FudmFzIGNvbnRleHQgd2l0aCBmb250XG4gIC8vIHJldHVybnMgdHJhbnNmb3JtZWQgdGV4dCBzdHJpbmdcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnNldHVwVGV4dFN0eWxlID0gZnVuY3Rpb24oIGNvbnRleHQsIGVsZW1lbnQgKXtcbiAgICAvLyBGb250IHN0eWxlXG4gICAgdmFyIHBhcmVudE9wYWNpdHkgPSBlbGVtZW50LmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50Ll9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBsYWJlbFN0eWxlID0gc3R5bGVbJ2ZvbnQtc3R5bGUnXS5zdHJWYWx1ZTtcbiAgICB2YXIgbGFiZWxTaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddLnB4VmFsdWUgKyAncHgnO1xuICAgIHZhciBsYWJlbEZhbWlseSA9IHN0eWxlWydmb250LWZhbWlseSddLnN0clZhbHVlO1xuICAgIHZhciBsYWJlbFdlaWdodCA9IHN0eWxlWydmb250LXdlaWdodCddLnN0clZhbHVlO1xuICAgIHZhciBvcGFjaXR5ID0gc3R5bGVbJ3RleHQtb3BhY2l0eSddLnZhbHVlICogc3R5bGVbJ29wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHk7XG4gICAgdmFyIG91dGxpbmVPcGFjaXR5ID0gc3R5bGVbJ3RleHQtb3V0bGluZS1vcGFjaXR5J10udmFsdWUgKiBvcGFjaXR5O1xuICAgIHZhciBjb2xvciA9IHN0eWxlWydjb2xvciddLnZhbHVlO1xuICAgIHZhciBvdXRsaW5lQ29sb3IgPSBzdHlsZVsndGV4dC1vdXRsaW5lLWNvbG9yJ10udmFsdWU7XG5cbiAgICB2YXIgZm9udENhY2hlS2V5ID0gZWxlbWVudC5fcHJpdmF0ZS5mb250S2V5O1xuICAgIHZhciBjYWNoZSA9IHRoaXMuZ2V0Rm9udENhY2hlKGNvbnRleHQpO1xuXG4gICAgaWYoIGNhY2hlLmtleSAhPT0gZm9udENhY2hlS2V5ICl7XG4gICAgICBjb250ZXh0LmZvbnQgPSBsYWJlbFN0eWxlICsgJyAnICsgbGFiZWxXZWlnaHQgKyAnICcgKyBsYWJlbFNpemUgKyAnICcgKyBsYWJlbEZhbWlseTtcblxuICAgICAgY2FjaGUua2V5ID0gZm9udENhY2hlS2V5O1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gU3RyaW5nKHN0eWxlWydjb250ZW50J10udmFsdWUpO1xuICAgIHZhciB0ZXh0VHJhbnNmb3JtID0gc3R5bGVbJ3RleHQtdHJhbnNmb3JtJ10udmFsdWU7XG4gICAgXG4gICAgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ25vbmUnKSB7XG4gICAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICd1cHBlcmNhc2UnKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbG93ZXJjYXNlJykge1xuICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHRleHQgZHJhdyBwb3NpdGlvbiBiYXNlZCBvbiB0ZXh0IGFsaWdubWVudFxuICAgIFxuICAgIC8vIHNvIHRleHQgb3V0bGluZXMgYXJlbid0IGphZ2dlZFxuICAgIGNvbnRleHQubGluZUpvaW4gPSAncm91bmQnO1xuXG4gICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG4gICAgXG4gICAgdGhpcy5zdHJva2VTdHlsZShjb250ZXh0LCBvdXRsaW5lQ29sb3JbMF0sIG91dGxpbmVDb2xvclsxXSwgb3V0bGluZUNvbG9yWzJdLCBvdXRsaW5lT3BhY2l0eSk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICAvLyBEcmF3IHRleHRcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRyYXdUZXh0ID0gZnVuY3Rpb24oY29udGV4dCwgZWxlbWVudCwgdGV4dFgsIHRleHRZKSB7XG4gICAgdmFyIHN0eWxlID0gZWxlbWVudC5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZW1lbnQuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICAgIGlmKCBwYXJlbnRPcGFjaXR5ID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgdmFyIHRleHQgPSB0aGlzLnNldHVwVGV4dFN0eWxlKCBjb250ZXh0LCBlbGVtZW50ICk7XG4gICAgXG4gICAgaWYgKCB0ZXh0ICE9IG51bGwgJiYgIWlzTmFOKHRleHRYKSAmJiAhaXNOYU4odGV4dFkpICkge1xuICAgICBcbiAgICAgIHZhciBsaW5lV2lkdGggPSAyICAqIHN0eWxlWyd0ZXh0LW91dGxpbmUtd2lkdGgnXS52YWx1ZTsgLy8gKjIgYi9jIHRoZSBzdHJva2UgaXMgZHJhd24gY2VudHJlZCBvbiB0aGUgbWlkZGxlXG4gICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHRleHRYLCB0ZXh0WSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgdGV4dFgsIHRleHRZKTtcbiAgICB9XG4gIH07XG5cbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcblxuICAvLyBEcmF3IG5vZGVcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRyYXdOb2RlID0gZnVuY3Rpb24oY29udGV4dCwgbm9kZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG5cbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIG5vZGVXaWR0aCwgbm9kZUhlaWdodDtcbiAgICB2YXIgc3R5bGUgPSBub2RlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgXG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcbiAgICB2YXIgY2FudmFzQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIHBhdGhDYWNoZUhpdCA9IGZhbHNlO1xuXG4gICAgdmFyIG92ZXJsYXlQYWRkaW5nID0gc3R5bGVbJ292ZXJsYXktcGFkZGluZyddLnB4VmFsdWU7XG4gICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gc3R5bGVbJ292ZXJsYXktb3BhY2l0eSddLnZhbHVlO1xuICAgIHZhciBvdmVybGF5Q29sb3IgPSBzdHlsZVsnb3ZlcmxheS1jb2xvciddLnZhbHVlO1xuXG4gICAgaWYoIGRyYXdPdmVybGF5SW5zdGVhZCAmJiBvdmVybGF5T3BhY2l0eSA9PT0gMCApeyAvLyBleGl0IGVhcmx5IGlmIGRyYXdpbmcgb3ZlcmxheSBidXQgbm9uZSB0byBkcmF3XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhcmVudE9wYWNpdHkgPSBub2RlLmVmZmVjdGl2ZU9wYWNpdHkoKTtcbiAgICBpZiggcGFyZW50T3BhY2l0eSA9PT0gMCApeyByZXR1cm47IH1cblxuICAgIG5vZGVXaWR0aCA9IHRoaXMuZ2V0Tm9kZVdpZHRoKG5vZGUpO1xuICAgIG5vZGVIZWlnaHQgPSB0aGlzLmdldE5vZGVIZWlnaHQobm9kZSk7XG4gICAgXG4gICAgY29udGV4dC5saW5lV2lkdGggPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcblxuICAgIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgPT09IHVuZGVmaW5lZCB8fCAhZHJhd092ZXJsYXlJbnN0ZWFkICl7XG5cbiAgICAgIC8vIE5vZGUgY29sb3IgJiBvcGFjaXR5XG5cbiAgICAgIHZhciBiZ0NvbG9yID0gc3R5bGVbJ2JhY2tncm91bmQtY29sb3InXS52YWx1ZTtcbiAgICAgIHZhciBib3JkZXJDb2xvciA9IHN0eWxlWydib3JkZXItY29sb3InXS52YWx1ZTtcbiAgICAgIHZhciBib3JkZXJTdHlsZSA9IHN0eWxlWydib3JkZXItc3R5bGUnXS52YWx1ZTtcblxuICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgYmdDb2xvclswXSwgYmdDb2xvclsxXSwgYmdDb2xvclsyXSwgc3R5bGVbJ2JhY2tncm91bmQtb3BhY2l0eSddLnZhbHVlICogc3R5bGVbJ29wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHkpO1xuICAgICAgXG4gICAgICB0aGlzLnN0cm9rZVN0eWxlKGNvbnRleHQsIGJvcmRlckNvbG9yWzBdLCBib3JkZXJDb2xvclsxXSwgYm9yZGVyQ29sb3JbMl0sIHN0eWxlWydib3JkZXItb3BhY2l0eSddLnZhbHVlICogc3R5bGVbJ29wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHkpO1xuXG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJzsgLy8gc28gYm9yZGVycyBhcmUgc3F1YXJlIHdpdGggdGhlIG5vZGUgc2hhcGVcblxuICAgICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIHN3aXRjaCggYm9yZGVyU3R5bGUgKXtcbiAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIDEsIDEgXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgNCwgMiBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL3ZhciBpbWFnZSA9IHRoaXMuZ2V0Q2FjaGVkSW1hZ2UoJ3VybCcpO1xuICAgICAgXG4gICAgICB2YXIgdXJsID0gc3R5bGVbJ2JhY2tncm91bmQtaW1hZ2UnXS52YWx1ZVsyXSB8fFxuICAgICAgICBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddLnZhbHVlWzFdO1xuICAgICAgXG4gICAgICB2YXIgc3R5bGVTaGFwZSA9IHN0eWxlWydzaGFwZSddLnN0clZhbHVlO1xuXG4gICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBzdHlsZVNoYXBlICsgJyQnICsgbm9kZVdpZHRoICsnJCcgKyBub2RlSGVpZ2h0O1xuXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCBwb3MueCwgcG9zLnkgKTtcblxuICAgICAgICBpZiggcnMucGF0aENhY2hlS2V5ID09PSBwYXRoQ2FjaGVLZXkgKXtcbiAgICAgICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICAgIHJzLnBhdGhDYWNoZUtleSA9IHBhdGhDYWNoZUtleTtcbiAgICAgICAgICBycy5wYXRoQ2FjaGUgPSBwYXRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhcGF0aENhY2hlSGl0ICl7XG5cbiAgICAgICAgdmFyIG5wb3MgPSBwb3M7XG5cbiAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgbnBvcyA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbdGhpcy5nZXROb2RlU2hhcGUobm9kZSldLmRyYXdQYXRoKFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBucG9zLngsXG4gICAgICAgICAgICAgIG5wb3MueSxcbiAgICAgICAgICAgICAgbm9kZVdpZHRoLFxuICAgICAgICAgICAgICBub2RlSGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dCA9IGNhbnZhc0NvbnRleHQ7XG5cbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIGdldCBpbWFnZSwgYW5kIGlmIG5vdCBsb2FkZWQgdGhlbiBhc2sgdG8gcmVkcmF3IHdoZW4gbGF0ZXIgbG9hZGVkXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuZ2V0Q2FjaGVkSW1hZ2UodXJsLCBmdW5jdGlvbigpe1xuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gdHJ1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBpbWFnZS5jb21wbGV0ZSApe1xuICAgICAgICAgIHRoaXMuZHJhd0luc2NyaWJlZEltYWdlKGNvbnRleHQsIGltYWdlLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gXG4gICAgICBcbiAgICAgIHZhciBkYXJrbmVzcyA9IHN0eWxlWydiYWNrZ3JvdW5kLWJsYWNrZW4nXS52YWx1ZTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuXG4gICAgICBpZiggdGhpcy5oYXNQaWUobm9kZSkgKXtcbiAgICAgICAgdGhpcy5kcmF3UGllKGNvbnRleHQsIG5vZGUpO1xuXG4gICAgICAgIC8vIHJlZHJhdyBwYXRoIGZvciBibGFja2VuIGFuZCBib3JkZXJcbiAgICAgICAgaWYoIGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwICl7XG5cbiAgICAgICAgICBpZiggIXVzZVBhdGhzICl7XG4gICAgICAgICAgICBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3UGF0aChcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHBvcy54LFxuICAgICAgICAgICAgICAgIHBvcy55LFxuICAgICAgICAgICAgICAgIG5vZGVXaWR0aCxcbiAgICAgICAgICAgICAgICBub2RlSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGRhcmtuZXNzID4gMCApe1xuICAgICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCAwLCAwLCAwLCBkYXJrbmVzcyk7XG5cbiAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYoIGRhcmtuZXNzIDwgMCApe1xuICAgICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAtZGFya25lc3MpO1xuICAgICAgICBcbiAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQm9yZGVyIHdpZHRoLCBkcmF3IGJvcmRlclxuICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuXG4gICAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScgKXtcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlLzM7XG5cbiAgICAgICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgICAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSggLXBvcy54LCAtcG9zLnkgKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzZXQgaW4gY2FzZSB3ZSBjaGFuZ2VkIHRoZSBib3JkZXIgc3R5bGVcbiAgICAgIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICB9XG5cbiAgICAvLyBkcmF3IHRoZSBvdmVybGF5XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYoIG92ZXJsYXlPcGFjaXR5ID4gMCApe1xuICAgICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBvdmVybGF5Q29sb3JbMF0sIG92ZXJsYXlDb2xvclsxXSwgb3ZlcmxheUNvbG9yWzJdLCBvdmVybGF5T3BhY2l0eSk7XG5cbiAgICAgICAgQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXS5kcmF3UGF0aChcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgICBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgICAgbm9kZVdpZHRoICsgb3ZlcmxheVBhZGRpbmcgKiAyLFxuICAgICAgICAgIG5vZGVIZWlnaHQgKyBvdmVybGF5UGFkZGluZyAqIDJcbiAgICAgICAgKTtcblxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvLyBkb2VzIHRoZSBub2RlIGhhdmUgYXQgbGVhc3Qgb25lIHBpZSBwaWVjZT9cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmhhc1BpZSA9IGZ1bmN0aW9uKG5vZGUpe1xuICAgIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuICAgIFxuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmhhc1BpZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZHJhd1BpZSA9IGZ1bmN0aW9uKGNvbnRleHQsIG5vZGUpe1xuICAgIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gICAgdmFyIHBpZVNpemUgPSBub2RlLl9wcml2YXRlLnN0eWxlWydwaWUtc2l6ZSddO1xuICAgIHZhciBub2RlVyA9IHRoaXMuZ2V0Tm9kZVdpZHRoKCBub2RlICk7XG4gICAgdmFyIG5vZGVIID0gdGhpcy5nZXROb2RlSGVpZ2h0KCBub2RlICk7XG4gICAgdmFyIHggPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uLng7XG4gICAgdmFyIHkgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnk7XG4gICAgdmFyIHJhZGl1cyA9IE1hdGgubWluKCBub2RlVywgbm9kZUggKSAvIDI7IC8vIG11c3QgZml0IGluIG5vZGVcbiAgICB2YXIgbGFzdFBlcmNlbnQgPSAwOyAvLyB3aGF0ICUgdG8gY29udGludWUgZHJhd2luZyBwaWUgc2xpY2VzIGZyb20gb24gWzAsIDFdXG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcblxuICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgeCA9IDA7XG4gICAgICB5ID0gMDtcbiAgICB9XG5cbiAgICBpZiggcGllU2l6ZS51bml0cyA9PT0gJyUnICl7XG4gICAgICByYWRpdXMgPSByYWRpdXMgKiBwaWVTaXplLnZhbHVlIC8gMTAwO1xuICAgIH0gZWxzZSBpZiggcGllU2l6ZS5weFZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHJhZGl1cyA9IHBpZVNpemUucHhWYWx1ZSAvIDI7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gJCQuc3R5bGUucGllQmFja2dyb3VuZE47IGkrKyApeyAvLyAxLi5OXG4gICAgICB2YXIgc2l6ZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJ10udmFsdWU7XG4gICAgICB2YXIgY29sb3IgPSBub2RlLl9wcml2YXRlLnN0eWxlWydwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtY29sb3InXS52YWx1ZTtcbiAgICAgIHZhciBvcGFjaXR5ID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLW9wYWNpdHknXS52YWx1ZTtcbiAgICAgIHZhciBwZXJjZW50ID0gc2l6ZSAvIDEwMDsgLy8gbWFwIGludGVnZXIgcmFuZ2UgWzAsIDEwMF0gdG8gWzAsIDFdXG4gICAgICB2YXIgYW5nbGVTdGFydCA9IDEuNSAqIE1hdGguUEkgKyAyICogTWF0aC5QSSAqIGxhc3RQZXJjZW50OyAvLyBzdGFydCBhdCAxMiBvJ2Nsb2NrIGFuZCBnbyBjbG9ja3dpc2VcbiAgICAgIHZhciBhbmdsZURlbHRhID0gMiAqIE1hdGguUEkgKiBwZXJjZW50O1xuICAgICAgdmFyIGFuZ2xlRW5kID0gYW5nbGVTdGFydCArIGFuZ2xlRGVsdGE7XG5cbiAgICAgIC8vIGlnbm9yZSBpZlxuICAgICAgLy8gLSB6ZXJvIHNpemVcbiAgICAgIC8vIC0gd2UncmUgYWxyZWFkeSBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgICAvLyAtIGFkZGluZyB0aGUgY3VycmVudCBzbGljZSB3b3VsZCBnbyBiZXlvbmQgdGhlIGZ1bGwgY2lyY2xlXG4gICAgICBpZiggc2l6ZSA9PT0gMCB8fCBsYXN0UGVyY2VudCA+PSAxIHx8IGxhc3RQZXJjZW50ICsgcGVyY2VudCA+IDEgKXtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICAgIGNvbnRleHQuYXJjKCB4LCB5LCByYWRpdXMsIGFuZ2xlU3RhcnQsIGFuZ2xlRW5kICk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBvcGFjaXR5KTtcblxuICAgICAgY29udGV4dC5maWxsKCk7XG5cbiAgICAgIGxhc3RQZXJjZW50ICs9IHBlcmNlbnQ7XG4gICAgfVxuXG4gIH07XG5cbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcblxuICAvLyB2YXIgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uKCl7IFxuICAgIHZhciBjb250ZXh0ID0gdGhpcy5kYXRhLmNvbnRleHRzWzBdO1xuXG4gICAgaWYoIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbyAhPSBudWxsICl7XG4gICAgICByZXR1cm4gdGhpcy5mb3JjZWRQaXhlbFJhdGlvO1xuICAgIH1cblxuICAgIHZhciBiYWNraW5nU3RvcmUgPSBjb250ZXh0LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGNvbnRleHQud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjb250ZXh0Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY29udGV4dC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IDE7XG5cbiAgICAvL2NvbnNvbGUubG9nKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCBiYWNraW5nU3RvcmUpO1xuXG4gICAgLy8gaWYoIGlzRmlyZWZveCApeyAvLyBiZWNhdXNlIGZmIGNhbid0IHNjYWxlIGNhbnZhcyBwcm9wZXJseVxuICAgIC8vICAgcmV0dXJuIDE7XG4gICAgLy8gfVxuXG4gICAgcmV0dXJuICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIGJhY2tpbmdTdG9yZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucGFpbnRDYWNoZSA9IGZ1bmN0aW9uKGNvbnRleHQpe1xuICAgIHZhciBjYWNoZXMgPSB0aGlzLnBhaW50Q2FjaGVzID0gdGhpcy5wYWludENhY2hlcyB8fCBbXTtcbiAgICB2YXIgbmVlZFRvQ3JlYXRlQ2FjaGUgPSB0cnVlO1xuICAgIHZhciBjYWNoZTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYWNoZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ldO1xuXG4gICAgICBpZiggY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCApe1xuICAgICAgICBuZWVkVG9DcmVhdGVDYWNoZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggbmVlZFRvQ3JlYXRlQ2FjaGUgKXtcbiAgICAgIGNhY2hlID0ge1xuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9O1xuICAgICAgY2FjaGVzLnB1c2goIGNhY2hlICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5maWxsU3R5bGUgPSBmdW5jdGlvbihjb250ZXh0LCByLCBnLCBiLCBhKXtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhICsgJyknO1xuICAgIFxuICAgIC8vIHR1cm4gb2ZmIGZvciBub3csIHNlZW1zIGNvbnRleHQgZG9lcyBpdHMgb3duIGNhY2hpbmdcblxuICAgIC8vIHZhciBjYWNoZSA9IHRoaXMucGFpbnRDYWNoZShjb250ZXh0KTtcblxuICAgIC8vIHZhciBmaWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAgIC8vIGlmKCBjYWNoZS5maWxsU3R5bGUgIT09IGZpbGxTdHlsZSApe1xuICAgIC8vICAgY29udGV4dC5maWxsU3R5bGUgPSBjYWNoZS5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgLy8gfVxuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5zdHJva2VTdHlsZSA9IGZ1bmN0aW9uKGNvbnRleHQsIHIsIGcsIGIsIGEpe1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgICBcbiAgICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgICAvLyB2YXIgc3Ryb2tlU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcblxuICAgIC8vIGlmKCBjYWNoZS5zdHJva2VTdHlsZSAhPT0gc3Ryb2tlU3R5bGUgKXtcbiAgICAvLyAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjYWNoZS5zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlO1xuICAgIC8vIH1cbiAgfTtcblxuICAvLyBSZXNpemUgY2FudmFzXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5tYXRjaENhbnZhc1NpemUgPSBmdW5jdGlvbihjb250YWluZXIpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgd2lkdGggPSBjb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldFBpeGVsUmF0aW8oKTtcbiAgICB2YXIgY2FudmFzV2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgdmFyIGNhbnZhc0hlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgdmFyIGNhbnZhcztcblxuICAgIGlmKCBjYW52YXNXaWR0aCA9PT0gdGhpcy5jYW52YXNXaWR0aCAmJiBjYW52YXNIZWlnaHQgPT09IHRoaXMuY2FudmFzSGVpZ2h0ICl7XG4gICAgICByZXR1cm47IC8vIHNhdmUgY3ljbGVzIGlmIHNhbWVcbiAgICB9XG5cbiAgICB0aGlzLmZvbnRDYWNoZXMgPSBudWxsOyAvLyByZXNpemluZyByZXNldHMgdGhlIHN0eWxlXG5cbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gZGF0YS5jYW52YXNDb250YWluZXI7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgIGNhbnZhc0NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTOyBpKyspIHtcblxuICAgICAgY2FudmFzID0gZGF0YS5jYW52YXNlc1tpXTtcbiAgICAgIFxuICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgIFxuICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkJVRkZFUl9DT1VOVDsgaSsrKSB7XG4gICAgICBcbiAgICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbaV07XG4gICAgICBcbiAgICAgIGlmIChjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCkge1xuICAgICAgICBcbiAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG5cbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRleHR1cmVNdWx0ID0gMTtcbiAgICBpZiggcGl4ZWxSYXRpbyA8PSAxICl7XG4gICAgICBjYW52YXMgPSBkYXRhLmJ1ZmZlckNhbnZhc2VzWyBDYW52YXNSZW5kZXJlci5URVhUVVJFX0JVRkZFUiBdO1xuXG4gICAgICB0aGlzLnRleHR1cmVNdWx0ID0gMjtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoICogdGhpcy50ZXh0dXJlTXVsdDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQgKiB0aGlzLnRleHR1cmVNdWx0O1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzV2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICB0aGlzLmNhbnZhc0hlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJUbyA9IGZ1bmN0aW9uKCBjeHQsIHpvb20sIHBhbiwgcHhSYXRpbyApe1xuICAgIHRoaXMucmVkcmF3KHtcbiAgICAgIGZvcmNlZENvbnRleHQ6IGN4dCxcbiAgICAgIGZvcmNlZFpvb206IHpvb20sXG4gICAgICBmb3JjZWRQYW46IHBhbixcbiAgICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgICBmb3JjZWRQeFJhdGlvOiBweFJhdGlvXG4gICAgfSk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnRpbWVUb1JlbmRlciA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMucmVkcmF3VG90YWxUaW1lIC8gdGhpcy5yZWRyYXdDb3VudDtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5taW5SZWRyYXdMaW1pdCA9IDEwMDAvNjA7IC8vIHBlb3BsZSBjYW4ndCBzZWUgbXVjaCBiZXR0ZXIgdGhhbiA2MGZwc1xuICBDYW52YXNSZW5kZXJlci5tYXhSZWRyYXdMaW1pdCA9IDEwMDA7ICAvLyBkb24ndCBjYXAgbWF4IGIvYyBpdCdzIG1vcmUgaW1wb3J0YW50IHRvIGJlIHJlc3BvbnNpdmUgdGhhbiBzbW9vdGhcbiAgQ2FudmFzUmVuZGVyZXIubW90aW9uQmx1ckRlbGF5ID0gMTAwO1xuXG4gIC8vIFJlZHJhdyBmcmFtZVxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucmVkcmF3ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBjb25zb2xlLmxvZygncmVkcmF3Jyk7XG5cbiAgICB2YXIgZm9yY2VkQ29udGV4dCA9IG9wdGlvbnMuZm9yY2VkQ29udGV4dDtcbiAgICB2YXIgZHJhd0FsbExheWVycyA9IG9wdGlvbnMuZHJhd0FsbExheWVycztcbiAgICB2YXIgZHJhd09ubHlOb2RlTGF5ZXIgPSBvcHRpb25zLmRyYXdPbmx5Tm9kZUxheWVyO1xuICAgIHZhciBmb3JjZWRab29tID0gb3B0aW9ucy5mb3JjZWRab29tO1xuICAgIHZhciBmb3JjZWRQYW4gPSBvcHRpb25zLmZvcmNlZFBhbjtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBvcHRpb25zLmZvcmNlZFB4UmF0aW8gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0UGl4ZWxSYXRpbygpIDogb3B0aW9ucy5mb3JjZWRQeFJhdGlvO1xuICAgIHZhciBjeSA9IHIuZGF0YS5jeTsgdmFyIGRhdGEgPSByLmRhdGE7IFxuICAgIHZhciBuZWVkRHJhdyA9IGRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG4gICAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgICBtb3Rpb25CbHVyID0gbW90aW9uQmx1ciAmJiAhZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJFbmFibGVkO1xuXG4gICAgaWYoIG1vdGlvbkJsdXIgJiYgci5tb3Rpb25CbHVyVGltZW91dCApe1xuICAgICAgY2xlYXJUaW1lb3V0KCByLm1vdGlvbkJsdXJUaW1lb3V0ICk7XG4gICAgfVxuXG4gICAgaWYoICFmb3JjZWRDb250ZXh0ICYmIHRoaXMucmVkcmF3VGltZW91dCApe1xuICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLnJlZHJhd1RpbWVvdXQgKTtcbiAgICB9XG4gICAgdGhpcy5yZWRyYXdUaW1lb3V0ID0gbnVsbDtcblxuICAgIGlmKCB0aGlzLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQgKXsgdGhpcy5hdmVyYWdlUmVkcmF3VGltZSA9IDA7IH1cblxuICAgIHZhciBtaW5SZWRyYXdMaW1pdCA9IENhbnZhc1JlbmRlcmVyLm1pblJlZHJhd0xpbWl0OyBcbiAgICB2YXIgbWF4UmVkcmF3TGltaXQgPSBDYW52YXNSZW5kZXJlci5tYXhSZWRyYXdMaW1pdDtcblxuICAgIHZhciByZWRyYXdMaW1pdCA9IHRoaXMuYXZlcmFnZVJlZHJhd1RpbWU7IC8vIGVzdGltYXRlIHRoZSBpZGVhbCByZWRyYXcgbGltaXQgYmFzZWQgb24gaG93IGZhc3Qgd2UgY2FuIGRyYXdcbiAgICByZWRyYXdMaW1pdCA9IG1pblJlZHJhd0xpbWl0ID4gcmVkcmF3TGltaXQgPyBtaW5SZWRyYXdMaW1pdCA6IHJlZHJhd0xpbWl0O1xuICAgIHJlZHJhd0xpbWl0ID0gcmVkcmF3TGltaXQgPCBtYXhSZWRyYXdMaW1pdCA/IHJlZHJhd0xpbWl0IDogbWF4UmVkcmF3TGltaXQ7XG5cbiAgICAvL2NvbnNvbGUubG9nKCctLVxcbmlkZWFsOiAlaTsgZWZmZWN0aXZlOiAlaScsIHRoaXMuYXZlcmFnZVJlZHJhd1RpbWUsIHJlZHJhd0xpbWl0KTtcblxuICAgIGlmKCB0aGlzLmxhc3REcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7IHRoaXMubGFzdERyYXdUaW1lID0gMDsgfVxuXG4gICAgdmFyIG5vd1RpbWUgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgdGltZUVsYXBzZWQgPSBub3dUaW1lIC0gdGhpcy5sYXN0RHJhd1RpbWU7XG4gICAgdmFyIGNhbGxBZnRlckxpbWl0ID0gdGltZUVsYXBzZWQgPj0gcmVkcmF3TGltaXQ7XG5cbiAgICBpZiggIWZvcmNlZENvbnRleHQgKXtcbiAgICAgIGlmKCAhY2FsbEFmdGVyTGltaXQgfHwgdGhpcy5jdXJyZW50bHlEcmF3aW5nICl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLSBza2lwJyk7XG5cbiAgICAgICAgLy8gd2UgaGF2ZSBuZXcgdGhpbmdzIHRvIGRyYXcgYnV0IHdlJ3JlIGJ1c3ksIHNvIHRyeSBhZ2FpbiB3aGVuIHBvc3NpYmx5IGZyZWVcbiAgICAgICAgdGhpcy5yZWRyYXdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0sIHJlZHJhd0xpbWl0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxhc3REcmF3VGltZSA9IG5vd1RpbWU7XG4gICAgICB0aGlzLmN1cnJlbnRseURyYXdpbmcgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgdmFyIHN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgLy9jb25zb2xlLmxvZygnLS0gcmVkcmF3IC0tJylcblxuXG4gICAgZnVuY3Rpb24gZHJhd1RvQ29udGV4dCgpeyBcbiAgICAgIC8vIHN0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xuICAgICAgLy8gY29uc29sZS5wcm9maWxlKCdkcmF3JyArIHN0YXJ0VGltZSlcbiAgICAgIHZhciBlZGdlcyA9IHIuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICAgIHZhciBjb3JlU3R5bGUgPSBjeS5zdHlsZSgpLl9wcml2YXRlLmNvcmVTdHlsZTtcbiAgICAgIFxuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgZWZmZWN0aXZlWm9vbSA9IGZvcmNlZFpvb20gIT09IHVuZGVmaW5lZCA/IGZvcmNlZFpvb20gOiB6b29tO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIGVmZmVjdGl2ZVBhbiA9IHtcbiAgICAgICAgeDogcGFuLngsXG4gICAgICAgIHk6IHBhbi55XG4gICAgICB9O1xuXG4gICAgICBpZiggZm9yY2VkUGFuICl7XG4gICAgICAgIGVmZmVjdGl2ZVBhbiA9IGZvcmNlZFBhbjtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcGl4ZWwgcmF0aW9cblxuICAgICAgZWZmZWN0aXZlWm9vbSAqPSBwaXhlbFJhdGlvO1xuICAgICAgZWZmZWN0aXZlUGFuLnggKj0gcGl4ZWxSYXRpbztcbiAgICAgIGVmZmVjdGl2ZVBhbi55ICo9IHBpeGVsUmF0aW87XG4gICAgICBcbiAgICAgIHZhciBlbGVzID0ge1xuICAgICAgICBkcmFnOiB7XG4gICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgIGVkZ2VzOiBbXSxcbiAgICAgICAgICBlbGVzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBub25kcmFnOiB7XG4gICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgIGVkZ2VzOiBbXSxcbiAgICAgICAgICBlbGVzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKXtcbiAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgICAgaWYoIGNsZWFyID09PSAnbW90aW9uQmx1cicgKXtcbiAgICAgICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICAgIHIuZmlsbFN0eWxlKCBjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAwLjY2NiApO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuXG4gICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBnY287XG4gICAgICAgIH0gZWxzZSBpZiggIWZvcmNlZENvbnRleHQgJiYgKGNsZWFyID09PSB1bmRlZmluZWQgfHwgY2xlYXIpICl7XG4gICAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggIWRyYXdBbGxMYXllcnMgKXtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShlZmZlY3RpdmVQYW4ueCwgZWZmZWN0aXZlUGFuLnkpO1xuICAgICAgICAgIGNvbnRleHQuc2NhbGUoZWZmZWN0aXZlWm9vbSwgZWZmZWN0aXZlWm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIGZvcmNlZFBhbiApe1xuICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSk7XG4gICAgICAgIH0gXG4gICAgICAgIGlmKCBmb3JjZWRab29tICl7XG4gICAgICAgICAgY29udGV4dC5zY2FsZShmb3JjZWRab29tLCBmb3JjZWRab29tKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dHVyZURyYXcgPSByLnRleHR1cmVPblZpZXdwb3J0ICYmICFmb3JjZWRDb250ZXh0ICYmIChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcpO1xuXG4gICAgICBpZiggdGV4dHVyZURyYXcgKXtcblxuICAgICAgICB2YXIgYmI7XG5cbiAgICAgICAgaWYoICFyLnRleHR1cmVDYWNoZSApe1xuICAgICAgICAgIHIudGV4dHVyZUNhY2hlID0ge307XG5cbiAgICAgICAgICBiYiA9IHIudGV4dHVyZUNhY2hlLmJiID0gY3kuZWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuXG4gICAgICAgICAgci50ZXh0dXJlQ2FjaGUudGV4dHVyZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1sgQ2FudmFzUmVuZGVyZXIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgICAgICAgIHZhciBjeHQgPSByLmRhdGEuYnVmZmVyQ29udGV4dHNbIENhbnZhc1JlbmRlcmVyLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICAgICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCk7XG4gICAgICAgICAgXG4gICAgICAgICAgci5yZWRyYXcoe1xuICAgICAgICAgICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgICAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgICAgICBmb3JjZWRQeFJhdGlvOiBwaXhlbFJhdGlvICogci50ZXh0dXJlTXVsdFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQgPSB7XG4gICAgICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgICAgICBwYW46IGN5LnBhbigpLFxuICAgICAgICAgICAgd2lkdGg6IHIuY2FudmFzV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZwLm1wYW4gPSB7XG4gICAgICAgICAgICB4OiAoMCAtIHZwLnBhbi54KS92cC56b29tLFxuICAgICAgICAgICAgeTogKDAgLSB2cC5wYW4ueSkvdnAuem9vbVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IGZhbHNlO1xuICAgICAgICBuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0c1tDYW52YXNSZW5kZXJlci5OT0RFXTtcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IHIudGV4dHVyZUNhY2hlLnRleHR1cmU7XG4gICAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0O1xuICAgICAgICBiYiA9IHIudGV4dHVyZUNhY2hlLmJiO1xuXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcblxuICAgICAgICB2YXIgb3V0c2lkZUJnQ29sb3IgPSBjb3JlU3R5bGVbJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvciddLnZhbHVlO1xuICAgICAgICB2YXIgb3V0c2lkZUJnT3BhY2l0eSA9IGNvcmVTdHlsZVsnb3V0c2lkZS10ZXh0dXJlLWJnLW9wYWNpdHknXS52YWx1ZTtcbiAgICAgICAgci5maWxsU3R5bGUoIGNvbnRleHQsIG91dHNpZGVCZ0NvbG9yWzBdLCBvdXRzaWRlQmdDb2xvclsxXSwgb3V0c2lkZUJnQ29sb3JbMl0sIG91dHNpZGVCZ09wYWNpdHkgKTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCggMCwgMCwgdnAud2lkdGgsIHZwLmhlaWdodCApO1xuXG4gICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICBcbiAgICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgZmFsc2UgKTtcblxuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCggdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoL3ZwLnpvb20vcGl4ZWxSYXRpbywgdnAuaGVpZ2h0L3ZwLnpvb20vcGl4ZWxSYXRpbyApO1xuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSggdGV4dHVyZSwgdnAubXBhbi54LCB2cC5tcGFuLnksIHZwLndpZHRoL3ZwLnpvb20vcGl4ZWxSYXRpbywgdnAuaGVpZ2h0L3ZwLnpvb20vcGl4ZWxSYXRpbyApO1xuXG4gICAgICB9IGVsc2UgaWYoIHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgKXsgLy8gY2xlYXIgdGhlIGNhY2hlIHNpbmNlIHdlIGRvbid0IG5lZWQgaXRcbiAgICAgICAgci50ZXh0dXJlQ2FjaGUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdnBNYW5pcCA9IChyLnBpbmNoaW5nIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuc3dpcGVQYW5uaW5nIHx8IHIuZGF0YS53aGVlbFpvb21pbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzKTtcbiAgICAgIHZhciBoaWRlRWRnZXMgPSByLmhpZGVFZGdlc09uVmlld3BvcnQgJiYgdnBNYW5pcDtcbiAgICAgIHZhciBoaWRlTGFiZWxzID0gci5oaWRlTGFiZWxzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuXG4gICAgICBpZiAobmVlZERyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gfHwgbmVlZERyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllcikge1xuICAgICAgICAvL05CIDogVkVSWSBFWFBFTlNJVkVcblxuICAgICAgICBpZiggaGlkZUVkZ2VzICl7IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIuZmluZEVkZ2VDb250cm9sUG9pbnRzKGVkZ2VzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB6RWxlcyA9IHIuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICAgICAgdmFyIGV4dGVudCA9IGN5LmV4dGVudCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgekVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWxlID0gekVsZXNbaV07XG4gICAgICAgICAgdmFyIGxpc3Q7XG4gICAgICAgICAgdmFyIGJiID0gZm9yY2VkQ29udGV4dCA/IG51bGwgOiBlbGUuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICB2YXIgaW5zaWRlRXh0ZW50ID0gZm9yY2VkQ29udGV4dCA/IHRydWUgOiAkJC5tYXRoLmJvdW5kaW5nQm94ZXNJbnRlcnNlY3QoIGV4dGVudCwgYmIgKTtcblxuICAgICAgICAgIGlmKCAhaW5zaWRlRXh0ZW50ICl7IGNvbnRpbnVlOyB9IC8vIG5vIG5lZWQgdG8gcmVuZGVyXG5cbiAgICAgICAgICBpZiAoIGVsZS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciApIHtcbiAgICAgICAgICAgIGxpc3QgPSBlbGVzLmRyYWc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3QgPSBlbGVzLm5vbmRyYWc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdC5lbGVzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICBmdW5jdGlvbiBkcmF3RWxlbWVudHMoIGxpc3QsIGNvbnRleHQgKXtcbiAgICAgICAgdmFyIGVsZXMgPSBsaXN0LmVsZXM7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICAgICAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSk7XG5cbiAgICAgICAgICAgIGlmKCAhaGlkZUxhYmVscyApe1xuICAgICAgICAgICAgICByLmRyYXdOb2RlVGV4dChjb250ZXh0LCBlbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYXdOb2RlKGNvbnRleHQsIGVsZSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmKCAhaGlkZUVkZ2VzICkge1xuICAgICAgICAgICAgci5kcmF3RWRnZShjb250ZXh0LCBlbGUpO1xuXG4gICAgICAgICAgICBpZiggIWhpZGVMYWJlbHMgKXtcbiAgICAgICAgICAgICAgci5kcmF3RWRnZVRleHQoY29udGV4dCwgZWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kcmF3RWRnZShjb250ZXh0LCBlbGUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlTGF5ZXJOZWVkc01vdGlvbkNsZWFyID0gbmVlZERyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gJiYgIW5lZWREcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZE5vZGVMYXllckZvck1vdGlvbkJsdXI7XG4gICAgICBpZiggbm9kZUxheWVyTmVlZHNNb3Rpb25DbGVhciApeyByLmNsZWFyZWROb2RlTGF5ZXJGb3JNb3Rpb25CbHVyID0gdHJ1ZTsgfVxuXG4gICAgICBpZiggbmVlZERyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gfHwgZHJhd0FsbExheWVycyB8fCBkcmF3T25seU5vZGVMYXllciB8fCBub2RlTGF5ZXJOZWVkc01vdGlvbkNsZWFyICl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZWRyYXdpbmcgbm9kZSBsYXllcicpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8IGRhdGEuY29udGV4dHNbQ2FudmFzUmVuZGVyZXIuTk9ERV07XG5cbiAgICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgbW90aW9uQmx1ciAmJiAhbm9kZUxheWVyTmVlZHNNb3Rpb25DbGVhciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZCApO1xuICAgICAgICBkcmF3RWxlbWVudHMoZWxlcy5ub25kcmFnLCBjb250ZXh0KTtcbiAgICAgICAgXG4gICAgICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgICAgIG5lZWREcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gZmFsc2U7IFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICggIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSB8fCBkcmF3QWxsTGF5ZXJzKSApIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCBkYXRhLmNvbnRleHRzW0NhbnZhc1JlbmRlcmVyLkRSQUddO1xuICAgICAgICBcbiAgICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgbW90aW9uQmx1ciA/ICdtb3Rpb25CbHVyJyA6IHVuZGVmaW5lZCApO1xuICAgICAgICBkcmF3RWxlbWVudHMoZWxlcy5kcmFnLCBjb250ZXh0KTtcbiAgICAgICAgXG4gICAgICAgIGlmKCAhZHJhd0FsbExheWVycyApe1xuICAgICAgICAgIG5lZWREcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIHIuc2hvd0ZwcyB8fCAoIWRyYXdPbmx5Tm9kZUxheWVyICYmIChuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSAmJiAhZHJhd0FsbExheWVycykpICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVkcmF3aW5nIHNlbGVjdGlvbiBib3gnKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCBkYXRhLmNvbnRleHRzW0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdO1xuXG4gICAgICAgIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQgKTtcblxuICAgICAgICBpZiggZGF0YS5zZWxlY3RbNF0gPT0gMSAmJiByLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgICAgICB2YXIgem9vbSA9IGRhdGEuY3kuem9vbSgpO1xuICAgICAgICAgIHZhciBib3JkZXJXaWR0aCA9IGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItd2lkdGgnXS52YWx1ZSAvIHpvb207XG4gICAgICAgICAgXG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYShcIiBcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWNvbG9yJ10udmFsdWVbMF0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtY29sb3InXS52YWx1ZVsxXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1jb2xvciddLnZhbHVlWzJdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LW9wYWNpdHknXS52YWx1ZSArIFwiKVwiO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoXG4gICAgICAgICAgICBkYXRhLnNlbGVjdFswXSxcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0WzFdLFxuICAgICAgICAgICAgZGF0YS5zZWxlY3RbMl0gLSBkYXRhLnNlbGVjdFswXSxcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0WzNdIC0gZGF0YS5zZWxlY3RbMV0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBcInJnYmEoXCIgXG4gICAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvciddLnZhbHVlWzBdICsgXCIsXCJcbiAgICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMV0gKyBcIixcIlxuICAgICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InXS52YWx1ZVsyXSArIFwiLFwiXG4gICAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LW9wYWNpdHknXS52YWx1ZSArIFwiKVwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoXG4gICAgICAgICAgICAgIGRhdGEuc2VsZWN0WzBdLFxuICAgICAgICAgICAgICBkYXRhLnNlbGVjdFsxXSxcbiAgICAgICAgICAgICAgZGF0YS5zZWxlY3RbMl0gLSBkYXRhLnNlbGVjdFswXSxcbiAgICAgICAgICAgICAgZGF0YS5zZWxlY3RbM10gLSBkYXRhLnNlbGVjdFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZyApe1xuICAgICAgICAgIHZhciB6b29tID0gZGF0YS5jeS56b29tKCk7XG4gICAgICAgICAgdmFyIHBvcyA9IGRhdGEuYmdBY3RpdmVQb3Npc3Rpb247XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IFwicmdiYShcIiBcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydhY3RpdmUtYmctY29sb3InXS52YWx1ZVswXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLWNvbG9yJ10udmFsdWVbMV0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1jb2xvciddLnZhbHVlWzJdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydhY3RpdmUtYmctb3BhY2l0eSddLnZhbHVlICsgXCIpXCI7XG5cbiAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHBvcy54LCBwb3MueSwgY29yZVN0eWxlWydhY3RpdmUtYmctc2l6ZSddLnB4VmFsdWUgLyB6b29tLCAwLCAyICogTWF0aC5QSSk7IFxuICAgICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgdGltZVRvUmVuZGVyID0gci5hdmVyYWdlUmVkcmF3VGltZTtcbiAgICAgICAgaWYoIHIuc2hvd0ZwcyAmJiB0aW1lVG9SZW5kZXIgKXtcbiAgICAgICAgICB0aW1lVG9SZW5kZXIgPSBNYXRoLnJvdW5kKCB0aW1lVG9SZW5kZXIgKTtcbiAgICAgICAgICB2YXIgZnBzID0gTWF0aC5yb3VuZCgxMDAwL3RpbWVUb1JlbmRlcik7XG5cbiAgICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgICAgIC8vY29udGV4dC5mb250ID0gJzIwcHggaGVsdmV0aWNhJztcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC43NSknO1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dCggJzEgZnJhbWUgPSAnICsgdGltZVRvUmVuZGVyICsgJyBtcyA9ICcgKyBmcHMgKyAnIGZwcycsIDAsIDIwKTtcblxuICAgICAgICAgIHZhciBtYXhGcHMgPSA2MDtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoMCwgMzAsIDI1MCwgMjApO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMzAsIDI1MCAqIE1hdGgubWluKGZwcy9tYXhGcHMsIDEpLCAyMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWRyYXdBbGxMYXllcnMgKXtcbiAgICAgICAgICBuZWVkRHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IGZhbHNlOyBcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIHZhciBlbmRUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICAgIGlmKCByLmF2ZXJhZ2VSZWRyYXdUaW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5hdmVyYWdlUmVkcmF3VGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCByLnJlZHJhd0NvdW50ID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5yZWRyYXdDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHIucmVkcmF3Q291bnQrKztcblxuICAgICAgaWYoIHIucmVkcmF3VG90YWxUaW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgci5yZWRyYXdUb3RhbFRpbWUgPSAwO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhd1RvdGFsVGltZSArPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgci5sYXN0UmVkcmF3VGltZSA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG5cbiAgICAgIC8vIHVzZSBhIHdlaWdodGVkIGF2ZXJhZ2Ugd2l0aCBhIGJpYXMgZnJvbSB0aGUgcHJldmlvdXMgYXZlcmFnZSBzbyB3ZSBkb24ndCBzcGlrZSBzbyBlYXNpbHlcbiAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSByLmF2ZXJhZ2VSZWRyYXdUaW1lLzIgKyAoZW5kVGltZSAtIHN0YXJ0VGltZSkvMjtcbiAgICAgIC8vY29uc29sZS5sb2coJ2FjdHVhbDogJWksIGF2ZXJhZ2U6ICVpJywgZW5kVGltZSAtIHN0YXJ0VGltZSwgdGhpcy5hdmVyYWdlUmVkcmF3VGltZSk7XG5cbiAgICAgIHIuY3VycmVudGx5RHJhd2luZyA9IGZhbHNlO1xuXG4gICAgICAvLyBjb25zb2xlLnByb2ZpbGVFbmQoJ2RyYXcnICsgc3RhcnRUaW1lKVxuXG4gICAgICBpZiggci5jbGVhcmluZ01vdGlvbkJsdXIgKXtcbiAgICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSBmYWxzZTtcbiAgICAgICAgci5tb3Rpb25CbHVyQ2xlYXJlZCA9IHRydWU7XG4gICAgICAgIHIubW90aW9uQmx1ciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCBtb3Rpb25CbHVyICl7IFxuICAgICAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHIubW90aW9uQmx1clRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtb3Rpb24gYmx1ciBjbGVhcicpO1xuXG4gICAgICAgICAgci5jbGVhcmVkTm9kZUxheWVyRm9yTW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgICAgIHIubW90aW9uQmx1ciA9IGZhbHNlO1xuICAgICAgICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gdHJ1ZTtcblxuICAgICAgICAgIG5lZWREcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTsgXG4gICAgICAgICAgbmVlZERyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlOyBcblxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH0sIENhbnZhc1JlbmRlcmVyLm1vdGlvbkJsdXJEZWxheSk7XG4gICAgICB9XG4gICAgfSAvLyBkcmF3IHRvIGNvbnRleHRcblxuICAgIGlmKCAhZm9yY2VkQ29udGV4dCApe1xuICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhd1RvQ29udGV4dCk7IC8vIG1ha2VzIGRpcmVjdCByZW5kZXJzIHRvIHNjcmVlbiBhIGJpdCBtb3JlIHJlc3BvbnNpdmVcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1RvQ29udGV4dCgpO1xuICAgIH1cblxuICAgIGlmKCAhZm9yY2VkQ29udGV4dCAmJiAhci5pbml0cmVuZGVyICl7XG4gICAgICByLmluaXRyZW5kZXIgPSB0cnVlO1xuICAgICAgY3kudHJpZ2dlcignaW5pdHJlbmRlcicpO1xuICAgIH1cbiAgICBcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcblxuICAvLyBATyBQb2x5Z29uIGRyYXdpbmdcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRyYXdQb2x5Z29uUGF0aCA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cykge1xuXG4gICAgdmFyIGhhbGZXID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSCA9IGhlaWdodCAvIDI7XG5cbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuXG4gICAgY29udGV4dC5tb3ZlVG8oIHggKyBoYWxmVyAqIHBvaW50c1swXSwgeSArIGhhbGZIICogcG9pbnRzWzFdICk7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIGNvbnRleHQubGluZVRvKCB4ICsgaGFsZlcgKiBwb2ludHNbaSAqIDJdLCB5ICsgaGFsZkggKiBwb2ludHNbaSAqIDIgKyAxXSApO1xuICAgIH1cbiAgICBcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuICBcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRyYXdQb2x5Z29uID0gZnVuY3Rpb24oXG4gICAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG5cbiAgICAvLyBEcmF3IHBhdGhcbiAgICB0aGlzLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpO1xuICAgIFxuICAgIC8vIEZpbGwgcGF0aFxuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xuICBcbiAgLy8gUm91bmQgcmVjdGFuZ2xlIGRyYXdpbmdcbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGggPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICBcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gJCQubWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBcbiAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuICAgIFxuICAgIC8vIFN0YXJ0IGF0IHRvcCBtaWRkbGVcbiAgICBjb250ZXh0Lm1vdmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gICAgLy8gQXJjIGZyb20gbWlkZGxlIHRvcCB0byByaWdodCBzaWRlXG4gICAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5IC0gaGFsZkhlaWdodCwgeCArIGhhbGZXaWR0aCwgeSwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBBcmMgZnJvbSByaWdodCBzaWRlIHRvIGJvdHRvbVxuICAgIGNvbnRleHQuYXJjVG8oeCArIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHgsIHkgKyBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIGJvdHRvbSB0byBsZWZ0IHNpZGVcbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCB4IC0gaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIGxlZnQgc2lkZSB0byB0b3BCb3JkZXJcbiAgICBjb250ZXh0LmFyY1RvKHggLSBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4LCB5IC0gaGFsZkhlaWdodCwgY29ybmVyUmFkaXVzKTtcbiAgICAvLyBKb2luIGxpbmVcbiAgICBjb250ZXh0LmxpbmVUbyh4LCB5IC0gaGFsZkhlaWdodCk7XG4gICAgXG4gICAgXG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfTtcbiAgXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5kcmF3Um91bmRSZWN0YW5nbGUgPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcbiAgICBcbiAgICB0aGlzLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcbiAgICBcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfTtcblxuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVCdWZmZXIgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGJ1ZmZlci53aWR0aCA9IHc7XG4gICAgYnVmZmVyLmhlaWdodCA9IGg7XG4gICAgXG4gICAgcmV0dXJuIFtidWZmZXIsIGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpXTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUuYnVmZmVyQ2FudmFzSW1hZ2UgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBjeSA9IGRhdGEuY3k7XG4gICAgdmFyIGJiID0gY3kuZWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuICAgIHZhciB3aWR0aCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi53KSA6IHRoaXMuZGF0YS5jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IG9wdGlvbnMuZnVsbCA/IE1hdGguY2VpbChiYi5oKSA6IHRoaXMuZGF0YS5jb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIHZhciBzY2FsZSA9IDE7XG5cbiAgICBpZiggb3B0aW9ucy5zY2FsZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICB3aWR0aCAqPSBvcHRpb25zLnNjYWxlO1xuICAgICAgaGVpZ2h0ICo9IG9wdGlvbnMuc2NhbGU7XG5cbiAgICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgYnVmZkNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgYnVmZkNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGJ1ZmZDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgYnVmZkNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBidWZmQ2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICB2YXIgYnVmZkN4dCA9IGJ1ZmZDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIFJhc3Rlcml6ZSB0aGUgbGF5ZXJzLCBidXQgb25seSBpZiBjb250YWluZXIgaGFzIG5vbnplcm8gc2l6ZVxuICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuXG4gICAgICBidWZmQ3h0LmNsZWFyUmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgICBpZiggb3B0aW9ucy5iZyApe1xuICAgICAgICBidWZmQ3h0LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmc7XG4gICAgICAgIGJ1ZmZDeHQucmVjdCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xuICAgICAgICBidWZmQ3h0LmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgYnVmZkN4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuXG4gICAgICBpZiggb3B0aW9ucy5mdWxsICl7IC8vIGRyYXcgdGhlIGZ1bGwgYm91bmRzIG9mIHRoZSBncmFwaFxuICAgICAgICB0aGlzLnJlZHJhdyh7XG4gICAgICAgICAgZm9yY2VkQ29udGV4dDogYnVmZkN4dCxcbiAgICAgICAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgICAgICAgIGZvcmNlZFpvb206IHNjYWxlLFxuICAgICAgICAgIGZvcmNlZFBhbjogeyB4OiAtYmIueDEqc2NhbGUsIHk6IC1iYi55MSpzY2FsZSB9LFxuICAgICAgICAgIGZvcmNlZFB4UmF0aW86IDFcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgeyAvLyBkcmF3IHRoZSBjdXJyZW50IHZpZXdcbiAgICAgICAgdmFyIGN5UGFuID0gY3kucGFuKCk7XG4gICAgICAgIHZhciBwYW4gPSB7XG4gICAgICAgICAgeDogY3lQYW4ueCAqIHNjYWxlLFxuICAgICAgICAgIHk6IGN5UGFuLnkgKiBzY2FsZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKSAqIHNjYWxlO1xuXG4gICAgICAgIHRoaXMucmVkcmF3KHtcbiAgICAgICAgICBmb3JjZWRDb250ZXh0OiBidWZmQ3h0LFxuICAgICAgICAgIGRyYXdBbGxMYXllcnM6IHRydWUsXG4gICAgICAgICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICAgICAgICBmb3JjZWRQYW46IHBhbixcbiAgICAgICAgICBmb3JjZWRQeFJhdGlvOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWZmQ2FudmFzO1xuICB9OyBcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUucG5nID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJDYW52YXNJbWFnZSggb3B0aW9ucyApLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZWdpc3RlckJpbmRpbmcgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50LCBoYW5kbGVyLCB1c2VDYXB0dXJlKXtcbiAgICB0aGlzLmJpbmRpbmdzLnB1c2goe1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBldmVudDogZXZlbnQsXG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgdXNlQ2FwdHVyZTogdXNlQ2FwdHVyZVxuICAgIH0pO1xuXG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5ub2RlSXNEcmFnZ2FibGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUuX3ByaXZhdGUuc3R5bGVbJ29wYWNpdHknXS52YWx1ZSAhPT0gMFxuICAgICAgJiYgbm9kZS5fcHJpdmF0ZS5zdHlsZVsndmlzaWJpbGl0eSddLnZhbHVlID09ICd2aXNpYmxlJ1xuICAgICAgJiYgbm9kZS5fcHJpdmF0ZS5zdHlsZVsnZGlzcGxheSddLnZhbHVlID09ICdlbGVtZW50J1xuICAgICAgJiYgIW5vZGUubG9ja2VkKClcbiAgICAgICYmIG5vZGUuZ3JhYmJhYmxlKCkgKSB7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IHRoaXM7XG5cbiAgICB2YXIgZ2V0RHJhZ0xpc3RJZHMgPSBmdW5jdGlvbihvcHRzKXtcbiAgICAgIHZhciBsaXN0SGFzSWQ7XG5cbiAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiByLmRhdGEuY3kuaGFzQ29tcG91bmROb2RlcygpICl7IC8vIG9ubHkgbmVlZGVkIGZvciBjb21wb3VuZCBncmFwaHNcbiAgICAgICAgaWYoICFvcHRzLmFkZFRvTGlzdC5oYXNJZCApeyAvLyBidWlsZCBpZHMgbG9va3VwIGlmIGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxuICAgICAgICAgIG9wdHMuYWRkVG9MaXN0Lmhhc0lkID0ge307XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wdHMuYWRkVG9MaXN0Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZWxlID0gb3B0cy5hZGRUb0xpc3RbaV07XG5cbiAgICAgICAgICAgIG9wdHMuYWRkVG9MaXN0Lmhhc0lkWyBlbGUuaWQoKSBdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0SGFzSWQgPSBvcHRzLmFkZFRvTGlzdC5oYXNJZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxpc3RIYXNJZCB8fCB7fTtcbiAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSB3aGljaCBjaGlsZCBub2RlcyBhbmQgaW5uZXIgZWRnZXNcbiAgICAvLyBvZiBhIGNvbXBvdW5kIG5vZGUgdG8gYmUgZHJhZ2dlZCBhcyB3ZWxsIGFzIHRoZSBncmFiYmVkIGFuZCBzZWxlY3RlZCBub2Rlc1xuICAgIHZhciBhZGREZXNjZW5kYW50c1RvRHJhZyA9IGZ1bmN0aW9uKG5vZGUsIG9wdHMpe1xuICAgICAgaWYoICFub2RlLl9wcml2YXRlLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyggb3B0cyApO1xuXG4gICAgICB2YXIgaW5uZXJOb2RlcyA9IG5vZGUuZGVzY2VuZGFudHMoKTtcblxuICAgICAgLy8gVE9ETyBkbyBub3QgZHJhZyBoaWRkZW4gY2hpbGRyZW4gJiBjaGlsZHJlbiBvZiBoaWRkZW4gY2hpbGRyZW4/XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGlubmVyTm9kZXMuc2l6ZSgpOyBpKysgKXtcbiAgICAgICAgdmFyIGlOb2RlID0gaW5uZXJOb2Rlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gaU5vZGUuX3ByaXZhdGU7XG5cbiAgICAgICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgKXtcbiAgICAgICAgICBfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0cy5hZGRUb0xpc3QgJiYgIWxpc3RIYXNJZFsgaU5vZGUuaWQoKSBdICl7XG4gICAgICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggaU5vZGUgKTtcbiAgICAgICAgICBsaXN0SGFzSWRbIGlOb2RlLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICBfcC5ncmFiYmVkID0gdHJ1ZTsgXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRnZXMgPSBfcC5lZGdlcztcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IG9wdHMuaW5EcmFnTGF5ZXIgJiYgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgZWRnZXNbal0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFkZHMgdGhlIGdpdmVuIG5vZGVzLCBhbmQgaXRzIGVkZ2VzIHRvIHRoZSBkcmFnIGxheWVyXG4gICAgdmFyIGFkZE5vZGVUb0RyYWcgPSBmdW5jdGlvbihub2RlLCBvcHRzKXtcblxuICAgICAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyggb3B0cyApO1xuXG4gICAgICBpZiggb3B0cy5pbkRyYWdMYXllciApe1xuICAgICAgICBfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiAhbGlzdEhhc0lkWyBub2RlLmlkKCkgXSApe1xuICAgICAgICBvcHRzLmFkZFRvTGlzdC5wdXNoKCBub2RlICk7XG4gICAgICAgIGxpc3RIYXNJZFsgbm9kZS5pZCgpIF0gPSB0cnVlO1xuXG4gICAgICAgIF9wLmdyYWJiZWQgPSB0cnVlOyBcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gX3AuZWRnZXM7XG4gICAgICBmb3IoIHZhciBpID0gMDsgb3B0cy5pbkRyYWdMYXllciAmJiBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZWRnZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBhZGREZXNjZW5kYW50c1RvRHJhZyggbm9kZSwgb3B0cyApOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcblxuICAgICAgLy8gYWxzbyBhZGQgbm9kZXMgYW5kIGVkZ2VzIHJlbGF0ZWQgdG8gdGhlIHRvcG1vc3QgYW5jZXN0b3JcbiAgICAgIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKCBub2RlLCB7XG4gICAgICAgIGluRHJhZ0xheWVyOiB0cnVlXG4gICAgICB9ICk7XG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggYW5jZXN0b3Igbm9kZXMgYW5kIGVkZ2VzIHNob3VsZCBnb1xuICAgIC8vIHRvIHRoZSBkcmFnIGxheWVyIChvciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyYWcgbGF5ZXIpLlxuICAgIHZhciB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciA9IGZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgICAgIC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuICAgICAgdmFyIHBhcmVudCA9IG5vZGU7XG5cbiAgICAgIGlmKCAhbm9kZS5fcHJpdmF0ZS5jeS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSggcGFyZW50LnBhcmVudCgpLm5vbmVtcHR5KCkgKXtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCgpWzBdO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBwYXJlbnQgbm9kZTogbm8gbm9kZXMgdG8gYWRkIHRvIHRoZSBkcmFnIGxheWVyXG4gICAgICBpZiggcGFyZW50ID09IG5vZGUgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZXMgPSBwYXJlbnRcbiAgICAgICAgLmRlc2NlbmRhbnRzKClcbiAgICAgICAgLmFkZCggcGFyZW50IClcbiAgICAgICAgLm5vdCggbm9kZSApXG4gICAgICAgIC5ub3QoIG5vZGUuZGVzY2VuZGFudHMoKSApXG4gICAgICA7XG5cbiAgICAgIHZhciBlZGdlcyA9IG5vZGVzLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyggb3B0cyApO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLnNpemUoKTsgaSsrICl7XG4gICAgICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBub2Rlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IG9wdHMuaW5EcmFnTGF5ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0cy5hZGRUb0xpc3QgJiYgIWxpc3RIYXNJZFsgbm9kZXNbaV0uaWQoKSBdICl7XG4gICAgICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggbm9kZXNbaV0gKTtcbiAgICAgICAgICBsaXN0SGFzSWRbIG5vZGVzW2ldLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICBub2Rlc1tpXS5fcHJpdmF0ZS5ncmFiYmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgb3B0cy5pbkRyYWdMYXllciAhPT0gdW5kZWZpbmVkICYmIGogPCBlZGdlcy5sZW5ndGg7IGorKyApIHtcbiAgICAgICAgZWRnZXNbal0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBvcHRzLmluRHJhZ0xheWVyO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiggdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICl7XG4gICAgICByLnJlbW92ZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oIG11dG5zICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbXV0bnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgbXV0biA9IG11dG5zW2ldO1xuICAgICAgICAgIHZhciByTm9kZXMgPSBtdXRuLnJlbW92ZWROb2RlcztcblxuICAgICAgICAgIGlmKCByTm9kZXMgKXsgZm9yKCB2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciByTm9kZSA9IHJOb2Rlc1tqXTtcblxuICAgICAgICAgICAgaWYoIHJOb2RlID09PSByLmRhdGEuY29udGFpbmVyICl7XG4gICAgICAgICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIub2JzZXJ2ZSggci5kYXRhLmNvbnRhaW5lci5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH1cblxuXG5cbiAgICAvLyBhdXRvIHJlc2l6ZVxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Jlc2l6ZScsICQkLnV0aWwuZGVib3VuY2UoIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG5cbiAgICAgIHIubWF0Y2hDYW52YXNTaXplKHIuZGF0YS5jb250YWluZXIpO1xuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSwgMTAwICkgKTtcblxuICAgIHZhciBpbnZhbEN0bnJCQk9uU2Nyb2xsID0gZnVuY3Rpb24oZG9tRWxlKXtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3Njcm9sbCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgfSApO1xuICAgIH07XG5cbiAgICB2YXIgYmJDdG5yID0gci5kYXRhLmN5LmNvbnRhaW5lcigpO1xuXG4gICAgZm9yKCA7OyApe1xuICAgICAgXG4gICAgICBpbnZhbEN0bnJCQk9uU2Nyb2xsKCBiYkN0bnIgKTtcblxuICAgICAgaWYoIGJiQ3Ruci5wYXJlbnROb2RlICl7XG4gICAgICAgIGJiQ3RuciA9IGJiQ3Ruci5wYXJlbnROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG5cbiAgICAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gci5kYXRhLnNlbGVjdFs0XSAhPT0gMDtcbiAgICB9O1xuXG4gICAgLy8gUHJpbWFyeSBrZXlcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkgeyBcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSB0cnVlO1xuICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBlLndoaWNoO1xuICAgICAgXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7IFxuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICB2YXIgc2VsZWN0ID0gci5kYXRhLnNlbGVjdDtcbiAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQocG9zWzBdLCBwb3NbMV0sIHRydWUpO1xuICAgICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG5cbiAgICAgIHIuaG92ZXJEYXRhLm1kb3duUG9zID0gcG9zO1xuXG4gICAgICB2YXIgY2hlY2tGb3JUYXBob2xkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCggci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQgKTtcblxuICAgICAgICByLmhvdmVyRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkICl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbGUgPSByLmhvdmVyRGF0YS5kb3duO1xuXG4gICAgICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgICAgIGVsZS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9LCByLnRhcGhvbGREdXJhdGlvbik7XG4gICAgICB9O1xuXG4gICAgICAvLyBSaWdodCBjbGljayBidXR0b25cbiAgICAgIGlmKCBlLndoaWNoID09IDMgKXtcblxuICAgICAgICByLmhvdmVyRGF0YS5jeHRTdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLCBcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH0gXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICAgIG5lYXIudHJpZ2dlciggY3h0RXZ0ICk7XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5kb3duID0gbmVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBQcmltYXJ5IGJ1dHRvblxuICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09IDEpIHtcbiAgICAgICAgXG4gICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWxlbWVudCBkcmFnZ2luZ1xuICAgICAgICB7XG4gICAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHVuZGVyIHRoZSBjdXJzb3IgYW5kIGl0IGlzIGRyYWdnYWJsZSwgcHJlcGFyZSB0byBncmFiIGl0XG4gICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuXG4gICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUobmVhcikgKXtcblxuICAgICAgICAgICAgICB2YXIgZ3JhYkV2ZW50ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZ3JhYicsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICggbmVhci5pc05vZGUoKSAmJiAhbmVhci5zZWxlY3RlZCgpICl7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggbmVhciwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50cyB9ICk7XG5cbiAgICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoZ3JhYkV2ZW50KTtcblxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBuZWFyLmlzTm9kZSgpICYmIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbICBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmlzTm9kZSgpICYmIHRoaXMuc2VsZWN0ZWQoKTsgfSk7XG5cbiAgICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBpKysgKXtcblxuICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgdGhpcyBzZWxlY3RlZCBub2RlIHRvIGRyYWcgaWYgaXQgaXMgZHJhZ2dhYmxlLCBlZy4gaGFzIG5vbnplcm8gb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKCBzZWxlY3RlZE5vZGVzW2ldICkgKXtcbiAgICAgICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggc2VsZWN0ZWROb2Rlc1tpXSwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50cyB9ICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBncmFiRXZlbnQgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbmVhclxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZWRvd24nLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwc3RhcnQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgXG4gICAgICAgICAgfSBlbHNlIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICAgIGN5XG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBzdGFydCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgICB9XG4gICAgICBcbiAgICAgICAgLy8gU2VsZWN0aW9uIGJveFxuICAgICAgICBpZiAoIG5lYXIgPT0gbnVsbCB8fCBuZWFyLmlzRWRnZSgpICkge1xuICAgICAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICAgICAgdmFyIHRpbWVVbnRpbEFjdGl2ZSA9IE1hdGgubWF4KCAwLCBDYW52YXNSZW5kZXJlci5wYW5PckJveFNlbGVjdERlbGF5IC0gKCtuZXcgRGF0ZSgpIC0gci5ob3ZlckRhdGEuZG93blRpbWUpICk7XG5cbiAgICAgICAgICBjbGVhclRpbWVvdXQoIHIuYmdBY3RpdmVUaW1lb3V0ICk7XG5cbiAgICAgICAgICBpZiggY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpIHx8ICggbmVhciAmJiBuZWFyLmlzRWRnZSgpICkgKXtcbiAgICAgICAgICAgIHIuYmdBY3RpdmVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgICAgICAgIG5lYXIudW5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBjaGVja0ZvclRhcGhvbGQoKTtcblxuICAgICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgXG4gICAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgICB9LCB0aW1lVW50aWxBY3RpdmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgeTogcG9zWzFdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjaGVja0ZvclRhcGhvbGQoKTtcblxuICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICBcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICBcbiAgICAgIH0gXG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgc2VsZWN0aW9uIGJveCBjb29yZGluYXRlc1xuICAgICAgc2VsZWN0WzBdID0gc2VsZWN0WzJdID0gcG9zWzBdO1xuICAgICAgc2VsZWN0WzFdID0gc2VsZWN0WzNdID0gcG9zWzFdO1xuICAgICAgXG4gICAgfSwgZmFsc2UpO1xuICAgIFxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ21vdXNlbW92ZScsICQkLnV0aWwudGhyb3R0bGUoIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuXG4gICAgICAvLyBzYXZlIGN5Y2xlcyBpZiBtb3VzZSBldmVudHMgYXJlbid0IHRvIGJlIGNhcHR1cmVkXG4gICAgICBpZiAoICFjYXB0dXJlICl7XG4gICAgICAgIHZhciBjb250YWluZXJQYWdlQ29vcmRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG5cbiAgICAgICAgaWYgKGUuY2xpZW50WCA+IGNvbnRhaW5lclBhZ2VDb29yZHNbMF0gJiYgZS5jbGllbnRYIDwgY29udGFpbmVyUGFnZUNvb3Jkc1swXSArIHIuY2FudmFzV2lkdGhcbiAgICAgICAgICAmJiBlLmNsaWVudFkgPiBjb250YWluZXJQYWdlQ29vcmRzWzFdICYmIGUuY2xpZW50WSA8IGNvbnRhaW5lclBhZ2VDb29yZHNbMV0gKyByLmNhbnZhc0hlaWdodFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBpbnNpZGUgY29udGFpbmVyIGJvdW5kcyBzbyBPS1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjeUNvbnRhaW5lciA9IHIuZGF0YS5jb250YWluZXI7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHRQYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUoIHRQYXJlbnQgKXtcbiAgICAgICAgICBpZiggdFBhcmVudCA9PT0gY3lDb250YWluZXIgKXtcbiAgICAgICAgICAgIGNvbnRhaW5lcklzVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRQYXJlbnQgPSB0UGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWNvbnRhaW5lcklzVGFyZ2V0ICl7IHJldHVybjsgfSAvLyBpZiB0YXJnZXQgaXMgb3V0aXNkZSBjeSBjb250YWluZXIsIHRoZW4gdGhpcyBldmVudCBpcyBub3QgZm9yIHVzXG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICB2YXIgc2VsZWN0ID0gci5kYXRhLnNlbGVjdDtcbiAgICAgIFxuICAgICAgdmFyIG5lYXIgPSBudWxsO1xuICAgICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgKXtcbiAgICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBsYXN0ID0gci5ob3ZlckRhdGEubGFzdDtcbiAgICAgIHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICAgIFxuICAgICAgdmFyIGRpc3AgPSBbcG9zWzBdIC0gc2VsZWN0WzJdLCBwb3NbMV0gLSBzZWxlY3RbM11dO1xuXG4gICAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcblxuICAgICAgdmFyIGR4ID0gc2VsZWN0WzJdIC0gc2VsZWN0WzBdO1xuICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICB2YXIgZHkgPSBzZWxlY3RbM10gLSBzZWxlY3RbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuXG4gICAgICByLmhvdmVyRGF0YS50YXBob2xkQ2FuY2VsbGVkID0gdHJ1ZTtcblxuICAgICAgdmFyIHVwZGF0ZURyYWdEZWx0YSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgICAgaWYoIGRyYWdEZWx0YS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICBkcmFnRGVsdGEucHVzaCgwKTtcbiAgICAgICAgICBkcmFnRGVsdGEucHVzaCgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuXG4gICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICAgIC8vIE1vdXNlbW92ZSBldmVudFxuICAgICAge1xuICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgbmVhclxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlbW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZycsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgO1xuICAgICAgICAgIFxuICAgICAgICB9IGVsc2UgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgIGN5XG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyB0cmlnZ2VyIGNvbnRleHQgZHJhZyBpZiBybW91c2UgZG93blxuICAgICAgaWYoIHIuaG92ZXJEYXRhLndoaWNoID09PSAzICl7XG4gICAgICAgIHZhciBjeHRFdnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgIHR5cGU6ICdjeHRkcmFnJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgICBkb3duLnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCA9IHRydWU7XG5cbiAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHRPdmVyIHx8IG5lYXIgIT09IHIuaG92ZXJEYXRhLmN4dE92ZXIgKXtcblxuICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS5jeHRPdmVyICl7XG4gICAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3V0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY3h0ZHJhZ291dCAnICsgci5ob3ZlckRhdGEuY3h0T3Zlci5pZCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmhvdmVyRGF0YS5jeHRPdmVyID0gbmVhcjtcblxuICAgICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2N4dGRyYWdvdmVyICcgKyBuZWFyLmlkKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIHdlIGFyZSBkcmFnIHBhbm5pbmcgdGhlIGVudGlyZSBncmFwaFxuICAgICAgfSBlbHNlIGlmIChyLmhvdmVyRGF0YS5kcmFnZ2luZykge1xuICAgICAgICBwcmV2ZW50RGVmYXVsdCA9IHRydWU7XG5cbiAgICAgICAgaWYoIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgKXtcbiAgICAgICAgICB2YXIgZGVsdGFQO1xuXG4gICAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuICl7XG4gICAgICAgICAgICB2YXIgbWRQb3MgPSByLmhvdmVyRGF0YS5tZG93blBvcztcblxuICAgICAgICAgICAgZGVsdGFQID0ge1xuICAgICAgICAgICAgICB4OiAoIHBvc1swXSAtIG1kUG9zWzBdICkgKiB6b29tLFxuICAgICAgICAgICAgICB5OiAoIHBvc1sxXSAtIG1kUG9zWzFdICkgKiB6b29tXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IGZhbHNlO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgICAgeDogZGlzcFswXSAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGRpc3BbMV0gKiB6b29tXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kucGFuQnkoIGRlbHRhUCApO1xuICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBOZWVkcyByZXByb2plY3QgZHVlIHRvIHBhbiBjaGFuZ2luZyB2aWV3cG9ydFxuICAgICAgICBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgICAvLyBDaGVja3MgcHJpbWFyeSBidXR0b24gZG93biAmIG91dCBvZiB0aW1lICYgbW91c2Ugbm90IG1vdmVkIG11Y2hcbiAgICAgIH0gZWxzZSBpZihcbiAgICAgICAgICBzZWxlY3RbNF0gPT0gMSAmJiAoZG93biA9PSBudWxsIHx8IGRvd24uaXNFZGdlKCkpXG4gICAgICAgICAgJiYgKCAhY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpIHx8ICgrbmV3IERhdGUoKSAtIHIuaG92ZXJEYXRhLmRvd25UaW1lID49IENhbnZhc1JlbmRlcmVyLnBhbk9yQm94U2VsZWN0RGVsYXkpIClcbiAgICAgICAgICAvLyYmIChNYXRoLmFicyhzZWxlY3RbM10gLSBzZWxlY3RbMV0pICsgTWF0aC5hYnMoc2VsZWN0WzJdIC0gc2VsZWN0WzBdKSA8IDQpXG4gICAgICAgICAgJiYgIXIuaG92ZXJEYXRhLnNlbGVjdGluZ1xuICAgICAgICAgICYmIHJkaXN0MiA+PSByLnRhcFRocmVzaG9sZDJcbiAgICAgICAgICAmJiBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpXG4gICAgICApe1xuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHIuaG92ZXJEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgICByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiA9IHRydWU7XG4gICAgICAgIHNlbGVjdFs0XSA9IDA7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlYWN0aXZhdGUgYmcgb24gYm94IHNlbGVjdGlvblxuICAgICAgICBpZiAoY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmIE1hdGgucG93KHNlbGVjdFsyXSAtIHNlbGVjdFswXSwgMikgKyBNYXRoLnBvdyhzZWxlY3RbM10gLSBzZWxlY3RbMV0sIDIpID4gNyAmJiBzZWxlY3RbNF0pe1xuICAgICAgICAgIGNsZWFyVGltZW91dCggci5iZ0FjdGl2ZVRpbWVvdXQgKTtcbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIGRvd24gJiYgZG93bi5pc0VkZ2UoKSAmJiBkb3duLmFjdGl2ZSgpICl7IGRvd24udW5hY3RpdmF0ZSgpOyB9XG5cbiAgICAgICAgaWYgKG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBsYXN0LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTsgXG5cbiAgICAgICAgICAgIGxhc3QudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWdvdXQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7IFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAobmVhcikge1xuICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnbW91c2VvdmVyJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApOyBcblxuICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZ292ZXInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7IFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByLmhvdmVyRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBkb3duICYmIGRvd24uaXNOb2RlKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZG93bikgKXtcblxuICAgICAgICAgIGlmKCByZGlzdDIgPj0gci50YXBUaHJlc2hvbGQyICl7IC8vIHRoZW4gZHJhZ1xuXG4gICAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcblxuICAgICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApIHtcbiAgICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTsgLy8gaW5kaWNhdGUgdGhhdCB3ZSBhY3R1YWxseSBkaWQgZHJhZyB0aGUgbm9kZVxuXG4gICAgICAgICAgICB2YXIgdG9UcmlnZ2VyID0gW107XG5cbiAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZW1lbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIHZhciBkRWxlID0gZHJhZ2dlZEVsZW1lbnRzW2ldO1xuXG4gICAgICAgICAgICAgIC8vIG5vdywgYWRkIHRoZSBlbGVtZW50cyB0byB0aGUgZHJhZyBsYXllciBpZiBub3QgZG9uZSBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmKCAhci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzICl7IFxuICAgICAgICAgICAgICAgIGFkZE5vZGVUb0RyYWcoIGRFbGUsIHsgaW5EcmFnTGF5ZXI6IHRydWUgfSApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTG9ja2VkIG5vZGVzIG5vdCBkcmFnZ2FibGUsIGFzIHdlbGwgYXMgbm9uLXZpc2libGUgbm9kZXNcbiAgICAgICAgICAgICAgaWYoIGRFbGUuaXNOb2RlKCkgJiYgci5ub2RlSXNEcmFnZ2FibGUoZEVsZSkgJiYgZEVsZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgICAgICB2YXIgZFBvcyA9IGRFbGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgICB0b1RyaWdnZXIucHVzaCggZEVsZSApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoZGlzcFswXSkgJiYgJCQuaXMubnVtYmVyKGRpc3BbMV0pICl7XG4gICAgICAgICAgICAgICAgICBkUG9zLnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkaXNwWzFdO1xuXG4gICAgICAgICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoICQkLmlzLm51bWJlcihkcmFnRGVsdGFbMF0pICYmICQkLmlzLm51bWJlcihkcmFnRGVsdGFbMV0pICl7XG4gICAgICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHRjb2wgPSAobmV3ICQkLkNvbGxlY3Rpb24oY3ksIHRvVHJpZ2dlcikpO1xuXG4gICAgICAgICAgICB0Y29sLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgICB0Y29sLnRyaWdnZXIoJ3Bvc2l0aW9uIGRyYWcnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gdHJ1ZTtcbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2Ugc2F2ZSBkcmFnIGRlbHRhIGZvciB3aGVuIHdlIGFjdHVhbGx5IHN0YXJ0IGRyYWdnaW5nIHNvIHRoZSByZWxhdGl2ZSBncmFiIHBvcyBpcyBjb25zdGFudFxuICAgICAgICAgICAgdXBkYXRlRHJhZ0RlbHRhKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgZHJhZ2dpbmcgZnJvbSB0cmlnZ2VyaW5nIHRleHQgc2VsZWN0aW9uIG9uIHRoZSBwYWdlXG4gICAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2VsZWN0WzJdID0gcG9zWzBdOyBzZWxlY3RbM10gPSBwb3NbMV07XG4gICAgICBcbiAgICAgIGlmKCBwcmV2ZW50RGVmYXVsdCApeyBcbiAgICAgICAgaWYoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgaWYoZS5wcmV2ZW50RGVmYXVsdCkgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIDEwMDAvMzAsIHsgdHJhaWxpbmc6IHRydWUgfSksIGZhbHNlKTtcbiAgICBcbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJy0tXFxubW91c2V1cCcsIGUpXG5cbiAgICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcbiAgICAgIGlmICghY2FwdHVyZSkgeyByZXR1cm47IH1cbiAgICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICBcbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7IHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChwb3NbMF0sIHBvc1sxXSwgdHJ1ZSk7IFxuICAgICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7IHZhciBkb3duID0gci5ob3ZlckRhdGEuZG93bjtcbiAgICAgIHZhciBzaGlmdERvd24gPSBlLnNoaWZ0S2V5O1xuICAgICAgXG4gICAgICBpZiggci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICl7XG4gICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgIHIucmVkcmF3KCk7XG4gICAgICB9XG5cbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDsgLy8gbm90IGFjdGl2ZSBiZyBub3dcbiAgICAgIGNsZWFyVGltZW91dCggci5iZ0FjdGl2ZVRpbWVvdXQgKTtcblxuICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcblxuICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgZG93bi51bmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMyApe1xuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgICBkb3duLnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5jeHREcmFnZ2VkICl7XG4gICAgICAgICAgdmFyIGN4dFRhcCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICB0eXBlOiAnY3h0dGFwJyxcbiAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYoIGRvd24gKXtcbiAgICAgICAgICAgIGRvd24udHJpZ2dlciggY3h0VGFwICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dFRhcCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgci5ob3ZlckRhdGEud2hpY2ggPSBudWxsO1xuXG4gICAgICAvLyBpZiBub3QgcmlnaHQgbW91c2VcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gRGVzZWxlY3QgYWxsIGVsZW1lbnRzIGlmIG5vdGhpbmcgaXMgY3VycmVudGx5IHVuZGVyIHRoZSBtb3VzZSBjdXJzb3IgYW5kIHdlIGFyZW4ndCBkcmFnZ2luZyBzb21ldGhpbmdcbiAgICAgICAgaWYgKCAoZG93biA9PSBudWxsKSAvLyBub3QgbW91c2Vkb3duIG9uIG5vZGVcbiAgICAgICAgICAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBtb3ZlIHRoZSBub2RlIGFyb3VuZFxuICAgICAgICAgICYmICEoTWF0aC5wb3coc2VsZWN0WzJdIC0gc2VsZWN0WzBdLCAyKSArIE1hdGgucG93KHNlbGVjdFszXSAtIHNlbGVjdFsxXSwgMikgPiA3ICYmIHNlbGVjdFs0XSkgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICAgICAmJiAhci5ob3ZlckRhdGEuZHJhZ2dpbmcgLy8gbm90IHBhbm5pbmdcbiAgICAgICAgKSB7XG5cbiAgICAgICAgICBjeS4kKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCgpO1xuICAgICAgICAgIH0pLnVuc2VsZWN0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRyYWdnZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gZHJhZ2dlZEVsZW1lbnRzID0gW107XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gTW91c2V1cCBldmVudFxuICAgICAgICB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3RyaWdnZXIgbW91c2V1cCBldCBhbCcpO1xuXG4gICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgbmVhclxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2V1cCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjeVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2V1cCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xpY2sgZXZlbnRcbiAgICAgICAge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0cmlnZ2VyIGNsaWNrIGV0IGFsJyk7XG5cbiAgICAgICAgICBpZiAoTWF0aC5wb3coc2VsZWN0WzJdIC0gc2VsZWN0WzBdLCAyKSArIE1hdGgucG93KHNlbGVjdFszXSAtIHNlbGVjdFsxXSwgMikgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgbmVhclxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgICAudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd0YXAnLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZjbGljaycsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGN5XG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnY2xpY2snLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3RhcCcsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndmNsaWNrJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpbmdsZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKG5lYXIgPT0gZG93biAmJiAhci5kcmFnRGF0YS5kaWREcmFnKSB7XG4gICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCAmJiBuZWFyLl9wcml2YXRlLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3NpbmdsZSBzZWxlY3Rpb24nKVxuXG4gICAgICAgICAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmcgKXtcbiAgICAgICAgICAgICAgLy8gaWYgcGFubmluZywgZG9uJ3QgY2hhbmdlIHNlbGVjdGlvbiBzdGF0ZVxuICAgICAgICAgICAgfSBlbHNlIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdhZGRpdGl2ZScgfHwgc2hpZnREb3duICl7XG4gICAgICAgICAgICAgIGlmKCBuZWFyLnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgICAgICBuZWFyLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmVhci5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYoICFzaGlmdERvd24gKXtcbiAgICAgICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS5ub3QoIG5lYXIgKS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgICAgIG5lYXIuc2VsZWN0KCk7XG4gICAgICAgICAgICAgIH0gICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTsgXG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgfSBcbiAgICAgICAgXG4gICAgICAgIGlmICggY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICYmICBNYXRoLnBvdyhzZWxlY3RbMl0gLSBzZWxlY3RbMF0sIDIpICsgTWF0aC5wb3coc2VsZWN0WzNdIC0gc2VsZWN0WzFdLCAyKSA+IDcgJiYgc2VsZWN0WzRdICkgeyAgICAgICAgIFxuICAgICAgICAgIHZhciBuZXdseVNlbGVjdGVkID0gW107XG4gICAgICAgICAgdmFyIGJveCA9IHIuZ2V0QWxsSW5Cb3goIHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSApO1xuXG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICAgIGlmKCBib3gubGVuZ3RoID4gMCApIHsgXG4gICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlOyBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGJveC5sZW5ndGg7IGkrKyApeyBcbiAgICAgICAgICAgIGlmKCBib3hbaV0uX3ByaXZhdGUuc2VsZWN0YWJsZSApe1xuICAgICAgICAgICAgICBuZXdseVNlbGVjdGVkLnB1c2goIGJveFtpXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXdseVNlbENvbCA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgbmV3bHlTZWxlY3RlZCApO1xuXG4gICAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ2FkZGl0aXZlJyApe1xuICAgICAgICAgICAgbmV3bHlTZWxDb2wuc2VsZWN0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCAhc2hpZnREb3duICl7XG4gICAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLm5vdCggbmV3bHlTZWxDb2wgKS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdseVNlbENvbC5zZWxlY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhbHdheXMgbmVlZCByZWRyYXcgaW4gY2FzZSBlbGVzIHVuc2VsZWN0YWJsZVxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENhbmNlbCBkcmFnIHBhblxuICAgICAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmcgKXtcbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFzZWxlY3RbNF0pIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZnJlZSBhdCBlbmQnLCBkcmFnZ2VkRWxlbWVudHMpXG5cbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlOyBcbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlOyBcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZHJhZ2dlZEVsZW1lbnRzW2ldLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnKSB7IFxuICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHZhciBzRWRnZXMgPSBkcmFnZ2VkRWxlbWVudHNbaV0uX3ByaXZhdGUuZWRnZXM7XG4gICAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgc0VkZ2VzLmxlbmd0aDsgaisrICl7IHNFZGdlc1tqXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlOyB9XG5cbiAgICAgICAgICAgICAgLy8gZm9yIGNvbXBvdW5kIG5vZGVzLCBhbHNvIHJlbW92ZSByZWxhdGVkIG5vZGVzIGFuZCBlZGdlcyBmcm9tIHRoZSBkcmFnIGxheWVyXG4gICAgICAgICAgICAgIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKGRyYWdnZWRFbGVtZW50c1tpXSwgeyBpbkRyYWdMYXllcjogZmFsc2UgfSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmKCBkcmFnZ2VkRWxlbWVudHNbaV0uX3ByaXZhdGUuZ3JvdXAgPT09ICdlZGdlcycgKXtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnRzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggZG93biApeyBkb3duLnRyaWdnZXIoJ2ZyZWUnKTsgfVxuXG4gIC8vICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gW107XG4gICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgfSAvLyBlbHNlIG5vdCByaWdodCBtb3VzZVxuXG4gICAgICBzZWxlY3RbNF0gPSAwOyByLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcbiAgICAgIFxuICAgICAgLy9yLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlOyBcbiAgICAgIFxuLy8gICAgICBjb25zb2xlLmxvZygnbXUnLCBwb3NbMF0sIHBvc1sxXSk7XG4vLyAgICAgIGNvbnNvbGUubG9nKCdzcycsIHNlbGVjdCk7XG4gICAgICBcbiAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICBcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB2YXIgd2hlZWxIYW5kbGVyID0gZnVuY3Rpb24oZSkgeyBcbiAgICAgIGlmKCByLnNjcm9sbGluZ1BhZ2UgKXsgcmV0dXJuOyB9IC8vIHdoaWxlIHNjcm9sbGluZywgaWdub3JlIHdoZWVsLXRvLXpvb21cblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5O1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICB2YXIgcnBvcyA9IFtwb3NbMF0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS54LFxuICAgICAgICAgICAgICAgICAgICBwb3NbMV0gKiBjeS56b29tKCkgKyBjeS5wYW4oKS55XTtcbiAgICAgIFxuICAgICAgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZyB8fCByLmhvdmVyRGF0YS5jeHRTdGFydGVkIHx8IGluQm94U2VsZWN0aW9uKCkgKXsgLy8gaWYgcGFuIGRyYWdnaW5nIG9yIGN4dCBkcmFnZ2luZywgd2hlZWwgbW92ZW1lbnRzIG1ha2Ugbm8gem9vbVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYoIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKCkgJiYgY3kuem9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSApe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFxuICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KCByLmRhdGEud2hlZWxUaW1lb3V0ICk7XG4gICAgICAgIHIuZGF0YS53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTsgXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSwgMTUwKTtcblxuICAgICAgICB2YXIgZGlmZiA9IGUuZGVsdGFZIC8gLTI1MCB8fCBlLndoZWVsRGVsdGFZIC8gMTAwMCB8fCBlLndoZWVsRGVsdGEgLyAxMDAwO1xuICAgICAgICBkaWZmID0gZGlmZiAqIHIud2hlZWxTZW5zaXRpdml0eTtcblxuICAgICAgICB2YXIgbmVlZHNXaGVlbEZpeCA9IGUuZGVsdGFNb2RlID09PSAxO1xuICAgICAgICBpZiggbmVlZHNXaGVlbEZpeCApeyAvLyBmaXhlcyBzbG93IHdoZWVsIGV2ZW50cyBvbiBmZi9saW51eCBhbmQgZmYvd2luZG93c1xuICAgICAgICAgIGRpZmYgKj0gMzM7XG4gICAgICAgIH1cblxuICAgICAgICBjeS56b29tKHtcbiAgICAgICAgICBsZXZlbDogY3kuem9vbSgpICogTWF0aC5wb3coMTAsIGRpZmYpLFxuICAgICAgICAgIHJlbmRlcmVkUG9zaXRpb246IHsgeDogcnBvc1swXSwgeTogcnBvc1sxXSB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgfTtcbiAgICBcbiAgICAvLyBGdW5jdGlvbnMgdG8gaGVscCB3aXRoIHdoZXRoZXIgbW91c2Ugd2hlZWwgc2hvdWxkIHRyaWdnZXIgem9vbWluZ1xuICAgIC8vIC0tXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ3doZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcblxuICAgIC8vIGRpc2FibGUgbm9uc3RhbmRhcmQgd2hlZWwgZXZlbnRzXG4gICAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ21vdXNld2hlZWwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAgIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdET01Nb3VzZVNjcm9sbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG4gICAgLy8gci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpOyAvLyBvbGRlciBmaXJlZm94XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdzY3JvbGwnLCBmdW5jdGlvbihlKXtcbiAgICAgIHIuc2Nyb2xsaW5nUGFnZSA9IHRydWU7XG5cbiAgICAgIGNsZWFyVGltZW91dCggci5zY3JvbGxpbmdQYWdlVGltZW91dCApO1xuICAgICAgci5zY3JvbGxpbmdQYWdlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgci5zY3JvbGxpbmdQYWdlID0gZmFsc2U7XG4gICAgICB9LCAyNTApO1xuICAgIH0sIHRydWUpO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggaGFuZGxpbmcgbW91c2VvdXQvbW91c2VvdmVyIG9uIHRoZSBDeXRvc2NhcGUgY29udGFpbmVyXG4gICAgICAgICAgLy8gSGFuZGxlIG1vdXNlb3V0IG9uIEN5dG9zY2FwZSBjb250YWluZXJcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnbW91c2VvdXQnLCBmdW5jdGlvbihlKSB7IFxuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG5cbiAgICAgIHIuZGF0YS5jeS50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgIHR5cGU6ICdtb3VzZW91dCcsXG4gICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgfSkpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnbW91c2VvdmVyJywgZnVuY3Rpb24oZSkgeyBcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgICByLmRhdGEuY3kudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICB0eXBlOiAnbW91c2VvdmVyJyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9KSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIFxuICAgIHZhciBmMXgxLCBmMXkxLCBmMngxLCBmMnkxOyAvLyBzdGFydGluZyBwb2ludHMgZm9yIHBpbmNoLXRvLXpvb21cbiAgICB2YXIgZGlzdGFuY2UxLCBkaXN0YW5jZTFTcTsgLy8gaW5pdGlhbCBkaXN0YW5jZSBiZXR3ZWVuIGZpbmdlciAxIGFuZCBmaW5nZXIgMiBmb3IgcGluY2gtdG8tem9vbVxuICAgIHZhciBjZW50ZXIxLCBtb2RlbENlbnRlcjE7IC8vIGNlbnRlciBwb2ludCBvbiBzdGFydCBwaW5jaCB0byB6b29tXG4gICAgdmFyIG9mZnNldExlZnQsIG9mZnNldFRvcDtcbiAgICB2YXIgY29udGFpbmVyV2lkdGgsIGNvbnRhaW5lckhlaWdodDtcbiAgICB2YXIgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlO1xuXG4gICAgdmFyIGRpc3RhbmNlID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpe1xuICAgICAgcmV0dXJuIE1hdGguc3FydCggKHgyLXgxKSooeDIteDEpICsgKHkyLXkxKSooeTIteTEpICk7XG4gICAgfTtcblxuICAgIHZhciBkaXN0YW5jZVNxID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpe1xuICAgICAgcmV0dXJuICh4Mi14MSkqKHgyLXgxKSArICh5Mi15MSkqKHkyLXkxKTtcbiAgICB9O1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIGNsZWFyVGltZW91dCggdGhpcy50aHJlZUZpbmdlclNlbGVjdFRpbWVvdXQgKTtcblxuICAgICAgaWYoIGUudGFyZ2V0ICE9PSByLmRhdGEubGluayApe1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgXG4gICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gdHJ1ZTtcbiAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5OyBcbiAgICAgIHZhciBub2RlcyA9IHIuZ2V0Q2FjaGVkTm9kZXMoKTtcbiAgICAgIHZhciBlZGdlcyA9IHIuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgICBcbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cbiAgICBcblxuICAgICAgLy8gcmVjb3JkIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICAgICAgaWYoIGUudG91Y2hlc1sxXSApe1xuXG4gICAgICAgIC8vIGFueXRoaW5nIGluIHRoZSBzZXQgb2YgZHJhZ2dlZCBlbGVzIHNob3VsZCBiZSByZWxlYXNlZFxuICAgICAgICB2YXIgcmVsZWFzZSA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICBlbGVzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGVsZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKCBlbGVzW2ldLmFjdGl2ZSgpICl7IGVsZXNbaV0udW5hY3RpdmF0ZSgpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZWxlYXNlKG5vZGVzKTtcbiAgICAgICAgcmVsZWFzZShlZGdlcyk7XG5cbiAgICAgICAgdmFyIG9mZnNldHMgPSByLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICAgICAgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgICAgIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgICAgIGNvbnRhaW5lcldpZHRoID0gb2Zmc2V0c1syXTtcbiAgICAgICAgY29udGFpbmVySGVpZ2h0ID0gb2Zmc2V0c1szXTtcblxuICAgICAgICBmMXgxID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgICBmMXkxID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIFxuICAgICAgICBmMngxID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgICBmMnkxID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG5cbiAgICAgICAgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlID0gXG4gICAgICAgICAgICAgMCA8PSBmMXgxICYmIGYxeDEgPD0gY29udGFpbmVyV2lkdGhcbiAgICAgICAgICAmJiAwIDw9IGYyeDEgJiYgZjJ4MSA8PSBjb250YWluZXJXaWR0aFxuICAgICAgICAgICYmIDAgPD0gZjF5MSAmJiBmMXkxIDw9IGNvbnRhaW5lckhlaWdodFxuICAgICAgICAgICYmIDAgPD0gZjJ5MSAmJiBmMnkxIDw9IGNvbnRhaW5lckhlaWdodFxuICAgICAgICA7XG5cbiAgICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZSggZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSApO1xuICAgICAgICBkaXN0YW5jZTFTcSA9IGRpc3RhbmNlU3EoIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTEgKTtcbiAgICAgICAgY2VudGVyMSA9IFsgKGYxeDEgKyBmMngxKS8yLCAoZjF5MSArIGYyeTEpLzIgXTtcbiAgICAgICAgbW9kZWxDZW50ZXIxID0gWyBcbiAgICAgICAgICAoY2VudGVyMVswXSAtIHBhbi54KSAvIHpvb20sXG4gICAgICAgICAgKGNlbnRlcjFbMV0gLSBwYW4ueSkgLyB6b29tXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gY29uc2lkZXIgY29udGV4dCB0YXBcbiAgICAgICAgdmFyIGN4dERpc3RUaHJlc2hvbGQgPSAyMDA7XG4gICAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkU3EgPSBjeHREaXN0VGhyZXNob2xkICogY3h0RGlzdFRocmVzaG9sZDtcbiAgICAgICAgaWYoIGRpc3RhbmNlMVNxIDwgY3h0RGlzdFRocmVzaG9sZFNxICYmICFlLnRvdWNoZXNbMl0gKXtcblxuICAgICAgICAgIHZhciBuZWFyMSA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlKTtcbiAgICAgICAgICB2YXIgbmVhcjIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMl0sIG5vd1szXSwgdHJ1ZSk7XG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKGRpc3RhbmNlMSlcblxuICAgICAgICAgIGlmKCBuZWFyMSAmJiBuZWFyMS5pc05vZGUoKSApe1xuICAgICAgICAgICAgbmVhcjEuYWN0aXZhdGUoKS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXIxO1xuICAgICAgICAgIFxuICAgICAgICAgIH0gZWxzZSBpZiggbmVhcjIgJiYgbmVhcjIuaXNOb2RlKCkgKXtcbiAgICAgICAgICAgIG5lYXIyLmFjdGl2YXRlKCkudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMjtcbiAgICAgICAgICBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgIH0gXG5cbiAgICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0ID0gdHJ1ZTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygnY3h0dGFwc3RhcnQnKVxuXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhjZW50ZXIxKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RvdWNoc3RhcnQgcHR6Jyk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG9mZnNldExlZnQsIG9mZnNldFRvcCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGYxeDEsIGYxeTEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhmMngxLCBmMnkxKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZGlzdGFuY2UxKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coY2VudGVyMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdhbm90aGVyIHRhcHN0YXJ0JylcbiAgICAgIFxuICAgICAgXG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgIG5lYXIuYWN0aXZhdGUoKTtcblxuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbmVhcjtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggbmVhci5pc05vZGUoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShuZWFyKSApe1xuXG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmKCBuZWFyLnNlbGVjdGVkKCkgKXtcbiAgICAgICAgICAgICAgLy8gcmVzZXQgZHJhZyBlbGVtZW50cywgc2luY2UgbmVhciB3aWxsIGJlIGFkZGVkIGFnYWluXG5cbiAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNOb2RlKCkgJiYgdGhpcy5zZWxlY3RlZCgpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBmb3IoIHZhciBrID0gMDsgayA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBrKysgKXtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1trXTtcblxuICAgICAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZShzZWxlY3RlZE5vZGUpICl7XG4gICAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBzZWxlY3RlZE5vZGUsIHsgYWRkVG9MaXN0OiBkcmFnZ2VkRWxlcyB9ICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBuZWFyLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZXMgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdncmFiJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZG93bicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgO1xuICAgICAgICB9IGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICBjeVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG5cbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gVGFwLCB0YXBob2xkXG4gICAgICAgIC8vIC0tLS0tXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpPTA7IGk8bm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWFybGllcltpXSA9IG5vd1tpXTtcbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uW2ldID0gbm93W2ldO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICAgIFxuICAgICAgICBjbGVhclRpbWVvdXQoIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ICk7XG4gICAgICAgIHIudG91Y2hEYXRhLnRhcGhvbGRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgJiYgIXIucGluY2hpbmcgLy8gaWYgcGluY2hpbmcsIHRoZW4gdGFwaG9sZCB1bnNlbGVjdCBzaG91bGRuJ3QgdGFrZSBlZmZlY3RcblxuICAgICAgICAgICAgICAvLyBUaGlzIHRpbWUgZG91YmxlIGNvbnN0cmFpbnQgcHJldmVudHMgbXVsdGlwbGUgcXVpY2sgdGFwc1xuICAgICAgICAgICAgICAvLyBmb2xsb3dlZCBieSBhIHRhcGhvbGQgdHJpZ2dlcmluZyBtdWx0aXBsZSB0YXBob2xkIGV2ZW50c1xuICAgICAgICAgICAgICAvLyYmIERhdGUubm93KCkgLSByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaFN0YXJ0VGltZSA+IDI1MFxuICAgICAgICAgICl7XG4gICAgICAgICAgICBpZiAoci50b3VjaERhdGEuc3RhcnQpIHtcbiAgICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByLmRhdGEuY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cblxuLy8gICAgICAgICAgICBjb25zb2xlLmxvZygndGFwaG9sZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvL3IucmVkcmF3KCk7XG4gICAgICBcbiAgICB9LCBmYWxzZSk7XG4gICAgXG4vLyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uKG0peyAkKCcjY29uc29sZScpLmFwcGVuZCgnPGRpdj4nK20rJzwvZGl2PicpOyB9O1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2htb3ZlJywgJCQudXRpbC50aHJvdHRsZShmdW5jdGlvbihlKSB7XG4gICAgXG4gICAgICB2YXIgc2VsZWN0ID0gci5kYXRhLnNlbGVjdDtcbiAgICAgIHZhciBjYXB0dXJlID0gci50b3VjaERhdGEuY2FwdHVyZTsgLy9pZiAoIWNhcHR1cmUpIHsgcmV0dXJuOyB9OyBcbiAgICAgIGlmKCBjYXB0dXJlICl7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgIFxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5OyBcbiAgICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7IHZhciBlYXJsaWVyID0gci50b3VjaERhdGEuZWFybGllcjtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgXG4gICAgICBpZiAoZS50b3VjaGVzWzBdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1syXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1syXS5jbGllbnRYLCBlLnRvdWNoZXNbMl0uY2xpZW50WSk7IG5vd1s0XSA9IHBvc1swXTsgbm93WzVdID0gcG9zWzFdOyB9XG4gICAgICB2YXIgZGlzcCA9IFtdOyBmb3IgKHZhciBqPTA7ajxub3cubGVuZ3RoO2orKykgeyBkaXNwW2pdID0gbm93W2pdIC0gZWFybGllcltqXTsgfVxuICAgICAgXG4gICAgICB2YXIgc3RhcnRQb3MgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uO1xuXG4gICAgICB2YXIgZHggPSBub3dbMF0gLSBzdGFydFBvc1swXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gbm93WzFdIC0gc3RhcnRQb3NbMV07XG4gICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgIHZhciBkaXN0MiA9IGR4MiArIGR5MjtcbiAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuXG4gICAgICBpZiggY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQgKXtcbiAgICAgICAgdmFyIGYxeDIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYxeTIgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgdmFyIGYyeDIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WCAtIG9mZnNldExlZnQsIGYyeTIgPSBlLnRvdWNoZXNbMV0uY2xpZW50WSAtIG9mZnNldFRvcDtcbiAgICAgICAgLy8gdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAgIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgICAgdmFyIGZhY3RvclNxID0gZGlzdGFuY2UyU3EgLyBkaXN0YW5jZTFTcTtcblxuICAgICAgICB2YXIgZGlzdFRocmVzaG9sZCA9IDE1MDtcbiAgICAgICAgdmFyIGRpc3RUaHJlc2hvbGRTcSA9IGRpc3RUaHJlc2hvbGQgKiBkaXN0VGhyZXNob2xkO1xuICAgICAgICB2YXIgZmFjdG9yVGhyZXNob2xkID0gMS41O1xuICAgICAgICB2YXIgZmFjdG9yVGhyZXNob2xkU3EgPSBmYWN0b3JUaHJlc2hvbGQgKiBmYWN0b3JUaHJlc2hvbGQ7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZyhmYWN0b3IsIGRpc3RhbmNlMilcblxuICAgICAgICAvLyBjYW5jZWwgY3R4IGdlc3R1cmVzIGlmIHRoZSBkaXN0YW5jZSBiL3QgdGhlIGZpbmdlcnMgaW5jcmVhc2VzXG4gICAgICAgIGlmKCBmYWN0b3JTcSA+PSBmYWN0b3JUaHJlc2hvbGRTcSB8fCBkaXN0YW5jZTJTcSA+PSBkaXN0VGhyZXNob2xkU3EgKXtcbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHQgPSBmYWxzZTtcbiAgICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQudW5hY3RpdmF0ZSgpOyByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7IH1cbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBjeHRFdnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSAgXG5cbiAgICAgIGlmKCBjYXB0dXJlICYmIHIudG91Y2hEYXRhLmN4dCApeyBcbiAgICAgICAgdmFyIGN4dEV2dCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9KTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTsgfVxuICAgICAgICByLnRvdWNoRGF0YS5jeHREcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjeHRkcmFnJylcblxuICAgICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlKTtcblxuICAgICAgICBpZiggIXIudG91Y2hEYXRhLmN4dE92ZXIgfHwgbmVhciAhPT0gci50b3VjaERhdGEuY3h0T3ZlciApe1xuXG4gICAgICAgICAgaWYoIHIudG91Y2hEYXRhLmN4dE92ZXIgKXtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLmN4dE92ZXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dGRyYWdvdXQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjeHRkcmFnb3V0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci50b3VjaERhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjeHRkcmFnb3ZlcicpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiggY2FwdHVyZSAmJiBlLnRvdWNoZXNbMl0gJiYgY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpICl7IFxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNsZWFyVGltZW91dCggdGhpcy50aHJlZUZpbmdlclNlbGVjdFRpbWVvdXQgKTtcbiAgICAgICAgdGhpcy5sYXN0VGhyZWVUb3VjaCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgaWYoICFzZWxlY3QgfHwgc2VsZWN0Lmxlbmd0aCA9PT0gMCB8fCBzZWxlY3RbMF0gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHNlbGVjdFswXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pLzM7XG4gICAgICAgICAgc2VsZWN0WzFdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkvMztcbiAgICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKS8zICsgMTtcbiAgICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKS8zICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKS8zO1xuICAgICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pLzM7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGNhcHR1cmUgJiYgZS50b3VjaGVzWzFdICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApIHsgLy8gdHdvIGZpbmdlcnMgPT4gcGluY2ggdG8gem9vbVxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuICAgICAgICBpZiggZHJhZ2dlZEVsZXMgKXsgXG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gdHJ1ZTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RvdWNobW92ZSBwdHonKTtcblxuICAgICAgICAvLyAoeDIsIHkyKSBmb3IgZmluZ2VycyAxIGFuZCAyXG4gICAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coIGYxeDIsIGYxeTIgKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyggZjJ4MiwgZjJ5MiApXG5cbiAgICAgICAgdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAgIC8vIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgICAgLy8gdmFyIGZhY3RvciA9IE1hdGguc3FydCggZGlzdGFuY2UyU3EgKSAvIE1hdGguc3FydCggZGlzdGFuY2UxU3EgKTtcbiAgICAgICAgdmFyIGZhY3RvciA9IGRpc3RhbmNlMiAvIGRpc3RhbmNlMTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhkaXN0YW5jZTIpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGZhY3RvcilcblxuICAgICAgICBpZiggZmFjdG9yICE9IDEgJiYgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlKXtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGZhY3RvcilcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhkaXN0YW5jZTIgKyAnIC8gJyArIGRpc3RhbmNlMSk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tJyk7XG5cbiAgICAgICAgICAvLyBkZWx0YSBmaW5nZXIxXG4gICAgICAgICAgdmFyIGRmMXggPSBmMXgyIC0gZjF4MTtcbiAgICAgICAgICB2YXIgZGYxeSA9IGYxeTIgLSBmMXkxO1xuXG4gICAgICAgICAgLy8gZGVsdGEgZmluZ2VyIDJcbiAgICAgICAgICB2YXIgZGYyeCA9IGYyeDIgLSBmMngxO1xuICAgICAgICAgIHZhciBkZjJ5ID0gZjJ5MiAtIGYyeTE7XG5cbiAgICAgICAgICAvLyB0cmFuc2xhdGlvbiBpcyB0aGUgbm9ybWFsaXNlZCB2ZWN0b3Igb2YgdGhlIHR3byBmaW5nZXJzIG1vdmVtZW50XG4gICAgICAgICAgLy8gaS5lLiBzbyBwaW5jaGluZyBjYW5jZWxzIG91dCBhbmQgbW92aW5nIHRvZ2V0aGVyIHBhbnNcbiAgICAgICAgICB2YXIgdHggPSAoZGYxeCArIGRmMngpLzI7XG4gICAgICAgICAgdmFyIHR5ID0gKGRmMXkgKyBkZjJ5KS8yO1xuXG4gICAgICAgICAgLy8gYWRqdXN0IGZhY3RvciBieSB0aGUgc3BlZWQgbXVsdGlwbGllclxuICAgICAgICAgIC8vIHZhciBzcGVlZCA9IDEuNTtcbiAgICAgICAgICAvLyBpZiggZmFjdG9yID4gMSApe1xuICAgICAgICAgIC8vICAgZmFjdG9yID0gKGZhY3RvciAtIDEpICogc3BlZWQgKyAxO1xuICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgLy8gICBmYWN0b3IgPSAxIC0gKDEgLSBmYWN0b3IpICogc3BlZWQ7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgLy8gbm93IGNhbGN1bGF0ZSB0aGUgem9vbVxuICAgICAgICAgIHZhciB6b29tMSA9IGN5Lnpvb20oKTtcbiAgICAgICAgICB2YXIgem9vbTIgPSB6b29tMSAqIGZhY3RvcjtcbiAgICAgICAgICB2YXIgcGFuMSA9IGN5LnBhbigpO1xuXG4gICAgICAgICAgLy8gdGhlIG1vZGVsIGNlbnRlciBwb2ludCBjb252ZXJ0ZWQgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZWQgcG9zXG4gICAgICAgICAgdmFyIGN0cnggPSBtb2RlbENlbnRlcjFbMF0gKiB6b29tMSArIHBhbjEueDtcbiAgICAgICAgICB2YXIgY3RyeSA9IG1vZGVsQ2VudGVyMVsxXSAqIHpvb20xICsgcGFuMS55O1xuXG4gICAgICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgICAgICB4OiAtem9vbTIvem9vbTEgKiAoY3RyeCAtIHBhbjEueCAtIHR4KSArIGN0cngsXG4gICAgICAgICAgICB5OiAtem9vbTIvem9vbTEgKiAoY3RyeSAtIHBhbjEueSAtIHR5KSArIGN0cnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2cocGFuMik7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coem9vbTIpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIGRyYWdnZWQgZWxlc1xuICAgICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICAgICAgICBpZiggZHJhZ2dlZEVsZXMgKXsgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgICB9IH1cblxuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5ncmFiYmVkID0gZmFsc2U7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydC5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuXG4gICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuXG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydFxuICAgICAgICAgICAgICAudHJpZ2dlcignZnJlZScpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKCd1bmFjdGl2YXRlJylcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjeS52aWV3cG9ydCh7XG4gICAgICAgICAgICB6b29tOiB6b29tMixcbiAgICAgICAgICAgIHBhbjogcGFuMixcbiAgICAgICAgICAgIGNhbmNlbE9uRmFpbGVkWm9vbTogdHJ1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGlzdGFuY2UxID0gZGlzdGFuY2UyOyAgXG4gICAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgICAgZjF5MSA9IGYxeTI7XG4gICAgICAgICAgZjJ4MSA9IGYyeDI7XG4gICAgICAgICAgZjJ5MSA9IGYyeTI7XG5cbiAgICAgICAgICByLnBpbmNoaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICBpZiAoZS50b3VjaGVzWzBdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTsgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07IH1cbiAgICAgICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuXG4gICAgICB9IGVsc2UgaWYgKGUudG91Y2hlc1swXSkge1xuICAgICAgICB2YXIgc3RhcnQgPSByLnRvdWNoRGF0YS5zdGFydDtcbiAgICAgICAgdmFyIGxhc3QgPSByLnRvdWNoRGF0YS5sYXN0O1xuICAgICAgICB2YXIgbmVhciA9IG5lYXIgfHwgci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUpO1xuXG4gICAgICAgIGlmKCBzdGFydCAhPSBudWxsICYmIHN0YXJ0Ll9wcml2YXRlLmdyb3VwID09ICdub2RlcycgJiYgci5ub2RlSXNEcmFnZ2FibGUoc3RhcnQpICl7XG5cbiAgICAgICAgICBpZiggcmRpc3QyID49IHIudGFwVGhyZXNob2xkMiApeyAvLyB0aGVuIGRyYWdnaW5nIGNhbiBoYXBwZW5cbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGsrKyApe1xuICAgICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZSA9IGRyYWdnZWRFbGVzW2tdO1xuXG4gICAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZShkcmFnZ2VkRWxlKSAmJiBkcmFnZ2VkRWxlLmlzTm9kZSgpICYmIGRyYWdnZWRFbGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZFBvcyA9IGRyYWdnZWRFbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG5cbiAgICAgICAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKGRpc3BbMF0pICYmICQkLmlzLm51bWJlcihkaXNwWzFdKSApe1xuICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZGlzcFsxXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBkcmFnZ2VkRWxlLCB7IGluRHJhZ0xheWVyOiB0cnVlIH0gKTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGRyYWdEZWx0YSA9IHIudG91Y2hEYXRhLmRyYWdEZWx0YTtcblxuICAgICAgICAgICAgICAgICAgaWYoICQkLmlzLm51bWJlcihkcmFnRGVsdGFbMF0pICYmICQkLmlzLm51bWJlcihkcmFnRGVsdGFbMV0pICl7XG4gICAgICAgICAgICAgICAgICAgIGRQb3MueCArPSBkcmFnRGVsdGFbMF07XG4gICAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkcmFnRGVsdGFbMV07XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRjb2wgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwgZHJhZ2dlZEVsZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRjb2wudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgICAgICAgIHRjb2wudHJpZ2dlcigncG9zaXRpb24gZHJhZycpO1xuXG4gICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSB0cnVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiggXG4gICAgICAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gPT0gZWFybGllclswXVxuICAgICAgICAgICAgICAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdID09IGVhcmxpZXJbMV1cbiAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIG90aGVyaXNlIGtlZXAgdHJhY2sgb2YgZHJhZyBkZWx0YSBmb3IgbGF0ZXJcbiAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgICAgICAgIGlmKCBkcmFnRGVsdGEubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKDApO1xuICAgICAgICAgICAgICBkcmFnRGVsdGEucHVzaCgwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgICAgICBkcmFnRGVsdGFbMV0gKz0gZGlzcFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRvdWNobW92ZSBldmVudFxuICAgICAgICB7XG5cbiAgICAgICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnQudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTsgXG5cbiAgICAgICAgICAgIHN0YXJ0LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApOyBcblxuICAgICAgICAgICAgc3RhcnQudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZW1vdmUnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7IFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoc3RhcnQgPT0gbnVsbCkgeyBcblxuICAgICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkgeyBcbiAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaG1vdmUnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApOyBcblxuICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWcnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZWFyID09IG51bGwpIHsgXG4gICAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7IFxuXG4gICAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWcnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApOyBcblxuICAgICAgICAgICAgICBjeS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgICAgaWYgKGxhc3QpIHsgbGFzdC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7IHR5cGU6ICd0YXBkcmFnb3V0JywgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9IH0pKTsgfVxuICAgICAgICAgICAgaWYgKG5lYXIpIHsgbmVhci50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7IHR5cGU6ICd0YXBkcmFnb3ZlcicsIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfSB9KSk7IH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgdG8gY2FuY2VsIHRhcGhvbGRcbiAgICAgICAgZm9yICh2YXIgaT0wO2k8bm93Lmxlbmd0aDtpKyspIHtcbiAgICAgICAgICBpZiAobm93W2ldIFxuICAgICAgICAgICAgJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXVxuICAgICAgICAgICAgJiYgTWF0aC5hYnMobm93W2ldIC0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXSkgPiA0KSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoXG4gICAgICAgICAgICBjYXB0dXJlXG4gICAgICAgICAgICAmJiAoIHN0YXJ0ID09IG51bGwgfHwgc3RhcnQuaXNFZGdlKCkgKVxuICAgICAgICAgICAgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKVxuICAgICAgICApe1xuXG4gICAgICAgICAgaWYoIHIuc3dpcGVQYW5uaW5nICl7XG4gICAgICAgICAgICBjeS5wYW5CeSh7XG4gICAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICB9IGVsc2UgaWYoIHJkaXN0MiA+PSByLnRhcFRocmVzaG9sZDIgKXtcbiAgICAgICAgICAgIHIuc3dpcGVQYW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGR5ICogem9vbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICAgIGlmKCAhci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICl7XG4gICAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmUtcHJvamVjdFxuICAgICAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzBdLmNsaWVudFgsIGUudG91Y2hlc1swXS5jbGllbnRZKTtcbiAgICAgICAgICBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqPTA7IGo8bm93Lmxlbmd0aDsgaisrKSB7IGVhcmxpZXJbal0gPSBub3dbal07IH1cbiAgICAgIC8vci5yZWRyYXcoKTtcbiAgICAgIFxuICAgIH0sIDEwMDAvMzAsIHsgdHJhaWxpbmc6IHRydWUgfSksIGZhbHNlKTtcbiAgICBcbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGVuZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7IFxuXG4gICAgICBpZiggY2FwdHVyZSApe1xuICAgICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuXG4gICAgICByLnN3aXBlUGFubmluZyA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgICBcbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTsgXG4gICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcbiAgICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cbiAgICAgIFxuICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eFRhcGVuZDtcbiAgICAgIGlmKCByLnRvdWNoRGF0YS5jeHQgKXtcbiAgICAgICAgY3R4VGFwZW5kID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgICAgc3RhcnQudHJpZ2dlciggY3R4VGFwZW5kICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3R4VGFwZW5kICk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjeHR0YXBlbmQnKVxuXG4gICAgICAgIGlmKCAhci50b3VjaERhdGEuY3h0RHJhZ2dlZCApe1xuICAgICAgICAgIHZhciBjdHhUYXAgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICAgICAgc3RhcnQudHJpZ2dlciggY3R4VGFwICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIGN0eFRhcCApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2N4dHRhcCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBtb3JlIGJveCBzZWxlY3Rpb24gaWYgd2UgZG9uJ3QgaGF2ZSB0aHJlZSBmaW5nZXJzXG4gICAgICBpZiggIWUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLnRocmVlRmluZ2VyU2VsZWN0VGltZW91dCApO1xuICAgICAgICAvL3RoaXMudGhyZWVGaW5nZXJTZWxlY3RUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBuZXdseVNlbGVjdGVkID0gW107XG4gICAgICAgICAgdmFyIGJveCA9IHIuZ2V0QWxsSW5Cb3goIHNlbGVjdFswXSwgc2VsZWN0WzFdLCBzZWxlY3RbMl0sIHNlbGVjdFszXSApO1xuXG4gICAgICAgICAgc2VsZWN0WzBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGVjdFsxXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxlY3RbMl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc2VsZWN0WzNdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGVjdFs0XSA9IDA7XG5cbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coYm94KTtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaTwgYm94Lmxlbmd0aDsgaSsrICkgeyBcbiAgICAgICAgICAgIGlmKCBib3hbaV0uX3ByaXZhdGUuc2VsZWN0YWJsZSApe1xuICAgICAgICAgICAgICBuZXdseVNlbGVjdGVkLnB1c2goIGJveFtpXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXdseVNlbENvbCA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgbmV3bHlTZWxlY3RlZCApO1xuXG4gICAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ3NpbmdsZScgKXtcbiAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLm5vdCggbmV3bHlTZWxDb2wgKS51bnNlbGVjdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5ld2x5U2VsQ29sLnNlbGVjdCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBuZXdseVNlbENvbC5sZW5ndGggPiAwICkgeyBcbiAgICAgICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7IFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAvL30sIDEwMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVTdGFydFN0eWxlID0gZmFsc2U7XG5cbiAgICAgIGlmKCBzdGFydCAhPSBudWxsICl7XG4gICAgICAgIHN0YXJ0Ll9wcml2YXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB1cGRhdGVTdGFydFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSB7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgIFxuICAgICAgLy8gTGFzdCB0b3VjaCByZWxlYXNlZFxuICAgICAgfSBlbHNlIGlmICghZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIFxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgaWYgKHN0YXJ0ICE9IG51bGwgKSB7XG5cbiAgICAgICAgICBpZiggc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCApe1xuICAgICAgICAgICAgc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhcnQudHJpZ2dlcignZnJlZScpO1xuICAgICAgICAgICAgc3RhcnQuX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIHNFZGdlcyA9IHN0YXJ0Ll9wcml2YXRlLmVkZ2VzO1xuICAgICAgICAgIGZvciAodmFyIGo9MDtqPHNFZGdlcy5sZW5ndGg7aisrKSB7IHNFZGdlc1tqXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlOyB9XG4gICAgICAgICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIoc3RhcnQsIGZhbHNlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggc3RhcnQuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKCdub2RlOnNlbGVjdGVkJyk7XG5cbiAgICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGsrKyApe1xuXG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSBzZWxlY3RlZE5vZGVzW2tdO1xuICAgICAgICAgICAgICBzZWxlY3RlZE5vZGUuX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgc2VsZWN0ZWROb2RlLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICB2YXIgc0VkZ2VzID0gc2VsZWN0ZWROb2RlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGo8c0VkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgc0VkZ2VzW2pdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllcihzZWxlY3RlZE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlOyBcbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlOyBcbiAgICAgICAgICBcbiAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBlbmQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZXVwJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG4gICAgICAgICAgXG4gICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUpO1xuICAgICAgICBcbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7IFxuICAgICAgICAgICAgbmVhclxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBlbmQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobmVhciA9PSBudWxsKSB7IFxuICAgICAgICAgICAgY3lcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndG91Y2hlbmQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGR4ID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvblswXSAtIG5vd1swXTtcbiAgICAgICAgdmFyIGR4MiA9IGR4ICogZHg7XG4gICAgICAgIHZhciBkeSA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMV0gLSBub3dbMV07XG4gICAgICAgIHZhciBkeTIgPSBkeSAqIGR5O1xuICAgICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICAgIHZhciByZGlzdDIgPSBkaXN0MiAqIHpvb20gKiB6b29tO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJlcGFyZSB0byBzZWxlY3QgdGhlIGN1cnJlbnRseSB0b3VjaGVkIG5vZGUsIG9ubHkgaWYgaXQgaGFzbid0IGJlZW4gZHJhZ2dlZCBwYXN0IGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAgICBpZiAoc3RhcnQgIT0gbnVsbCBcbiAgICAgICAgICAgICYmICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IGRyYWcgbm9kZXMgYXJvdW5kXG4gICAgICAgICAgICAmJiBzdGFydC5fcHJpdmF0ZS5zZWxlY3RhYmxlIFxuICAgICAgICAgICAgJiYgcmRpc3QyIDwgci50YXBUaHJlc2hvbGQyXG4gICAgICAgICAgICAmJiAhci5waW5jaGluZyAvLyBwaW5jaCB0byB6b29tIHNob3VsZCBub3QgYWZmZWN0IHNlbGVjdGlvblxuICAgICAgICApIHtcblxuICAgICAgICAgIGlmKCBjeS5zZWxlY3Rpb25UeXBlKCkgPT09ICdzaW5nbGUnICl7XG4gICAgICAgICAgICBjeS4kKCc6c2VsZWN0ZWQnKS5ub3QoIHN0YXJ0ICkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIHN0YXJ0LnNlbGVjdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiggc3RhcnQuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICBzdGFydC51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlU3RhcnRTdHlsZSA9IHRydWU7XG5cbiAgICAgICAgICBcbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlOyBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVGFwIGV2ZW50LCByb3VnaGx5IHNhbWUgYXMgbW91c2UgY2xpY2sgZXZlbnQgZm9yIHRvdWNoXG4gICAgICAgIGlmICggci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXJ0XG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2Y2xpY2snLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3lcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3ZjbGljaycsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbi8vICAgICAgICAgIGNvbnNvbGUubG9nKCd0YXAnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgci50b3VjaERhdGEuc2luZ2xlVG91Y2hNb3ZlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbm93Lmxlbmd0aDsgaisrICl7IGVhcmxpZXJbal0gPSBub3dbal07IH1cblxuICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gZmFsc2U7IC8vIHJlc2V0IGZvciBuZXh0IG1vdXNlZG93blxuXG4gICAgICBpZiggZS50b3VjaGVzWzBdICl7XG4gICAgICAgIHIudG91Y2hEYXRhLmRyYWdEZWx0YSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiggdXBkYXRlU3RhcnRTdHlsZSAmJiBzdGFydCApe1xuICAgICAgICBzdGFydC51cGRhdGVTdHlsZShmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBlLnRvdWNoZXMubGVuZ3RoIDwgMiApe1xuICAgICAgICByLnBpbmNoaW5nID0gZmFsc2U7XG4gICAgICAgIHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7IFxuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICAvL3IucmVkcmF3KCk7XG4gICAgICBcbiAgICB9LCBmYWxzZSk7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgcmVuZGVyZXIgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG4gIHZhciB1c2VQYXRocyA9IENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzKCk7XG5cbiAgLy8gTm9kZSBzaGFwZSBjb250cmFjdDpcbiAgLy9cbiAgLy8gZHJhdzogZHJhd1xuICAvLyBpbnRlcnNlY3RMaW5lOiByZXBvcnQgaW50ZXJzZWN0aW9uIGZyb20geCwgeSwgdG8gbm9kZSBjZW50ZXJcbiAgLy8gY2hlY2tQb2ludDogY2hlY2sgeCwgeSBpbiBub2RlXG5cbiAgdmFyIG5vZGVTaGFwZXMgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzID0ge307XG5cbiAgdmFyIHNpbjAgPSBNYXRoLnNpbigwKTtcbiAgdmFyIGNvczAgPSBNYXRoLmNvcygwKTtcblxuICB2YXIgc2luID0ge307XG4gIHZhciBjb3MgPSB7fTtcblxuICB2YXIgZWxsaXBzZVN0ZXBTaXplID0gMC4xO1xuXG4gIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSApIHtcbiAgICBzaW5baV0gPSBNYXRoLnNpbihpKTtcbiAgICBjb3NbaV0gPSBNYXRoLmNvcyhpKTtcbiAgfVxuXG4gIG5vZGVTaGFwZXNbJ2VsbGlwc2UnXSA9IHtcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBub2RlU2hhcGVzWydlbGxpcHNlJ10uZHJhd1BhdGgoY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIFxuLy8gICAgICBjb25zb2xlLmxvZygnZHJhd2luZyBlbGxpcHNlJyk7XG4vLyAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cblxuICAgICAgICB2YXIgeFBvcywgeVBvcztcbiAgICAgICAgdmFyIHJ3ID0gd2lkdGgvMjtcbiAgICAgICAgdmFyIHJoID0gaGVpZ2h0LzI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwICogTWF0aC5QSTsgaSA8IDIgKiBNYXRoLlBJOyBpICs9IGVsbGlwc2VTdGVwU2l6ZSApIHtcbiAgICAgICAgICAgIHhQb3MgPSBjZW50ZXJYIC0gKHJ3ICogc2luW2ldKSAqIHNpbjAgKyAocncgKiBjb3NbaV0pICogY29zMDtcbiAgICAgICAgICAgIHlQb3MgPSBjZW50ZXJZICsgKHJoICogY29zW2ldKSAqIHNpbjAgKyAocmggKiBzaW5baV0pICogY29zMDtcblxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh4UG9zLCB5UG9zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5saW5lVG8oeFBvcywgeVBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgY29udGV4dC5zY2FsZSh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICAvLyBBdCBvcmlnaW4sIHJhZGl1cyAxLCAwIHRvIDJwaVxuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCAxLCAwLCBNYXRoLlBJICogMiAqIDAuOTk5LCBmYWxzZSk7IC8vICowLjk5OSBiL2MgY2hyb21lIHJlbmRlcmluZyBidWcgb24gZnVsbCBjaXJjbGVcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgICBjb250ZXh0LnNjYWxlKDIvd2lkdGgsIDIvaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLWNlbnRlclgsIC1jZW50ZXJZKTtcblxuICAgICAgfVxuICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHZhciBpbnRlcnNlY3QgPSAkJC5tYXRoLmludGVyc2VjdExpbmVFbGxpcHNlKFxuICAgICAgICB4LCB5LFxuICAgICAgICBub2RlWCxcbiAgICAgICAgbm9kZVksXG4gICAgICAgIHdpZHRoIC8gMiArIHBhZGRpbmcsXG4gICAgICAgIGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGludGVyc2VjdDtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICB4MSwgeTEsIHgyLCB5Miwgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZykge1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5ib3hJbnRlcnNlY3RFbGxpcHNlKFxuICAgICAgICB4MSwgeTEsIHgyLCB5MiwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSk7XG4gICAgfSxcbiAgICBcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIFxuLy8gICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgICAgXG4gICAgICB4IC09IGNlbnRlclg7XG4gICAgICB5IC09IGNlbnRlclk7XG4gICAgICBcbiAgICAgIHggLz0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgeSAvPSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgXG4gICAgICByZXR1cm4gKE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikgPD0gMSk7XG4gICAgfVxuICB9O1xuICBcbiAgbm9kZVNoYXBlc1sndHJpYW5nbGUnXSA9IHtcbiAgICBwb2ludHM6ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDMsIDApLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIG5vZGVTaGFwZXNbJ3RyaWFuZ2xlJ10ucG9pbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXdQYXRoOiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3UG9seWdvblBhdGgoY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgbm9kZVNoYXBlc1sndHJpYW5nbGUnXS5wb2ludHMpO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24obm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gJCQubWF0aC5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVNoYXBlc1sndHJpYW5nbGUnXS5wb2ludHMsXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyLFxuICAgICAgICBwYWRkaW5nKTtcbiAgICBcbiAgICAgIC8qXG4gICAgICBwb2x5Z29uSW50ZXJzZWN0TGluZSh4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCBcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG4gICAgICAqL1xuICAgICAgXG4gICAgICBcbiAgICAgIC8qXG4gICAgICByZXR1cm4gcmVuZGVyZXIucG9seWdvbkludGVyc2VjdExpbmUoXG4gICAgICAgIG5vZGUsIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIHgsIHksIG5vZGVTaGFwZXNbJ3RyaWFuZ2xlJ10ucG9pbnRzKTtcbiAgICAgICovXG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uKFxuICAgICAgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICAgIFxuICAgICAgdmFyIHBvaW50cyA9IG5vZGVTaGFwZXNbJ3RyaWFuZ2xlJ10ucG9pbnRzO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5ib3hJbnRlcnNlY3RQb2x5Z29uKFxuICAgICAgICB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgcG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIG5vZGVTaGFwZXNbJ3RyaWFuZ2xlJ10ucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG4gIFxuICBub2RlU2hhcGVzWydzcXVhcmUnXSA9IHtcbiAgICBwb2ludHM6ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIG5vZGVTaGFwZXNbJ3NxdWFyZSddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIG5vZGVTaGFwZXNbJ3NxdWFyZSddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvbHlnb25JbnRlcnNlY3RMaW5lKFxuICAgICAgICAgIHgsIHksXG4gICAgICAgICAgbm9kZVNoYXBlc1snc3F1YXJlJ10ucG9pbnRzLFxuICAgICAgICAgIG5vZGVYLFxuICAgICAgICAgIG5vZGVZLFxuICAgICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMixcbiAgICAgICAgICBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICB4MSwgeTEsIHgyLCB5MixcbiAgICAgIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIFxuICAgICAgY2VudGVyWSwgcGFkZGluZykge1xuICAgICAgXG4gICAgICB2YXIgcG9pbnRzID0gbm9kZVNoYXBlc1snc3F1YXJlJ10ucG9pbnRzO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5ib3hJbnRlcnNlY3RQb2x5Z29uKFxuICAgICAgICB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgcG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBcbiAgICAgICAgY2VudGVyWSwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIG5vZGVTaGFwZXNbJ3NxdWFyZSddLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfVxuICB9O1xuICBcbiAgbm9kZVNoYXBlc1sncmVjdGFuZ2xlJ10gPSBub2RlU2hhcGVzWydzcXVhcmUnXTtcbiAgXG4gIG5vZGVTaGFwZXNbJ29jdG9nb24nXSA9IHt9O1xuICBcbiAgbm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXSA9IHtcbiAgICBwb2ludHM6ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDQsIDApLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdSb3VuZFJlY3RhbmdsZShjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAxMCk7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3UGF0aDogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAxMCk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiAkJC5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0TGluZShcbiAgICAgICAgICB4LCB5LFxuICAgICAgICAgIG5vZGVYLFxuICAgICAgICAgIG5vZGVZLFxuICAgICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uKFxuICAgICAgeDEsIHkxLCB4MiwgeTIsXG4gICAgICB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBcbiAgICAgIGNlbnRlclksIHBhZGRpbmcpIHtcblxuICAgICAgcmV0dXJuICQkLm1hdGgucm91bmRSZWN0YW5nbGVJbnRlcnNlY3RCb3goXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLCBcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBMb29rcyBsaWtlIHRoZSB3aWR0aCBwYXNzZWQgaW50byB0aGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IHRoZSB0b3RhbCB3aWR0aCAvIDJcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIFxuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9ICQkLm1hdGguZ2V0Um91bmRSZWN0YW5nbGVSYWRpdXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGhCb3hcbiAgICAgIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBub2RlU2hhcGVzWydyb3VuZHJlY3RhbmdsZSddLnBvaW50cyxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCAtIDIgKiBjb3JuZXJSYWRpdXMsIFswLCAtMV0sIHBhZGRpbmcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayB2Qm94XG4gICAgICBpZiAoJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXS5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoIC0gMiAqIGNvcm5lclJhZGl1cywgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGNoZWNrSW5FbGxpcHNlID0gZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICAgICAgICB4IC09IGNlbnRlclg7XG4gICAgICAgIHkgLT0gY2VudGVyWTtcbiAgICAgICAgXG4gICAgICAgIHggLz0gKHdpZHRoIC8gMiArIHBhZGRpbmcpO1xuICAgICAgICB5IC89IChoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gKE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikgPD0gMSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRvcCBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLypcbiAgICAgIGlmIChyZW5kZXJlci5ib3hJbnRlcnNlY3RFbGxpcHNlKHgsIHksIHgsIHksIHBhZGRpbmcsIFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLFxuICAgICAgICBjZW50ZXJYIC0gd2lkdGggKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgKyBjb3JuZXJSYWRpdXMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgKi9cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdG9wIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgYm90dG9tIHJpZ2h0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCArIHdpZHRoIC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgYm90dG9tIGxlZnQgcXVhcnRlciBjaXJjbGVcbiAgICAgIGlmIChjaGVja0luRWxsaXBzZSh4LCB5LFxuICAgICAgICBjZW50ZXJYIC0gd2lkdGggLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgcGFkZGluZykpIHtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuICBcbiAgbm9kZVNoYXBlc1sncGVudGFnb24nXSA9IHtcbiAgICBwb2ludHM6ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDUsIDApLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIG5vZGVTaGFwZXNbJ3BlbnRhZ29uJ10ucG9pbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXdQYXRoOiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3UG9seWdvblBhdGgoY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgbm9kZVNoYXBlc1sncGVudGFnb24nXS5wb2ludHMpO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24obm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gcmVuZGVyZXIucG9seWdvbkludGVyc2VjdExpbmUoXG4gICAgICAgIHgsIHksXG4gICAgICAgIG5vZGVTaGFwZXNbJ3BlbnRhZ29uJ10ucG9pbnRzLFxuICAgICAgICBub2RlWCxcbiAgICAgICAgbm9kZVksXG4gICAgICAgIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMixcbiAgICAgICAgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uKFxuICAgICAgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICAgIFxuICAgICAgdmFyIHBvaW50cyA9IG5vZGVTaGFwZXNbJ3BlbnRhZ29uJ10ucG9pbnRzO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5ib3hJbnRlcnNlY3RQb2x5Z29uKFxuICAgICAgICB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgcG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1sncGVudGFnb24nXS5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbiAgXG4gIG5vZGVTaGFwZXNbJ2hleGFnb24nXSA9IHtcbiAgICBwb2ludHM6ICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDYsIDApLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uKGNvbnRleHQsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgIG5vZGVTaGFwZXNbJ2hleGFnb24nXS5wb2ludHMpO1xuICAgIH0sXG4gICAgXG4gICAgZHJhd1BhdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBub2RlU2hhcGVzWydoZXhhZ29uJ10ucG9pbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uKG5vZGVYLCBub2RlWSwgd2lkdGgsIGhlaWdodCwgeCwgeSwgcGFkZGluZykge1xuICAgICAgcmV0dXJuICQkLm1hdGgucG9seWdvbkludGVyc2VjdExpbmUoXG4gICAgICAgIHgsIHksXG4gICAgICAgIG5vZGVTaGFwZXNbJ2hleGFnb24nXS5wb2ludHMsXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyLFxuICAgICAgICBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgICAgIFxuICAgICAgdmFyIHBvaW50cyA9IG5vZGVTaGFwZXNbJ2hleGFnb24nXS5wb2ludHM7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLmJveEludGVyc2VjdFBvbHlnb24oXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICBwb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oXG4gICAgICB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCBub2RlU2hhcGVzWydoZXhhZ29uJ10ucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG4gIFxuICBub2RlU2hhcGVzWydoZXB0YWdvbiddID0ge1xuICAgIHBvaW50czogJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNywgMCksXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb24oY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgbm9kZVNoYXBlc1snaGVwdGFnb24nXS5wb2ludHMpO1xuICAgIH0sXG4gICAgXG4gICAgZHJhd1BhdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBub2RlU2hhcGVzWydoZXB0YWdvbiddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVNoYXBlc1snaGVwdGFnb24nXS5wb2ludHMsXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyLFxuICAgICAgICBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgICBcbiAgICAgIHZhciBwb2ludHMgPSBub2RlU2hhcGVzWydoZXB0YWdvbiddLnBvaW50cztcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlbmRlcmVyLmJveEludGVyc2VjdFBvbHlnb24oXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICBwb2ludHMsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIG5vZGVTaGFwZXNbJ2hlcHRhZ29uJ10ucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9XG4gIH07XG4gIFxuICBub2RlU2hhcGVzWydvY3RhZ29uJ10gPSB7XG4gICAgcG9pbnRzOiAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg4LCAwKSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3UG9seWdvbihjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBub2RlU2hhcGVzWydvY3RhZ29uJ10ucG9pbnRzKTtcbiAgICB9LFxuICAgIFxuICAgIGRyYXdQYXRoOiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3UG9seWdvblBhdGgoY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgbm9kZVNoYXBlc1snb2N0YWdvbiddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVNoYXBlc1snb2N0YWdvbiddLnBvaW50cyxcbiAgICAgICAgbm9kZVgsXG4gICAgICAgIG5vZGVZLFxuICAgICAgICB3aWR0aCAvIDIsIGhlaWdodCAvIDIsXG4gICAgICAgIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbihcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICAgIFxuICAgICAgdmFyIHBvaW50cyA9IG5vZGVTaGFwZXNbJ29jdGFnb24nXS5wb2ludHM7XG4gICAgICBcbiAgICAgIHJldHVybiByZW5kZXJlci5ib3hJbnRlcnNlY3RQb2x5Z29uKFxuICAgICAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgIHBvaW50cywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICBjaGVja1BvaW50OiBmdW5jdGlvbihcbiAgICAgIHgsIHksIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIG5vZGVTaGFwZXNbJ29jdGFnb24nXS5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcbiAgXG4gIHZhciBzdGFyNVBvaW50cyA9IG5ldyBBcnJheSgyMCk7XG4gIHtcbiAgICB2YXIgb3V0ZXJQb2ludHMgPSAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgMCk7XG4gICAgdmFyIGlubmVyUG9pbnRzID0gJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIE1hdGguUEkgLyA1KTtcbiAgICBcbi8vICAgIGNvbnNvbGUubG9nKG91dGVyUG9pbnRzKTtcbi8vICAgIGNvbnNvbGUubG9nKGlubmVyUG9pbnRzKTtcbiAgICBcbiAgICAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcbiAgICBpbm5lclJhZGl1cyAqPSAxLjU3O1xuICAgIFxuICAgIGZvciAodmFyIGk9MDtpPGlubmVyUG9pbnRzLmxlbmd0aC8yO2krKykge1xuICAgICAgaW5uZXJQb2ludHNbaSoyXSAqPSBpbm5lclJhZGl1cztcbiAgICAgIGlubmVyUG9pbnRzW2kqMisxXSAqPSBpbm5lclJhZGl1cztcbiAgICB9XG4gICAgXG4gICAgZm9yICh2YXIgaT0wO2k8MjAvNDtpKyspIHtcbiAgICAgIHN0YXI1UG9pbnRzW2kqNF0gPSBvdXRlclBvaW50c1tpKjJdO1xuICAgICAgc3RhcjVQb2ludHNbaSo0KzFdID0gb3V0ZXJQb2ludHNbaSoyKzFdO1xuICAgICAgXG4gICAgICBzdGFyNVBvaW50c1tpKjQrMl0gPSBpbm5lclBvaW50c1tpKjJdO1xuICAgICAgc3RhcjVQb2ludHNbaSo0KzNdID0gaW5uZXJQb2ludHNbaSoyKzFdO1xuICAgIH1cbiAgICBcbi8vICAgIGNvbnNvbGUubG9nKHN0YXI1UG9pbnRzKTtcbiAgfVxuXG4gIHN0YXI1UG9pbnRzID0gJCQubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUoIHN0YXI1UG9pbnRzICk7XG4gIFxuICBub2RlU2hhcGVzWydzdGFyNSddID0gbm9kZVNoYXBlc1snc3RhciddID0ge1xuICAgIHBvaW50czogc3RhcjVQb2ludHMsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmVuZGVyZXIuZHJhd1BvbHlnb24oY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgbm9kZVNoYXBlc1snc3RhcjUnXS5wb2ludHMpO1xuICAgIH0sXG4gICAgXG4gICAgZHJhd1BhdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICBub2RlU2hhcGVzWydzdGFyNSddLnBvaW50cyk7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiByZW5kZXJlci5wb2x5Z29uSW50ZXJzZWN0TGluZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVNoYXBlc1snc3RhcjUnXS5wb2ludHMsXG4gICAgICAgIG5vZGVYLFxuICAgICAgICBub2RlWSxcbiAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyLFxuICAgICAgICBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGludGVyc2VjdEJveDogZnVuY3Rpb24oXG4gICAgICAgIHgxLCB5MSwgeDIsIHkyLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgICBcbiAgICAgIHZhciBwb2ludHMgPSBub2RlU2hhcGVzWydzdGFyNSddLnBvaW50cztcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlbmRlcmVyLmJveEludGVyc2VjdFBvbHlnb24oXG4gICAgICAgICAgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgcG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgeCwgeSwgcGFkZGluZywgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgY2VudGVyWSkge1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1snc3RhcjUnXS5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIFswLCAtMV0sIHBhZGRpbmcpO1xuICAgIH1cbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGFuaW1hdGU6IHRydWUsIC8vIHdoZXRoZXIgdG8gc2hvdyB0aGUgbGF5b3V0IGFzIGl0J3MgcnVubmluZ1xuICAgIG1heFNpbXVsYXRpb25UaW1lOiA0MDAwLCAvLyBtYXggbGVuZ3RoIGluIG1zIHRvIHJ1biB0aGUgbGF5b3V0XG4gICAgZml0OiB0cnVlLCAvLyBvbiBldmVyeSBsYXlvdXQgcmVwb3NpdGlvbiBvZiBub2RlcywgZml0IHRoZSB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIGFyb3VuZCB0aGUgc2ltdWxhdGlvblxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIHVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZzogZmFsc2UsIC8vIHNvIHlvdSBjYW4ndCBkcmFnIG5vZGVzIGR1cmluZyBsYXlvdXRcblxuICAgIC8vIGNhbGxiYWNrcyBvbiBsYXlvdXQgZXZlbnRzXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHkgXG4gICAgc3RvcDogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG5cbiAgICAvLyBmb3JjZXMgdXNlZCBieSBhcmJvciAodXNlIGFyYm9yIGRlZmF1bHQgb24gdW5kZWZpbmVkKVxuICAgIHJlcHVsc2lvbjogdW5kZWZpbmVkLFxuICAgIHN0aWZmbmVzczogdW5kZWZpbmVkLFxuICAgIGZyaWN0aW9uOiB1bmRlZmluZWQsXG4gICAgZ3Jhdml0eTogdHJ1ZSxcbiAgICBmcHM6IHVuZGVmaW5lZCxcbiAgICBwcmVjaXNpb246IHVuZGVmaW5lZCxcblxuICAgIC8vIHN0YXRpYyBudW1iZXJzIG9yIGZ1bmN0aW9ucyB0aGF0IGR5bmFtaWNhbGx5IHJldHVybiB3aGF0IHRoZXNlXG4gICAgLy8gdmFsdWVzIHNob3VsZCBiZSBmb3IgZWFjaCBlbGVtZW50XG4gICAgLy8gZS5nLiBub2RlTWFzczogZnVuY3Rpb24obil7IHJldHVybiBuLmRhdGEoJ3dlaWdodCcpIH1cbiAgICBub2RlTWFzczogdW5kZWZpbmVkLCBcbiAgICBlZGdlTGVuZ3RoOiB1bmRlZmluZWQsXG5cbiAgICBzdGVwU2l6ZTogMC4xLCAvLyBzbW9vdGhpbmcgb2YgYXJib3IgYm91bmRpbmcgYm94XG5cbiAgICAvLyBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgc3lzdGVtIGlzIHN0YWJsZSB0byBpbmRpY2F0ZVxuICAgIC8vIHRoYXQgdGhlIGxheW91dCBjYW4gYmUgc3RvcHBlZFxuICAgIHN0YWJsZUVuZXJneTogZnVuY3Rpb24oIGVuZXJneSApe1xuICAgICAgdmFyIGUgPSBlbmVyZ3k7IFxuICAgICAgcmV0dXJuIChlLm1heCA8PSAwLjUpIHx8IChlLm1lYW4gPD0gMC4zKTtcbiAgICB9LFxuXG4gICAgLy8gaW5maW5pdGUgbGF5b3V0IG9wdGlvbnNcbiAgICBpbmZpbml0ZTogZmFsc2UgLy8gb3ZlcnJpZGVzIGFsbCBvdGhlciBvcHRpb25zIGZvciBhIGZvcmNlcy1hbGwtdGhlLXRpbWUgbW9kZVxuICB9O1xuICBcbiAgZnVuY3Rpb24gQXJib3JMYXlvdXQob3B0aW9ucyl7XG4gICAgdGhpcy5fcHJpdmF0ZSA9IHt9O1xuXG4gICAgdGhpcy5fcHJpdmF0ZS5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICAgIFxuICBBcmJvckxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3ByaXZhdGUub3B0aW9ucztcblxuICAgICQkLnV0aWwucmVxdWlyZSgnYXJib3InLCBmdW5jdGlvbihhcmJvcil7XG5cbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gICAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcbiAgICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgfSApO1xuICAgICAgdmFyIHNpbVVwZGF0aW5nUG9zID0gZmFsc2U7XG5cbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgZm9yIG9sZCBhbmltYXRpb24gb3B0aW9uXG4gICAgICBpZiggb3B0aW9ucy5saXZlVXBkYXRlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgb3B0aW9ucy5hbmltYXRlID0gb3B0aW9ucy5saXZlVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICAvLyBhcmJvciBkb2Vzbid0IHdvcmsgd2l0aCBqdXN0IDEgbm9kZSBcbiAgICAgIGlmKCBjeS5ub2RlcygpLnNpemUoKSA8PSAxICl7XG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LnJlc2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBjeS5ub2RlcygpLnBvc2l0aW9uKHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKCAoYmIueDEgKyBiYi54MikvMiApLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQoIChiYi55MSArIGJiLnkyKS8yIClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN5cyA9IGxheW91dC5fcHJpdmF0ZS5zeXN0ZW0gPSBhcmJvci5QYXJ0aWNsZVN5c3RlbSgpO1xuXG4gICAgICBzeXMucGFyYW1ldGVycyh7XG4gICAgICAgIHJlcHVsc2lvbjogb3B0aW9ucy5yZXB1bHNpb24sXG4gICAgICAgIHN0aWZmbmVzczogb3B0aW9ucy5zdGlmZm5lc3MsIFxuICAgICAgICBmcmljdGlvbjogb3B0aW9ucy5mcmljdGlvbiwgXG4gICAgICAgIGdyYXZpdHk6IG9wdGlvbnMuZ3Jhdml0eSwgXG4gICAgICAgIGZwczogb3B0aW9ucy5mcHMsIFxuICAgICAgICBkdDogb3B0aW9ucy5kdCwgXG4gICAgICAgIHByZWNpc2lvbjogb3B0aW9ucy5wcmVjaXNpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiggb3B0aW9ucy5hbmltYXRlICYmIG9wdGlvbnMuZml0ICl7XG4gICAgICAgIGN5LmZpdCggYmIsIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZG9uZVRpbWUgPSAyNTA7XG4gICAgICB2YXIgZG9uZVRpbWVvdXQ7XG4gICAgICBcbiAgICAgIHZhciByZWFkeSA9IGZhbHNlO1xuICAgICAgXG4gICAgICB2YXIgbGFzdERyYXcgPSArbmV3IERhdGUoKTtcbiAgICAgIHZhciBzeXNSZW5kZXJlciA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oc3lzdGVtKXtcbiAgICAgICAgfSxcbiAgICAgICAgcmVkcmF3OiBmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBlbmVyZ3kgPSBzeXMuZW5lcmd5KCk7XG5cbiAgICAgICAgICAvLyBpZiB3ZSdyZSBzdGFibGUgKGFjY29yZGluZyB0byB0aGUgY2xpZW50KSwgd2UncmUgZG9uZVxuICAgICAgICAgIGlmKCAhb3B0aW9ucy5pbmZpbml0ZSAmJiBvcHRpb25zLnN0YWJsZUVuZXJneSAhPSBudWxsICYmIGVuZXJneSAhPSBudWxsICYmIGVuZXJneS5uID4gMCAmJiBvcHRpb25zLnN0YWJsZUVuZXJneShlbmVyZ3kpICl7XG4gICAgICAgICAgICBsYXlvdXQuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhb3B0aW9ucy5pbmZpbml0ZSAmJiBkb25lVGltZSAhPSBJbmZpbml0eSApe1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRvbmVUaW1lb3V0KTtcbiAgICAgICAgICAgIGRvbmVUaW1lb3V0ID0gc2V0VGltZW91dChkb25lSGFuZGxlciwgZG9uZVRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgbW92ZWROb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzeXMuZWFjaE5vZGUoZnVuY3Rpb24obiwgcG9pbnQpeyBcbiAgICAgICAgICAgIHZhciBkYXRhID0gbi5kYXRhO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBkYXRhLmVsZW1lbnQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBub2RlID09IG51bGwgKXtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggIW5vZGUubG9ja2VkKCkgJiYgIW5vZGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgIG5vZGUuc2lsZW50UG9zaXRpb24oe1xuICAgICAgICAgICAgICAgIHg6IGJiLngxICsgcG9pbnQueCxcbiAgICAgICAgICAgICAgICB5OiBiYi55MSArIHBvaW50LnlcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgbW92ZWROb2Rlcy5tZXJnZSggbm9kZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuXG4gICAgICAgICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSAmJiBtb3ZlZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIHNpbVVwZGF0aW5nUG9zID0gdHJ1ZTtcblxuICAgICAgICAgICAgbW92ZWROb2Rlcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcblxuICAgICAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3REcmF3ID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICBzaW1VcGRhdGluZ1BvcyA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCAhcmVhZHkgKXtcbiAgICAgICAgICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH07XG4gICAgICBzeXMucmVuZGVyZXIgPSBzeXNSZW5kZXJlcjtcbiAgICAgIHN5cy5zY3JlZW5TaXplKCBiYi53LCBiYi5oICk7XG4gICAgICBzeXMuc2NyZWVuUGFkZGluZyggb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICBzeXMuc2NyZWVuU3RlcCggb3B0aW9ucy5zdGVwU2l6ZSApO1xuXG4gICAgICBmdW5jdGlvbiBjYWxjdWxhdGVWYWx1ZUZvckVsZW1lbnQoZWxlbWVudCwgdmFsdWUpe1xuICAgICAgICBpZiggdmFsdWUgPT0gbnVsbCApe1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSBpZiggdHlwZW9mIHZhbHVlID09IHR5cGVvZiBmdW5jdGlvbigpe30gKXtcbiAgICAgICAgICByZXR1cm4gdmFsdWUuYXBwbHkoZWxlbWVudCwgW2VsZW1lbnQuX3ByaXZhdGUuZGF0YSwge1xuICAgICAgICAgICAgbm9kZXM6IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGVkZ2VzOiBlZGdlcy5sZW5ndGgsXG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICAgICAgfV0pOyBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGdyYWJIYW5kbGVyO1xuICAgICAgbm9kZXMub24oJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIGlmKCBzaW1VcGRhdGluZ1BvcyApeyByZXR1cm47IH1cblxuICAgICAgICB2YXIgcG9zID0gdGhpcy5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgYXBvcyA9IHN5cy5mcm9tU2NyZWVuKCBwb3MgKTtcbiAgICAgICAgaWYoICFhcG9zICl7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBwID0gYXJib3IuUG9pbnQoYXBvcy54LCBhcG9zLnkpO1xuICAgICAgICB2YXIgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZztcblxuICAgICAgICBpZihcbiAgICAgICAgICBiYi54MSArIHBhZGRpbmcgPD0gcG9zLnggJiYgcG9zLnggPD0gYmIueDIgLSBwYWRkaW5nICYmXG4gICAgICAgICAgYmIueTEgKyBwYWRkaW5nIDw9IHBvcy55ICYmIHBvcy55IDw9IGJiLnkyIC0gcGFkZGluZ1xuICAgICAgICApe1xuICAgICAgICAgIHRoaXMuc2NyYXRjaCgpLmFyYm9yLnAgPSBwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzd2l0Y2goIGUudHlwZSApe1xuICAgICAgICBjYXNlICdncmFiJzpcbiAgICAgICAgICB0aGlzLnNjcmF0Y2goKS5hcmJvci5maXhlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZyZWUnOlxuICAgICAgICAgIHRoaXMuc2NyYXRjaCgpLmFyYm9yLmZpeGVkID0gZmFsc2U7XG4gICAgICAgICAgLy90aGlzLnNjcmF0Y2goKS5hcmJvci50ZW1wTWFzcyA9IDEwMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbG9ja0hhbmRsZXI7XG4gICAgICBub2Rlcy5vbignbG9jayB1bmxvY2snLCBsb2NrSGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICBub2RlLnNjcmF0Y2goKS5hcmJvci5maXhlZCA9IG5vZGUubG9ja2VkKCk7XG4gICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgdmFyIHJlbW92ZUhhbmRsZXI7XG4gICAgICBlbGVzLm9uKCdyZW1vdmUnLCByZW1vdmVIYW5kbGVyID0gZnVuY3Rpb24oZSl7IHJldHVybjsgLy8gVE9ETyBlbmFibGUgd2hlbiBsYXlvdXQgYWRkL3JlbW92ZSBhcGkgYWRkZWRcbiAgICAgICAgLy8gdmFyIGVsZSA9IHRoaXM7XG4gICAgICAgIC8vIHZhciBhcmJvckVsZSA9IGVsZS5zY3JhdGNoKCkuYXJib3I7XG5cbiAgICAgICAgLy8gaWYoICFhcmJvckVsZSApeyByZXR1cm47IH1cblxuICAgICAgICAvLyBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICAgIC8vICAgc3lzLnBydW5lTm9kZSggYXJib3JFbGUgKTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICBzeXMucHJ1bmVFZGdlKCBhcmJvckVsZSApO1xuICAgICAgICAvLyB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGFkZEhhbmRsZXI7XG4gICAgICBjeS5vbignYWRkJywgJyonLCBhZGRIYW5kbGVyID0gZnVuY3Rpb24oKXsgcmV0dXJuOyAvLyBUT0RPIGVuYWJsZSB3aGVuIGxheW91dCBhZGQvcmVtb3ZlIGFwaSBhZGRlZFxuICAgICAgICAvLyB2YXIgZWxlID0gdGhpcztcblxuICAgICAgICAvLyBpZiggZWxlLmlzTm9kZSgpICl7XG4gICAgICAgIC8vICAgYWRkTm9kZSggZWxlICk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgYWRkRWRnZSggZWxlICk7XG4gICAgICAgIC8vIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzaXplSGFuZGxlcjtcbiAgICAgIGN5Lm9uKCdyZXNpemUnLCByZXNpemVIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggPT0gbnVsbCAmJiBsYXlvdXQuX3ByaXZhdGUuc3lzdGVtICE9IG51bGwgKXtcbiAgICAgICAgICB2YXIgdyA9IGN5LndpZHRoKCk7XG4gICAgICAgICAgdmFyIGggPSBjeS5oZWlnaHQoKTtcblxuICAgICAgICAgIHN5cy5zY3JlZW5TaXplKCB3LCBoICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBhZGROb2RlKCBub2RlICl7XG4gICAgICAgIGlmKCBub2RlLmlzRnVsbEF1dG9QYXJlbnQoKSApeyByZXR1cm47IH0gLy8gdGhleSBkb24ndCBleGlzdCBpbiB0aGUgc2ltXG5cbiAgICAgICAgdmFyIGlkID0gbm9kZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICB2YXIgbWFzcyA9IGNhbGN1bGF0ZVZhbHVlRm9yRWxlbWVudChub2RlLCBvcHRpb25zLm5vZGVNYXNzKTtcbiAgICAgICAgdmFyIGxvY2tlZCA9IG5vZGUuX3ByaXZhdGUubG9ja2VkO1xuICAgICAgICB2YXIgblBvcyA9IG5vZGUucG9zaXRpb24oKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBwb3MgPSBzeXMuZnJvbVNjcmVlbih7XG4gICAgICAgICAgeDogblBvcy54LFxuICAgICAgICAgIHk6IG5Qb3MueVxuICAgICAgICB9KTtcblxuICAgICAgICBub2RlLnNjcmF0Y2goKS5hcmJvciA9IHN5cy5hZGROb2RlKGlkLCB7XG4gICAgICAgICAgZWxlbWVudDogbm9kZSxcbiAgICAgICAgICBtYXNzOiBtYXNzLFxuICAgICAgICAgIGZpeGVkOiBsb2NrZWQsXG4gICAgICAgICAgeDogbG9ja2VkID8gcG9zLnggOiB1bmRlZmluZWQsXG4gICAgICAgICAgeTogbG9ja2VkID8gcG9zLnkgOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEVkZ2UoIGVkZ2UgKXtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2Uuc291cmNlKCkuaWQoKTtcbiAgICAgICAgdmFyIHRndCA9IGVkZ2UudGFyZ2V0KCkuaWQoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNhbGN1bGF0ZVZhbHVlRm9yRWxlbWVudChlZGdlLCBvcHRpb25zLmVkZ2VMZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgZWRnZS5zY3JhdGNoKCkuYXJib3IgPSBzeXMuYWRkRWRnZShzcmMsIHRndCwge1xuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoXG4gICAgICAgIH0pOyBcbiAgICAgIH1cblxuICAgICAgbm9kZXMuZWFjaChmdW5jdGlvbihpLCBub2RlKXtcbiAgICAgICAgYWRkTm9kZSggbm9kZSApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGVkZ2VzLmVhY2goZnVuY3Rpb24oaSwgZWRnZSl7XG4gICAgICAgIGFkZEVkZ2UoIGVkZ2UgKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB2YXIgZ3JhYmJhYmxlTm9kZXMgPSBub2Rlcy5maWx0ZXIoXCI6Z3JhYmJhYmxlXCIpO1xuICAgICAgLy8gZGlzYWJsZSBncmFiYmluZyBpZiBzbyBzZXRcbiAgICAgIGlmKCBvcHRpb25zLnVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZyApe1xuICAgICAgICBncmFiYmFibGVOb2Rlcy51bmdyYWJpZnkoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGRvbmVIYW5kbGVyID0gbGF5b3V0Ll9wcml2YXRlLmRvbmVIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgbGF5b3V0Ll9wcml2YXRlLmRvbmVIYW5kbGVyID0gbnVsbDtcblxuICAgICAgICBpZiggIW9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgY3kucmVzZXQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBub2Rlcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVuYmluZCBoYW5kbGVyc1xuICAgICAgICBub2Rlcy5vZmYoJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyKTtcbiAgICAgICAgbm9kZXMub2ZmKCdsb2NrIHVubG9jaycsIGxvY2tIYW5kbGVyKTtcbiAgICAgICAgZWxlcy5vZmYoJ3JlbW92ZScsIHJlbW92ZUhhbmRsZXIpO1xuICAgICAgICBjeS5vZmYoJ2FkZCcsICcqJywgYWRkSGFuZGxlcik7XG4gICAgICAgIGN5Lm9mZigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBlbmFibGUgYmFjayBncmFiYmluZyBpZiBzbyBzZXRcbiAgICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgICAgZ3JhYmJhYmxlTm9kZXMuZ3JhYmlmeSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHN5cy5zdGFydCgpO1xuICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICYmIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUgIT0gbnVsbCAmJiBvcHRpb25zLm1heFNpbXVsYXRpb25UaW1lID4gMCAmJiBvcHRpb25zLm1heFNpbXVsYXRpb25UaW1lICE9PSBJbmZpbml0eSApe1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgbGF5b3V0LnN0b3AoKTtcbiAgICAgICAgfSwgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgXG4gICAgfSk7IC8vIHJlcXVpcmVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG5cbiAgQXJib3JMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIGlmKCB0aGlzLl9wcml2YXRlLnN5c3RlbSAhPSBudWxsICl7XG4gICAgICB0aGlzLl9wcml2YXRlLnN5c3RlbS5zdG9wKCk7XG4gICAgfVxuXG4gICAgaWYoIHRoaXMuX3ByaXZhdGUuZG9uZUhhbmRsZXIgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuZG9uZUhhbmRsZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAnYXJib3InLCBBcmJvckxheW91dCk7XG4gIFxuICBcbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgZGlyZWN0ZWQ6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSB0cmVlIGlzIGRpcmVjdGVkIGRvd253YXJkcyAob3IgZWRnZXMgY2FuIHBvaW50IGluIGFueSBkaXJlY3Rpb24gaWYgZmFsc2UpXG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gICAgY2lyY2xlOiBmYWxzZSwgLy8gcHV0IGRlcHRocyBpbiBjb25jZW50cmljIGNpcmNsZXMgaWYgdHJ1ZSwgcHV0IGRlcHRocyB0b3AgZG93biBpZiBmYWxzZVxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIHJvb3RzOiB1bmRlZmluZWQsIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgICBtYXhpbWFsQWRqdXN0bWVudHM6IDAsIC8vIGhvdyBtYW55IHRpbWVzIHRvIHRyeSB0byBwb3NpdGlvbiB0aGUgbm9kZXMgaW4gYSBtYXhpbWFsIHdheSAoaS5lLiBubyBiYWNrdHJhY2tpbmcpXG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIEJyZWFkdGhGaXJzdExheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIEJyZWFkdGhGaXJzdExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIFxuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgdmFyIGdyYXBoID0gZWxlcztcbiAgICBcbiAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgfSApO1xuXG4gICAgdmFyIHJvb3RzO1xuICAgIGlmKCAkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKG9wdGlvbnMucm9vdHMpICl7XG4gICAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5hcnJheShvcHRpb25zLnJvb3RzKSApe1xuICAgICAgdmFyIHJvb3RzQXJyYXkgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJvb3RzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbaV07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcbiAgICAgICAgcm9vdHNBcnJheS5wdXNoKCBlbGUgKTtcbiAgICAgIH1cblxuICAgICAgcm9vdHMgPSBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHJvb3RzQXJyYXkgKTtcbiAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhvcHRpb25zLnJvb3RzKSApe1xuICAgICAgcm9vdHMgPSBjeS4kKCBvcHRpb25zLnJvb3RzICk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIG9wdGlvbnMuZGlyZWN0ZWQgKXtcbiAgICAgICAgcm9vdHMgPSBub2Rlcy5yb290cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIHVuaGFuZGxlZE5vZGVzID0gbm9kZXM7XG5cbiAgICAgICAgd2hpbGUoIHVuaGFuZGxlZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICB2YXIgY3VyckNvbXAgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgICBlbGVzLmJmcyh7XG4gICAgICAgICAgICByb290czogdW5oYW5kbGVkTm9kZXNbMF0sXG4gICAgICAgICAgICB2aXNpdDogZnVuY3Rpb24oaSwgZGVwdGgsIG5vZGUsIGVkZ2UsIHBOb2RlKXtcbiAgICAgICAgICAgICAgY3VyckNvbXAgPSBjdXJyQ29tcC5hZGQoIG5vZGUgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXJlY3RlZDogZmFsc2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHVuaGFuZGxlZE5vZGVzID0gdW5oYW5kbGVkTm9kZXMubm90KCBjdXJyQ29tcCApO1xuICAgICAgICAgIGNvbXBvbmVudHMucHVzaCggY3VyckNvbXAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgY29tcCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKCBmYWxzZSApO1xuICAgICAgICAgIHZhciBjb21wUm9vdHMgPSBjb21wLmZpbHRlcihmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVncmVlKGZhbHNlKSA9PT0gbWF4RGVncmVlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcm9vdHMgPSByb290cy5hZGQoIGNvbXBSb290cyApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfVxuICAgIH1cblxuXG4gICAgdmFyIGRlcHRocyA9IFtdO1xuICAgIHZhciBmb3VuZEJ5QmZzID0ge307XG4gICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgdmFyIHByZXZOb2RlID0ge307XG4gICAgdmFyIHByZXZFZGdlID0ge307XG4gICAgdmFyIHN1Y2Nlc3NvcnMgPSB7fTtcblxuICAgIC8vIGZpbmQgdGhlIGRlcHRocyBvZiB0aGUgbm9kZXNcbiAgICBncmFwaC5iZnMoe1xuICAgICAgcm9vdHM6IHJvb3RzLFxuICAgICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgICB2aXNpdDogZnVuY3Rpb24oaSwgZGVwdGgsIG5vZGUsIGVkZ2UsIHBOb2RlKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmKCAhZGVwdGhzW2RlcHRoXSApe1xuICAgICAgICAgIGRlcHRoc1tkZXB0aF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcHRoc1tkZXB0aF0ucHVzaCggZWxlICk7XG4gICAgICAgIGZvdW5kQnlCZnNbIGlkIF0gPSB0cnVlO1xuICAgICAgICBpZDJkZXB0aFsgaWQgXSA9IGRlcHRoO1xuICAgICAgICBwcmV2Tm9kZVsgaWQgXSA9IHBOb2RlO1xuICAgICAgICBwcmV2RWRnZVsgaWQgXSA9IGVkZ2U7XG5cbiAgICAgICAgaWYoIHBOb2RlICl7XG4gICAgICAgICAgdmFyIHByZXZJZCA9IHBOb2RlLmlkKCk7XG4gICAgICAgICAgdmFyIHN1Y2MgPSBzdWNjZXNzb3JzWyBwcmV2SWQgXSA9IHN1Y2Nlc3NvcnNbIHByZXZJZCBdIHx8IFtdO1xuICAgICAgICAgIFxuICAgICAgICAgIHN1Y2MucHVzaCggbm9kZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuICAgIHZhciBvcnBoYW5Ob2RlcyA9IFtdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcblxuICAgICAgaWYoIGZvdW5kQnlCZnNbIGVsZS5pZCgpIF0gKXtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcnBoYW5Ob2Rlcy5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIGEgZGVwdGggZnJvbSB0aGVpciBuZWlnaGJvcmhvb2RcbiAgICB2YXIgbWF4Q2hlY2tzID0gb3JwaGFuTm9kZXMubGVuZ3RoICogMztcbiAgICB2YXIgY2hlY2tzID0gMDtcbiAgICB3aGlsZSggb3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwICYmIGNoZWNrcyA8IG1heENoZWNrcyApe1xuICAgICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IG5vZGUubmVpZ2hib3Job29kKCkubm9kZXMoKTtcbiAgICAgIHZhciBhc3NpZ25lZERlcHRoID0gZmFsc2U7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoWyBuZWlnaGJvcnNbaV0uaWQoKSBdO1xuXG4gICAgICAgIGlmKCBkZXB0aCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBub2RlICk7XG4gICAgICAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICFhc3NpZ25lZERlcHRoICl7XG4gICAgICAgIG9ycGhhbk5vZGVzLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cblxuICAgICAgY2hlY2tzKys7XG4gICAgfVxuXG4gICAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0aGF0IGFyZSBzdGlsbCBsZWZ0IHRvIHRoZSBkZXB0aCBvZiB0aGVpciBzdWJncmFwaFxuICAgIHdoaWxlKCBvcnBoYW5Ob2Rlcy5sZW5ndGggIT09IDAgKXtcbiAgICAgIHZhciBub2RlID0gb3JwaGFuTm9kZXMuc2hpZnQoKTtcbiAgICAgIC8vdmFyIHN1YmdyYXBoID0gZ3JhcGguYmZzKCBub2RlICkucGF0aDtcbiAgICAgIHZhciBhc3NpZ25lZERlcHRoID0gZmFsc2U7XG5cbiAgICAgIC8vIGZvciggdmFyIGkgPSAwOyBpIDwgc3ViZ3JhcGgubGVuZ3RoOyBpKysgKXtcbiAgICAgIC8vICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHN1YmdyYXBoW2ldLmlkKCkgXTtcblxuICAgICAgLy8gICBpZiggZGVwdGggIT09IHVuZGVmaW5lZCApe1xuICAgICAgLy8gICAgIGRlcHRoc1tkZXB0aF0ucHVzaCggbm9kZSApO1xuICAgICAgLy8gICAgIGFzc2lnbmVkRGVwdGggPSB0cnVlO1xuICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG5cbiAgICAgIGlmKCAhYXNzaWduZWREZXB0aCApeyAvLyB3b3JzdCBjYXNlIGlmIHRoZSBncmFwaCByZWFsbHkgaXNuJ3QgdHJlZSBmcmllbmRseSwgdGhlbiBqdXN0IGR1bXAgaXQgaW4gMFxuICAgICAgICBpZiggZGVwdGhzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgIGRlcHRocy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZGVwdGhzWzBdLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gdGhlIG5vZGVzIGEgZGVwdGggYW5kIGluZGV4XG4gICAgdmFyIGFzc2lnbkRlcHRoc1RvRWxlcyA9IGZ1bmN0aW9uKCl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRlcHRocy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlcyA9IGRlcHRoc1tpXTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tqXTtcblxuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdCA9IHtcbiAgICAgICAgICAgIGRlcHRoOiBpLFxuICAgICAgICAgICAgaW5kZXg6IGpcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBhc3NpZ25EZXB0aHNUb0VsZXMoKTtcblxuXG4gICAgdmFyIGludGVyc2VjdHNEZXB0aCA9IGZ1bmN0aW9uKCBub2RlICl7IC8vIHJldHVybnMgdHJ1ZSBpZiBoYXMgZWRnZXMgcG9pbnRpbmcgaW4gZnJvbSBhIGhpZ2hlciBkZXB0aFxuICAgICAgdmFyIGVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcyhmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCd0YXJnZXQnKSA9PT0gbm9kZS5pZCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgdGhpc0luZm8gPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGhpZ2hlc3REZXB0aE9mT3RoZXIgPSAwO1xuICAgICAgdmFyIGhpZ2hlc3RPdGhlcjtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICAgIHZhciBvdGhlckluZm8gPSBvdGhlck5vZGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgICAgaWYoIHRoaXNJbmZvLmRlcHRoIDw9IG90aGVySW5mby5kZXB0aCAmJiBoaWdoZXN0RGVwdGhPZk90aGVyIDwgb3RoZXJJbmZvLmRlcHRoICl7XG4gICAgICAgICAgaGlnaGVzdERlcHRoT2ZPdGhlciA9IG90aGVySW5mby5kZXB0aDtcbiAgICAgICAgICBoaWdoZXN0T3RoZXIgPSBvdGhlck5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhpZ2hlc3RPdGhlcjtcbiAgICB9O1xuXG4gICAgIC8vIG1ha2UgbWF4aW1hbCBpZiBzbyBzZXQgYnkgYWRqdXN0aW5nIGRlcHRoc1xuICAgIGZvciggdmFyIGFkaiA9IDA7IGFkaiA8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzOyBhZGorKyApe1xuXG4gICAgICB2YXIgbkRlcHRocyA9IGRlcHRocy5sZW5ndGg7XG4gICAgICB2YXIgZWxlc1RvTW92ZSA9IFtdO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuRGVwdGhzOyBpKysgKXtcbiAgICAgICAgdmFyIGRlcHRoID0gZGVwdGhzW2ldO1xuXG4gICAgICAgIHZhciBuRGVwdGggPSBkZXB0aC5sZW5ndGg7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbkRlcHRoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZGVwdGhbal07XG4gICAgICAgICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICAgICAgdmFyIGludEVsZSA9IGludGVyc2VjdHNEZXB0aChlbGUpO1xuXG4gICAgICAgICAgaWYoIGludEVsZSApe1xuICAgICAgICAgICAgaW5mby5pbnRFbGUgPSBpbnRFbGU7XG4gICAgICAgICAgICBlbGVzVG9Nb3ZlLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb01vdmUubGVuZ3RoOyBpKysgKXsgXG4gICAgICAgIHZhciBlbGUgPSBlbGVzVG9Nb3ZlW2ldO1xuICAgICAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgICAgdmFyIGludEVsZSA9IGluZm8uaW50RWxlO1xuICAgICAgICB2YXIgaW50SW5mbyA9IGludEVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcblxuICAgICAgICBkZXB0aHNbIGluZm8uZGVwdGggXS5zcGxpY2UoIGluZm8uaW5kZXgsIDEgKTsgLy8gcmVtb3ZlIGZyb20gb2xkIGRlcHRoICYgaW5kZXhcblxuICAgICAgICAvLyBhZGQgdG8gZW5kIG9mIG5ldyBkZXB0aFxuICAgICAgICB2YXIgbmV3RGVwdGggPSBpbnRJbmZvLmRlcHRoICsgMTtcbiAgICAgICAgd2hpbGUoIG5ld0RlcHRoID4gZGVwdGhzLmxlbmd0aCAtIDEgKXtcbiAgICAgICAgICBkZXB0aHMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGhzWyBuZXdEZXB0aCBdLnB1c2goIGVsZSApO1xuXG4gICAgICAgIGluZm8uZGVwdGggPSBuZXdEZXB0aDtcbiAgICAgICAgaW5mby5pbmRleCA9IGRlcHRoc1tuZXdEZXB0aF0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG4gICAgfVxuXG4gICAgLy8gZmluZCBtaW4gZGlzdGFuY2Ugd2UgbmVlZCB0byBsZWF2ZSBiZXR3ZWVuIG5vZGVzXG4gICAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgICBpZiggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHcgPSBub2Rlc1tpXS5vdXRlcldpZHRoKCk7XG4gICAgICAgIHZhciBoID0gbm9kZXNbaV0ub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgXG4gICAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICAgICAgfVxuICAgICAgbWluRGlzdGFuY2UgKj0gMS43NTsgLy8ganVzdCB0byBoYXZlIHNvbWUgbmljZSBzcGFjaW5nXG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB3ZWlnaHRlZCBwZXJjZW50IGZvciBhbiBlbGVtZW50IGJhc2VkIG9uIGl0cyBjb25uZWN0aXZpdHkgdG8gb3RoZXIgbGV2ZWxzXG4gICAgdmFyIGNhY2hlZFdlaWdodGVkUGVyY2VudCA9IHt9O1xuICAgIHZhciBnZXRXZWlnaHRlZFBlcmNlbnQgPSBmdW5jdGlvbiggZWxlICl7XG4gICAgICBpZiggY2FjaGVkV2VpZ2h0ZWRQZXJjZW50WyBlbGUuaWQoKSBdICl7XG4gICAgICAgIHJldHVybiBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF07XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVEZXB0aCA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdC5kZXB0aDtcbiAgICAgIHZhciBuZWlnaGJvcnMgPSBlbGUubmVpZ2hib3Job29kKCkubm9kZXMoKTtcbiAgICAgIHZhciBwZXJjZW50ID0gMDtcbiAgICAgIHZhciBzYW1wbGVzID0gMDtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2ldO1xuICAgICAgICB2YXIgaW5kZXggPSBuZWlnaGJvci5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdC5pbmRleDtcbiAgICAgICAgdmFyIGRlcHRoID0gbmVpZ2hib3IuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3QuZGVwdGg7XG4gICAgICAgIHZhciBuRGVwdGggPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgICAgICBpZiggZWxlRGVwdGggPiBkZXB0aCB8fCBlbGVEZXB0aCA9PT0gMCApeyAvLyBvbmx5IGdldCBpbmZsdWVuY2VkIGJ5IGVsZW1lbnRzIGFib3ZlXG4gICAgICAgICAgcGVyY2VudCArPSBpbmRleCAvIG5EZXB0aDtcbiAgICAgICAgICBzYW1wbGVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2FtcGxlcyA9IE1hdGgubWF4KDEsIHNhbXBsZXMpO1xuICAgICAgcGVyY2VudCA9IHBlcmNlbnQgLyBzYW1wbGVzO1xuXG4gICAgICBpZiggc2FtcGxlcyA9PT0gMCApeyAvLyBzbyBsb25lIG5vZGVzIGhhdmUgYSBcImRvbid0IGNhcmVcIiBzdGF0ZSBpbiBzb3J0aW5nXG4gICAgICAgIHBlcmNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlZFdlaWdodGVkUGVyY2VudFsgZWxlLmlkKCkgXSA9IHBlcmNlbnQ7XG4gICAgICByZXR1cm4gcGVyY2VudDtcbiAgICB9O1xuXG5cbiAgICAvLyByZWFycmFuZ2UgdGhlIGluZGljZXMgaW4gZWFjaCBkZXB0aCBsZXZlbCBiYXNlZCBvbiBjb25uZWN0aXZpdHlcblxuICAgIHZhciBzb3J0Rm4gPSBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHZhciBhcGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KCBhICk7XG4gICAgICB2YXIgYnBjdCA9IGdldFdlaWdodGVkUGVyY2VudCggYiApO1xuXG4gICAgICByZXR1cm4gYXBjdCAtIGJwY3Q7XG4gICAgfTtcblxuICAgIGZvciggdmFyIHRpbWVzID0gMDsgdGltZXMgPCAzOyB0aW1lcysrICl7IC8vIGRvIGl0IGEgZmV3IHRpbWVzIGIvYyB0aGUgZGVwdGhzIGFyZSBkeW5hbWljIGFuZCB3ZSB3YW50IGEgbW9yZSBzdGFibGUgcmVzdWx0XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGRlcHRoc1tpXSA9IGRlcHRoc1tpXS5zb3J0KCBzb3J0Rm4gKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbkRlcHRoc1RvRWxlcygpOyAvLyBhbmQgdXBkYXRlXG5cbiAgICB9XG5cbiAgICB2YXIgYmlnZ2VzdERlcHRoU2l6ZSA9IDA7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGJpZ2dlc3REZXB0aFNpemUgPSBNYXRoLm1heCggZGVwdGhzW2ldLmxlbmd0aCwgYmlnZ2VzdERlcHRoU2l6ZSApO1xuICAgIH1cblxuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICB4OiBiYi54MSArIGJiLncvMixcbiAgICAgIHk6IGJiLngxICsgYmIuaC8yXG4gICAgfTtcbiAgIFxuICAgIHZhciBnZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCBlbGUsIGlzQm90dG9tRGVwdGggKXtcbiAgICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGRlcHRoID0gaW5mby5kZXB0aDtcbiAgICAgIHZhciBpbmRleCA9IGluZm8uaW5kZXg7XG4gICAgICB2YXIgZGVwdGhTaXplID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG5cbiAgICAgIGlmKCBvcHRpb25zLnN0cmljdEhpZXJhcmNoeSApe1xuICAgICAgICBkZXB0aFNpemUgPSBiaWdnZXN0RGVwdGhTaXplO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlzdGFuY2VYID0gTWF0aC5tYXgoIGJiLncgLyAoZGVwdGhTaXplICsgMSksIG1pbkRpc3RhbmNlICk7XG4gICAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5tYXgoIGJiLmggLyAoZGVwdGhzLmxlbmd0aCArIDEpLCBtaW5EaXN0YW5jZSApO1xuICAgICAgdmFyIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5taW4oIGJiLncgLyAyIC8gZGVwdGhzLmxlbmd0aCwgYmIuaCAvIDIgLyBkZXB0aHMubGVuZ3RoICk7XG4gICAgICByYWRpdXNTdGVwU2l6ZSA9IE1hdGgubWF4KCByYWRpdXNTdGVwU2l6ZSwgbWluRGlzdGFuY2UgKTtcblxuICAgICAgaWYoIG9wdGlvbnMuc3RyaWN0SGllcmFyY2h5ICYmICFvcHRpb25zLmNpcmNsZSApe1xuICAgICAgICBcbiAgICAgICAgdmFyIGVwb3MgPSB7XG4gICAgICAgICAgeDogY2VudGVyLnggKyAoaW5kZXggKyAxIC0gKGRlcHRoU2l6ZSArIDEpLzIpICogZGlzdGFuY2VYLFxuICAgICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYoIGlzQm90dG9tRGVwdGggKXtcbiAgICAgICAgICByZXR1cm4gZXBvcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWNjcyA9IHN1Y2Nlc3NvcnNbIGVsZS5pZCgpIF07XG4gICAgICAgIGlmKCBzdWNjcyApe1xuICAgICAgICAgIGVwb3MueCA9IDA7XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMCA7IGkgPCBzdWNjcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIHNwb3MgPSBwb3NbIHN1Y2NzW2ldLmlkKCkgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZXBvcy54ICs9IHNwb3MueDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcG9zLnggLz0gc3VjY3MubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vZGVidWdnZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXBvcztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIG9wdGlvbnMuY2lyY2xlICl7XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c1N0ZXBTaXplICogZGVwdGggKyByYWRpdXNTdGVwU2l6ZSAtIChkZXB0aHMubGVuZ3RoID4gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoIDw9IDMgPyByYWRpdXNTdGVwU2l6ZS8yIDogMCk7XG4gICAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbZGVwdGhdLmxlbmd0aCAqIGluZGV4O1xuXG4gICAgICAgICAgaWYoIGRlcHRoID09PSAwICYmIGRlcHRoc1swXS5sZW5ndGggPT09IDEgKXtcbiAgICAgICAgICAgIHJhZGl1cyA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54ICsgcmFkaXVzICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICAgICAgeTogY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKS8yKSAqIGRpc3RhbmNlWCxcbiAgICAgICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfTtcblxuICAgIC8vIGdldCBwb3NpdGlvbnMgaW4gcmV2ZXJzZSBkZXB0aCBvcmRlclxuICAgIHZhciBwb3MgPSB7fTtcbiAgICBmb3IoIHZhciBpID0gZGVwdGhzLmxlbmd0aCAtIDE7IGkgPj0wOyBpLS0gKXtcbiAgICAgIHZhciBkZXB0aCA9IGRlcHRoc1tpXTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBkZXB0aC5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgbm9kZSA9IGRlcHRoW2pdO1xuXG4gICAgICAgIHBvc1sgbm9kZS5pZCgpIF0gPSBnZXRQb3NpdGlvbiggbm9kZSwgaSA9PT0gZGVwdGhzLmxlbmd0aCAtIDEgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBwb3NbIHRoaXMuaWQoKSBdO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdicmVhZHRoZmlyc3QnLCBCcmVhZHRoRmlyc3RMYXlvdXQpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCwgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBhbmQgcmFkaXVzIGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgICByYWRpdXM6IHVuZGVmaW5lZCwgLy8gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAgc3RhcnRBbmdsZTogMy8yICogTWF0aC5QSSwgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBub2RlXG4gICAgY291bnRlcmNsb2Nrd2lzZTogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY291bnRlcmNsb2Nrd2lzZSAodHJ1ZSkgb3IgY2xvY2t3aXNlIChmYWxzZSlcbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gQ2lyY2xlTGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgQ2lyY2xlTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgXG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgICAgXG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgIFxuICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICB9ICk7XG5cbiAgICB2YXIgY2VudGVyID0ge1xuICAgICAgeDogYmIueDEgKyBiYi53LzIsXG4gICAgICB5OiBiYi55MSArIGJiLmgvMlxuICAgIH07XG4gICAgXG4gICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlO1xuICAgIHZhciBkVGhldGEgPSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgcjtcblxuICAgIHZhciBtaW5EaXN0YW5jZSA9IDA7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHcgPSBub2Rlc1tpXS5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgaCA9IG5vZGVzW2ldLm91dGVySGVpZ2h0KCk7XG4gICAgICBcbiAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICAgIH1cblxuICAgIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5yYWRpdXMpICl7XG4gICAgICByID0gb3B0aW9ucy5yYWRpdXM7XG4gICAgfSBlbHNlIGlmKCBub2Rlcy5sZW5ndGggPD0gMSApe1xuICAgICAgciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBNYXRoLm1pbiggYmIuaCwgYmIudyApLzIgLSBtaW5EaXN0YW5jZTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuICAgIGlmKCBub2Rlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgIG1pbkRpc3RhbmNlICo9IDEuNzU7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuXG4gICAgICB2YXIgZFRoZXRhID0gMiAqIE1hdGguUEkgLyBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgZGNvcyA9IE1hdGguY29zKGRUaGV0YSkgLSBNYXRoLmNvcygwKTtcbiAgICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQoIG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UgLyAoIGRjb3MqZGNvcyArIGRzaW4qZHNpbiApICk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcbiAgICAgIHIgPSBNYXRoLm1heCggck1pbiwgciApO1xuICAgIH1cblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiggaSwgZWxlICl7XG4gICAgICB2YXIgcnggPSByICogTWF0aC5jb3MoIHRoZXRhICk7XG4gICAgICB2YXIgcnkgPSByICogTWF0aC5zaW4oIHRoZXRhICk7XG4gICAgICB2YXIgcG9zID0ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHJ4LFxuICAgICAgICB5OiBjZW50ZXIueSArIHJ5XG4gICAgICB9O1xuXG4gICAgICB0aGV0YSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA/IHRoZXRhIC0gZFRoZXRhIDogdGhldGEgKyBkVGhldGE7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdjaXJjbGUnLCBDaXJjbGVMYXlvdXQpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBhbmltYXRlOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHNob3cgdGhlIGxheW91dCBhcyBpdCdzIHJ1bm5pbmdcbiAgICByZWZyZXNoOiAxLCAvLyBudW1iZXIgb2YgdGlja3MgcGVyIGZyYW1lOyBoaWdoZXIgaXMgZmFzdGVyIGJ1dCBtb3JlIGplcmt5XG4gICAgbWF4U2ltdWxhdGlvblRpbWU6IDQwMDAsIC8vIG1heCBsZW5ndGggaW4gbXMgdG8gcnVuIHRoZSBsYXlvdXRcbiAgICB1bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmc6IGZhbHNlLCAvLyBzbyB5b3UgY2FuJ3QgZHJhZyBub2RlcyBkdXJpbmcgbGF5b3V0XG4gICAgZml0OiB0cnVlLCAvLyBvbiBldmVyeSBsYXlvdXQgcmVwb3NpdGlvbiBvZiBub2RlcywgZml0IHRoZSB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIGFyb3VuZCB0aGUgc2ltdWxhdGlvblxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuXG4gICAgLy8gbGF5b3V0IGV2ZW50IGNhbGxiYWNrc1xuICAgIHJlYWR5OiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogZnVuY3Rpb24oKXt9LCAvLyBvbiBsYXlvdXRzdG9wXG5cbiAgICAvLyBwb3NpdGlvbmluZyBvcHRpb25zXG4gICAgcmFuZG9taXplOiBmYWxzZSwgLy8gdXNlIHJhbmRvbSBub2RlIHBvc2l0aW9ucyBhdCBiZWdpbm5pbmcgb2YgbGF5b3V0XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBpZiB0cnVlLCBwcmV2ZW50cyBvdmVybGFwIG9mIG5vZGUgYm91bmRpbmcgYm94ZXNcbiAgICBoYW5kbGVEaXNjb25uZWN0ZWQ6IHRydWUsIC8vIGlmIHRydWUsIGF2b2lkcyBkaXNjb25uZWN0ZWQgY29tcG9uZW50cyBmcm9tIG92ZXJsYXBwaW5nXG4gICAgbm9kZVNwYWNpbmc6IGZ1bmN0aW9uKCBub2RlICl7IHJldHVybiAxMDsgfSwgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXNcbiAgICBmbG93OiB1bmRlZmluZWQsIC8vIHVzZSBEQUcvdHJlZSBmbG93IGxheW91dCBpZiBzcGVjaWZpZWQsIGUuZy4geyBheGlzOiAneScsIG1pblNlcGFyYXRpb246IDMwIH1cbiAgICBhbGlnbm1lbnQ6IHVuZGVmaW5lZCwgLy8gcmVsYXRpdmUgYWxpZ25tZW50IGNvbnN0cmFpbnRzIG9uIG5vZGVzLCBlLmcuIGZ1bmN0aW9uKCBub2RlICl7IHJldHVybiB7IHg6IDAsIHk6IDEgfSB9XG5cbiAgICAvLyBkaWZmZXJlbnQgbWV0aG9kcyBvZiBzcGVjaWZ5aW5nIGVkZ2UgbGVuZ3RoXG4gICAgLy8gZWFjaCBjYW4gYmUgYSBjb25zdGFudCBudW1lcmljYWwgdmFsdWUgb3IgYSBmdW5jdGlvbiBsaWtlIGBmdW5jdGlvbiggZWRnZSApeyByZXR1cm4gMjsgfWBcbiAgICBlZGdlTGVuZ3RoOiB1bmRlZmluZWQsIC8vIHNldHMgZWRnZSBsZW5ndGggZGlyZWN0bHkgaW4gc2ltdWxhdGlvblxuICAgIGVkZ2VTeW1EaWZmTGVuZ3RoOiB1bmRlZmluZWQsIC8vIHN5bW1ldHJpYyBkaWZmIGVkZ2UgbGVuZ3RoIGluIHNpbXVsYXRpb25cbiAgICBlZGdlSmFjY2FyZExlbmd0aDogdW5kZWZpbmVkLCAvLyBqYWNjYXJkIGVkZ2UgbGVuZ3RoIGluIHNpbXVsYXRpb25cblxuICAgIC8vIGl0ZXJhdGlvbnMgb2YgY29sYSBhbGdvcml0aG07IHVzZXMgZGVmYXVsdCB2YWx1ZXMgb24gdW5kZWZpbmVkXG4gICAgdW5jb25zdHJJdGVyOiB1bmRlZmluZWQsIC8vIHVuY29uc3RyYWluZWQgaW5pdGlhbCBsYXlvdXQgaXRlcmF0aW9uc1xuICAgIHVzZXJDb25zdEl0ZXI6IHVuZGVmaW5lZCwgLy8gaW5pdGlhbCBsYXlvdXQgaXRlcmF0aW9ucyB3aXRoIHVzZXItc3BlY2lmaWVkIGNvbnN0cmFpbnRzXG4gICAgYWxsQ29uc3RJdGVyOiB1bmRlZmluZWQsIC8vIGluaXRpYWwgbGF5b3V0IGl0ZXJhdGlvbnMgd2l0aCBhbGwgY29uc3RyYWludHMgaW5jbHVkaW5nIG5vbi1vdmVybGFwXG5cbiAgICAvLyBpbmZpbml0ZSBsYXlvdXQgb3B0aW9uc1xuICAgIGluZmluaXRlOiBmYWxzZSAvLyBvdmVycmlkZXMgYWxsIG90aGVyIG9wdGlvbnMgZm9yIGEgZm9yY2VzLWFsbC10aGUtdGltZSBtb2RlXG4gIH07XG5cbiAgLy8gY29uc3RydWN0b3JcbiAgLy8gb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gIGZ1bmN0aW9uIENvbGFMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpOyBcbiAgfVxuXG4gIC8vIHJ1bnMgdGhlIGxheW91dFxuICBDb2xhTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgJCQudXRpbC5yZXF1aXJlKCdjb2xhJywgZnVuY3Rpb24oY29sYSl7XG5cbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7IC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICAgICAgdmFyIGVkZ2VzID0gZWxlcy5lZGdlcygpO1xuICAgICAgdmFyIHJlYWR5ID0gZmFsc2U7XG4gICAgICBcbiAgICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgfSApO1xuXG4gICAgICB2YXIgZ2V0T3B0VmFsID0gZnVuY3Rpb24oIHZhbCwgZWxlICl7XG4gICAgICAgIGlmKCAkJC5pcy5mbih2YWwpICl7XG4gICAgICAgICAgdmFyIGZuID0gdmFsO1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseSggZWxlLCBbIGVsZSBdICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHVwZGF0ZU5vZGVQb3NpdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgeCA9IHsgbWluOiBJbmZpbml0eSwgbWF4OiAtSW5maW5pdHkgfTtcbiAgICAgICAgdmFyIHkgPSB7IG1pbjogSW5maW5pdHksIG1heDogLUluZmluaXR5IH07XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIHNjcmF0Y2ggPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcblxuICAgICAgICAgIHgubWluID0gTWF0aC5taW4oIHgubWluLCBzY3JhdGNoLnggKTtcbiAgICAgICAgICB4Lm1heCA9IE1hdGgubWF4KCB4Lm1heCwgc2NyYXRjaC54ICk7XG5cbiAgICAgICAgICB5Lm1pbiA9IE1hdGgubWluKCB5Lm1pbiwgc2NyYXRjaC55ICk7XG4gICAgICAgICAgeS5tYXggPSBNYXRoLm1heCggeS5tYXgsIHNjcmF0Y2gueSApO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZXMucG9zaXRpb25zKGZ1bmN0aW9uKGksIG5vZGUpe1xuICAgICAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBzY3JhdGNoID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG5cbiAgICAgICAgICBpZiggIW5vZGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICBwb3MueCA9IGJiLngxICsgc2NyYXRjaC54IC0geC5taW47XG4gICAgICAgICAgICBwb3MueSA9IGJiLnkxICsgc2NyYXRjaC55IC0geS5taW47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiggIXJlYWR5ICl7XG4gICAgICAgICAgb25SZWFkeSgpO1xuICAgICAgICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBvbkRvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBsYXlvdXQubWFudWFsbHlTdG9wcGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgICAgZ3JhYmJhYmxlTm9kZXMuZ3JhYmlmeSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZXMub2ZmKCdncmFiIGZyZWUgcG9zaXRpb24nLCBncmFiSGFuZGxlcik7XG4gICAgICAgIG5vZGVzLm9mZignbG9jayB1bmxvY2snLCBsb2NrSGFuZGxlcik7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBvblJlYWR5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gdHJpZ2dlciBsYXlvdXRyZWFkeSB3aGVuIGVhY2ggbm9kZSBoYXMgaGFkIGl0cyBwb3NpdGlvbiBzZXQgYXQgbGVhc3Qgb25jZVxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIHRpY2tzUGVyRnJhbWUgPSBvcHRpb25zLnJlZnJlc2g7XG4gICAgICB2YXIgdGlja1NraXAgPSAxOyAvLyBmcmFtZXMgdW50aWwgYSB0aWNrOyB1c2VkIHRvIHNsb3cgZG93biBzaW0gZm9yIGRlYnVnZ2luZ1xuXG4gICAgICBpZiggb3B0aW9ucy5yZWZyZXNoIDwgMCApe1xuICAgICAgICB0aWNrU2tpcCA9IE1hdGguYWJzKCBvcHRpb25zLnJlZnJlc2ggKTtcbiAgICAgICAgdGlja3NQZXJGcmFtZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWNrc1BlckZyYW1lID0gTWF0aC5tYXgoIDEsIHRpY2tzUGVyRnJhbWUgKTsgLy8gYXQgbGVhc3QgMVxuICAgICAgfVxuXG4gICAgICB2YXIgYWRhcHRvciA9IGNvbGEuYWRhcHRvcih7XG4gICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKCBlICl7IC8vIG9uIHNpbSBldmVudFxuICAgICAgICAgIHN3aXRjaCggZS50eXBlICl7XG4gICAgICAgICAgICBjYXNlICd0aWNrJzpcbiAgICAgICAgICAgICAgaWYoIG9wdGlvbnMuYW5pbWF0ZSApe1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZW5kJzogXG4gICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoKTtcbiAgICAgICAgICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlIHx8IGxheW91dC5tYW51YWxseVN0b3BwZWQgKXsgb25Eb25lKCk7IH0gICAgICAgICAgIFxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAga2ljazogZnVuY3Rpb24oIHRpY2sgKXsgLy8ga2ljayBvZmYgdGhlIHNpbXVsYXRpb25cbiAgICAgICAgICB2YXIgc2tpcCA9IDA7XG5cbiAgICAgICAgICB2YXIgaW5mdGljayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgcmV0ID0gdGljaygpO1xuXG4gICAgICAgICAgICBpZiggcmV0ICYmIG9wdGlvbnMuaW5maW5pdGUgKXsgLy8gcmVzdW1lIGxheW91dCBpZiBkb25lXG4gICAgICAgICAgICAgIGFkYXB0b3IucmVzdW1lKCk7IC8vIHJlc3VtZSA9PiBuZXcga2lja1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcmV0OyAvLyBhbGxvdyByZWd1bGFyIGZpbmlzaCBiL2Mgb2YgbmV3IGtpY2tcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIG11bHRpdGljayA9IGZ1bmN0aW9uKCl7IC8vIG11bHRpcGxlIHRpY2tzIGluIGEgcm93XG4gICAgICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgICAgICAvLyBza2lwIHRpY2tzIHRvIHNsb3cgZG93biBsYXlvdXQgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgdmFyIHRoaXNTa2lwID0gc2tpcDtcbiAgICAgICAgICAgIHNraXAgPSAoc2tpcCArIDEpICUgdGlja1NraXA7XG4gICAgICAgICAgICBpZiggdGhpc1NraXAgIT09IDAgKXtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRpY2tzUGVyRnJhbWUgJiYgIXJldDsgaSsrICl7XG4gICAgICAgICAgICAgIHJldCA9IHJldCB8fCBpbmZ0aWNrKCk7IC8vIHBpY2sgdXAgdHJ1ZSByZXQgdmFscyA9PiBzaW0gZG9uZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiggb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZiggbXVsdGl0aWNrKCkgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZyYW1lICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnJhbWUgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUoICFpbmZ0aWNrKCkgKXt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uOiBmdW5jdGlvbiggdHlwZSwgbGlzdGVuZXIgKXt9LCAvLyBkdW1teTsgbm90IG5lZWRlZFxuXG4gICAgICAgIGRyYWc6IGZ1bmN0aW9uKCl7fSAvLyBUT0RPXG4gICAgICB9KTtcbiAgICAgIGxheW91dC5hZGFwdG9yID0gYWRhcHRvcjtcblxuICAgICAgLy8gaWYgc2V0IG5vIGdyYWJiaW5nIGR1cmluZyBsYXlvdXRcbiAgICAgIHZhciBncmFiYmFibGVOb2RlcyA9IG5vZGVzLmZpbHRlcignOmdyYWJiYWJsZScpO1xuICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgIGdyYWJiYWJsZU5vZGVzLnVuZ3JhYmlmeSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgbm9kZSBkcmFnZ2luZ1xuICAgICAgdmFyIGdyYWJIYW5kbGVyO1xuICAgICAgbm9kZXMub24oJ2dyYWIgZnJlZSBwb3NpdGlvbicsIGdyYWJIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHZhciBub2RlID0gdGhpcztcbiAgICAgICAgdmFyIHNjckNvbGEgPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgICAgaWYoIG5vZGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgc2NyQ29sYS54ID0gcG9zLnggLSBiYi54MTtcbiAgICAgICAgICBzY3JDb2xhLnkgPSBwb3MueSAtIGJiLnkxO1xuXG4gICAgICAgICAgYWRhcHRvci5kcmFnc3RhcnQoIHNjckNvbGEgKTtcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoc2NyQ29sYS54KSAmJiAkJC5pcy5udW1iZXIoc2NyQ29sYS55KSApe1xuICAgICAgICAgIHBvcy54ID0gc2NyQ29sYS54ICsgYmIueDE7XG4gICAgICAgICAgcG9zLnkgPSBzY3JDb2xhLnkgKyBiYi55MTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCggZS50eXBlICl7XG4gICAgICAgICAgY2FzZSAnZ3JhYic6XG4gICAgICAgICAgICBhZGFwdG9yLmRyYWdzdGFydCggc2NyQ29sYSApO1xuICAgICAgICAgICAgYWRhcHRvci5yZXN1bWUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2ZyZWUnOlxuICAgICAgICAgICAgYWRhcHRvci5kcmFnZW5kKCBzY3JDb2xhICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbG9ja0hhbmRsZXI7XG4gICAgICBub2Rlcy5vbignbG9jayB1bmxvY2snLCBsb2NrSGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIHZhciBzY3JDb2xhID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG4gICAgICBcbiAgICAgICAgaWYoIG5vZGUubG9ja2VkKCkgKXtcbiAgICAgICAgICBhZGFwdG9yLmRyYWdzdGFydCggc2NyQ29sYSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkYXB0b3IuZHJhZ2VuZCggc2NyQ29sYSApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIG5vbnBhcmVudE5vZGVzID0gbm9kZXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIHJldHVybiAhbm9kZS5pc1BhcmVudCgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGFkZCBub2RlcyB0byBjb2xhXG4gICAgICBhZGFwdG9yLm5vZGVzKCBub25wYXJlbnROb2Rlcy5tYXAoZnVuY3Rpb24oIG5vZGUsIGkgKXtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBnZXRPcHRWYWwoIG9wdGlvbnMubm9kZVNwYWNpbmcsIG5vZGUgKTtcbiAgICAgICAgdmFyIHBvcyA9IG5vZGUucG9zaXRpb24oKTtcblxuICAgICAgICB2YXIgc3RydWN0ID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEgPSB7XG4gICAgICAgICAgeDogb3B0aW9ucy5yYW5kb21pemUgPyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIudyApIDogcG9zLngsXG4gICAgICAgICAgeTogb3B0aW9ucy5yYW5kb21pemUgPyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIuaCApIDogcG9zLnksXG4gICAgICAgICAgd2lkdGg6IG5vZGUub3V0ZXJXaWR0aCgpICsgMipwYWRkaW5nLFxuICAgICAgICAgIGhlaWdodDogbm9kZS5vdXRlckhlaWdodCgpICsgMipwYWRkaW5nLFxuICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICAgIH0pICk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmFsaWdubWVudCApeyAvLyB0aGVuIHNldCBhbGlnbm1lbnQgY29uc3RyYWludHNcblxuICAgICAgICB2YXIgb2Zmc2V0c1ggPSBbXTtcbiAgICAgICAgdmFyIG9mZnNldHNZID0gW107XG5cbiAgICAgICAgbm9ucGFyZW50Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICAgIHZhciBhbGlnbiA9IGdldE9wdFZhbCggb3B0aW9ucy5hbGlnbm1lbnQsIG5vZGUgKTtcbiAgICAgICAgICB2YXIgc2NyQ29sYSA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhO1xuICAgICAgICAgIHZhciBpbmRleCA9IHNjckNvbGEuaW5kZXg7XG5cbiAgICAgICAgICBpZiggIWFsaWduICl7IHJldHVybjsgfVxuXG4gICAgICAgICAgaWYoIGFsaWduLnggIT0gbnVsbCApe1xuICAgICAgICAgICAgb2Zmc2V0c1gucHVzaCh7XG4gICAgICAgICAgICAgIG5vZGU6IGluZGV4LFxuICAgICAgICAgICAgICBvZmZzZXQ6IGFsaWduLnhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhbGlnbi55ICE9IG51bGwgKXtcbiAgICAgICAgICAgIG9mZnNldHNZLnB1c2goe1xuICAgICAgICAgICAgICBub2RlOiBpbmRleCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBhbGlnbi55XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGFkZCBhbGlnbm1lbnQgY29uc3RyYWludHMgb24gbm9kZXNcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gW107XG5cbiAgICAgICAgaWYoIG9mZnNldHNYLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICBjb25zdHJhaW50cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdhbGlnbm1lbnQnLFxuICAgICAgICAgICAgYXhpczogJ3gnLFxuICAgICAgICAgICAgb2Zmc2V0czogb2Zmc2V0c1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvZmZzZXRzWS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYWxpZ25tZW50JyxcbiAgICAgICAgICAgIGF4aXM6ICd5JyxcbiAgICAgICAgICAgIG9mZnNldHM6IG9mZnNldHNZXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGFkYXB0b3IuY29uc3RyYWludHMoIGNvbnN0cmFpbnRzICk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGNvbXBvdW5kIG5vZGVzIHRvIGNvbGFcbiAgICAgIGFkYXB0b3IuZ3JvdXBzKCBub2Rlcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgcmV0dXJuIG5vZGUuaXNQYXJlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiggbm9kZSwgaSApeyAvLyBhZGQgYmFzaWMgZ3JvdXAgaW5jbCBsZWFmIG5vZGVzXG4gICAgICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhID0ge1xuICAgICAgICAgIGluZGV4OiBpLFxuXG4gICAgICAgICAgbGVhdmVzOiBub2RlLmNoaWxkcmVuKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKCBjaGlsZCApe1xuICAgICAgICAgICAgcmV0dXJuICFjaGlsZC5pc1BhcmVudCgpO1xuICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiggY2hpbGQgKXtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFswXS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEuaW5kZXg7XG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiggbm9kZSApeyAvLyBhZGQgc3ViZ3JvdXBzXG4gICAgICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhLmdyb3VwcyA9IG5vZGUuY2hpbGRyZW4oKS5zdGRGaWx0ZXIoZnVuY3Rpb24oIGNoaWxkICl7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkLmlzUGFyZW50KCk7XG4gICAgICAgIH0pLm1hcChmdW5jdGlvbiggY2hpbGQgKXtcbiAgICAgICAgICByZXR1cm4gY2hpbGQuX3ByaXZhdGUuc2NyYXRjaC5jb2xhLmluZGV4O1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG4gICAgICB9KSApO1xuXG4gICAgICAvLyBnZXQgdGhlIGVkZ2UgbGVuZ3RoIHNldHRpbmcgbWVjaGFuaXNtXG4gICAgICB2YXIgbGVuZ3RoO1xuICAgICAgdmFyIGxlbmd0aEZuTmFtZTtcbiAgICAgIGlmKCBvcHRpb25zLmVkZ2VMZW5ndGggIT0gbnVsbCApe1xuICAgICAgICBsZW5ndGggPSBvcHRpb25zLmVkZ2VMZW5ndGg7XG4gICAgICAgIGxlbmd0aEZuTmFtZSA9ICdsaW5rRGlzdGFuY2UnO1xuICAgICAgfSBlbHNlIGlmKCBvcHRpb25zLmVkZ2VTeW1EaWZmTGVuZ3RoICE9IG51bGwgKXtcbiAgICAgICAgbGVuZ3RoID0gb3B0aW9ucy5lZGdlU3ltRGlmZkxlbmd0aDtcbiAgICAgICAgbGVuZ3RoRm5OYW1lID0gJ3N5bW1ldHJpY0RpZmZMaW5rTGVuZ3Rocyc7XG4gICAgICB9IGVsc2UgaWYoIG9wdGlvbnMuZWRnZUphY2NhcmRMZW5ndGggIT0gbnVsbCApe1xuICAgICAgICBsZW5ndGggPSBvcHRpb25zLmVkZ2VKYWNjYXJkTGVuZ3RoO1xuICAgICAgICBsZW5ndGhGbk5hbWUgPSAnamFjY2FyZExpbmtMZW5ndGhzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbmd0aCA9IDEwMDtcbiAgICAgICAgbGVuZ3RoRm5OYW1lID0gJ2xpbmtEaXN0YW5jZSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGhHZXR0ZXIgPSBmdW5jdGlvbiggbGluayApe1xuICAgICAgICByZXR1cm4gbGluay5jYWxjTGVuZ3RoO1xuICAgICAgfTtcblxuICAgICAgLy8gYWRkIHRoZSBlZGdlcyB0byBjb2xhXG4gICAgICBhZGFwdG9yLmxpbmtzKCBlZGdlcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVkZ2UgKXtcbiAgICAgICAgcmV0dXJuICFlZGdlLnNvdXJjZSgpLmlzUGFyZW50KCkgJiYgIWVkZ2UudGFyZ2V0KCkuaXNQYXJlbnQoKTtcbiAgICAgIH0pLm1hcChmdW5jdGlvbiggZWRnZSwgaSApe1xuICAgICAgICB2YXIgYyA9IGVkZ2UuX3ByaXZhdGUuc2NyYXRjaC5jb2xhID0ge1xuICAgICAgICAgIHNvdXJjZTogZWRnZS5zb3VyY2UoKVswXS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEuaW5kZXgsXG4gICAgICAgICAgdGFyZ2V0OiBlZGdlLnRhcmdldCgpWzBdLl9wcml2YXRlLnNjcmF0Y2guY29sYS5pbmRleFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBsZW5ndGggIT0gbnVsbCApe1xuICAgICAgICAgIGMuY2FsY0xlbmd0aCA9IGdldE9wdFZhbCggbGVuZ3RoLCBlZGdlICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYztcbiAgICAgIH0pICk7XG5cbiAgICAgIGFkYXB0b3Iuc2l6ZShbIGJiLncsIGJiLmggXSk7XG5cbiAgICAgIGlmKCBsZW5ndGggIT0gbnVsbCApe1xuICAgICAgICBhZGFwdG9yWyBsZW5ndGhGbk5hbWUgXSggbGVuZ3RoR2V0dGVyICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgZmxvdyBvZiBjb2xhXG4gICAgICBpZiggb3B0aW9ucy5mbG93ICl7XG4gICAgICAgIHZhciBmbG93O1xuICAgICAgICB2YXIgZGVmQXhpcyA9ICd5JztcbiAgICAgICAgdmFyIGRlZk1pblNlcCA9IDUwO1xuXG4gICAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3B0aW9ucy5mbG93KSApe1xuICAgICAgICAgIGZsb3cgPSB7XG4gICAgICAgICAgICBheGlzOiBvcHRpb25zLmZsb3csXG4gICAgICAgICAgICBtaW5TZXBhcmF0aW9uOiBkZWZNaW5TZXBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLmZsb3cpICl7XG4gICAgICAgICAgZmxvdyA9IHtcbiAgICAgICAgICAgIGF4aXM6IGRlZkF4aXMsXG4gICAgICAgICAgICBtaW5TZXBhcmF0aW9uOiBvcHRpb25zLmZsb3dcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMuZmxvdykgKXtcbiAgICAgICAgICBmbG93ID0gb3B0aW9ucy5mbG93O1xuXG4gICAgICAgICAgZmxvdy5heGlzID0gZmxvdy5heGlzIHx8IGRlZkF4aXM7XG4gICAgICAgICAgZmxvdy5taW5TZXBhcmF0aW9uID0gZmxvdy5taW5TZXBhcmF0aW9uICE9IG51bGwgPyBmbG93Lm1pblNlcGFyYXRpb24gOiBkZWZNaW5TZXA7XG4gICAgICAgIH0gZWxzZSB7IC8vIGUuZy4gb3B0aW9ucy5mbG93OiB0cnVlXG4gICAgICAgICAgZmxvdyA9IHtcbiAgICAgICAgICAgIGF4aXM6IGRlZkF4aXMsXG4gICAgICAgICAgICBtaW5TZXBhcmF0aW9uOiBkZWZNaW5TZXBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgYWRhcHRvci5mbG93TGF5b3V0KCBmbG93LmF4aXMgLCBmbG93Lm1pblNlcGFyYXRpb24gKTtcbiAgICAgIH1cblxuICAgICAgYWRhcHRvclxuICAgICAgICAuYXZvaWRPdmVybGFwcyggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKVxuICAgICAgICAuaGFuZGxlRGlzY29ubmVjdGVkKCBvcHRpb25zLmhhbmRsZURpc2Nvbm5lY3RlZCApXG4gICAgICAgIC5zdGFydCggb3B0aW9ucy51bmNvbnN0ckl0ZXIsIG9wdGlvbnMudXNlckNvbnN0SXRlciwgb3B0aW9ucy5hbGxDb25zdEl0ZXIpXG4gICAgICA7XG5cbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgIGlmKCAhb3B0aW9ucy5pbmZpbml0ZSApe1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgYWRhcHRvci5zdG9wKCk7XG4gICAgICAgIH0sIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUpO1xuICAgICAgfVxuXG4gICAgfSk7IC8vIHJlcXVpcmVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICBDb2xhTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICBpZiggdGhpcy5hZGFwdG9yICl7XG4gICAgICB0aGlzLm1hbnVhbGx5U3RvcHBlZCA9IHRydWU7XG4gICAgICB0aGlzLmFkYXB0b3Iuc3RvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIHJlZ2lzdGVyIHRoZSBsYXlvdXRcbiAgJCQoJ2xheW91dCcsICdjb2xhJywgQ29sYUxheW91dCk7XG5cbn0pKGN5dG9zY2FwZSk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLCAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgICBzdGFydEFuZ2xlOiAzLzIgKiBNYXRoLlBJLCAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG5vZGVcbiAgICBjb3VudGVyY2xvY2t3aXNlOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKHRydWUpIG9yIGNsb2Nrd2lzZSAoZmFsc2UpXG4gICAgbWluTm9kZVNwYWNpbmc6IDEwLCAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIGhlaWdodDogdW5kZWZpbmVkLCAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICAgIHdpZHRoOiB1bmRlZmluZWQsIC8vIHdpZHRoIG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIHdpZHRoKVxuICAgIGNvbmNlbnRyaWM6IGZ1bmN0aW9uKCl7IC8vIHJldHVybnMgbnVtZXJpYyB2YWx1ZSBmb3IgZWFjaCBub2RlLCBwbGFjaW5nIGhpZ2hlciBub2RlcyBpbiBsZXZlbHMgdG93YXJkcyB0aGUgY2VudHJlXG4gICAgICByZXR1cm4gdGhpcy5kZWdyZWUoKTtcbiAgICB9LFxuICAgIGxldmVsV2lkdGg6IGZ1bmN0aW9uKG5vZGVzKXsgLy8gdGhlIHZhcmlhdGlvbiBvZiBjb25jZW50cmljIHZhbHVlcyBpbiBlYWNoIGxldmVsXG4gICAgICByZXR1cm4gbm9kZXMubWF4RGVncmVlKCkgLyA0O1xuICAgIH0sXG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIENvbmNlbnRyaWNMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBDb25jZW50cmljTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIG9wdGlvbnMgPSBwYXJhbXM7XG4gICAgXG4gICAgdmFyIGN5ID0gcGFyYW1zLmN5O1xuICAgIFxuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICBcbiAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgfSApO1xuXG4gICAgdmFyIGNlbnRlciA9IHtcbiAgICAgIHg6IGJiLngxICsgYmIudy8yLFxuICAgICAgeTogYmIueTEgKyBiYi5oLzJcbiAgICB9O1xuICAgIFxuICAgIHZhciBub2RlVmFsdWVzID0gW107IC8vIHsgbm9kZSwgdmFsdWUgfVxuICAgIHZhciB0aGV0YSA9IG9wdGlvbnMuc3RhcnRBbmdsZTtcbiAgICB2YXIgbWF4Tm9kZVNpemUgPSAwO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIFxuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBub2RlIHZhbHVlXG4gICAgICB2YWx1ZSA9IG9wdGlvbnMuY29uY2VudHJpYy5jYWxsKG5vZGUpO1xuICAgICAgbm9kZVZhbHVlcy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBub2RlOiBub2RlXG4gICAgICB9KTtcblxuICAgICAgLy8gZm9yIHN0eWxlIG1hcHBpbmdcbiAgICAgIG5vZGUuX3ByaXZhdGUubGF5b3V0RGF0YS5jb25jZW50cmljID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gaW4gY2FzZSB3ZSB1c2VkIHRoZSBgY29uY2VudHJpY2AgaW4gc3R5bGVcbiAgICBub2Rlcy51cGRhdGVTdHlsZSgpO1xuXG4gICAgLy8gY2FsY3VsYXRlIG1heCBzaXplIG5vdyBiYXNlZCBvbiBwb3RlbnRpYWxseSB1cGRhdGVkIG1hcHBlcnNcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KCBtYXhOb2RlU2l6ZSwgbm9kZS5vdXRlcldpZHRoKCksIG5vZGUub3V0ZXJIZWlnaHQoKSApO1xuICAgIH1cblxuICAgIC8vIHNvcnQgbm9kZSB2YWx1ZXMgaW4gZGVzY3JlYXNpbmcgb3JkZXJcbiAgICBub2RlVmFsdWVzLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gICAgfSk7XG5cbiAgICB2YXIgbGV2ZWxXaWR0aCA9IG9wdGlvbnMubGV2ZWxXaWR0aCggbm9kZXMgKTtcblxuICAgIC8vIHB1dCB0aGUgdmFsdWVzIGludG8gbGV2ZWxzXG4gICAgdmFyIGxldmVscyA9IFsgW10gXTtcbiAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZVZhbHVlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHZhbCA9IG5vZGVWYWx1ZXNbaV07XG5cbiAgICAgIGlmKCBjdXJyZW50TGV2ZWwubGVuZ3RoID4gMCApe1xuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKCBjdXJyZW50TGV2ZWxbMF0udmFsdWUgLSB2YWwudmFsdWUgKTtcblxuICAgICAgICBpZiggZGlmZiA+PSBsZXZlbFdpZHRoICl7XG4gICAgICAgICAgY3VycmVudExldmVsID0gW107XG4gICAgICAgICAgbGV2ZWxzLnB1c2goIGN1cnJlbnRMZXZlbCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRMZXZlbC5wdXNoKCB2YWwgKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgcG9zaXRpb25zIGZyb20gbGV2ZWxzXG5cbiAgICB2YXIgcG9zID0ge307IC8vIGlkID0+IHBvc2l0aW9uXG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBtaW5EaXN0ID0gbWF4Tm9kZVNpemUgKyBvcHRpb25zLm1pbk5vZGVTcGFjaW5nOyAvLyBtaW4gZGlzdCBiZXR3ZWVuIG5vZGVzXG5cbiAgICBpZiggIW9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIHRoZW4gc3RyaWN0bHkgY29uc3RyYWluIHRvIGJiXG4gICAgICB2YXIgZmlyc3RMdmxIYXNNdWx0aSA9IGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1swXS5sZW5ndGggPiAxO1xuICAgICAgdmFyIG1heFIgPSAoIE1hdGgubWluKGJiLncsIGJiLmgpIC8gMiAtIG1pbkRpc3QgKTtcbiAgICAgIHZhciByU3RlcCA9IG1heFIgLyAoIGxldmVscy5sZW5ndGggKyBmaXJzdEx2bEhhc011bHRpID8gMSA6IDAgKTtcblxuICAgICAgbWluRGlzdCA9IE1hdGgubWluKCBtaW5EaXN0LCByU3RlcCApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICB2YXIgZFRoZXRhID0gMiAqIE1hdGguUEkgLyBsZXZlbC5sZW5ndGg7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gICAgICBpZiggbGV2ZWwubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCApeyAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQoIG1pbkRpc3QgKiBtaW5EaXN0IC8gKCBkY29zKmRjb3MgKyBkc2luKmRzaW4gKSApOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG4gICAgICAgIHIgPSBNYXRoLm1heCggck1pbiwgciApO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGxldmVsLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciB2YWwgPSBsZXZlbFtqXTtcbiAgICAgICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgKG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA/IDEgOiAtMSkgKiBkVGhldGEgKiBqO1xuXG4gICAgICAgIHZhciBwID0ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICB5OiBjZW50ZXIueSArIHIgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgICAgfTtcblxuICAgICAgICBwb3NbIHZhbC5ub2RlLmlkKCkgXSA9IHA7XG4gICAgICB9XG5cbiAgICAgIHIgKz0gbWluRGlzdDtcbiAgICAgIFxuICAgIH0gXG5cbiAgICAvLyBwb3NpdGlvbiB0aGUgbm9kZXNcbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpZCA9IHRoaXMuaWQoKTtcblxuICAgICAgcmV0dXJuIHBvc1tpZF07XG4gICAgfSk7XG4gIFxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdjb25jZW50cmljJywgQ29uY2VudHJpY0xheW91dCk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG4vKlxuICBUaGUgQ29TRSBsYXlvdXQgd2FzIHdyaXR0ZW4gYnkgR2VyYXJkbyBIdWNrLlxuXG4gIE1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG47KGZ1bmN0aW9uKCQkKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgREVCVUc7XG5cbiAgLyoqXG4gICAqIEBicmllZiA6ICBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gICAqL1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgICByZWFkeSAgICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgICBzdG9wICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8vIFdoZXRoZXIgdG8gYW5pbWF0ZSB3aGlsZSBydW5uaW5nIHRoZSBsYXlvdXRcbiAgICBhbmltYXRlICAgICAgICAgICAgIDogdHJ1ZSxcblxuICAgIC8vIE51bWJlciBvZiBpdGVyYXRpb25zIGJldHdlZW4gY29uc2VjdXRpdmUgc2NyZWVuIHBvc2l0aW9ucyB1cGRhdGUgKDAgLT4gb25seSB1cGRhdGVkIG9uIHRoZSBlbmQpXG4gICAgcmVmcmVzaCAgICAgICAgICAgICA6IDQsXG4gICAgXG4gICAgLy8gV2hldGhlciB0byBmaXQgdGhlIG5ldHdvcmsgdmlldyBhZnRlciB3aGVuIGRvbmVcbiAgICBmaXQgICAgICAgICAgICAgICAgIDogdHJ1ZSwgXG5cbiAgICAvLyBQYWRkaW5nIG9uIGZpdFxuICAgIHBhZGRpbmcgICAgICAgICAgICAgOiAzMCwgXG5cbiAgICAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBib3VuZGluZ0JveCAgICAgICAgIDogdW5kZWZpbmVkLFxuXG4gICAgLy8gV2hldGhlciB0byByYW5kb21pemUgbm9kZSBwb3NpdGlvbnMgb24gdGhlIGJlZ2lubmluZ1xuICAgIHJhbmRvbWl6ZSAgICAgICAgICAgOiB0cnVlLFxuICAgIFxuICAgIC8vIFdoZXRoZXIgdG8gdXNlIHRoZSBKUyBjb25zb2xlIHRvIHByaW50IGRlYnVnIG1lc3NhZ2VzXG4gICAgZGVidWcgICAgICAgICAgICAgICA6IGZhbHNlLFxuXG4gICAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICAgIG5vZGVSZXB1bHNpb24gICAgICAgOiA0MDAwMDAsXG4gICAgXG4gICAgLy8gTm9kZSByZXB1bHNpb24gKG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gICAgbm9kZU92ZXJsYXAgICAgICAgICA6IDEwLFxuICAgIFxuICAgIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICAgIGlkZWFsRWRnZUxlbmd0aCAgICAgOiAxMCxcbiAgICBcbiAgICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgICBlZGdlRWxhc3RpY2l0eSAgICAgIDogMTAwLFxuICAgIFxuICAgIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgICBuZXN0aW5nRmFjdG9yICAgICAgIDogNSwgXG4gICAgXG4gICAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gICAgZ3Jhdml0eSAgICAgICAgICAgICA6IDI1MCwgXG4gICAgXG4gICAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gICAgbnVtSXRlciAgICAgICAgICAgICA6IDEwMCxcbiAgICBcbiAgICAvLyBJbml0aWFsIHRlbXBlcmF0dXJlIChtYXhpbXVtIG5vZGUgZGlzcGxhY2VtZW50KVxuICAgIGluaXRpYWxUZW1wICAgICAgICAgOiAyMDAsXG4gICAgXG4gICAgLy8gQ29vbGluZyBmYWN0b3IgKGhvdyB0aGUgdGVtcGVyYXR1cmUgaXMgcmVkdWNlZCBiZXR3ZWVuIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnNcbiAgICBjb29saW5nRmFjdG9yICAgICAgIDogMC45NSwgXG4gICAgXG4gICAgLy8gTG93ZXIgdGVtcGVyYXR1cmUgdGhyZXNob2xkIChiZWxvdyB0aGlzIHBvaW50IHRoZSBsYXlvdXQgd2lsbCBlbmQpXG4gICAgbWluVGVtcCAgICAgICAgICAgICA6IDEuMFxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiAgICAgICA6IGNvbnN0cnVjdG9yXG4gICAqIEBhcmcgb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBDb3NlTGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpOyBcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IHJ1bnMgdGhlIGxheW91dFxuICAgKi9cbiAgQ29zZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGN5ICAgICAgPSBvcHRpb25zLmN5O1xuICAgIHZhciBsYXlvdXQgID0gdGhpcztcblxuICAgIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgLy8gU2V0IERFQlVHIC0gR2xvYmFsIHZhcmlhYmxlXG4gICAgaWYgKHRydWUgPT09IG9wdGlvbnMuZGVidWcpIHtcbiAgICAgIERFQlVHID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgREVCVUcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc3RhcnQgdGltZVxuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuICAgIHZhciBsYXlvdXRJbmZvID0gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKTtcbiAgICBcbiAgICAvLyBTaG93IExheW91dEluZm8gY29udGVudHMgaWYgZGVidWdnaW5nXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBwcmludExheW91dEluZm8obGF5b3V0SW5mbyk7XG4gICAgfVxuXG4gICAgLy8gSWYgcmVxdWlyZWQsIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9uc1xuICAgIGlmICh0cnVlID09PSBvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8sIGN5KTtcbiAgICB9XG5cbiAgICB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuXG4gICAgdmFyIG1haW5Mb29wID0gZnVuY3Rpb24oaSl7XG4gICAgICBpZiggbGF5b3V0LnN0b3BwZWQgKXtcbiAgICAgICAgbG9nRGVidWcoXCJMYXlvdXQgbWFudWFsbHkgc3RvcHBlZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIG9uZSBzdGVwIGluIHRoZSBwaGlzaWNhbCBzaW11bGF0aW9uXG4gICAgICBzdGVwKGxheW91dEluZm8sIGN5LCBvcHRpb25zLCBpKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRlbXBlcmF0dXJlXG4gICAgICBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlID0gbGF5b3V0SW5mby50ZW1wZXJhdHVyZSAqIG9wdGlvbnMuY29vbGluZ0ZhY3RvcjtcbiAgICAgIGxvZ0RlYnVnKFwiTmV3IHRlbXBlcmF0dXJlOiBcIiArIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuXG4gICAgICBpZiAobGF5b3V0SW5mby50ZW1wZXJhdHVyZSA8IG9wdGlvbnMubWluVGVtcCkge1xuICAgICAgICBsb2dEZWJ1ZyhcIlRlbXBlcmF0dXJlIGRyb3AgYmVsb3cgbWluaW11bSB0aHJlc2hvbGQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEZpdCB0aGUgZ3JhcGggaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5maXQpIHtcbiAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IGVuZCB0aW1lXG4gICAgICB2YXIgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIGNvbnNvbGUuaW5mbygnTGF5b3V0IHRvb2sgJyArIChlbmRUaW1lIC0gc3RhcnRUaW1lKSArICcgbXMnKTtcblxuICAgICAgLy8gTGF5b3V0IGhhcyBmaW5pc2hlZFxuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgfTtcblxuICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBmcmFtZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyIGYgPSAwO1xuICAgICAgICB2YXIgbG9vcFJldDtcbiAgICAgICAgd2hpbGUoIGYgPCBvcHRpb25zLnJlZnJlc2ggJiYgaSA8IG9wdGlvbnMubnVtSXRlciApe1xuICAgICAgICAgIHZhciBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICAgICAgaWYoIGxvb3BSZXQgPT09IGZhbHNlICl7IGJyZWFrOyB9XG5cbiAgICAgICAgICBmKys7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGxvb3BSZXQgIT09IGZhbHNlICYmIGkgKyAxIDwgb3B0aW9ucy5udW1JdGVyICkge1xuICAgICAgICAgICQkLnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmcmFtZSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZyYW1lICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5udW1JdGVyOyBpKyspIHtcbiAgICAgICAgaWYoIG1haW5Mb29wKGkpID09PSBmYWxzZSApeyBicmVhazsgfVxuICAgICAgfVxuXG4gICAgICBkb25lKCk7XG4gICAgfVxuICAgXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gICAqL1xuICBDb3NlTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICAgICA6IENyZWF0ZXMgYW4gb2JqZWN0IHdoaWNoIGlzIGNvbnRhaW5zIGFsbCB0aGUgZGF0YVxuICAgKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAgICogQGFyZyBjeSAgICA6IGN5dG9zY2FwZS5qcyBvYmplY3RcbiAgICogQHJldHVybiAgICA6IGxheW91dEluZm8gb2JqZWN0IGluaXRpYWxpemVkXG4gICAqL1xuICB2YXIgY3JlYXRlTGF5b3V0SW5mbyA9IGZ1bmN0aW9uKGN5LCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIHZhciBlZGdlcyA9IG9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICAgIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuXG4gICAgdmFyIGxheW91dEluZm8gICA9IHtcbiAgICAgIGxheW91dCAgICAgICA6IGxheW91dCxcbiAgICAgIGxheW91dE5vZGVzICA6IFtdLCBcbiAgICAgIGlkVG9JbmRleCAgICA6IHt9LFxuICAgICAgbm9kZVNpemUgICAgIDogbm9kZXMuc2l6ZSgpLFxuICAgICAgZ3JhcGhTZXQgICAgIDogW10sXG4gICAgICBpbmRleFRvR3JhcGggOiBbXSwgXG4gICAgICBsYXlvdXRFZGdlcyAgOiBbXSxcbiAgICAgIGVkZ2VTaXplICAgICA6IGVkZ2VzLnNpemUoKSxcbiAgICAgIHRlbXBlcmF0dXJlICA6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgICBjbGllbnRXaWR0aCAgOiBjeS53aWR0aCgpLFxuICAgICAgY2xpZW50SGVpZ2h0IDogY3kud2lkdGgoKSxcbiAgICAgIGJvdW5kaW5nQm94ICA6ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgICAgICAgICAgICAgICAgfSApXG4gICAgfTsgXG4gICAgXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgY3JlYXRpbmcgbGF5b3V0IG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciB0ZW1wTm9kZSAgICAgICAgPSB7fTtcbiAgICAgIHRlbXBOb2RlLmlkICAgICAgICAgPSBub2Rlc1tpXS5kYXRhKCdpZCcpO1xuICAgICAgdGVtcE5vZGUucGFyZW50SWQgICA9IG5vZGVzW2ldLmRhdGEoJ3BhcmVudCcpOyAgICAgIFxuICAgICAgdGVtcE5vZGUuY2hpbGRyZW4gICA9IFtdO1xuICAgICAgdGVtcE5vZGUucG9zaXRpb25YICA9IG5vZGVzW2ldLnBvc2l0aW9uKCd4Jyk7XG4gICAgICB0ZW1wTm9kZS5wb3NpdGlvblkgID0gbm9kZXNbaV0ucG9zaXRpb24oJ3knKTtcbiAgICAgIHRlbXBOb2RlLm9mZnNldFggICAgPSAwOyAgICAgIFxuICAgICAgdGVtcE5vZGUub2Zmc2V0WSAgICA9IDA7XG4gICAgICB0ZW1wTm9kZS5oZWlnaHQgICAgID0gbm9kZXNbaV0uaGVpZ2h0KCk7XG4gICAgICB0ZW1wTm9kZS53aWR0aCAgICAgID0gbm9kZXNbaV0ud2lkdGgoKTtcbiAgICAgIHRlbXBOb2RlLm1heFggICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblggKyB0ZW1wTm9kZS53aWR0aCAgLyAyO1xuICAgICAgdGVtcE5vZGUubWluWCAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWCAtIHRlbXBOb2RlLndpZHRoICAvIDI7XG4gICAgICB0ZW1wTm9kZS5tYXhZICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25ZICsgdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICAgIHRlbXBOb2RlLm1pblkgICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblkgLSB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgICAgdGVtcE5vZGUucGFkTGVmdCAgICA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLWxlZnQnXS5weFZhbHVlO1xuICAgICAgdGVtcE5vZGUucGFkUmlnaHQgICA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLXJpZ2h0J10ucHhWYWx1ZTtcbiAgICAgIHRlbXBOb2RlLnBhZFRvcCAgICAgPSBub2Rlc1tpXS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy10b3AnXS5weFZhbHVlO1xuICAgICAgdGVtcE5vZGUucGFkQm90dG9tICA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLWJvdHRvbSddLnB4VmFsdWU7XG4gICAgICBcbiAgICAgIC8vIEFkZCBuZXcgbm9kZVxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlcy5wdXNoKHRlbXBOb2RlKTtcbiAgICAgIC8vIEFkZCBlbnRyeSB0byBpZC1pbmRleCBtYXBcbiAgICAgIGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLmlkXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciBzdGFydCA9IDA7ICAgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcbiAgICB2YXIgZW5kICAgPSAtMTsgIC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gICAgdmFyIHRlbXBHcmFwaCA9IFtdO1xuXG4gICAgLy8gU2Vjb25kIHBhc3MgdG8gYWRkIGNoaWxkIGluZm9ybWF0aW9uIGFuZCBcbiAgICAvLyBpbml0aWFsaXplIHF1ZXVlIGZvciBoaWVyYXJjaGljYWwgdHJhdmVyc2FsXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIHZhciBwX2lkID0gbi5wYXJlbnRJZDtcbiAgICAgIC8vIENoZWNrIGlmIG5vZGUgbiBoYXMgYSBwYXJlbnQgbm9kZVxuICAgICAgaWYgKG51bGwgIT0gcF9pZCkge1xuICAgICAgLy8gQWRkIG5vZGUgSWQgdG8gcGFyZW50J3MgbGlzdCBvZiBjaGlsZHJlblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwX2lkXV0uY2hpbGRyZW4ucHVzaChuLmlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBhIG5vZGUgZG9lc24ndCBoYXZlIGEgcGFyZW50LCB0aGVuIGl0J3MgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHF1ZXVlWysrZW5kXSA9IG4uaWQ7XG4gICAgICB0ZW1wR3JhcGgucHVzaChuLmlkKTsgICAgXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCByb290IGdyYXBoIHRvIGdyYXBoU2V0XG4gICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKHRlbXBHcmFwaCk7XG5cbiAgICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLCBcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgICB2YXIgbm9kZV9pZCAgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICAgIHZhciBub2RlX2l4ICA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVfaWRdO1xuICAgICAgdmFyIG5vZGUgICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlX2l4XTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQWRkIGNoaWxkcmVuIG5vZGVzIGFzIGEgbmV3IGdyYXBoIHRvIGdyYXBoIHNldFxuICAgICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKGNoaWxkcmVuKTtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWUgcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgaW5kZXhUb0dyYXBoIG1hcFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykgeyAgICAgIFxuICAgICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JhcGgubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXTtcbiAgICAgIGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2luZGV4XSA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXMsIGNyZWF0aW5nIExheW91dCBFZGdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHRlbXBFZGdlID0ge307ICAgICAgXG4gICAgICB0ZW1wRWRnZS5pZCAgICAgICA9IGUuZGF0YSgnaWQnKTtcbiAgICAgIHRlbXBFZGdlLnNvdXJjZUlkID0gZS5kYXRhKCdzb3VyY2UnKTtcbiAgICAgIHRlbXBFZGdlLnRhcmdldElkID0gZS5kYXRhKCd0YXJnZXQnKTtcblxuICAgICAgLy8gQ29tcHV0ZSBpZGVhbCBsZW5ndGhcbiAgICAgIHZhciBpZGVhbExlbmd0aCA9IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuXG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGludGVyIGdyYXBoIGVkZ2VcbiAgICAgIHZhciBzb3VyY2VJeCAgICA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnNvdXJjZUlkXTtcbiAgICAgIHZhciB0YXJnZXRJeCAgICA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnRhcmdldElkXTtcbiAgICAgIHZhciBzb3VyY2VHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3NvdXJjZUl4XTtcbiAgICAgIHZhciB0YXJnZXRHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3RhcmdldEl4XTtcblxuICAgICAgaWYgKHNvdXJjZUdyYXBoICE9IHRhcmdldEdyYXBoKSB7XG4gICAgICAvLyBGaW5kIGxvd2VzdCBjb21tb24gZ3JhcGggYW5jZXN0b3JcbiAgICAgIHZhciBsY2EgPSBmaW5kTENBKHRlbXBFZGdlLnNvdXJjZUlkLCB0ZW1wRWRnZS50YXJnZXRJZCwgbGF5b3V0SW5mbyk7XG5cbiAgICAgIC8vIENvbXB1dGUgc3VtIG9mIG5vZGUgZGVwdGhzLCByZWxhdGl2ZSB0byBsY2EgZ3JhcGhcbiAgICAgIHZhciBsY2FHcmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbbGNhXTtcbiAgICAgIHZhciBkZXB0aCAgICA9IDA7XG5cbiAgICAgIC8vIFNvdXJjZSBkZXB0aFxuICAgICAgdmFyIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG4gICAgICB3aGlsZSAoLTEgPT09ICQuaW5BcnJheSh0ZW1wTm9kZS5pZCwgbGNhR3JhcGgpKSB7XG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5wYXJlbnRJZF1dO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBUYXJnZXQgZGVwdGhcbiAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG4gICAgICB3aGlsZSAoLTEgPT09ICQuaW5BcnJheSh0ZW1wTm9kZS5pZCwgbGNhR3JhcGgpKSB7XG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5wYXJlbnRJZF1dO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICBsb2dEZWJ1ZygnTENBIG9mIG5vZGVzICcgKyB0ZW1wRWRnZS5zb3VyY2VJZCArICcgYW5kICcgKyB0ZW1wRWRnZS50YXJnZXRJZCArICBcbiAgICAgICAgIFwiLiBJbmRleDogXCIgKyBsY2EgKyBcIiBDb250ZW50czogXCIgKyBsY2FHcmFwaC50b1N0cmluZygpICsgXG4gICAgICAgICBcIi4gRGVwdGg6IFwiICsgZGVwdGgpO1xuXG4gICAgICAvLyBVcGRhdGUgaWRlYWxMZW5ndGhcbiAgICAgIGlkZWFsTGVuZ3RoICo9IGRlcHRoICogb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICAgICAgfVxuXG4gICAgICB0ZW1wRWRnZS5pZGVhbExlbmd0aCA9IGlkZWFsTGVuZ3RoO1xuXG4gICAgICBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLnB1c2godGVtcEVkZ2UpO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIHJldHVybiBsYXlvdXRJbmZvIG9iamVjdFxuICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICB9O1xuXG4gIFxuICAvKipcbiAgICogQGJyaWVmIDogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxvd2VzdCBjb21tb24gXG4gICAqICAgICAgICAgIGdyYXBoIGFuY2VzdG9yIGJldHdlZW4gMiBub2RlcyBpbiB0aGUgc3VidHJlZSBcbiAgICogICAgICAgICAgKGZyb20gdGhlIGdyYXBoIGhpZXJhcmNoeSBpbmR1Y2VkIHRyZWUpIHdob3NlXG4gICAqICAgICAgICAgIHJvb3QgaXMgZ3JhcGhJeFxuICAgKlxuICAgKiBAYXJnIG5vZGUxOiBub2RlMSdzIElEXG4gICAqIEBhcmcgbm9kZTI6IG5vZGUyJ3MgSURcbiAgICogQGFyZyBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvIG9iamVjdFxuICAgKlxuICAgKi9cbiAgdmFyIGZpbmRMQ0EgPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8pIHtcbiAgICAvLyBGaW5kIHRoZWlyIGNvbW1vbiBhbmNlc3Rlciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBncmFwaFxuICAgIHZhciByZXMgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIDAsIGxheW91dEluZm8pO1xuICAgIGlmICgyID4gcmVzLmNvdW50KSB7XG4gICAgICAvLyBJZiBhdXggZnVuY3Rpb24gY291bGRuJ3QgZmluZCB0aGUgY29tbW9uIGFuY2VzdGVyLCBcbiAgICAgIC8vIHRoZW4gaXQgaXMgdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzLmdyYXBoO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBBdXhpbGlhcnkgZnVuY3Rpb24gdXNlZCBmb3IgTENBIGNvbXB1dGF0aW9uXG4gICAqIFxuICAgKiBAYXJnIG5vZGUxICAgICAgOiBub2RlMSdzIElEXG4gICAqIEBhcmcgbm9kZTIgICAgICA6IG5vZGUyJ3MgSURcbiAgICogQGFyZyBncmFwaEl4ICAgIDogc3ViZ3JhcGggaW5kZXhcbiAgICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBvYmplY3RcbiAgICpcbiAgICogQHJldHVybiAgICAgICAgIDogb2JqZWN0IG9mIHRoZSBmb3JtIHtjb3VudDogWCwgZ3JhcGg6IFl9LCB3aGVyZTpcbiAgICogICAgICAgICAgICAgICAgICAgWCBpcyB0aGUgbnVtYmVyIG9mIGFuY2VzdGVycyAobWF4OiAyKSBmb3VuZCBpbiBcbiAgICogICAgICAgICAgICAgICAgICAgZ3JhcGhJeCAoYW5kIGl0J3Mgc3ViZ3JhcGhzKSxcbiAgICogICAgICAgICAgICAgICAgICAgWSBpcyB0aGUgZ3JhcGggaW5kZXggb2YgdGhlIGxvd2VzdCBncmFwaCBjb250YWluaW5nIFxuICAgKiAgICAgICAgICAgICAgICAgICBhbGwgWCBub2Rlc1xuICAgKi9cbiAgdmFyIGZpbmRMQ0FfYXV4ID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyLCBncmFwaEl4LCBsYXlvdXRJbmZvKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtncmFwaEl4XTtcbiAgICAvLyBJZiBib3RoIG5vZGVzIGJlbG9uZ3MgdG8gZ3JhcGhJeFxuICAgIGlmICgtMSA8ICQuaW5BcnJheShub2RlMSwgZ3JhcGgpICYmIC0xIDwgJC5pbkFycmF5KG5vZGUyLCBncmFwaCkpIHtcbiAgICAgIHJldHVybiB7Y291bnQ6MiwgZ3JhcGg6Z3JhcGhJeH07XG4gICAgfVxuXG4gICAgLy8gTWFrZSByZWN1cnNpdmUgY2FsbHMgZm9yIGFsbCBzdWJncmFwaHNcbiAgICB2YXIgYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGVJZCAgID0gZ3JhcGhbaV07XG4gICAgICB2YXIgbm9kZUl4ICAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSXhdLmNoaWxkcmVuO1xuXG4gICAgICAvLyBJZiB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIHNraXAgaXRcbiAgICAgIGlmICgwID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRHcmFwaEl4ID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5bMF1dXTtcbiAgICAgIHZhciByZXN1bHQgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyk7XG4gICAgICBpZiAoMCA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAvLyBOZWl0aGVyIG5vZGUxIG5vciBub2RlMiBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoMSA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAvLyBPbmUgb2YgKG5vZGUxLCBub2RlMikgaXMgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjKys7XG4gICAgICBpZiAoMiA9PT0gYykge1xuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGZvdW5kIGJvdGggbm9kZXMsIG5vIG5lZWQgdG8ga2VlcCBzZWFyY2hpbmdcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBub2RlcyBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSAgICAgIFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge2NvdW50OmMsIGdyYXBoOmdyYXBoSXh9O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZjogcHJpbnRzTGF5b3V0SW5mbyBpbnRvIGpzIGNvbnNvbGVcbiAgICogICAgICAgICBPbmx5IHVzZWQgZm9yIGRlYmJ1Z2luZyBcbiAgICovXG4gIHZhciBwcmludExheW91dEluZm8gPSBmdW5jdGlvbihsYXlvdXRJbmZvKSB7XG4gICAgaWYgKCFERUJVRykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmRlYnVnKFwibGF5b3V0Tm9kZXM6XCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICB2YXIgcyA9IFxuICAgICAgXCJcXG5pbmRleDogXCIgICAgICsgaSArIFxuICAgICAgXCJcXG5JZDogXCIgICAgICAgICsgbi5pZCArIFxuICAgICAgXCJcXG5DaGlsZHJlbjogXCIgICsgbi5jaGlsZHJlbi50b1N0cmluZygpICsgIFxuICAgICAgXCJcXG5wYXJlbnRJZDogXCIgICsgbi5wYXJlbnRJZCAgKyBcbiAgICAgIFwiXFxucG9zaXRpb25YOiBcIiArIG4ucG9zaXRpb25YICsgXG4gICAgICBcIlxcbnBvc2l0aW9uWTogXCIgKyBuLnBvc2l0aW9uWSArXG4gICAgICBcIlxcbk9mZnNldFg6IFwiICsgbi5vZmZzZXRYICsgXG4gICAgICBcIlxcbk9mZnNldFk6IFwiICsgbi5vZmZzZXRZICsgXG4gICAgICBcIlxcbnBhZExlZnQ6IFwiICsgbi5wYWRMZWZ0ICsgXG4gICAgICBcIlxcbnBhZFJpZ2h0OiBcIiArIG4ucGFkUmlnaHQgKyBcbiAgICAgIFwiXFxucGFkVG9wOiBcIiArIG4ucGFkVG9wICsgXG4gICAgICBcIlxcbnBhZEJvdHRvbTogXCIgKyBuLnBhZEJvdHRvbTtcblxuICAgICAgY29uc29sZS5kZWJ1ZyhzKTsgICAgXG4gICAgfSAgXG4gICAgXG4gICAgY29uc29sZS5kZWJ1ZygnaWRUb0luZGV4Jyk7XG4gICAgZm9yICh2YXIgaSBpbiBsYXlvdXRJbmZvLmlkVG9JbmRleCkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhcIklkOiBcIiArIGkgKyBcIlxcbkluZGV4OiBcIiArIGxheW91dEluZm8uaWRUb0luZGV4W2ldKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmRlYnVnKCdHcmFwaCBTZXQnKTtcbiAgICB2YXIgc2V0ID0gbGF5b3V0SW5mby5ncmFwaFNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKyspIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXCJTZXQgOiBcIiArIGkgKyBcIjogXCIgKyBzZXRbaV0udG9TdHJpbmcoKSk7XG4gICAgfSBcblxuICAgIHZhciBzID0gJ0luZGV4VG9HcmFwaCc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaC5sZW5ndGg7IGkgKyspIHtcbiAgICAgIHMgKz0gXCJcXG5JbmRleCA6IFwiICsgaSArIFwiIEdyYXBoOiBcIisgbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbaV07XG4gICAgfVxuICAgIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgICBzID0gJ0xheW91dCBFZGdlcyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgICBzICs9IFwiXFxuRWRnZSBJbmRleDogXCIgKyBpICsgXCIgSUQ6IFwiICsgZS5pZCArIFxuICAgICAgXCIgU291Y2VJRDogXCIgKyBlLnNvdXJjZUlkICsgXCIgVGFyZ2V0SWQ6IFwiICsgZS50YXJnZXRJZCArIFxuICAgICAgXCIgSWRlYWwgTGVuZ3RoOiBcIiArIGUuaWRlYWxMZW5ndGg7XG4gICAgfVxuICAgIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgICBzID0gIFwibm9kZVNpemU6IFwiICsgbGF5b3V0SW5mby5ub2RlU2l6ZTtcbiAgICBzICs9IFwiXFxuZWRnZVNpemU6IFwiICsgbGF5b3V0SW5mby5lZGdlU2l6ZTtcbiAgICBzICs9IFwiXFxudGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZTtcbiAgICBjb25zb2xlLmRlYnVnKHMpO1xuXG4gICAgcmV0dXJuO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IFJhbmRvbWl6ZXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBub2Rlc1xuICAgKi9cbiAgdmFyIHJhbmRvbWl6ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5KSB7XG4gICAgdmFyIHdpZHRoICAgICA9IGxheW91dEluZm8uY2xpZW50V2lkdGg7XG4gICAgdmFyIGhlaWdodCAgICA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzXG4gICAgICBpZiAodHJ1ZSB8fCAwID09PSBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBuLnBvc2l0aW9uWCA9IE1hdGgucmFuZG9tKCkgKiB3aWR0aDtcbiAgICAgICAgbi5wb3NpdGlvblkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBcbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBpbiB0aGUgbmV0d29ya1xuICAgKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdFxuICAgKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAqL1xuICB2YXIgcmVmcmVzaFBvc2l0aW9ucyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7ICBcbiAgICB2YXIgcyA9ICdSZWZyZXNoaW5nIHBvc2l0aW9ucyc7XG4gICAgbG9nRGVidWcocyk7XG5cbiAgICB2YXIgbGF5b3V0ID0gbGF5b3V0SW5mby5sYXlvdXQ7XG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gICAgdmFyIGJiID0gbGF5b3V0SW5mby5ib3VuZGluZ0JveDtcbiAgICB2YXIgY29zZUJCID0geyB4MTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkxOiBJbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuICAgIFxuICAgIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZS5kYXRhKCdpZCcpXV07XG5cbiAgICAgICAgY29zZUJCLngxID0gTWF0aC5taW4oIGNvc2VCQi54MSwgbG5vZGUucG9zaXRpb25YICk7XG4gICAgICAgIGNvc2VCQi54MiA9IE1hdGgubWF4KCBjb3NlQkIueDIsIGxub2RlLnBvc2l0aW9uWCApO1xuXG4gICAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKCBjb3NlQkIueTEsIGxub2RlLnBvc2l0aW9uWSApO1xuICAgICAgICBjb3NlQkIueTIgPSBNYXRoLm1heCggY29zZUJCLnkyLCBsbm9kZS5wb3NpdGlvblkgKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb3NlQkIudyA9IGNvc2VCQi54MiAtIGNvc2VCQi54MTtcbiAgICAgIGNvc2VCQi5oID0gY29zZUJCLnkyIC0gY29zZUJCLnkxO1xuICAgIH1cblxuICAgIG5vZGVzLnBvc2l0aW9ucyhmdW5jdGlvbihpLCBlbGUpIHtcbiAgICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZWxlLmRhdGEoJ2lkJyldXTtcbiAgICAgIHMgPSBcIk5vZGU6IFwiICsgbG5vZGUuaWQgKyBcIi4gUmVmcmVzaGVkIHBvc2l0aW9uOiAoXCIgKyBcbiAgICAgIGxub2RlLnBvc2l0aW9uWCArIFwiLCBcIiArIGxub2RlLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAgIGxvZ0RlYnVnKHMpO1xuXG4gICAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApeyAvLyB0aGVuIGFkZCBleHRyYSBib3VuZGluZyBib3ggY29uc3RyYWludFxuICAgICAgICB2YXIgcGN0WCA9IChsbm9kZS5wb3NpdGlvblggLSBjb3NlQkIueDEpIC8gY29zZUJCLnc7XG4gICAgICAgIHZhciBwY3RZID0gKGxub2RlLnBvc2l0aW9uWSAtIGNvc2VCQi55MSkgLyBjb3NlQkIuaDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGJiLngxICsgcGN0WCAqIGJiLncsXG4gICAgICAgICAgeTogYmIueTEgKyBwY3RZICogYmIuaFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBsbm9kZS5wb3NpdGlvblgsXG4gICAgICAgICAgeTogbG5vZGUucG9zaXRpb25ZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUcmlnZ2VyIGxheW91dFJlYWR5IG9ubHkgb24gZmlyc3QgY2FsbFxuICAgIGlmICh0cnVlICE9PSBsYXlvdXRJbmZvLnJlYWR5KSB7XG4gICAgICBzID0gJ1RyaWdnZXJpbmcgbGF5b3V0cmVhZHknO1xuICAgICAgbG9nRGVidWcocyk7XG4gICAgICBsYXlvdXRJbmZvLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogdGhpcyB9KTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogUGVyZm9ybXMgb25lIGl0ZXJhdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2ltdWxhdGlvblxuICAgKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIHZhciBzdGVwID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMsIHN0ZXApIHsgIFxuICAgIHZhciBzID0gXCJcXG5cXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXCI7XG4gICAgcyArPSBcIlxcblNURVA6IFwiICsgc3RlcDtcbiAgICBzICs9IFwiXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xcblwiO1xuICAgIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIG5vZGUgcmVwdWxzaW9uc1xuICAgIGNhbGN1bGF0ZU5vZGVGb3JjZXMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgIC8vIENhbGN1bGF0ZSBlZGdlIGZvcmNlc1xuICAgIGNhbGN1bGF0ZUVkZ2VGb3JjZXMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgIC8vIENhbGN1bGF0ZSBncmF2aXR5IGZvcmNlc1xuICAgIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgIC8vIFByb3BhZ2F0ZSBmb3JjZXMgZnJvbSBwYXJlbnQgdG8gY2hpbGRcbiAgICBwcm9wYWdhdGVGb3JjZXMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gY2FsY3VsYXRlZCBmb3JjZXNcbiAgICB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICB9O1xuXG4gIFxuICAvKipcbiAgICogQGJyaWVmIDogQ29tcHV0ZXMgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlc1xuICAgKi9cbiAgdmFyIGNhbGN1bGF0ZU5vZGVGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgZ3JhcGhzIGluIGdyYXBoU2V0XG4gICAgLy8gTm9kZXMgb25seSByZXBlbCBlYWNoIG90aGVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIGdyYXBoXG4gICAgdmFyIHMgPSAnY2FsY3VsYXRlTm9kZUZvcmNlcyc7XG4gICAgbG9nRGVidWcocyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGdyYXBoICAgID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDtcblxuICAgICAgcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICBsb2dEZWJ1ZyhzKTtcblxuICAgICAgLy8gTm93IGdldCBhbGwgdGhlIHBhaXJzIG9mIG5vZGVzIFxuICAgICAgLy8gT25seSBnZXQgZWFjaCBwYWlyIG9uY2UsIChBLCBCKSA9IChCLCBBKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICB2YXIgbm9kZTEgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07XG4gICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBudW1Ob2RlczsgaysrKSB7XG4gICAgICAgIHZhciBub2RlMiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhba11dXTtcbiAgICAgICAgbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcbiAgICAgIH0gXG4gICAgICB9XG4gICAgfSBcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDb21wdXRlIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiBhIHBhaXIgb2Ygbm9kZXNcbiAgICovXG4gIHZhciBub2RlUmVwdWxzaW9uID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcblxuICAgIC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG4gICAgdmFyIGRpcmVjdGlvblggPSBub2RlMi5wb3NpdGlvblggLSBub2RlMS5wb3NpdGlvblg7XG4gICAgdmFyIGRpcmVjdGlvblkgPSBub2RlMi5wb3NpdGlvblkgLSBub2RlMS5wb3NpdGlvblk7XG4gICAgcyArPSBcIlxcbmRpcmVjdGlvblg6IFwiICsgZGlyZWN0aW9uWCArIFwiLCBkaXJlY3Rpb25ZOiBcIiArIGRpcmVjdGlvblk7XG5cbiAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBhcHBseSBhIHJhbmRvbSBmb3JjZVxuICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgIHMgKz0gXCJcXG5Ob2RlcyBoYXZlIHRoZSBzYW1lIHBvc2l0aW9uLlwiO1xuICAgICAgcmV0dXJuOyAvLyBUT0RPXG4gICAgfVxuXG4gICAgdmFyIG92ZXJsYXAgPSBub2Rlc092ZXJsYXAobm9kZTEsIG5vZGUyLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICBcbiAgICBpZiAob3ZlcmxhcCA+IDApIHtcbiAgICAgIHMgKz0gXCJcXG5Ob2RlcyBETyBvdmVybGFwLlwiO1xuICAgICAgcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAgIC8vIElmIG5vZGVzIG92ZXJsYXAsIHJlcHVsc2lvbiBmb3JjZSBpcyBwcm9wb3J0aW9uYWwgXG4gICAgICAvLyB0byB0aGUgb3ZlcmxhcFxuICAgICAgdmFyIGZvcmNlICAgID0gb3B0aW9ucy5ub2RlT3ZlcmxhcCAqIG92ZXJsYXA7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlyZWN0aW9uWCAqIGRpcmVjdGlvblggKyBkaXJlY3Rpb25ZICogZGlyZWN0aW9uWSk7XG4gICAgICBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgICB2YXIgZm9yY2VYICAgPSBmb3JjZSAqIGRpcmVjdGlvblggLyBkaXN0YW5jZTtcbiAgICAgIHZhciBmb3JjZVkgICA9IGZvcmNlICogZGlyZWN0aW9uWSAvIGRpc3RhbmNlO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMgKz0gXCJcXG5Ob2RlcyBkbyBOT1Qgb3ZlcmxhcC5cIjtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gb3ZlcmxhcCwgZm9yY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCBcbiAgICAgIC8vIHRvIHNxdWFyZWQgZGlzdGFuY2VcblxuICAgICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUxLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMiwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpO1xuXG4gICAgICAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcbiAgICAgIHZhciBkaXN0YW5jZVggICA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgICB2YXIgZGlzdGFuY2VZICAgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgICAgdmFyIGRpc3RhbmNlU3FyID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgdmFyIGRpc3RhbmNlICAgID0gTWF0aC5zcXJ0KGRpc3RhbmNlU3FyKTtcbiAgICAgIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICAgIHZhciBmb3JjZSAgPSBvcHRpb25zLm5vZGVSZXB1bHNpb24gLyBkaXN0YW5jZVNxcjtcbiAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlzdGFuY2VZIC8gZGlzdGFuY2U7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgZm9yY2VcbiAgICBub2RlMS5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICBub2RlMS5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICBub2RlMi5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICBub2RlMi5vZmZzZXRZICs9IGZvcmNlWTtcblxuICAgIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgICBsb2dEZWJ1ZyhzKTtcblxuICAgIHJldHVybjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBGaW5kcyB0aGUgcG9pbnQgaW4gd2hpY2ggYW4gZWRnZSAoZGlyZWN0aW9uIGRYLCBkWSkgaW50ZXJzZWN0cyBcbiAgICogICAgICAgICAgdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGJveCBvZiBpdCdzIHNvdXJjZS90YXJnZXQgbm9kZSBcbiAgICovXG4gIHZhciBmaW5kQ2xpcHBpbmdQb2ludCA9IGZ1bmN0aW9uKG5vZGUsIGRYLCBkWSkge1xuXG4gICAgLy8gU2hvcmN1dHNcbiAgICB2YXIgWCA9IG5vZGUucG9zaXRpb25YO1xuICAgIHZhciBZID0gbm9kZS5wb3NpdGlvblk7XG4gICAgdmFyIEggPSBub2RlLmhlaWdodDtcbiAgICB2YXIgVyA9IG5vZGUud2lkdGg7XG4gICAgdmFyIGRpclNsb3BlICAgICA9IGRZIC8gZFg7XG4gICAgdmFyIG5vZGVTbG9wZSAgICA9IEggLyBXO1xuXG4gICAgdmFyIHMgPSAnQ29tcHV0aW5nIGNsaXBwaW5nIHBvaW50IG9mIG5vZGUgJyArIG5vZGUuaWQgKyBcbiAgICAgIFwiIC4gSGVpZ2h0OiAgXCIgKyBIICsgXCIsIFdpZHRoOiBcIiArIFcgKyBcbiAgICAgIFwiXFxuRGlyZWN0aW9uIFwiICsgZFggKyBcIiwgXCIgKyBkWTsgXG4gICAgXG4gICAgLy8gQ29tcHV0ZSBpbnRlcnNlY3Rpb25cbiAgICB2YXIgcmVzID0ge307XG4gICAgZG8ge1xuICAgICAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uICh1cClcbiAgICAgIGlmICgwID09PSBkWCAmJiAwIDwgZFkpIHtcbiAgICAgICAgcmVzLnggPSBYO1xuICAgICAgICBzICs9IFwiXFxuVXAgZGlyZWN0aW9uXCI7XG4gICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uIChkb3duKVxuICAgICAgaWYgKDAgPT09IGRYICYmIDAgPiBkWSkge1xuICAgICAgICByZXMueCA9IFg7XG4gICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICBzICs9IFwiXFxuRG93biBkaXJlY3Rpb25cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9ICAgICAgXG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHJpZ2h0IGJvcmRlclxuICAgICAgaWYgKDAgPCBkWCAmJiBcbiAgICAgIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmIFxuICAgICAgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgICAgIHJlcy54ID0gWCArIFcgLyAyO1xuICAgICAgICByZXMueSA9IFkgKyAoVyAqIGRZIC8gMiAvIGRYKTtcbiAgICAgICAgcyArPSBcIlxcblJpZ2h0Ym9yZGVyXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBsZWZ0IGJvcmRlclxuICAgICAgaWYgKDAgPiBkWCAmJiBcbiAgICAgIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmIFxuICAgICAgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgICAgIHJlcy54ID0gWCAtIFcgLyAyO1xuICAgICAgICByZXMueSA9IFkgLSAoVyAqIGRZIC8gMiAvIGRYKTtcbiAgICAgICAgcyArPSBcIlxcbkxlZnRib3JkZXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHRvcCBib3JkZXJcbiAgICAgIGlmICgwIDwgZFkgJiYgXG4gICAgICAoIGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8XG4gICAgICAgIGRpclNsb3BlID49IG5vZGVTbG9wZSApKSB7XG4gICAgICAgIHJlcy54ID0gWCArIChIICogZFggLyAyIC8gZFkpO1xuICAgICAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAgICAgcyArPSBcIlxcblRvcCBib3JkZXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGJvdHRvbSBib3JkZXJcbiAgICAgIGlmICgwID4gZFkgJiYgXG4gICAgICAoIGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8XG4gICAgICAgIGRpclNsb3BlID49IG5vZGVTbG9wZSApKSB7XG4gICAgICAgIHJlcy54ID0gWCAtIChIICogZFggLyAyIC8gZFkpO1xuICAgICAgICByZXMueSA9IFkgLSBIIC8gMjtcbiAgICAgICAgcyArPSBcIlxcbkJvdHRvbSBib3JkZXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IHdoaWxlIChmYWxzZSk7XG5cbiAgICBzICs9IFwiXFxuQ2xpcHBpbmcgcG9pbnQgZm91bmQgYXQgXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55O1xuICAgIGxvZ0RlYnVnKHMpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICA6IERldGVybWluZXMgd2hldGhlciB0d28gbm9kZXMgb3ZlcmxhcCBvciBub3RcbiAgICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICAgKi9cbiAgdmFyIG5vZGVzT3ZlcmxhcCA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMiwgZFgsIGRZKSB7XG5cbiAgICBpZiAoZFggPiAwKSB7XG4gICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMS5tYXhYIC0gbm9kZTIubWluWDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG92ZXJsYXBYID0gbm9kZTIubWF4WCAtIG5vZGUxLm1pblg7XG4gICAgfVxuXG4gICAgaWYgKGRZID4gMCkge1xuICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvdmVybGFwWSA9IG5vZGUyLm1heFkgLSBub2RlMS5taW5ZO1xuICAgIH1cblxuICAgIGlmIChvdmVybGFwWCA+PSAwICYmIG92ZXJsYXBZID49IDApIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQob3ZlcmxhcFggKiBvdmVybGFwWCArIG92ZXJsYXBZICogb3ZlcmxhcFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gICAgXG4gIFxuICAvKipcbiAgICogQGJyaWVmIDogQ2FsY3VsYXRlcyBhbGwgZWRnZSBmb3JjZXNcbiAgICovXG4gIHZhciBjYWxjdWxhdGVFZGdlRm9yY2VzID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICAgIC8vIEdldCBlZGdlLCBzb3VyY2UgJiB0YXJnZXQgbm9kZXNcbiAgICAgIHZhciBlZGdlICAgICA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnNvdXJjZUlkXTtcbiAgICAgIHZhciBzb3VyY2UgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS50YXJnZXRJZF07XG4gICAgICB2YXIgdGFyZ2V0ICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcblxuICAgICAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgICB2YXIgZGlyZWN0aW9uWSA9IHRhcmdldC5wb3NpdGlvblkgLSBzb3VyY2UucG9zaXRpb25ZO1xuICAgICAgXG4gICAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBkbyBub3RoaW5nLlxuICAgICAgLy8gQSByYW5kb20gZm9yY2UgaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIGFzIG5vZGUgcmVwdWxzaW9uXG4gICAgICBpZiAoMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZKSB7XG4gICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChzb3VyY2UsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KHRhcmdldCwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpO1xuXG5cbiAgICAgIHZhciBseCA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgICB2YXIgbHkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgICAgdmFyIGwgID0gTWF0aC5zcXJ0KGx4ICogbHggKyBseSAqIGx5KTtcblxuICAgICAgdmFyIGZvcmNlICA9IE1hdGgucG93KGVkZ2UuaWRlYWxMZW5ndGggLSBsLCAyKSAvIG9wdGlvbnMuZWRnZUVsYXN0aWNpdHk7IFxuXG4gICAgICBpZiAoMCAhPT0gbCkge1xuICAgICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBseCAvIGw7XG4gICAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGx5IC8gbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmb3JjZVggPSAwO1xuICAgICAgICB2YXIgZm9yY2VZID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoaXMgZm9yY2UgdG8gdGFyZ2V0IGFuZCBzb3VyY2Ugbm9kZXNcbiAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICAgIHRhcmdldC5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgIHRhcmdldC5vZmZzZXRZIC09IGZvcmNlWTtcblxuICAgICAgdmFyIHMgPSAnRWRnZSBmb3JjZSBiZXR3ZWVuIG5vZGVzICcgKyBzb3VyY2UuaWQgKyAnIGFuZCAnICsgdGFyZ2V0LmlkO1xuICAgICAgcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGwgKyBcIiBGb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpXCI7XG4gICAgICBsb2dEZWJ1ZyhzKTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogQ29tcHV0ZXMgZ3Jhdml0eSBmb3JjZXMgZm9yIGFsbCBub2Rlc1xuICAgKi9cbiAgdmFyIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIHZhciBzID0gJ2NhbGN1bGF0ZUdyYXZpdHlGb3JjZXMnO1xuICAgIGxvZ0RlYnVnKHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkgKyspIHtcbiAgICAgIHZhciBncmFwaCAgICA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAgIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgbG9nRGVidWcocyk7XG4gICAgICAgICAgXG4gICAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuICAgICAgaWYgKDAgPT09IGkpIHtcbiAgICAgICAgdmFyIGNlbnRlclggICA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGNlbnRlclkgICA9IGxheW91dEluZm8uY2xpZW50V2lkdGggIC8gMjsgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgUGFyZW50IG5vZGUgZm9yIHRoaXMgZ3JhcGgsIGFuZCB1c2UgaXRzIHBvc2l0aW9uIGFzIGNlbnRlclxuICAgICAgICB2YXIgdGVtcCAgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbMF1dXTtcbiAgICAgICAgdmFyIHBhcmVudCAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXAucGFyZW50SWRdXTtcbiAgICAgICAgdmFyIGNlbnRlclggPSBwYXJlbnQucG9zaXRpb25YO1xuICAgICAgICB2YXIgY2VudGVyWSA9IHBhcmVudC5wb3NpdGlvblk7XG4gICAgICB9XG4gICAgICBzID0gXCJDZW50ZXIgZm91bmQgYXQ6IFwiICsgY2VudGVyWCArIFwiLCBcIiArIGNlbnRlclk7XG4gICAgICBsb2dEZWJ1ZyhzKTtcblxuICAgICAgLy8gQXBwbHkgZm9yY2UgdG8gYWxsIG5vZGVzIGluIGdyYXBoXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07XG4gICAgICAgIHMgPSBcIk5vZGU6IFwiICsgbm9kZS5pZDtcbiAgICAgICAgdmFyIGR4ID0gY2VudGVyWCAtIG5vZGUucG9zaXRpb25YO1xuICAgICAgICB2YXIgZHkgPSBjZW50ZXJZIC0gbm9kZS5wb3NpdGlvblk7XG4gICAgICAgIHZhciBkICA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGlmIChkID4gMS4wKSB7IC8vIFRPRE86IFVzZSBnbG9iYWwgdmFyaWFibGUgZm9yIGRpc3RhbmNlIHRocmVzaG9sZFxuICAgICAgICAgIHZhciBmeCA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR4IC8gZDtcbiAgICAgICAgICB2YXIgZnkgPSBvcHRpb25zLmdyYXZpdHkgKiBkeSAvIGQ7XG4gICAgICAgICAgbm9kZS5vZmZzZXRYICs9IGZ4O1xuICAgICAgICAgIG5vZGUub2Zmc2V0WSArPSBmeTtcbiAgICAgICAgICBzICs9IFwiOiBBcHBsaWVkIGZvcmNlOiBcIiArIGZ4ICsgXCIsIFwiICsgZnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcyArPSBcIjogc2t5cHBlZCBzaW5jZSBpdCdzIHRvbyBjbG9zZSB0byBjZW50ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBsb2dEZWJ1ZyhzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogVGhpcyBmdW5jdGlvbiBwcm9wYWdhdGVzIHRoZSBleGlzdGluZyBvZmZzZXRzIGZyb20gXG4gICAqICAgICAgICAgICAgICAgICAgIHBhcmVudCBub2RlcyB0byBpdHMgZGVzY2VuZGVudHMuXG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gT2JqZWN0XG4gICAqIEBhcmcgY3kgICAgICAgICA6IGN5dG9zY2FwZSBPYmplY3RcbiAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIHZhciBwcm9wYWdhdGVGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykgeyAgXG4gICAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciBzdGFydCA9IDA7ICAgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcbiAgICB2YXIgZW5kICAgPSAtMTsgIC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gICAgbG9nRGVidWcoJ3Byb3BhZ2F0ZUZvcmNlcycpO1xuXG4gICAgLy8gU3RhcnQgYnkgdmlzaXRpbmcgdGhlIG5vZGVzIGluIHRoZSByb290IGdyYXBoXG4gICAgcXVldWUucHVzaC5hcHBseShxdWV1ZSwgbGF5b3V0SW5mby5ncmFwaFNldFswXSk7XG4gICAgZW5kICs9IGxheW91dEluZm8uZ3JhcGhTZXRbMF0ubGVuZ3RoO1xuXG4gICAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCwgXG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgICAgdmFyIG5vZGVJZCAgICA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgICAgdmFyIG5vZGVJbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgICB2YXIgbm9kZSAgICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSW5kZXhdO1xuICAgICAgdmFyIGNoaWxkcmVuICA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBub2RlIGlmIGl0J3MgY29tcG91bmRcbiAgICAgIGlmICgwIDwgY2hpbGRyZW4ubGVuZ3RoKSB7ICAgIFxuICAgICAgdmFyIG9mZlggPSBub2RlLm9mZnNldFg7XG4gICAgICB2YXIgb2ZmWSA9IG5vZGUub2Zmc2V0WTtcblxuICAgICAgdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG9mZnNldCBmcm9tIHBhcmVudCBub2RlIDogXCIgKyBub2RlLmlkICsgXG4gICAgICAgIFwiLiBPZmZzZXRYOiBcIiArIG9mZlggKyBcIi4gT2Zmc2V0WTogXCIgKyBvZmZZO1xuICAgICAgcyArPSBcIlxcbiBDaGlsZHJlbjogXCIgKyBjaGlsZHJlbi50b1N0cmluZygpO1xuICAgICAgbG9nRGVidWcocyk7XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5baV1dXTtcbiAgICAgICAgLy8gUHJvcGFnYXRlIG9mZnNldFxuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WCArPSBvZmZYO1xuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WSArPSBvZmZZO1xuICAgICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVzZXQgcGFyZW50IG9mZnNldHNcbiAgICAgIG5vZGUub2Zmc2V0WCA9IDA7XG4gICAgICBub2RlLm9mZnNldFkgPSAwO1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IFVwZGF0ZXMgdGhlIGxheW91dCBtb2RlbCBwb3NpdGlvbnMsIGJhc2VkIG9uIFxuICAgKiAgICAgICAgICB0aGUgYWNjdW11bGF0ZWQgZm9yY2VzXG4gICAqL1xuICB2YXIgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgICB2YXIgcyA9ICdVcGRhdGluZyBwb3NpdGlvbnMnO1xuICAgIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gUmVzZXQgYm91bmRhcmllcyBmb3IgY29tcG91bmQgbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBsb2dEZWJ1ZyhcIlJlc2V0dGluZyBib3VuZGFyaWVzIG9mIGNvbXBvdW5kIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICAgIG4ubWF4WCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbi5taW5YID0gdW5kZWZpbmVkO1xuICAgICAgICBuLm1heFkgPSB1bmRlZmluZWQ7XG4gICAgICAgIG4ubWluWSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIHNldCBjb21wb3VuZCBub2RlIHBvc2l0aW9uXG4gICAgICAgIGxvZ0RlYnVnKFwiU2tpcHBpbmcgcG9zaXRpb24gdXBkYXRlIG9mIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcyA9IFwiTm9kZTogXCIgKyBuLmlkICsgXCIgUHJldmlvdXMgcG9zaXRpb246IChcIiArIFxuICAgICAgbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjsgXG5cbiAgICAgIC8vIExpbWl0IGRpc3BsYWNlbWVudCBpbiBvcmRlciB0byBpbXByb3ZlIHN0YWJpbGl0eVxuICAgICAgdmFyIHRlbXBGb3JjZSA9IGxpbWl0Rm9yY2Uobi5vZmZzZXRYLCBuLm9mZnNldFksIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuICAgICAgbi5wb3NpdGlvblggKz0gdGVtcEZvcmNlLng7IFxuICAgICAgbi5wb3NpdGlvblkgKz0gdGVtcEZvcmNlLnk7XG4gICAgICBuLm9mZnNldFggPSAwO1xuICAgICAgbi5vZmZzZXRZID0gMDtcbiAgICAgIG4ubWluWCAgICA9IG4ucG9zaXRpb25YIC0gbi53aWR0aDsgXG4gICAgICBuLm1heFggICAgPSBuLnBvc2l0aW9uWCArIG4ud2lkdGg7IFxuICAgICAgbi5taW5ZICAgID0gbi5wb3NpdGlvblkgLSBuLmhlaWdodDsgXG4gICAgICBuLm1heFkgICAgPSBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0OyBcbiAgICAgIHMgKz0gXCIgTmV3IFBvc2l0aW9uOiAoXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgICAgbG9nRGVidWcocyk7XG5cbiAgICAgIC8vIFVwZGF0ZSBhbmNlc3RyeSBib3VkYXJpZXNcbiAgICAgIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhuLCBsYXlvdXRJbmZvKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc2l6ZSwgcG9zaXRpb24gb2YgY29tcHVuZCBub2Rlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIG4ucG9zaXRpb25YID0gKG4ubWF4WCArIG4ubWluWCkgLyAyO1xuICAgICAgICBuLnBvc2l0aW9uWSA9IChuLm1heFkgKyBuLm1pblkpIC8gMjtcbiAgICAgICAgbi53aWR0aCAgICAgPSBuLm1heFggLSBuLm1pblg7XG4gICAgICAgIG4uaGVpZ2h0ICAgID0gbi5tYXhZIC0gbi5taW5ZO1xuICAgICAgICBzID0gXCJVcGRhdGluZyBwb3NpdGlvbiwgc2l6ZSBvZiBjb21wb3VuZCBub2RlIFwiICsgbi5pZDtcbiAgICAgICAgcyArPSBcIlxcblBvc2l0aW9uWDogXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBQb3NpdGlvblk6IFwiICsgbi5wb3NpdGlvblk7XG4gICAgICAgIHMgKz0gXCJcXG5XaWR0aDogXCIgKyBuLndpZHRoICsgXCIsIEhlaWdodDogXCIgKyBuLmhlaWdodDtcbiAgICAgICAgbG9nRGVidWcocyk7XG4gICAgICB9XG4gICAgfSAgXG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogTGltaXRzIGEgZm9yY2UgKGZvcmNlWCwgZm9yY2VZKSB0byBiZSBub3QgXG4gICAqICAgICAgICAgIGdyZWF0ZXIgKGluIG1vZHVsbykgdGhhbiBtYXguIFxuICAgOCAgICAgICAgICBQcmVzZXJ2ZXMgZm9yY2UgZGlyZWN0aW9uLiBcbiAgICovXG4gIHZhciBsaW1pdEZvcmNlID0gZnVuY3Rpb24oZm9yY2VYLCBmb3JjZVksIG1heCkge1xuICAgIHZhciBzID0gXCJMaW1pdGluZyBmb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpLiBNYXg6IFwiICsgbWF4O1xuICAgIHZhciBmb3JjZSA9IE1hdGguc3FydChmb3JjZVggKiBmb3JjZVggKyBmb3JjZVkgKiBmb3JjZVkpO1xuXG4gICAgaWYgKGZvcmNlID4gbWF4KSB7XG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgeCA6IG1heCAqIGZvcmNlWCAvIGZvcmNlLFxuICAgICAgeSA6IG1heCAqIGZvcmNlWSAvIGZvcmNlXG4gICAgICB9OyAgICAgIFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSB7XG4gICAgICB4IDogZm9yY2VYLFxuICAgICAgeSA6IGZvcmNlWVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzICs9IFwiLlxcblJlc3VsdDogKFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueSArIFwiKVwiO1xuICAgIGxvZ0RlYnVnKHMpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBGdW5jdGlvbiB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGNvbXBvdW5kIG5vZGUgXG4gICAqICAgICAgICAgIHNpemVzLCBzaW5jZSB0aGV5IHNob3VsZCBib3VuZCBhbGwgdGhlaXIgc3Vibm9kZXMuXG4gICAqL1xuICB2YXIgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzID0gZnVuY3Rpb24obm9kZSwgbGF5b3V0SW5mbykge1xuICAgIHZhciBzID0gXCJQcm9wYWdhdGluZyBuZXcgcG9zaXRpb24vc2l6ZSBvZiBub2RlIFwiICsgbm9kZS5pZDtcbiAgICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgIGlmIChudWxsID09IHBhcmVudElkKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UgYXJlIGRvbmVcbiAgICAgIHMgKz0gXCIuIE5vIHBhcmVudCBub2RlLlwiO1xuICAgICAgbG9nRGVidWcocyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IFBhcmVudCBOb2RlXG4gICAgdmFyIHAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BhcmVudElkXV07XG4gICAgdmFyIGZsYWcgPSBmYWxzZTtcblxuICAgIC8vIE1heFhcbiAgICBpZiAobnVsbCA9PSBwLm1heFggfHwgbm9kZS5tYXhYICsgcC5wYWRSaWdodCA+IHAubWF4WCkge1xuICAgICAgcC5tYXhYID0gbm9kZS5tYXhYICsgcC5wYWRSaWdodDtcbiAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgcyArPSBcIlxcbk5ldyBtYXhYIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFg7XG4gICAgfVxuXG4gICAgLy8gTWluWFxuICAgIGlmIChudWxsID09IHAubWluWCB8fCBub2RlLm1pblggLSBwLnBhZExlZnQgPCBwLm1pblgpIHtcbiAgICAgIHAubWluWCA9IG5vZGUubWluWCAtIHAucGFkTGVmdDtcbiAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgcyArPSBcIlxcbk5ldyBtaW5YIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblg7XG4gICAgfVxuXG4gICAgLy8gTWF4WVxuICAgIGlmIChudWxsID09IHAubWF4WSB8fCBub2RlLm1heFkgKyBwLnBhZEJvdHRvbSA+IHAubWF4WSkge1xuICAgICAgcC5tYXhZID0gbm9kZS5tYXhZICsgcC5wYWRCb3R0b207XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIHMgKz0gXCJcXG5OZXcgbWF4WSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhZO1xuICAgIH1cblxuICAgIC8vIE1pbllcbiAgICBpZiAobnVsbCA9PSBwLm1pblkgfHwgbm9kZS5taW5ZIC0gcC5wYWRUb3AgPCBwLm1pblkpIHtcbiAgICAgIHAubWluWSA9IG5vZGUubWluWSAtIHAucGFkVG9wO1xuICAgICAgZmxhZyA9IHRydWU7XG4gICAgICBzICs9IFwiXFxuTmV3IG1pblkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWTtcbiAgICB9XG5cbiAgICAvLyBJZiB1cGRhdGVkIGJvdW5kYXJpZXMsIHByb3BhZ2F0ZSBjaGFuZ2VzIHVwd2FyZFxuICAgIGlmIChmbGFnKSB7XG4gICAgICBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybiB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMocCwgbGF5b3V0SW5mbyk7XG4gICAgfSBcblxuICAgIHMgKz0gXCIuIE5vIGNoYW5nZXMgaW4gYm91bmRhcmllcy9wb3NpdGlvbiBvZiBwYXJlbnQgbm9kZSBcIiArIHAuaWQ7ICBcbiAgICBsb2dEZWJ1ZyhzKTtcbiAgICByZXR1cm47XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogTG9ncyBhIGRlYnVnIG1lc3NhZ2UgaW4gSlMgY29uc29sZSwgaWYgREVCVUcgaXMgT05cbiAgICovXG4gIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcodGV4dCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLy8gcmVnaXN0ZXIgdGhlIGxheW91dFxuICAkJCgnbGF5b3V0JywgJ2Nvc2UnLCBDb3NlTGF5b3V0KTtcblxufSkoY3l0b3NjYXBlKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gZGVmYXVsdCBsYXlvdXQgb3B0aW9uc1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgLy8gZGFncmUgYWxnbyBvcHRpb25zLCB1c2VzIGRlZmF1bHQgdmFsdWUgb24gdW5kZWZpbmVkXG4gICAgbm9kZVNlcDogdW5kZWZpbmVkLCAvLyB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIGFkamFjZW50IG5vZGVzIGluIHRoZSBzYW1lIHJhbmtcbiAgICBlZGdlU2VwOiB1bmRlZmluZWQsIC8vIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gYWRqYWNlbnQgZWRnZXMgaW4gdGhlIHNhbWUgcmFua1xuICAgIHJhbmtTZXA6IHVuZGVmaW5lZCwgLy8gdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBhZGphY2VudCBub2RlcyBpbiB0aGUgc2FtZSByYW5rXG4gICAgcmFua0RpcjogdW5kZWZpbmVkLCAvLyAnVEInIGZvciB0b3AgdG8gYm90dG9tIGZsb3csICdMUicgZm9yIGxlZnQgdG8gcmlnaHRcbiAgICBtaW5MZW46IGZ1bmN0aW9uKCBlZGdlICl7IHJldHVybiAxOyB9LCAvLyBudW1iZXIgb2YgcmFua3MgdG8ga2VlcCBiZXR3ZWVuIHRoZSBzb3VyY2UgYW5kIHRhcmdldCBvZiB0aGUgZWRnZVxuICAgIFxuICAgIC8vIGdlbmVyYWwgbGF5b3V0IG9wdGlvbnNcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIGZpdCBwYWRkaW5nXG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIHJlYWR5OiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogZnVuY3Rpb24oKXt9IC8vIG9uIGxheW91dHN0b3BcbiAgfTtcblxuICAvLyBjb25zdHJ1Y3RvclxuICAvLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAgZnVuY3Rpb24gRGFncmVMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpOyBcbiAgfVxuXG4gIC8vIHJ1bnMgdGhlIGxheW91dFxuICBEYWdyZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcblxuICAgICQkLnV0aWwucmVxdWlyZSgnZGFncmUnLCBmdW5jdGlvbihkYWdyZSl7XG5cbiAgICAgIHZhciBjeSA9IG9wdGlvbnMuY3k7IC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gICAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICAgIH0gKTtcblxuICAgICAgdmFyIGcgPSBuZXcgZGFncmUuRGlncmFwaCgpO1xuXG4gICAgICAvLyBhZGQgbm9kZXMgdG8gZGFncmVcbiAgICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgICBnLmFkZE5vZGUoIG5vZGUuaWQoKSwge1xuICAgICAgICAgIHdpZHRoOiBub2RlLndpZHRoKCksXG4gICAgICAgICAgaGVpZ2h0OiBub2RlLmhlaWdodCgpXG4gICAgICAgIH0gKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGVkZ2VzIHRvIGRhZ3JlXG4gICAgICB2YXIgZWRnZXMgPSBlbGVzLmVkZ2VzKCk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG5cbiAgICAgICAgZy5hZGRFZGdlKCBlZGdlLmlkKCksIGVkZ2Uuc291cmNlKCkuaWQoKSwgZWRnZS50YXJnZXQoKS5pZCgpLCB7XG4gICAgICAgICAgbWluTGVuOiAkJC5pcy5mbihvcHRpb25zLm1pbkxlbikgPyBvcHRpb25zLm1pbkxlbi5hcHBseSggZWRnZSwgWyBlZGdlIF0gKSA6IG9wdGlvbnMubWluTGVuXG4gICAgICAgIH0gKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGQgPSBkYWdyZS5sYXlvdXQoKTtcblxuICAgICAgaWYoIG9wdGlvbnMubm9kZVNlcCApe1xuICAgICAgICBkLm5vZGVTZXAoIG9wdGlvbnMubm9kZVNlcCApO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0aW9ucy5lZGdlU2VwICl7XG4gICAgICAgIGQuZWRnZVNlcCggb3B0aW9ucy5lZGdlU2VwICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBvcHRpb25zLnJhbmtTZXAgKXtcbiAgICAgICAgZC5yYW5rU2VwKCBvcHRpb25zLnJhbmtTZXAgKTtcbiAgICAgIH1cblxuICAgICAgaWYoIG9wdGlvbnMucmFua0RpciApe1xuICAgICAgICBkLnJhbmtEaXIoIG9wdGlvbnMucmFua0RpciApO1xuICAgICAgfVxuICAgICAgICBcbiAgICAgIGQgPSBkLnJ1bihnKTtcblxuICAgICAgZC5lYWNoTm9kZShmdW5jdGlvbihpZCwgbikge1xuICAgICAgICBjeS5nZXRFbGVtZW50QnlJZChpZCkuc2NyYXRjaCgpLmRhZ3JlID0gbjtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGFncmVCQjtcblxuICAgICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggKXtcbiAgICAgICAgZGFncmVCQiA9IHsgeDE6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MTogSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICAgIHZhciBkTW9kZWwgPSBub2RlLnNjcmF0Y2goKS5kYWdyZTtcblxuICAgICAgICAgIGRhZ3JlQkIueDEgPSBNYXRoLm1pbiggZGFncmVCQi54MSwgZE1vZGVsLnggKTtcbiAgICAgICAgICBkYWdyZUJCLngyID0gTWF0aC5tYXgoIGRhZ3JlQkIueDIsIGRNb2RlbC54ICk7XG5cbiAgICAgICAgICBkYWdyZUJCLnkxID0gTWF0aC5taW4oIGRhZ3JlQkIueTEsIGRNb2RlbC55ICk7XG4gICAgICAgICAgZGFncmVCQi55MiA9IE1hdGgubWF4KCBkYWdyZUJCLnkyLCBkTW9kZWwueSApO1xuICAgICAgICB9KTtcblxuICAgICAgICBkYWdyZUJCLncgPSBkYWdyZUJCLngyIC0gZGFncmVCQi54MTtcbiAgICAgICAgZGFncmVCQi5oID0gZGFncmVCQi55MiAtIGRhZ3JlQkIueTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYWdyZUJCID0gYmI7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25zdHJhaW5Qb3MgPSBmdW5jdGlvbiggcCApe1xuICAgICAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApe1xuICAgICAgICAgIHZhciB4UGN0ID0gKHAueCAtIGRhZ3JlQkIueDEpIC8gZGFncmVCQi53O1xuICAgICAgICAgIHZhciB5UGN0ID0gKHAueSAtIGRhZ3JlQkIueTEpIC8gZGFncmVCQi5oO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGJiLngxICsgeFBjdCAqIGJiLncsXG4gICAgICAgICAgICB5OiBiYi55MSArIHlQY3QgKiBiYi5oXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGRNb2RlbCA9IHRoaXMuc2NyYXRjaCgpLmRhZ3JlO1xuXG4gICAgICAgIHJldHVybiBjb25zdHJhaW5Qb3Moe1xuICAgICAgICAgIHg6IGRNb2RlbC54LFxuICAgICAgICAgIHk6IGRNb2RlbC55XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICB9KTsgLy8gcmVxdWlyZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gcmVnaXN0ZXIgdGhlIGxheW91dFxuICAkJCgnbGF5b3V0JywgJ2RhZ3JlJywgRGFncmVMYXlvdXQpO1xuXG59KShjeXRvc2NhcGUpO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyB1c2VkIG9uIGZpdFxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIHJvd3M6IHVuZGVmaW5lZCwgLy8gZm9yY2UgbnVtIG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgICBjb2x1bW5zOiB1bmRlZmluZWQsIC8vIGZvcmNlIG51bSBvZiBjb2xzIGluIHRoZSBncmlkXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKCBub2RlICl7fSwgLy8gcmV0dXJucyB7IHJvdywgY29sIH0gZm9yIGVsZW1lbnRcbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gR3JpZExheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIEdyaWRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICBcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgIFxuICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICB9ICk7XG5cbiAgICBpZiggYmIuaCA9PT0gMCB8fCBiYi53ID09PSAwKXtcbiAgICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyh0aGlzLCBvcHRpb25zLCBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4geyB4OiBiYi54MSwgeTogYmIueTEgfTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgIFxuICAgICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgICB2YXIgY2VsbHMgPSBub2Rlcy5zaXplKCk7XG4gICAgICB2YXIgc3BsaXRzID0gTWF0aC5zcXJ0KCBjZWxscyAqIGJiLmgvYmIudyApO1xuICAgICAgdmFyIHJvd3MgPSBNYXRoLnJvdW5kKCBzcGxpdHMgKTtcbiAgICAgIHZhciBjb2xzID0gTWF0aC5yb3VuZCggYmIudy9iYi5oICogc3BsaXRzICk7XG5cbiAgICAgIHZhciBzbWFsbCA9IGZ1bmN0aW9uKHZhbCl7XG4gICAgICAgIGlmKCB2YWwgPT0gbnVsbCApe1xuICAgICAgICAgIHJldHVybiBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgICAgICAgaWYoIG1pbiA9PSByb3dzICl7XG4gICAgICAgICAgICByb3dzID0gdmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2xzID0gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgdmFyIGxhcmdlID0gZnVuY3Rpb24odmFsKXtcbiAgICAgICAgaWYoIHZhbCA9PSBudWxsICl7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyb3dzLCBjb2xzKTtcbiAgICAgICAgICBpZiggbWF4ID09IHJvd3MgKXtcbiAgICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBpZiByb3dzIG9yIGNvbHVtbnMgd2VyZSBzZXQgaW4gb3B0aW9ucywgdXNlIHRob3NlIHZhbHVlc1xuICAgICAgaWYoIG9wdGlvbnMucm93cyAhPSBudWxsICYmIG9wdGlvbnMuY29sdW1ucyAhPSBudWxsICl7XG4gICAgICAgIHJvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgICAgIGNvbHMgPSBvcHRpb25zLmNvbHVtbnM7XG4gICAgICB9IGVsc2UgaWYoIG9wdGlvbnMucm93cyAhPSBudWxsICYmIG9wdGlvbnMuY29sdW1ucyA9PSBudWxsICl7XG4gICAgICAgIHJvd3MgPSBvcHRpb25zLnJvd3M7XG4gICAgICAgIGNvbHMgPSBNYXRoLmNlaWwoIGNlbGxzIC8gcm93cyApO1xuICAgICAgfSBlbHNlIGlmKCBvcHRpb25zLnJvd3MgPT0gbnVsbCAmJiBvcHRpb25zLmNvbHVtbnMgIT0gbnVsbCApe1xuICAgICAgICBjb2xzID0gb3B0aW9ucy5jb2x1bW5zO1xuICAgICAgICByb3dzID0gTWF0aC5jZWlsKCBjZWxscyAvIGNvbHMgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgYXV0b21hdGljIHZhbHVlcyBhbmQgYWRqdXN0IGFjY29yZGluZ2x5XG4gICAgICBcbiAgICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB1cCwgc2VlIGlmIHdlIGNhbiByZWR1Y2Ugcm93cyBvciBjb2x1bW5zXG4gICAgICBlbHNlIGlmKCBjb2xzICogcm93cyA+IGNlbGxzICl7XG4gICAgICAgIHZhciBzbSA9IHNtYWxsKCk7XG4gICAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyByZWR1Y2luZyB0aGUgc21hbGwgc2lkZSB0YWtlcyBhd2F5IHRoZSBtb3N0IGNlbGxzLCBzbyB0cnkgaXQgZmlyc3RcbiAgICAgICAgaWYoIChzbSAtIDEpICogbGcgPj0gY2VsbHMgKXtcbiAgICAgICAgICBzbWFsbChzbSAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYoIChsZyAtIDEpICogc20gPj0gY2VsbHMgKXtcbiAgICAgICAgICBsYXJnZShsZyAtIDEpO1xuICAgICAgICB9IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXG4gICAgICAgIC8vIGlmIHJvdW5kaW5nIHdhcyB0b28gbG93LCBhZGQgcm93cyBvciBjb2x1bW5zXG4gICAgICAgIHdoaWxlKCBjb2xzICogcm93cyA8IGNlbGxzICl7XG4gICAgICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgICAgICB2YXIgbGcgPSBsYXJnZSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcbiAgICAgICAgICBpZiggKGxnICsgMSkgKiBzbSA+PSBjZWxscyApe1xuICAgICAgICAgICAgbGFyZ2UobGcgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc21hbGwoc20gKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGNlbGxXaWR0aCA9IGJiLncgLyBjb2xzO1xuICAgICAgdmFyIGNlbGxIZWlnaHQgPSBiYi5oIC8gcm93cztcblxuICAgICAgaWYoIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciB3ID0gbm9kZS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgdmFyIGggPSBub2RlLm91dGVySGVpZ2h0KCk7XG5cbiAgICAgICAgICBjZWxsV2lkdGggPSBNYXRoLm1heCggY2VsbFdpZHRoLCB3ICk7XG4gICAgICAgICAgY2VsbEhlaWdodCA9IE1hdGgubWF4KCBjZWxsSGVpZ2h0LCBoICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG4gICAgICBcbiAgICAgIHZhciB1c2VkID0gZnVuY3Rpb24ocm93LCBjb2wpe1xuICAgICAgICByZXR1cm4gY2VsbFVzZWRbJ2MtJyArIHJvdyArICctJyArIGNvbF0gPyB0cnVlIDogZmFsc2U7XG4gICAgICB9O1xuICAgICAgXG4gICAgICB2YXIgdXNlID0gZnVuY3Rpb24ocm93LCBjb2wpe1xuICAgICAgICBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA9IHRydWU7XG4gICAgICB9O1xuXG4gICAgICAvLyB0byBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgY2VsbCBwb3NpdGlvblxuICAgICAgdmFyIHJvdyA9IDA7XG4gICAgICB2YXIgY29sID0gMDtcbiAgICAgIHZhciBtb3ZlVG9OZXh0Q2VsbCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNvbCsrO1xuICAgICAgICBpZiggY29sID49IGNvbHMgKXtcbiAgICAgICAgICBjb2wgPSAwO1xuICAgICAgICAgIHJvdysrO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBnZXQgYSBjYWNoZSBvZiBhbGwgdGhlIG1hbnVhbCBwb3NpdGlvbnNcbiAgICAgIHZhciBpZDJtYW5Qb3MgPSB7fTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIHJjUG9zID0gb3B0aW9ucy5wb3NpdGlvbiggbm9kZSApO1xuXG4gICAgICAgIGlmKCByY1BvcyAmJiAocmNQb3Mucm93ICE9PSB1bmRlZmluZWQgfHwgcmNQb3MuY29sICE9PSB1bmRlZmluZWQpICl7IC8vIG11c3QgaGF2ZSBhdCBsZWFzdCByb3cgb3IgY29sIGRlZidkXG4gICAgICAgICAgdmFyIHBvcyA9IHtcbiAgICAgICAgICAgIHJvdzogcmNQb3Mucm93LFxuICAgICAgICAgICAgY29sOiByY1Bvcy5jb2xcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYoIHBvcy5jb2wgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCBjb2xcbiAgICAgICAgICAgIHBvcy5jb2wgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSggdXNlZChwb3Mucm93LCBwb3MuY29sKSApe1xuICAgICAgICAgICAgICBwb3MuY29sKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmKCBwb3Mucm93ID09PSB1bmRlZmluZWQgKXsgLy8gZmluZCB1bnVzZWQgcm93XG4gICAgICAgICAgICBwb3Mucm93ID0gMDtcblxuICAgICAgICAgICAgd2hpbGUoIHVzZWQocG9zLnJvdywgcG9zLmNvbCkgKXtcbiAgICAgICAgICAgICAgcG9zLnJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlkMm1hblBvc1sgbm9kZS5pZCgpIF0gPSBwb3M7XG4gICAgICAgICAgdXNlKCBwb3Mucm93LCBwb3MuY29sICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgICB2YXIgeCwgeTtcblxuICAgICAgICBpZiggZWxlbWVudC5sb2NrZWQoKSB8fCBlbGVtZW50LmlzRnVsbEF1dG9QYXJlbnQoKSApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlZSBpZiB3ZSBoYXZlIGEgbWFudWFsIHBvc2l0aW9uIHNldFxuICAgICAgICB2YXIgcmNQb3MgPSBpZDJtYW5Qb3NbIGVsZW1lbnQuaWQoKSBdO1xuICAgICAgICBpZiggcmNQb3MgKXtcbiAgICAgICAgICB4ID0gcmNQb3MuY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoLzIgKyBiYi54MTtcbiAgICAgICAgICB5ID0gcmNQb3Mucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQvMiArIGJiLnkxO1xuICAgICAgICBcbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlIHNldCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIFxuICAgICAgICAgIHdoaWxlKCB1c2VkKHJvdywgY29sKSApe1xuICAgICAgICAgICAgbW92ZVRvTmV4dENlbGwoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4ID0gY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoLzIgKyBiYi54MTtcbiAgICAgICAgICB5ID0gcm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQvMiArIGJiLnkxO1xuICAgICAgICAgIHVzZSggcm93LCBjb2wgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG4gICAgICAgIFxuICAgICAgfTtcblxuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICBcbiAgfTtcbiAgXG4gICQkKCdsYXlvdXQnLCAnZ3JpZCcsIEdyaWRMYXlvdXQpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICByZWFkeTogZnVuY3Rpb24oKXt9LCAvLyBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IGZ1bmN0aW9uKCl7fSAvLyBvbiBsYXlvdXRzdG9wXG4gIH07XG5cbiAgLy8gY29uc3RydWN0b3JcbiAgLy8gb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gIGZ1bmN0aW9uIE51bGxMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpOyBcbiAgfVxuXG4gIC8vIHJ1bnMgdGhlIGxheW91dFxuICBOdWxsTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzOyAvLyBlbGVtZW50cyB0byBjb25zaWRlciBpbiB0aGUgbGF5b3V0XG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG5cbiAgICAvLyBjeSBpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBmb3IgdXMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgdmFyIGN5ID0gb3B0aW9ucy5jeTsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICBsYXlvdXQudHJpZ2dlcignbGF5b3V0c3RhcnQnKTtcblxuICAgIC8vIHB1dHMgYWxsIG5vZGVzIGF0ICgwLCAwKVxuICAgIGVsZXMubm9kZXMoKS5wb3NpdGlvbnMoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyB0cmlnZ2VyIGxheW91dHJlYWR5IHdoZW4gZWFjaCBub2RlIGhhcyBoYWQgaXRzIHBvc2l0aW9uIHNldCBhdCBsZWFzdCBvbmNlXG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICBsYXlvdXQudHJpZ2dlcignbGF5b3V0cmVhZHknKTtcblxuICAgIC8vIHRyaWdnZXIgbGF5b3V0c3RvcCB3aGVuIHRoZSBsYXlvdXQgc3RvcHMgKGUuZy4gZmluaXNoZXMpXG4gICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgbGF5b3V0LnRyaWdnZXIoJ2xheW91dHN0b3AnKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGNhbGxlZCBvbiBjb250aW51b3VzIGxheW91dHMgdG8gc3RvcCB0aGVtIGJlZm9yZSB0aGV5IGZpbmlzaFxuICBOdWxsTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvLyByZWdpc3RlciB0aGUgbGF5b3V0XG4gICQkKCdsYXlvdXQnLCAnbnVsbCcsIE51bGxMYXlvdXQpO1xuXG59KShjeXRvc2NhcGUpO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBwb3NpdGlvbnM6IHVuZGVmaW5lZCwgLy8gbWFwIG9mIChub2RlIGlkKSA9PiAocG9zaXRpb24gb2JqKTsgb3IgZnVuY3Rpb24obm9kZSl7IHJldHVybiBzb21Qb3M7IH1cbiAgICB6b29tOiB1bmRlZmluZWQsIC8vIHRoZSB6b29tIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgICBwYW46IHVuZGVmaW5lZCwgLy8gdGhlIHBhbiBsZXZlbCB0byBzZXQgKHByb2Igd2FudCBmaXQgPSBmYWxzZSBpZiBzZXQpXG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIG9uIGZpdFxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBQcmVzZXRMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBQcmVzZXRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG5cbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gICAgdmFyIHBvc0lzRm4gPSAkJC5pcy5mbiggb3B0aW9ucy5wb3NpdGlvbnMgKTtcblxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uKG5vZGUpe1xuICAgICAgaWYoIG9wdGlvbnMucG9zaXRpb25zID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmKCBwb3NJc0ZuICl7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnBvc2l0aW9ucy5hcHBseSggbm9kZSwgWyBub2RlIF0gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHBvcyA9IG9wdGlvbnMucG9zaXRpb25zW25vZGUuX3ByaXZhdGUuZGF0YS5pZF07XG5cbiAgICAgIGlmKCBwb3MgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKGksIG5vZGUpe1xuICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24obm9kZSk7XG4gICAgICBcbiAgICAgIGlmKCBub2RlLmxvY2tlZCgpIHx8IHBvc2l0aW9uID09IG51bGwgKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfSk7XG4gICAgICAgIFxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdwcmVzZXQnLCBQcmVzZXRMYXlvdXQpO1xuICBcbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLCAvLyBmaXQgcGFkZGluZ1xuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBSYW5kb21MYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG4gIFxuICBSYW5kb21MYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgXG4gICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgIH0gKTtcblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiggaSwgbm9kZSApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogYmIueDEgKyBNYXRoLnJvdW5kKCBNYXRoLnJhbmRvbSgpICogYmIudyApLFxuICAgICAgICB5OiBiYi55MSArIE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBiYi5oIClcbiAgICAgIH07XG4gICAgfTtcblxuICAgIG5vZGVzLmxheW91dFBvc2l0aW9ucyggdGhpcywgb3B0aW9ucywgZ2V0UG9zICk7XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgXG4gIC8vIHJlZ2lzdGVyIHRoZSBsYXlvdXRcbiAgJCQoXG4gICAgJ2xheW91dCcsIC8vIHdlJ3JlIHJlZ2lzdGVyaW5nIGEgbGF5b3V0XG4gICAgJ3JhbmRvbScsIC8vIHRoZSBsYXlvdXQgbmFtZVxuICAgIFJhbmRvbUxheW91dCAvLyB0aGUgbGF5b3V0IHByb3RvdHlwZVxuICApO1xuICBcbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYW5pbWF0ZTogdHJ1ZSwgLy8gd2hldGhlciB0byBzaG93IHRoZSBsYXlvdXQgYXMgaXQncyBydW5uaW5nXG4gICAgbWF4U2ltdWxhdGlvblRpbWU6IDQwMDAsIC8vIG1heCBsZW5ndGggaW4gbXMgdG8gcnVuIHRoZSBsYXlvdXRcbiAgICB1bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmc6IGZhbHNlLCAvLyBzbyB5b3UgY2FuJ3QgZHJhZyBub2RlcyBkdXJpbmcgbGF5b3V0XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgcmFuZG9tOiBmYWxzZSwgLy8gd2hldGhlciB0byB1c2UgcmFuZG9tIGluaXRpYWwgcG9zaXRpb25zXG4gICAgaW5maW5pdGU6IGZhbHNlLCAvLyBvdmVycmlkZXMgYWxsIG90aGVyIG9wdGlvbnMgZm9yIGEgZm9yY2VzLWFsbC10aGUtdGltZSBtb2RlXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcblxuICAgIC8vIHNwcmluZ3kgZm9yY2VzXG4gICAgc3RpZmZuZXNzOiA0MDAsXG4gICAgcmVwdWxzaW9uOiA0MDAsXG4gICAgZGFtcGluZzogMC41XG4gIH07XG5cbiAgZnVuY3Rpb24gU3ByaW5neUxheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIFNwcmluZ3lMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgJCQudXRpbC5yZXF1aXJlKCdTcHJpbmd5JywgZnVuY3Rpb24oU3ByaW5neSl7XG5cbiAgICAgIHZhciBzaW1VcGRhdGluZ1BvcyA9IGZhbHNlO1xuXG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIFxuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgICB2YXIgZWRnZXMgPSBlbGVzLmVkZ2VzKCk7XG4gICBcbiAgICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgfSApO1xuICAgICAgXG4gICAgICAvLyBtYWtlIGEgbmV3IGdyYXBoXG4gICAgICB2YXIgZ3JhcGggPSBuZXcgU3ByaW5neS5HcmFwaCgpO1xuXG4gICAgICAvLyBtYWtlIHNvbWUgbm9kZXNcbiAgICAgIG5vZGVzLmVhY2goZnVuY3Rpb24oaSwgbm9kZSl7XG4gICAgICAgIG5vZGUuc2NyYXRjaCgnc3ByaW5neScsIHtcbiAgICAgICAgICBtb2RlbDogZ3JhcGgubmV3Tm9kZSh7XG4gICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gY29ubmVjdCB0aGVtIHdpdGggZWRnZXNcbiAgICAgIGVkZ2VzLmVhY2goZnVuY3Rpb24oaSwgZWRnZSl7XG4gICAgICAgIHZhciBmZFNyYyA9IGVkZ2Uuc291cmNlKCkuc2NyYXRjaCgnc3ByaW5neScpLm1vZGVsO1xuICAgICAgICB2YXIgZmRUZ3QgPSBlZGdlLnRhcmdldCgpLnNjcmF0Y2goJ3NwcmluZ3knKS5tb2RlbDtcbiAgICAgICAgXG4gICAgICAgIGVkZ2Uuc2NyYXRjaCgnc3ByaW5neScsIHtcbiAgICAgICAgICBtb2RlbDogZ3JhcGgubmV3RWRnZShmZFNyYywgZmRUZ3QsIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVkZ2VcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB2YXIgc2ltID0gd2luZG93LnNpbSA9IG5ldyBTcHJpbmd5LkxheW91dC5Gb3JjZURpcmVjdGVkKGdyYXBoLCBvcHRpb25zLnN0aWZmbmVzcywgb3B0aW9ucy5yZXB1bHNpb24sIG9wdGlvbnMuZGFtcGluZyk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmluZmluaXRlICl7XG4gICAgICAgIHNpbS5taW5FbmVyZ3lUaHJlc2hvbGQgPSAtSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50QkIgPSBzaW0uZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgIC8vIHZhciB0YXJnZXRCQiA9IHtib3R0b21sZWZ0OiBuZXcgU3ByaW5neS5WZWN0b3IoLTIsIC0yKSwgdG9wcmlnaHQ6IG5ldyBTcHJpbmd5LlZlY3RvcigyLCAyKX07XG4gICAgICBcbiAgICAgIC8vIGNvbnZlcnQgdG8vZnJvbSBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgIHZhciB0b1NjcmVlbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgY3VycmVudEJCID0gc2ltLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgdmFyIHNpemUgPSBjdXJyZW50QkIudG9wcmlnaHQuc3VidHJhY3QoY3VycmVudEJCLmJvdHRvbWxlZnQpO1xuICAgICAgICB2YXIgc3ggPSBwLnN1YnRyYWN0KGN1cnJlbnRCQi5ib3R0b21sZWZ0KS5kaXZpZGUoc2l6ZS54KS54ICogYmIudyArIGJiLngxO1xuICAgICAgICB2YXIgc3kgPSBwLnN1YnRyYWN0KGN1cnJlbnRCQi5ib3R0b21sZWZ0KS5kaXZpZGUoc2l6ZS55KS55ICogYmIuaCArIGJiLngxO1xuXG4gICAgICAgIHJldHVybiBuZXcgU3ByaW5neS5WZWN0b3Ioc3gsIHN5KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBmcm9tU2NyZWVuID0gZnVuY3Rpb24ocykge1xuICAgICAgICBjdXJyZW50QkIgPSBzaW0uZ2V0Qm91bmRpbmdCb3goKTtcblxuICAgICAgICB2YXIgc2l6ZSA9IGN1cnJlbnRCQi50b3ByaWdodC5zdWJ0cmFjdChjdXJyZW50QkIuYm90dG9tbGVmdCk7XG4gICAgICAgIHZhciBweCA9ICgocy54IC0gYmIueDEpIC8gYmIudykgKiBzaXplLnggKyBjdXJyZW50QkIuYm90dG9tbGVmdC54O1xuICAgICAgICB2YXIgcHkgPSAoKHMueSAtIGJiLnkxKSAvIGJiLmgpICogc2l6ZS55ICsgY3VycmVudEJCLmJvdHRvbWxlZnQueTtcblxuICAgICAgICByZXR1cm4gbmV3IFNwcmluZ3kuVmVjdG9yKHB4LCBweSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICB2YXIgbW92ZWROb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIFxuICAgICAgdmFyIG51bU5vZGVzID0gY3kubm9kZXMoKS5zaXplKCk7XG4gICAgICB2YXIgZHJhd25Ob2RlcyA9IDE7XG4gICAgICB2YXIgZmRSZW5kZXJlciA9IG5ldyBTcHJpbmd5LlJlbmRlcmVyKHNpbSxcbiAgICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgaWYoIG1vdmVkTm9kZXMubGVuZ3RoID4gMCAmJiBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICAgIHNpbVVwZGF0aW5nUG9zID0gdHJ1ZTtcblxuICAgICAgICAgICAgbW92ZWROb2Rlcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcblxuICAgICAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdmVkTm9kZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHNpbVVwZGF0aW5nUG9zID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdFZGdlKGVkZ2UsIHAxLCBwMikge1xuICAgICAgICAgIC8vIGRyYXcgYW4gZWRnZVxuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdOb2RlKG5vZGUsIHApIHtcbiAgICAgICAgICB2YXIgdiA9IHRvU2NyZWVuKHApO1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gbm9kZS5kYXRhLmVsZW1lbnQ7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoICFlbGVtZW50LmxvY2tlZCgpICYmICFlbGVtZW50LmdyYWJiZWQoKSApe1xuICAgICAgICAgICAgICBlbGVtZW50Ll9wcml2YXRlLnBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHYueCxcbiAgICAgICAgICAgICAgICB5OiB2LnlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbW92ZWROb2Rlcy5tZXJnZShlbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9zZXRMYXlvdXRQb3NpdGlvbkZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBkcmF3bk5vZGVzID09IG51bU5vZGVzICl7XG4gICAgICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0cmVhZHknLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgICAgICB9IFxuICAgICAgICAgIFxuICAgICAgICAgIGRyYXduTm9kZXMrKztcbiAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIHNldCBpbml0aWFsIG5vZGUgcG9pbnRzXG4gICAgICBub2Rlcy5lYWNoKGZ1bmN0aW9uKGksIGVsZSl7XG4gICAgICAgIGlmKCAhb3B0aW9ucy5yYW5kb20gKXtcbiAgICAgICAgICBzZXRMYXlvdXRQb3NpdGlvbkZvckVsZW1lbnQoZWxlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIHVwZGF0ZSBub2RlIHBvc2l0aW9ucyB3aGVuIGRyYWdnaW5nXG4gICAgICB2YXIgZHJhZ0hhbmRsZXI7XG4gICAgICBub2Rlcy5vbigncG9zaXRpb24nLCBkcmFnSGFuZGxlciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCBzaW1VcGRhdGluZ1BvcyApeyByZXR1cm47IH1cblxuICAgICAgICBzZXRMYXlvdXRQb3NpdGlvbkZvckVsZW1lbnQodGhpcyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gc2V0TGF5b3V0UG9zaXRpb25Gb3JFbGVtZW50KGVsZW1lbnQpe1xuICAgICAgICB2YXIgZmRJZCA9IGVsZW1lbnQuc2NyYXRjaCgnc3ByaW5neScpLm1vZGVsLmlkO1xuICAgICAgICB2YXIgZmRQID0gZmRSZW5kZXJlci5sYXlvdXQubm9kZVBvaW50c1tmZElkXS5wO1xuICAgICAgICB2YXIgcG9zID0gZWxlbWVudC5wb3NpdGlvbigpO1xuICAgICAgICB2YXIgcG9zaXRpb25JbkZkID0gKHBvcy54ICE9IG51bGwgJiYgcG9zLnkgIT0gbnVsbCkgPyBmcm9tU2NyZWVuKGVsZW1lbnQucG9zaXRpb24oKSkgOiB7XG4gICAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIDQgLSAyLFxuICAgICAgICAgIHk6IE1hdGgucmFuZG9tKCkgKiA0IC0gMlxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZmRQLnggPSBwb3NpdGlvbkluRmQueDtcbiAgICAgICAgZmRQLnkgPSBwb3NpdGlvbkluRmQueTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGdyYWJiYWJsZU5vZGVzID0gbm9kZXMuZmlsdGVyKFwiOmdyYWJiYWJsZVwiKTtcbiAgICAgIFxuICAgICAgZnVuY3Rpb24gc3RhcnQoKXtcbiAgICAgICAgLy8gZGlzYWJsZSBncmFiYmluZyBpZiBzbyBzZXRcbiAgICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgICAgZ3JhYmJhYmxlTm9kZXMudW5ncmFiaWZ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZkUmVuZGVyZXIuc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2VsZi5zdG9wU3lzdGVtID0gZnVuY3Rpb24oKXtcbiAgICAgICAgZ3JhcGguZmlsdGVyTm9kZXMoZnVuY3Rpb24oKXtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJlbW92ZSBhbGwgbm9kZXNcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgICBncmFiYmFibGVOb2Rlcy5ncmFiaWZ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBub2Rlcy5vZmYoJ2RyYWcgcG9zaXRpb24nLCBkcmFnSGFuZGxlcik7XG5cbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcblxuICAgICAgICBzZWxmLnN0b3BTeXN0ZW0gPSBudWxsO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgc3RhcnQoKTtcbiAgICAgIGlmKCAhb3B0aW9ucy5pbmZpbml0ZSApe1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgc2VsZi5zdG9wKCk7XG4gICAgICAgIH0sIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUpO1xuICAgICAgfVxuXG4gICAgfSk7IC8vIHJlcXVpcmVcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIFNwcmluZ3lMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIGlmKCB0aGlzLnN0b3BTeXN0ZW0gIT0gbnVsbCApe1xuICAgICAgdGhpcy5zdG9wU3lzdGVtKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ3NwcmluZ3knLCBTcHJpbmd5TGF5b3V0KTtcblxuICBcbn0pKGN5dG9zY2FwZSk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gICAgXG4gIGZ1bmN0aW9uIE51bGxSZW5kZXJlcihvcHRpb25zKXtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIFxuICBOdWxsUmVuZGVyZXIucHJvdG90eXBlLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCl7XG4gIH07XG5cbiAgTnVsbFJlbmRlcmVyLnByb3RvdHlwZS5ub3RpZnkgPSBmdW5jdGlvbigpe1xuICAgIC8vIHRoZSBudWxsIHJlbmRlcmVyIGRvZXMgbm90aGluZ1xuICB9O1xuICBcbiAgJCQoJ3JlbmRlcmVyJywgJ251bGwnLCBOdWxsUmVuZGVyZXIpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2N5dG9zY2FwZS9kaXN0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MlxuXG4vKipcbiAqIElmIGBCdWZmZXIuX3VzZVR5cGVkQXJyYXlzYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKGNvbXBhdGlibGUgZG93biB0byBJRTYpXG4gKi9cbkJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgPSAoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgaWYgYnJvd3NlciBzdXBwb3J0cyBUeXBlZCBBcnJheXMuIFN1cHBvcnRlZCBicm93c2VycyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLFxuICAvLyBDaHJvbWUgNyssIFNhZmFyaSA1LjErLCBPcGVyYSAxMS42KywgaU9TIDQuMisuIElmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYWRkaW5nXG4gIC8vIHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcywgdGhlbiB0aGF0J3MgdGhlIHNhbWUgYXMgbm8gYFVpbnQ4QXJyYXlgIHN1cHBvcnRcbiAgLy8gYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gYWRkIGFsbCB0aGUgbm9kZSBCdWZmZXIgQVBJIG1ldGhvZHMuIFRoaXMgaXMgYW4gaXNzdWVcbiAgLy8gaW4gRmlyZWZveCA0LTI5LiBOb3cgZml4ZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOFxuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiZcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAvLyBDaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gV29ya2Fyb3VuZDogbm9kZSdzIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgc3RyaW5nc1xuICAvLyB3aGlsZSBiYXNlNjQtanMgZG9lcyBub3QuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcgJiYgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzdWJqZWN0ID0gc3RyaW5ndHJpbShzdWJqZWN0KVxuICAgIHdoaWxlIChzdWJqZWN0Lmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0ICsgJz0nXG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0KVxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QubGVuZ3RoKSAvLyBhc3N1bWUgdGhhdCBvYmplY3QgaXMgYXJyYXktbGlrZVxuICBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgICBlbHNlXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3RbaV1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPT0gbnVsbCAmJiBiICE9PSB1bmRlZmluZWQgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW3RvdGFsTGVuZ3RoXSlcXG4nICtcbiAgICAgICdsaXN0IHNob3VsZCBiZSBhbiBBcnJheS4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gX2hleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgYXNzZXJ0KHN0ckxlbiAlIDIgPT09IDAsICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBhc3NlcnQoIWlzTmFOKGJ5dGUpLCAnSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMlxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBfdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2FzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX2JpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIF9hc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcbiAgc3RhcnQgPSBOdW1iZXIoc3RhcnQpIHx8IDBcbiAgZW5kID0gKGVuZCAhPT0gdW5kZWZpbmVkKVxuICAgID8gTnVtYmVyKGVuZClcbiAgICA6IGVuZCA9IHNlbGYubGVuZ3RoXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gX2hleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IF91dGY4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gX2FzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IF9iaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gX2Jhc2U2NFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBfdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIUJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRfc3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gX2Jhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBfdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gX2JpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIF9hc2NpaVNsaWNlKGJ1Ziwgc3RhcnQsIGVuZClcbn1cblxuZnVuY3Rpb24gX2hleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSsxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSBjbGFtcChzdGFydCwgbGVuLCAwKVxuICBlbmQgPSBjbGFtcChlbmQsIGxlbiwgbGVuKVxuXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5fYXVnbWVudCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpKVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgdmFyIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgICByZXR1cm4gbmV3QnVmXG4gIH1cbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLnNldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMud3JpdGVVSW50OCh2LCBvZmZzZXQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICB2YXIgbmVnID0gdGhpc1tvZmZzZXRdICYgMHg4MFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MzIoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMDAwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZmZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRmxvYXQgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWREb3VibGUgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgcmV0dXJuIGllZWU3NTQucmVhZChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCAyKTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAgICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQzMihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gIH1cblxuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpLCAndmFsdWUgaXMgbm90IGEgbnVtYmVyJylcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHRoaXNbaV0gPSB2YWx1ZVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpXG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbmZ1bmN0aW9uIGNsYW1wIChpbmRleCwgbGVuLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicpIHJldHVybiBkZWZhdWx0VmFsdWVcbiAgaW5kZXggPSB+fmluZGV4OyAgLy8gQ29lcmNlIHRvIGludGVnZXIuXG4gIGlmIChpbmRleCA+PSBsZW4pIHJldHVybiBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICBpbmRleCArPSBsZW5cbiAgaWYgKGluZGV4ID49IDApIHJldHVybiBpbmRleFxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBjb2VyY2UgKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpXG4gIHJldHVybiBsZW5ndGggPCAwID8gMCA6IGxlbmd0aFxufVxuXG5mdW5jdGlvbiBpc0FycmF5IChzdWJqZWN0KSB7XG4gIHJldHVybiAoQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoc3ViamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ViamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgfSkoc3ViamVjdClcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpXG4gICAgICBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuXG4vKlxuICogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgYSB2YWxpZCBpbnRlZ2VyLiBUaGlzIG1lYW5zIHRoYXQgaXRcbiAqIGlzIG5vbi1uZWdhdGl2ZS4gSXQgaGFzIG5vIGZyYWN0aW9uYWwgY29tcG9uZW50IGFuZCB0aGF0IGl0IGRvZXMgbm90XG4gKiBleGNlZWQgdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gdmVyaWZ1aW50ICh2YWx1ZSwgbWF4KSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA+PSAwLCAnc3BlY2lmaWVkIGEgbmVnYXRpdmUgdmFsdWUgZm9yIHdyaXRpbmcgYW4gdW5zaWduZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgaXMgbGFyZ2VyIHRoYW4gbWF4aW11bSB2YWx1ZSBmb3IgdHlwZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmc2ludCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpXG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCAodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodGVzdCwgbWVzc2FnZSkge1xuICBpZiAoIXRlc3QpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdGYWlsZWQgYXNzZXJ0aW9uJylcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanNcIixcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG52YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXHR2YXIgUExVU19VUkxfU0FGRSA9ICctJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSF9VUkxfU0FGRSA9ICdfJy5jaGFyQ29kZUF0KDApXG5cblx0ZnVuY3Rpb24gZGVjb2RlIChlbHQpIHtcblx0XHR2YXIgY29kZSA9IGVsdC5jaGFyQ29kZUF0KDApXG5cdFx0aWYgKGNvZGUgPT09IFBMVVMgfHxcblx0XHQgICAgY29kZSA9PT0gUExVU19VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0ggfHxcblx0XHQgICAgY29kZSA9PT0gU0xBU0hfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCIxWWlaNVNcIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0XCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiMVlpWjVTXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIsXCIvLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzc1wiKSJdfQ==
